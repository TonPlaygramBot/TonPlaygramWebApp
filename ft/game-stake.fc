;; Game lobby stake contract
;; Players send TON or jettons to this contract before starting a match.
;; When the game is finished, call op#1 with the winner address.
;; The contract distributes the balance between the winner and the developer
;; according to a configurable share. When a jetton wallet is configured the
;; payout is performed by instructing that wallet to withdraw jettons.

const END_GAME_OP = 1;

(slice dev_addr, int dev_share, slice jetton_wallet) load_config() inline {
  slice ds = get_data().begin_parse();
  return (ds~load_msg_addr(), ds~load_uint(8), ds~load_msg_addr());
}

() recv_internal(int my_balance, int msg_value, cell in_msg_full, slice in_msg_body) impure {
  var (dev_addr, dev_pct, jetton_wallet) = load_config();
  if (in_msg_body.slice_empty?()) {
    accept_message();
    return ();
  }
  int op = in_msg_body~load_uint(32);
  throw_unless(401, op == END_GAME_OP);
  slice winner = in_msg_body~load_msg_addr();
  int dev_share = my_balance * dev_pct / 100;
  int win_share = my_balance - dev_share;

  if (jetton_wallet.preload_uint(2) == 0) {
    builder b1 = begin_cell().store_slice(winner).store_coins(win_share);
    send_raw_message(b1.end_cell(), 1);
    builder b2 = begin_cell().store_slice(dev_addr).store_coins(dev_share);
    send_raw_message(b2.end_cell(), 1);
  } else {
    cell body1 = begin_cell()
      .store_uint(0x768a50b2, 32)
      .store_uint(0, 64)
      .store_slice(winner)
      .store_coins(win_share)
      .store_maybe_ref(null)
      .end_cell();
    builder msg1 = begin_cell()
      .store_uint(0x10, 6)
      .store_slice(jetton_wallet)
      .store_coins(msg_value / 2)
      .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1)
      .store_ref(body1);
    send_raw_message(msg1.end_cell(), 1);

    cell body2 = begin_cell()
      .store_uint(0x768a50b2, 32)
      .store_uint(0, 64)
      .store_slice(dev_addr)
      .store_coins(dev_share)
      .store_maybe_ref(null)
      .end_cell();
    builder msg2 = begin_cell()
      .store_uint(0x10, 6)
      .store_slice(jetton_wallet)
      .store_coins(msg_value - msg_value / 2)
      .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1)
      .store_ref(body2);
    send_raw_message(msg2.end_cell(), 1);
  }
  accept_message();
}
