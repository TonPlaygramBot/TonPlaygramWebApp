<!doctype html>
<html lang="sq">
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no,viewport-fit=cover"
    />
    <title>Deluxe Billiards • 2.5D Cartoon (Portrait)</title>
    <style>
      /* ------------------------------------------------------------------
       DELUXE BILLIARDS 2.5D CARTOON (PORTRAIT)
       - Tavoline vertikale, kornize druri, 6 gropa korrekte (meset anesore).
       - Panel djathtas: SPIN siper, STEKA poshte (pull & release).
       - Steke mbi felt; zgjatje vizuale sipas fuqise.
       - Guida me pika qe shkallezohen me fuqine; rrotullim topash me "spin".
       - Palete ngjyrash reale, hije 2.5D.
       - Teste konsole per integritet – te ndihmojne te debug.
       ------------------------------------------------------------------ */

      * {
        box-sizing: border-box;
        touch-action: none;
      }

      html,
      body {
        margin: 0;
        height: 100%;
        background: #1a2b4d; /* blu me e ndritshme per kontrast me te mire */
        color: #fff;
        font-family:
          system-ui,
          -apple-system,
          Segoe UI,
          Roboto,
          Ubuntu,
          Cantarell,
          'Helvetica Neue',
          Arial,
          'Noto Sans';
        overscroll-behavior: none;
      }

      #app {
        position: fixed;
        inset: 0;
        display: flex;
        flex-direction: column;
      }

      #header,
      #footer {
        height: 56px;
        display: flex;
        align-items: center;
        justify-content: space-between;
        padding: 0 12px;
        background: linear-gradient(#20345a, #1a2b4d);
      }

      #header {
        position: relative;
      }

      #header {
        border-bottom: 1px solid #24375f;
      }
      #footer {
        border-top: 1px solid #24375f;
        justify-content: center;
        height: calc(56px + env(safe-area-inset-bottom));
        padding-bottom: env(safe-area-inset-bottom);
        position: relative;
      }

      .player {
        display: flex;
        align-items: center;
        gap: 8px;
      }

      .avatar {
        width: 36px;
        height: 36px;
        border-radius: 50%;
        background: #fff;
        color: #222;
        display: grid;
        place-items: center;
        font-weight: 700;
        border: 2px solid var(--player-frame-color, #000);
      }

      .avatar.turn {
        box-shadow: 0 0 0 2px #facc15;
        border-color: #facc15;
      }

      .name {
        font-weight: 700;
      }
      .name.small {
        font-size: 12px;
      }

      .player .info {
        display: flex;
        flex-direction: column;
        align-items: center;
      }

      .score {
        font-size: 18px;
        font-weight: 700;
        min-width: 32px;
        text-align: center;
      }

      .potted {
        display: flex;
        gap: 2px;
        margin-top: 2px;
      }

      .potted .ball {
        width: 14px;
        height: 14px;
        border-radius: 50%;
        display: block;
      }

      #statusMsg {
        font-size: 12px;
        margin-top: 2px;
      }

      .foul {
        color: red;
      }

      #centerPopup {
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        font-size: 32px;
        font-weight: 700;
        pointer-events: none;
        z-index: 200;
        display: none;
      }

      #centerPopup.foul {
        color: red;
        text-shadow: 2px 2px 0 #fff;
      }

      #centerPopup.shots {
        color: #fff;
        text-shadow: 2px 2px 0 #000;
      }

      #wrap {
        position: relative;
        flex: 1 1 auto;
        display: flex;
        overflow: hidden;
        /* Ensure background image covers the available space without
         overlapping top or bottom elements. Extend the width slightly
         so the thin green boundary line is fully visible while keeping
         extra clearance at the bottom. The brightness filter is applied
         to a pseudo-element so the balls and other children remain
         unaffected. */
      }
      #wrap::before {
        content: '';
        position: absolute;
        inset: 0;
        background: url('/assets/icons/64e79228-35e3-4fdc-b914-fca635a40220.webp')
          top center/calc(100% + 8px) calc(100% + 20px) no-repeat;
        filter: brightness(var(--table-brightness));
        z-index: -1;
      }

      :root {
        --rpw: min(23vw, 115px);
        --player-frame-color: #000;
        --table-brightness: 1.1;
      }

      /* Canvas i tavolines (mbulon gjithcka, pervec panelit djathtas) */
      #table {
        position: absolute;
        top: 0;
        left: 0;
        transform: translateY(-2px);
        z-index: 4;
      }

      #cueHint {
        position: absolute;
        z-index: 7;
        display: none;
        font-size: 24px;
        pointer-events: none;
      }

      /* Paneli djathtas – SPIN siper, STEKA poshte */
      #rightPanel {
        position: absolute;
        top: 56px;
        right: 0;
        bottom: calc(56px + env(safe-area-inset-bottom));
        width: var(--rpw);

        display: flex;
        flex-direction: column;
        align-items: flex-end;
        justify-content: flex-end;
        gap: 8px;
        padding: 12px 0 0 8px;
        z-index: 10;
        /* Let table receive touches except on interactive elements */
        pointer-events: none;
      }

      #spinBox {
        width: 70px;
        height: 70px;
        border-radius: 50%;
        background: #f6f6f6;
        position: absolute;
        left: 50%;
        top: 120%;
        transform: translate(-50%, -50%);
        box-shadow:
          0 4px 10px rgba(0, 0, 0, 0.4) inset,
          0 0 0 2px rgba(0, 0, 0, 0.15);
        transform-origin: center;
        z-index: 10;
        pointer-events: auto;
        touch-action: none;
        cursor: pointer;
      }

      #spinDot {
        position: absolute;
        width: 10px;
        height: 10px;
        border-radius: 50%;
        background: #e63; /* pika e kuqe */
        left: 50%;
        top: 50%;
        transform: translate(-50%, -50%);
        pointer-events: none;
      }

      #turnTimerText {
        position: absolute;
        left: 50%;
        top: 50%;
        transform: translate(-50%, -50%);
        font-weight: 700;
        pointer-events: none;
        -webkit-text-stroke: 1px #000;
      }

      #pullArea {
        position: relative;
        width: 52px;
        height: 67%;
        border-radius: 16px;
        background: none;
        box-shadow: none;
        display: flex;
        align-items: center;
        justify-content: center;
        padding: 9px 0;
        /* Allow the handle to overflow so only half of it is visible */
        overflow: visible;
        z-index: 7;
        pointer-events: none;
        margin-right: 0;
      }

      #settingsBtn {
        position: absolute;
        right: 8px;
        bottom: 8px;
        background: none;
        border: none;
        font-size: 24px;
        color: #fff;
        cursor: pointer;
      }

      .settings-panel {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: #fff;
        color: #000;
        padding: 16px;
        border: 2px solid #000;
        border-radius: 8px;
        z-index: 200;
        display: none;
        min-width: 200px;
      }
      .settings-panel.active {
        display: block;
      }
      .settings-panel label {
        display: flex;
        align-items: center;
        gap: 6px;
        margin-top: 8px;
      }
      .settings-panel select,
      .settings-panel input[type='range'] {
        margin-left: 6px;
      }
      .settings-panel select option {
        color: #000;
      }
      .settings-actions {
        margin-top: 12px;
        display: flex;
        justify-content: flex-end;
        gap: 8px;
      }

      body.frame-style-1 .avatar {
        border-style: solid;
      }
      body.frame-style-2 .avatar {
        border-style: dashed;
      }
      body.frame-style-3 .avatar {
        border-style: dotted;
      }

      #cueRail {
        position: absolute;
        right: -8px;
        left: auto;
        transform: none;
        width: 12px;
        height: calc(100% - 28px);
        background: none;
        border-radius: 9px;
        box-shadow: none;
        pointer-events: none;
      }

      #powerBox {
        width: 12px;
        height: 100%;
        background: none;
        border-radius: 6px;
        position: absolute;
        overflow: hidden;
        border: none;
        box-shadow: none;
        left: calc(100% - 16px);
        top: 0;
        transform: translate(-50%, 0);
        pointer-events: none;
        z-index: 6;
      }

      #powerFill {
        position: absolute;
        left: 0;
        top: 0;
        width: 100%;
        height: 0%;
        background:
          repeating-linear-gradient(
            to bottom,
            transparent 0 calc(10% - 1px),
            rgba(0, 0, 0, 0.6) calc(10% - 1px) 10%
          ),
          linear-gradient(
            to bottom,
            #fde047 0%,
            #f97316 50%,
            #dc2626 100%
          );
      }

      #powerCue {
        position: absolute;
        /* Align cue image with pull handle and power text along the right edge */
        left: calc(100% - 16px);
        top: 0;
        transform: translate(-50%, 0) scaleY(1.2);
        transform-origin: top center;
        pointer-events: none;
        touch-action: none;
        z-index: 7;
      }

      #powerBg {
        position: absolute;
        left: calc(100% - 16px);
        top: 0;
        transform: translate(-50%, 0);
        width: 12px;
        height: 100%;
        background:
          repeating-linear-gradient(
            to bottom,
            transparent 0 calc(10% - 1px),
            rgba(0, 0, 0, 0.6) calc(10% - 1px) 10%
          ),
          linear-gradient(
            to bottom,
            #fde047 0%,
            #f97316 50%,
            #dc2626 100%
          );
        border-radius: 6px;
        pointer-events: none;
        opacity: 0.25;
        z-index: 5;
      }

      #pullLabel {
        position: absolute;
        top: 0;
        left: auto;
        right: -2px;
        transform: none;
        font-size: 12px;
        color: #fff;
        text-align: center;
        pointer-events: auto;
        width: 44px;
        height: 44px;
        border-radius: 50%;
        border: 1px solid #fff;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        background: none;
        cursor: pointer;
        touch-action: none;
        z-index: 8;
      }

      #cueOptions {
        position: absolute;
        /* Slightly raise the cue controls */
        bottom: calc(env(safe-area-inset-bottom) + 2px);
        left: 50%;
        transform: translateX(-50%);
        display: flex;
        flex-direction: row;
        align-items: center;
        gap: 6px;
        z-index: 20;
        pointer-events: auto;
      }
      #cueOptions .cue-label {
        font-size: 10px;
        margin: 0;
      }
      #cueOptions .cue-btn {
        width: 36px;
        height: 36px;
        border-radius: 50%;
        border: 1px solid #fff;
        background: none;
        color: #fff;
        font-size: 8px;
        cursor: pointer;
        margin: 0;
      }
      #cueOptions .cue-btn.active {
        background: #facc15;
        color: #000;
      }

      #pullLabel .pullArrow {
        display: block;
        /* shift arrow so it sits under the "u" in "Pull" */
        transform: translateX(-4px);
      }

      #powerTxt {
        position: absolute;
        right: -2px;
        top: -30px;
        font-size: 15px;
        opacity: 0.85;
        width: 44px;
        text-align: center;
        pointer-events: none;
        z-index: 9;
      }

      #play {
        position: absolute;
        left: 50%;
        top: 50%;
        transform: translate(-50%, -50%);
        background: #2b4f81;
        color: #fff;
        border: none;
        border-radius: 10px;
        padding: 14px 28px;
        font-size: 16px;
        cursor: pointer;
        z-index: 10;
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.45);
      }

      #play:hover {
        background: #3c67a3;
      }

      /* Removed the round shadow from the aiming line */
      #aimGlow {
        display: none;
      }

      .winnerOverlay {
        position: fixed;
        inset: 0;
        display: flex;
        align-items: center;
        justify-content: center;
        background: rgba(0, 0, 0, 0.6);
        z-index: 60;
      }
      .winnerOverlay.hidden {
        display: none;
      }
      .winnerOverlay img {
        width: 120px;
        height: 120px;
        border-radius: 50%;
      }
      .coin-confetti {
        position: fixed;
        top: -40px;
        width: 32px;
        height: 32px;
        pointer-events: none;
        animation: coin-fall var(--duration, 3s) linear forwards;
      }
      @keyframes coin-fall {
        from {
          transform: translateY(-10vh) rotate(0deg);
          opacity: 1;
        }
        to {
          transform: translateY(100vh) rotate(360deg);
          opacity: 0;
        }
      }

      .hidden {
        display: none;
      }

      #rulesBtn {
        position: fixed;
        left: 12px;
        bottom: 12px;
        width: 28px;
        height: 28px;
        border-radius: 50%;
        border: none;
        background: rgba(0, 0, 0, 0.5);
        color: #fff;
        font-size: 18px;
        line-height: 28px;
        text-align: center;
        cursor: pointer;
        z-index: 80;
      }

      #trainingMenuWrapper {
        position: fixed;
        left: 12px;
        bottom: 40px;
        z-index: 300;
      }
      #trainingMenuButton {
        width: 32px;
        height: 32px;
        border-radius: 8px;
        border: 1px solid #24375f;
        background: #20345a;
        color: #fff;
      }
      #trainingMenu {
        position: fixed;
        inset: 0;
        background: rgba(0, 0, 0, 0.7);
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 400;
      }
      #trainingMenu.hidden {
        display: none;
      }
      #trainingMenuInner {
        background: #20345a;
        padding: 8px;
        border-radius: 8px;
        display: flex;
        flex-direction: column;
        gap: 4px;
      }
      #trainingMenuInner button {
        background: #1a2b4d;
        border: 1px solid #24375f;
        color: #fff;
        padding: 4px 8px;
        border-radius: 4px;
      }

      #tournamentOverlay {
        position: fixed;
        inset: 0;
        background: #111;
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 400;
      }
      #tournamentOverlay.hidden {
        display: none;
      }
      #tournamentOverlay canvas {
        background: #fff;
        width: 95vw;
        height: 95vh;
        border: 1px solid #000;
      }

      #rulesModal {
        position: fixed;
        inset: 0;
        background: rgba(0, 0, 0, 0.7);
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 90;
        padding: 16px;
      }

      #rulesModal.hidden {
        display: none;
      }

      #rulesModal .rules-content {
        position: relative;
        background: #fff;
        color: #000;
        padding: 16px;
        border-radius: 8px;
        max-width: 90%;
        max-height: 80%;
        overflow-y: auto;
        line-height: 1.4;
      }

      #rulesModal h2 {
        margin-top: 0;
      }

      #closeRules {
        position: absolute;
        top: 8px;
        right: 8px;
        background: none;
        border: none;
        font-size: 18px;
        cursor: pointer;
      }

      #diceOverlay {
        position: absolute;
        inset: 0;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        background: none;
        z-index: 100;
        pointer-events: none;
      }
      #diceOverlay.hidden {
        display: none;
      }
      #diceOverlay .dice-row {
        display: flex;
        gap: 20px;
        margin-bottom: 20px;
        pointer-events: auto;
      }
      /* Dice styling copied from main app for consistent look */
      @keyframes roll {
        0% {
          transform: rotateX(0) rotateY(0) rotateZ(0) translateY(0);
        }
        50% {
          transform: rotateX(360deg) rotateY(360deg) rotateZ(360deg) translateY(-10px);
        }
        100% {
          transform: rotateX(720deg) rotateY(720deg) rotateZ(720deg) translateY(0);
        }
      }
      .animate-roll {
        animation: roll 0.5s ease-in-out;
      }
      .dice-container {
        width: 40px;
        height: 40px;
        perspective: 600px;
      }
      .dice-cube {
        position: relative;
        width: 100%;
        height: 100%;
        transform-style: preserve-3d;
        transition: transform 0.5s;
      }
      .dice-face {
        position: absolute;
        width: 100%;
        height: 100%;
        display: flex;
        align-items: center;
        justify-content: center;
        background: #fff;
        border-radius: 6px;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
      }
      .dice-face .dot {
        width: 6px;
        height: 6px;
        background: #000;
        border-radius: 50%;
      }
      .dice-face--front {
        transform: rotateY(0deg) translateZ(20px);
      }
      .dice-face--back {
        transform: rotateY(180deg) translateZ(20px);
      }
      .dice-face--right {
        transform: rotateY(90deg) translateZ(20px);
      }
      .dice-face--left {
        transform: rotateY(-90deg) translateZ(20px);
      }
      .dice-face--top {
        transform: rotateX(90deg) translateZ(20px);
      }
      .dice-face--bottom {
        transform: rotateX(-90deg) translateZ(20px);
      }
    </style>
  </head>
  <body>
    <div id="app">
      <div id="header">
        <div class="player">
          <div class="avatar">A</div>
          <div class="score" id="p1Score">0</div>
          <div class="info">
            <div class="name">Artur</div>
            <div class="potted" id="p1Potted"></div>
          </div>
        </div>
        <div id="spinBox">
          <div id="spinDot"></div>
          <div id="turnTimerText"></div>
        </div>
        <div class="player">
          <div class="info">
            <div class="name">CPU</div>
            <div class="potted" id="p2Potted"></div>
          </div>
          <div class="score" id="p2Score">0</div>
          <div class="avatar">C</div>
        </div>
      </div>

      <div id="wrap">
        <canvas id="table"></canvas>
        <div id="cueHint">✋️</div>

        <div id="cueOptions">
          <div class="cue-label">Cue</div>
          <button class="cue-btn" data-cue="short">Short</button>
          <button class="cue-btn" data-cue="medium">Medium</button>
          <button class="cue-btn" data-cue="long">Long</button>
          <button class="cue-btn" data-cue="auto">Auto</button>
        </div>

        <!-- Panel djathtas: vetem slideri i fuqise -->
        <aside id="rightPanel">
          <div id="pullArea">
            <div id="powerBg"></div>
            <div id="powerBox"><div id="powerFill"></div></div>
            <img
              id="powerCue"
              src="/assets/icons/file_0000000019d86243a2f7757076cd7869.webp"
              alt="Cue"
            />
            <div id="cueRail"></div>
            <div id="powerTxt"><div id="powerPercent">0%</div></div>
            <div id="pullLabel">Pull<br /><span class="pullArrow">⬇</span></div>
          </div>
        </aside>

        <button id="play">Play</button>
      </div>

      <div id="footer">
        <div id="turnPlayer" class="player">
          <div class="avatar"></div>
          <div class="info">
            <div class="name"></div>
            <div id="statusMsg"></div>
          </div>
        </div>
        <button id="settingsBtn">🎛️</button>
      </div>
    </div>
    <div id="winnerOverlay" class="winnerOverlay hidden"></div>
    <div id="centerPopup"></div>

    <div id="diceOverlay" class="hidden"></div>

    <button id="rulesBtn" aria-label="Game rules">ℹ️</button>
    <div id="rulesModal" class="hidden" role="dialog" aria-modal="true">
      <div class="rules-content">
        <button id="closeRules" aria-label="Close">✖</button>
        <h2 id="rulesTitle"></h2>
        <ul id="rulesList"></ul>
        <p class="rule-source" id="rulesSource"></p>
      </div>
    </div>

    <div id="settingsPanel" class="settings-panel">
      <label
        >Crowd Volume<input
          type="range"
          id="crowdVolume"
          min="0"
          max="1"
          step="0.1"
      /></label>
      <label
        >Pocket Volume<input
          type="range"
          id="pocketVolume"
          min="0"
          max="1"
          step="0.1"
      /></label>
      <label
        >Ball Volume<input
          type="range"
          id="ballVolume"
          min="0"
          max="1"
          step="0.1"
      /></label>
      <label
        >Table Brightness<input
          type="range"
          id="tableBrightness"
          min="0.5"
          max="1.5"
          step="0.1"
      /></label>
      <label>Frame Style<select id="playerFrameStyle"></select></label>
      <label
        >Frame Color<select id="playerFrameColor" class="color-select"></select
      ></label>
      <div class="settings-actions">
        <button id="saveSettings">Save</button>
        <button id="closeSettings">Close</button>
      </div>
    </div>

<script src="/flag-emojis.js"></script>
    <script src="/poll-royale-api.js"></script>

    <!--
    Shenim: Perdorim script me type="text/javascript" per te shmangur
    cdo interpretim si modul ose si gjuhe tjeter; kjo adreson gabimet e
    tipit "Unexpected token / (1:0)" ne disa rrethina.
  -->
    <script type="text/javascript">
      (function () {
        'use strict';

        document.addEventListener(
          'touchmove',
          function (e) {
            e.preventDefault();
          },
          { passive: false }
        );

        var params = new URLSearchParams(location.search);
        var tgKey = params.get("tgId") || "anon";
        var STATE_KEY = `pollRoyaleTournamentState_${tgKey}`;
        var OPP_KEY = `pollRoyaleTournamentOpponent_${tgKey}`;
        var stake = parseInt(params.get("amount") || "0", 10);
        var accountId = params.get("accountId");
        var tgId = params.get("tgId");
        var devAccount = params.get("dev");
        var devAccount1 = params.get("dev1");
        var devAccount2 = params.get("dev2");
        var variant = params.get('variant') || 'uk';
        var isAmerican = variant === 'american';
        var isNineBall = variant === '9ball';
        var playType = params.get('type') || 'regular';
        window.trainingMode = playType === 'training';
        window.tournamentMode = playType === 'tournament';
        window.trainingSolo = false;
        window.tournamentPlayers = parseInt(params.get('players') || '0', 10);
        window.potAmount = parseInt(params.get('amount') || '0', 10);
        window.playerName = params.get('name') || 'Player';
        const planShotPromise = import('/lib/poolAi.js');

        /* ==========================================================
       KONSTANTA TE LAYOUT-it DHE FIZIKES (sipas portrait)
       ========================================================= */
        var TABLE_W = 768; // gjeresi logjike e felt-it
        var TABLE_H = 1216; // lartesi logjike e felt-it
        var BORDER = 57; // korniza e drurit pak me e ngushte anash
        // Gropat pak me te vogla per t'u mbyllur me shume dhe jo per t'u zgjeruar
        var POCKET_R = 32; // rrezja baze e gropave pak me e vogel nga jashte
        var SIDE_POCKET_R = 30; // gropat anesore gjithashtu pak me te vogla
        // move pockets slightly closer to the center of the table
        var POCKET_SHORTEN = 4; // gropat zhvendosen pak me brenda per te ruajtur anen e brendshme
        var BALL_R = 22; // rrezja baze e topave pak me e vogel
        var SHORT_DIST = BALL_R * 28;
        var MED_DIST = BALL_R * 56;
        var BORDER_TOP = BORDER + BALL_R * 2 - 4; // bordi i siperm pak me i holle per fushe me te gjate
        // Raise only the bottom field line by the thickness of one green side
        // marking so the table's lower boundary sits slightly higher.
        var BORDER_BOTTOM = BORDER + 14; // anet e tjera mbeten te pandryshuara
        // Move the rack slightly upward on the table
        var SPOT_Y =
          BORDER_TOP +
          (TABLE_H - BORDER_TOP - BORDER_BOTTOM) * 0.25 -
          BALL_R * 0.5; // pika per trekendshin siper
        var LINE_Y = BORDER_TOP + (TABLE_H - BORDER_TOP - BORDER_BOTTOM) * 0.75; // vija e bardhe poshte
        var CUE_START_Y =
          LINE_Y + (TABLE_H - BORDER_BOTTOM - LINE_Y - BALL_R * 2) / 2; // pozicioni fillestar i cueball-it

        var FRICTION = 0.985; // ferkimi linear, pak me i vogel per te ruajtur shpejtesine
        var BOUNCE = 0.99; // koeficienti i rikthimit pak me i madh

        var MIN_V = 0.12; // shpejtesia min. qe konsiderohet "ne levizje"

        var POCKET_DIRS = [
          { x: 1, y: 1 },
          { x: -1, y: 1 },
          { x: 1, y: 0 },
          { x: -1, y: 0 },
          { x: 1, y: -1 },
          { x: -1, y: -1 }
        ];

        /* ==========================================================
       ELEMENTET DOM
       ========================================================= */
        var canvas = document.getElementById('table');
        var ctx = canvas.getContext('2d');
        var rightPanel = document.getElementById('rightPanel');
        var playBtn = document.getElementById('play');
        var turnPlayer = document.getElementById('turnPlayer');
        var footerAvatar = turnPlayer.querySelector('.avatar');
        var footerName = turnPlayer.querySelector('.name');
        var statusMsg = document.getElementById('statusMsg');
        var footerTimeout = null;
        var centerPopup = document.getElementById('centerPopup');
        var spinBox = document.getElementById('spinBox');
        var spinDot = document.getElementById('spinDot');
        var timerDisplay = document.getElementById('turnTimerText');
        var logoImg = new Image();
        logoImg.src = '/assets/icons/pool-royale.svg';
        var cueImg = new Image();
        cueImg.src = '/assets/icons/file_0000000019d86243a2f7757076cd7869.webp';
        var pullArea = document.getElementById('pullArea');
        var powerFill = document.getElementById('powerFill');
        var powerBox = document.getElementById('powerBox');
        var powerTxt = document.getElementById('powerTxt');
        var powerPercent = document.getElementById('powerPercent');
        var powerCue = document.getElementById('powerCue');
        var powerBg = document.getElementById('powerBg');
        var pullHandle = document.getElementById('pullLabel');
        var cueRail = document.getElementById('cueRail');
        var cueButtons = document.querySelectorAll('#cueOptions .cue-btn');
        var settingsBtn = document.getElementById('settingsBtn');
        var settingsPanel = document.getElementById('settingsPanel');
        var crowdVolumeInput = document.getElementById('crowdVolume');
        var pocketVolumeInput = document.getElementById('pocketVolume');
        var ballVolumeInput = document.getElementById('ballVolume');
        var brightnessInput = document.getElementById('tableBrightness');
        var frameStyleSelect = document.getElementById('playerFrameStyle');
        var frameColorSelect = document.getElementById('playerFrameColor');
        var saveSettingsBtn = document.getElementById('saveSettings');
        var closeSettingsBtn = document.getElementById('closeSettings');

        var currentCue = 'short';
        var autoCue = false;
        function setCueVariant(v, fromAuto) {
          if (v === 'auto') {
            autoCue = true;
          } else {
            currentCue = v;
            if (!fromAuto) autoCue = false;
          }
          cueButtons.forEach(function (b) {
            if (b.dataset.cue === 'auto') {
              b.classList.toggle('active', autoCue);
            } else {
              b.classList.toggle('active', b.dataset.cue === currentCue);
            }
          });
        }
        function updateAutoCue() {
          if (!autoCue || !table) return;
          var cue = table.balls[0];
          var aim = table.aim;
          var dist = Math.hypot(aim.x - cue.p.x, aim.y - cue.p.y);
          var bucket =
            dist <= SHORT_DIST ? 'short' : dist <= MED_DIST ? 'medium' : 'long';
          setCueVariant(bucket, true);
        }
        cueButtons.forEach(function (b) {
          b.addEventListener('click', function () {
            if (b.dataset.cue === 'auto') {
              autoCue = true;
              updateAutoCue();
            } else {
              setCueVariant(b.dataset.cue);
            }
          });
        });
        setCueVariant(currentCue);

        var avatarP1 = document.querySelector(
          '#header .player:first-child .avatar'
        );
        var nameP1 = document.querySelector(
          '#header .player:first-child .name'
        );
        var avatarCPU = document.querySelector(
          '#header .player:last-child .avatar'
        );
        var nameCPU = document.querySelector(
          '#header .player:last-child .name'
        );

        var crowdVolume =
          parseFloat(localStorage.getItem('poolCrowdVol')) || 1;
        var pocketVolume =
          parseFloat(localStorage.getItem('poolPocketVol')) || 1;
        var ballVolume =
          parseFloat(localStorage.getItem('poolBallVol')) || 1;
        var tableBrightness =
          parseFloat(localStorage.getItem('poolBrightness')) || 1.1;
        var frameStyleSetting =
          localStorage.getItem('poolFrameStyle') || '1';
        var frameColorSetting =
          localStorage.getItem('poolFrameColor') || '#000';

        document.body.classList.add('frame-style-' + frameStyleSetting);
        document.documentElement.style.setProperty(
          '--player-frame-color',
          frameColorSetting
        );

        if (frameStyleSelect) {
          for (var fs = 1; fs <= 3; fs++) {
            var opt = document.createElement('option');
            opt.value = fs;
            opt.textContent = 'Style ' + fs;
            frameStyleSelect.appendChild(opt);
          }
          frameStyleSelect.value = frameStyleSetting;
        }

        if (frameColorSelect) {
          ['#000', '#f00', '#0f0', '#00f', '#ff0', '#f0f', '#0ff', '#fff'].forEach(
            function (c) {
              var opt = document.createElement('option');
              opt.value = c;
              opt.textContent = c;
              opt.style.background =
                'linear-gradient(to right, ' + c + ' 0 16px, #fff 16px)';
              frameColorSelect.appendChild(opt);
            }
          );
          frameColorSelect.value = frameColorSetting;
        }

        if (crowdVolumeInput) crowdVolumeInput.value = crowdVolume;
        if (pocketVolumeInput) pocketVolumeInput.value = pocketVolume;
        if (ballVolumeInput) ballVolumeInput.value = ballVolume;
        if (brightnessInput) brightnessInput.value = tableBrightness;

        document.documentElement.style.setProperty(
          '--table-brightness',
          tableBrightness
        );

        function applySettings() {
          crowdVolume = parseFloat(crowdVolumeInput.value || crowdVolume);
          pocketVolume = parseFloat(pocketVolumeInput.value || pocketVolume);
          ballVolume = parseFloat(ballVolumeInput.value || ballVolume);
          tableBrightness = parseFloat(brightnessInput.value || tableBrightness);
          document.body.className = document.body.className.replace(
            /frame-style-\d+/g,
            ''
          );
          document.body.classList.add(
            'frame-style-' + frameStyleSelect.value
          );
          document.documentElement.style.setProperty(
            '--player-frame-color',
            frameColorSelect.value
          );
          document.documentElement.style.setProperty(
            '--table-brightness',
            tableBrightness
          );
        }

        if (settingsBtn) {
          settingsBtn.addEventListener('click', function () {
            settingsPanel.classList.add('active');
          });
          closeSettingsBtn.addEventListener('click', function () {
            settingsPanel.classList.remove('active');
          });
          saveSettingsBtn.addEventListener('click', function () {
            localStorage.setItem('poolCrowdVol', crowdVolumeInput.value);
            localStorage.setItem('poolPocketVol', pocketVolumeInput.value);
            localStorage.setItem('poolBallVol', ballVolumeInput.value);
            localStorage.setItem('poolBrightness', brightnessInput.value);
            localStorage.setItem('poolFrameStyle', frameStyleSelect.value);
            localStorage.setItem('poolFrameColor', frameColorSelect.value);
            applySettings();
            settingsPanel.classList.remove('active');
          });
        }

        applySettings();

        function formatPlayerName(name, el) {
          el.classList.remove('small');
          if (name.length > 15) {
            var initials = name
              .trim()
              .split(/\s+/)
              .map(function (part) {
                return part.charAt(0);
              })
              .join('');
            el.textContent = initials;
          } else {
            el.textContent = name;
            if (name.length > 12) {
              el.classList.add('small');
            }
          }
        }

        formatPlayerName(nameP1.textContent, nameP1);
        formatPlayerName(nameCPU.textContent, nameCPU);
        var pottedP1 = document.getElementById('p1Potted');
        var pottedP2 = document.getElementById('p2Potted');
        var scoreP1 = document.getElementById('p1Score');
        var scoreP2 = document.getElementById('p2Score');
        var cueHint = document.getElementById('cueHint');

        if (!isAmerican) {
          scoreP1.style.display = 'none';
          scoreP2.style.display = 'none';
        }

        var urlParams = new URLSearchParams(location.search);
        var avatarParam = urlParams.get('avatar');
        var nameParam = urlParams.get('name');
        if (nameParam) {
          formatPlayerName(nameParam, nameP1);
        }
        if (avatarParam) {
          avatarP1.style.backgroundImage = 'url(' + avatarParam + ')';
          avatarP1.style.backgroundSize = 'cover';
          avatarP1.textContent = '';
        }

        function coinConfetti(count, iconSrc) {
          count = count || 50;
          iconSrc = iconSrc || '/assets/icons/ezgif-54c96d8a9b9236.webp';
          for (var i = 0; i < count; i++) {
            var img = document.createElement('img');
            img.src = iconSrc;
            img.className = 'coin-confetti';
            img.style.left = Math.random() * 100 + 'vw';
            img.style.setProperty('--duration', 2 + Math.random() * 2 + 's');
            document.body.appendChild(img);
            setTimeout(
              (function (el) {
                return function () {
                  el.remove();
                };
              })(img),
              3000
            );
          }
        }

        function endGame(winner) {
          table.running = false;
          shotInProgress = false;
          if (window.tournamentMode && typeof window.handleTournamentResult === 'function') {
            try{localStorage.setItem(`pollRoyaleLastResult_${tgKey}`, JSON.stringify({scores, variant}));}catch{}
            window.handleTournamentResult(winner);
            return;
          }
          var overlay = document.getElementById('winnerOverlay');
          var avatar = winner === 1 ? avatarP1 : avatarCPU;
          if (avatar) overlay.innerHTML = avatar.outerHTML;
          overlay.classList.remove('hidden');
          coinConfetti(50);
          setTimeout(function () {
            location.href =
              '/games/pollroyale/lobby?winner=' +
              winner +
              '&variant=' +
              variant;
          }, 2000);
        }

        // --------------------------------------------------
        // Audio setup
        // --------------------------------------------------
        var audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        var hitBuffer = null,
          ballHitBuffer = null,
          pocketBuffer = null,
          knockBuffer = null,
          cheerBuffer = null,
          shockBuffer = null,
          activeSound = null;

        fetch('/assets/sounds/billiard-pool-hit-371618.mp3')
          .then(function (r) {
            return r.arrayBuffer();
          })
          .then(function (b) {
            return audioCtx.decodeAudioData(b);
          })
          .then(function (buf) {
            hitBuffer = buf;
          });

        fetch(encodeURI('/assets/sounds/billiard-sound newhit.mp3'))
          .then(function (r) {
            return r.arrayBuffer();
          })
          .then(function (b) {
            return audioCtx.decodeAudioData(b);
          })
          .then(function (buf) {
            ballHitBuffer = buf;
          });

        fetch('/assets/sounds/billiard-sound-6-288417.mp3')
          .then(function (r) {
            return r.arrayBuffer();
          })
          .then(function (b) {
            return audioCtx.decodeAudioData(b);
          })
          .then(function (buf) {
            pocketBuffer = buf;
          });

        fetch('/assets/sounds/wooden-door-knock-102902.mp3')
          .then(function (r) {
            return r.arrayBuffer();
          })
          .then(function (b) {
            return audioCtx.decodeAudioData(b);
          })
          .then(function (buf) {
            knockBuffer = buf;
          });

        fetch('/assets/sounds/crowd-cheering-383111.mp3')
          .then(function (r) {
            return r.arrayBuffer();
          })
          .then(function (b) {
            return audioCtx.decodeAudioData(b);
          })
          .then(function (buf) {
            cheerBuffer = buf;
          });

        fetch('/assets/sounds/crowd-shocked-reaction-352766.mp3')
          .then(function (r) {
            return r.arrayBuffer();
          })
          .then(function (b) {
            return audioCtx.decodeAudioData(b);
          })
          .then(function (buf) {
            shockBuffer = buf;
          });

        function stopActiveSound() {
          if (activeSound) {
            try {
              activeSound.stop();
            } catch (e) {}
            activeSound = null;
          }
        }

        function playCueHit(vol) {
          audioCtx.resume();
          if (!hitBuffer) return;
          var src = audioCtx.createBufferSource();
          src.buffer = hitBuffer;
          var gain = audioCtx.createGain();
          gain.gain.value = clamp(vol, 0, 1);
          src.connect(gain).connect(audioCtx.destination);
          src.start(0, 0, 0.5);
        }

        function playBallHit(vol) {
          audioCtx.resume();
          if (!ballHitBuffer) return;
          var src = audioCtx.createBufferSource();
          src.buffer = ballHitBuffer;
          var gain = audioCtx.createGain();
          gain.gain.value = clamp(vol * ballVolume * 0.72, 0, 1);
          src.connect(gain).connect(audioCtx.destination);
          src.start(0);
        }

        function playPocket(vol) {
          audioCtx.resume();
          if (!pocketBuffer) return;
          var src = audioCtx.createBufferSource();
          src.buffer = pocketBuffer;
          var gain = audioCtx.createGain();
          gain.gain.value = clamp(vol * pocketVolume * 0.8, 0, 1);
          src.connect(gain).connect(audioCtx.destination);
          var d = pocketBuffer.duration;
          src.start(0, Math.max(0, d - 1), 1);
        }

        function playTurnSound() {
          audioCtx.resume();
          if (!knockBuffer) return;
          var src = audioCtx.createBufferSource();
          src.buffer = knockBuffer;
          var gain = audioCtx.createGain();
          gain.gain.value = 1;
          src.connect(gain).connect(audioCtx.destination);
          src.start(0);
        }

        function playCheer(vol) {
          if (!cheerBuffer) return;
          audioCtx.resume().then(function () {
            stopActiveSound();
            var src = audioCtx.createBufferSource();
            src.buffer = cheerBuffer;
            var gain = audioCtx.createGain();
            gain.gain.value = clamp(vol * crowdVolume, 0, 1);
            src.connect(gain).connect(audioCtx.destination);
            src.start(0);
            activeSound = src;
          });
        }

        function playShock(vol) {
          audioCtx.resume();
          if (!shockBuffer) return;
          stopActiveSound();
          var src = audioCtx.createBufferSource();
          src.buffer = shockBuffer;
          var gain = audioCtx.createGain();
          gain.gain.value = clamp(vol * crowdVolume, 0, 1);
          src.connect(gain).connect(audioCtx.destination);
          src.start(0);
          activeSound = src;
        }

        var tg = window.Telegram?.WebApp;
        var userData = tg?.initDataUnsafe?.user;
        if (userData) {
          if (!nameParam) {
            var fullName =
              [userData.first_name, userData.last_name]
                .filter(Boolean)
                .join(' ') || 'You';
            formatPlayerName(fullName, nameP1);
          }
          if (!avatarParam) {
            if (userData.photo_url) {
              avatarP1.style.backgroundImage =
                'url(' + userData.photo_url + ')';
              avatarP1.style.backgroundSize = 'cover';
              avatarP1.textContent = '';
            } else if (userData.first_name) {
              avatarP1.textContent = userData.first_name.charAt(0);
            }
          }
          tg?.expand();
        }

        var regionNames = new Intl.DisplayNames(['en'], { type: 'region' });
        function flagToName(flag) {
          try {
            var codes = Array.from(flag).map(function (c) {
              return c.codePointAt(0) - 0x1f1e6 + 65;
            });
            return regionNames.of(String.fromCharCode.apply(null, codes));
          } catch (e) {
            return 'AI';
          }
        }
        if (window.tournamentMode) {
          try {
            var opp = JSON.parse(localStorage.getItem(OPP_KEY) || '{}');
            if (opp.flag) avatarCPU.textContent = opp.flag;
            formatPlayerName(opp.name || 'CPU', nameCPU);
          } catch (e) {
            formatPlayerName('CPU', nameCPU);
          }
        } else if (window.FLAG_EMOJIS) {
          var flag = FLAG_EMOJIS[(Math.random() * FLAG_EMOJIS.length) | 0];
          avatarCPU.textContent = flag;
          formatPlayerName(flagToName(flag) || 'CPU', nameCPU);
        }

        /* ==========================================================
       SHKALlEZIMI / RESIZE
       ========================================================= */
        var sX = 1,
          sY = 1,
          scaleFactor = 1,
          ballR = BALL_R;
        function resize() {
          var wrap = document.getElementById('wrap');
          var w = wrap.clientWidth;
          var h = wrap.clientHeight;
          var ar = TABLE_W / TABLE_H;
          var cw = w,
            ch = h;
          if (cw / ch > ar) cw = ch * ar;
          else ch = cw / ar;
          canvas.width = cw;
          canvas.height = ch;
          canvas.style.width = cw + 'px';
          canvas.style.height = ch + 'px';
          canvas.style.left = (w - cw) / 2 + 'px';
          canvas.style.top = (h - ch) / 2 + 'px';
          sX = cw / TABLE_W;
          sY = ch / TABLE_H;
          scaleFactor = (sX + sY) / 2;
          ballR = BALL_R * scaleFactor;
          powerCue.style.height = BALL_R * 28 * sX + 'px';
          updatePullHandle();
        }
        window.addEventListener('resize', resize);

        /* ==========================================================
       UTILITARE
       ========================================================= */
        function clamp(v, a, b) {
          return Math.max(a, Math.min(b, v));
        }
        function len(x, y) {
          return Math.hypot(x, y);
        }
        function norm(x, y) {
          var L = len(x, y) || 1;
          return { x: x / L, y: y / L };
        }
        function d2(a, b) {
          var dx = a.x - b.x,
            dy = a.y - b.y;
          return dx * dx + dy * dy;
        }

        /* ==========================================================
       PALETA E NGJYRAVE DHE LISTA E TOPAVE
       ========================================================= */
        var COL, BALLS;
        if (isAmerican) {
          COL = {
            cue: '#f5f5f5',
            1: '#f5c400',
            2: '#2256ff',
            3: '#d92d30',
            4: '#7c3aed',
            5: '#ff8c1a',
            6: '#1faa4a',
            7: '#7a2f2f',
            8: '#111'
          };
          // BALLS – 0..15 — cdo element ka { n, t, c }
          BALLS = [
            { n: 0, t: 'cue', c: COL.cue },
            { n: 1, t: 'solid', c: COL[1] },
            { n: 2, t: 'solid', c: COL[2] },
            { n: 3, t: 'solid', c: COL[3] },
            { n: 4, t: 'solid', c: COL[4] },
            { n: 5, t: 'solid', c: COL[5] },
            { n: 6, t: 'solid', c: COL[6] },
            { n: 7, t: 'solid', c: COL[7] },
            { n: 8, t: 'eight', c: COL[8] },
            { n: 9, t: 'stripe', c: COL[1] },
            { n: 10, t: 'stripe', c: COL[2] },
            { n: 11, t: 'stripe', c: COL[3] },
            { n: 12, t: 'stripe', c: COL[4] },
            { n: 13, t: 'stripe', c: COL[5] },
            { n: 14, t: 'stripe', c: COL[6] },
            { n: 15, t: 'stripe', c: COL[7] }
          ];
        } else if (isNineBall) {
          COL = {
            cue: '#f5f5f5',
            1: '#f5c400',
            2: '#2256ff',
            3: '#d92d30',
            4: '#7c3aed',
            5: '#ff8c1a',
            6: '#1faa4a',
            7: '#7a2f2f',
            8: '#111',
            9: '#f5c400'
          };
          BALLS = [
            { n: 0, t: 'cue', c: COL.cue },
            { n: 1, t: 'solid', c: COL[1] },
            { n: 2, t: 'solid', c: COL[2] },
            { n: 3, t: 'solid', c: COL[3] },
            { n: 4, t: 'solid', c: COL[4] },
            { n: 5, t: 'solid', c: COL[5] },
            { n: 6, t: 'solid', c: COL[6] },
            { n: 7, t: 'solid', c: COL[7] },
            { n: 8, t: 'solid', c: COL[8] },
            { n: 9, t: 'stripe', c: COL[9] }
          ];
        } else {
          COL = {
            cue: '#f5f5f5',
            red: '#d92d30',
            yellow: '#f5c400',
            eight: '#111'
          };
          BALLS = [{ n: 0, t: 'cue', c: COL.cue }];
          for (var nn = 1; nn <= 7; nn++)
            BALLS.push({ n: nn, t: 'red', c: COL.red });
          BALLS.push({ n: 8, t: 'eight', c: COL.eight });
          for (var mm = 9; mm <= 15; mm++)
            BALLS.push({ n: mm, t: 'yellow', c: COL.yellow });
        }
        var TOTAL_BALLS = BALLS.length;

        // Map i sigurt sipas numrit → shmang akses jashte indekseve
        var BALL_BY_N = {};
        BALLS.forEach(function (b) {
          BALL_BY_N[b.n] = b;
        });

        /* ==========================================================
       KLASAT E ENTITETEVE
       ========================================================= */
        function Ball(info, x, y) {
          if (!info)
            throw new Error('Ball info undefined (nuk egziston ne BALLS)');
          this.n = info.n; // numri (0..15)
          this.t = info.t; // tipi (solid / stripe / eight / cue)
          this.c = info.c; // ngjyra
          this.p = { x: x, y: y }; // pozicioni
          this.v = { x: 0, y: 0 }; // shpejtesia
          this.pocketed = false; // ne grope
          this.a = 0; // kendi per vizualizim rrotullimi
          this.spin = { x: 0, y: 0 }; // spin aktiv
          this.spinApplied = false;
        }

        function Pocket(x, y, r) {
          this.x = x;
          this.y = y;
          this.r = r || POCKET_R;
        }

        function Table() {
          this.balls = [];
          this.pockets = [];
          this.running = false;
          this.turn = 0; // 0: waiting for dice, 1: P1, 2: CPU
          this.captured = { 1: [], 2: [] };
          this.aim = { x: TABLE_W / 2, y: TABLE_H / 3 };
          // Track ball pairs that are currently colliding to avoid
          // triggering the collision sound more than once for a single
          // contact event.
          this.prevCollisions = new Set();
          this.reset();
        }

        Table.prototype.reset = function () {
          var i, j;
          this.balls = [];
          this.prevCollisions.clear();

          // Cue ball (center poshte vijes se bardhe)
          this.balls.push(new Ball(BALL_BY_N[0], TABLE_W / 2, CUE_START_Y));
          cueBallFree = true;
          aiming = false;
          cueHintTime = Date.now();

          // Trekendshi siper me 15 topa (8-shi ne qender rreshti 3)
          // Rrotulluar qe topi i verdhe te jete perballe cue ball-it
          var rowGap = BALL_R * 2.1;
          var colGap = BALL_R * 1.95;
          var cx = TABLE_W / 2;
          var cy = SPOT_Y - colGap * 2;

          if (isAmerican) {
            // Lista e numrave te tjere – do perdoren gradualisht
            var pool = [];
            for (i = 1; i <= 15; i++) {
              if (i !== 1 && i !== 2 && i !== 8 && i !== 11) pool.push(i);
            }
            var cursor = 0;

            // 5 rreshta nga lart poshte - trekendesh me maje poshte
            for (var r = 0; r < 5; r++) {
              var count = 5 - r;
              var startX = cx - (rowGap * (count - 1)) / 2;
              var y = cy + r * colGap;
              for (j = 0; j < count; j++) {
                var x = startX + j * rowGap;
                var num;
                if (r === 4 && j === 0)
                  num = 1; // yellow ne maje (poshte)
                else if (r === 2 && j === 1)
                  num = 8; // qender
                else if (r === 0 && j === 0)
                  num = 2; // qoshe solid majtas
                else if (r === 0 && j === 4)
                  num = 11; // qoshe stripe djathtas
                else num = pool[cursor++];
                var info = BALL_BY_N[num];
                if (!info) {
                  console.warn('Rack: numer i papercaktuar', num);
                  continue;
                }
                this.balls.push(new Ball(info, x, y));
              }
            }
          } else if (isNineBall) {
            // Rregullimi per 9-ball (diamant), i rrotulluar qe topi i verdhe te jete perballe cue ball-it
            var pattern9 = [
              [8],
              [7, 6],
              [5, 9, 4],
              [3, 2],
              [1]
            ];
            for (var r9 = 0; r9 < pattern9.length; r9++) {
              var cnt9 = pattern9[r9].length;
              var startX9 = cx - (rowGap * (cnt9 - 1)) / 2;
              var y9 = cy + r9 * colGap;
              for (var j9 = 0; j9 < cnt9; j9++) {
                var x9 = startX9 + j9 * rowGap;
                var num9 = pattern9[r9][j9];
                var info9 = BALL_BY_N[num9];
                if (!info9) {
                  console.warn('Rack: numer i papercaktuar', num9);
                  continue;
                }
                this.balls.push(new Ball(info9, x9, y9));
              }
            }
          } else {
            // Rregullimi standart per 8-ball UK (red & yellow)
            var pattern = [
              [9, 1, 10, 2, 11],
              [3, 12, 4, 13],
              [14, 8, 5],
              [15, 6],
              [7]
            ];
            for (var r2 = 0; r2 < pattern.length; r2++) {
              var cnt = pattern[r2].length;
              var startX2 = cx - (rowGap * (cnt - 1)) / 2;
              var y2 = cy + r2 * colGap;
              for (var j2 = 0; j2 < cnt; j2++) {
                var x2 = startX2 + j2 * rowGap;
                var num2 = pattern[r2][j2];
                var info2 = BALL_BY_N[num2];
                if (!info2) {
                  console.warn('Rack: numer i papercaktuar', num2);
                  continue;
                }
                this.balls.push(new Ball(info2, x2, y2));
              }
            }
          }

          // Pockets (4 qoshe + 2 te mesit anesore)
          // Shift all pockets pak jashte per t'i bere hapjet e drejta me te shkurtra,
          // dhe gropat anesore shtyhen edhe pak me shume majtas/djathtas.
          var holeEls = document.querySelectorAll('.hole');
          if (holeEls.length === 6) {
            var wrapRect = document
              .getElementById('wrap')
              .getBoundingClientRect();
            this.pockets = Array.prototype.map.call(
              holeEls,
              function (el) {
                var r = el.getBoundingClientRect();
                var cx =
                  ((r.left + r.width / 2 - wrapRect.left) / wrapRect.width) *
                  TABLE_W;
                var cy =
                  ((r.top + r.height / 2 - wrapRect.top) / wrapRect.height) *
                  TABLE_H;
                var pr = (r.width / 2 / wrapRect.width) * TABLE_W;
                return new Pocket(cx, cy, pr);
              }
            );
          } else {
            this.pockets = [
              new Pocket(
                BORDER - POCKET_SHORTEN + 4,
                BORDER_TOP - POCKET_SHORTEN,
                POCKET_R
              ),
              new Pocket(
                TABLE_W - BORDER + POCKET_SHORTEN - 4,
                BORDER_TOP - POCKET_SHORTEN,
                POCKET_R
              ),
              // Lift middle pockets a touch more to align with the shifted field
              // boundary, matching the green marking thickness, and nudge them
              // slightly farther from center.
              new Pocket(
                BORDER - 16 - POCKET_SHORTEN,
                TABLE_H / 2 + BALL_R - 14,
                SIDE_POCKET_R
              ),
              new Pocket(
                TABLE_W - BORDER + 16 + POCKET_SHORTEN,
                TABLE_H / 2 + BALL_R - 14,
                SIDE_POCKET_R
              ),
              new Pocket(
                BORDER - POCKET_SHORTEN,
                TABLE_H - BORDER_BOTTOM + POCKET_SHORTEN,
                POCKET_R
              ),
              new Pocket(
                TABLE_W - BORDER + POCKET_SHORTEN,
                TABLE_H - BORDER_BOTTOM + POCKET_SHORTEN,
                POCKET_R
              )
            ];
          }
          this.captured = { 1: [], 2: [] };
          this.turn = 1;
          freeShots = { 1: 0, 2: 0 };
          firstHit = null;

          // TESTE TE INTEGRITETIT (console.assert)
          runSelfTests(this);
        };

        Table.prototype.isMoving = function () {
          for (var i = 0; i < this.balls.length; i++) {
            var b = this.balls[i];
            if (b.pocketed) continue;
            if (Math.abs(b.v.x) > MIN_V || Math.abs(b.v.y) > MIN_V) return true;
          }
          return false;
        };

        Table.prototype.update = function (dt) {
          var i, j;
          // Track collisions in this frame so that audio for each
          // pair of balls is played only once per contact.
          var newCollisions = new Set();
          // Levizje + ferkim + kufij
          for (i = 0; i < this.balls.length; i++) {
            var b = this.balls[i];
            if (b.pocketed) continue;
            var prevX = b.p.x,
              prevY = b.p.y;
            b.p.x += b.v.x * dt;
            b.p.y += b.v.y * dt;
            b.v.x *= FRICTION;
            b.v.y *= FRICTION;
            if (b.spin && b.spinApplied) {
              b.v.x += b.spin.x * 58.5 * dt;
              b.v.y += b.spin.y * 58.5 * dt;
              b.spin.x *= 0.98;
              b.spin.y *= 0.98;
            }
            b.a += (Math.hypot(b.v.x, b.v.y) * dt) / (BALL_R * 0.6);

            var L = BORDER + BALL_R;
            var R = TABLE_W - BORDER - BALL_R;
            var T = BORDER_TOP + BALL_R;
            var B = TABLE_H - BORDER_BOTTOM - BALL_R;
            var nearest = null,
              prevDist = Infinity;
            for (var k = 0; k < this.pockets.length; k++) {
              var pk = this.pockets[k];
              var dPrev = Math.hypot(prevX - pk.x, prevY - pk.y);
              if (dPrev < prevDist) {
                prevDist = dPrev;
                nearest = pk;
              }
            }
            var newDist = nearest
              ? Math.hypot(b.p.x - nearest.x, b.p.y - nearest.y)
              : Infinity;
            // Detect when a ball just grazes a pocket to trigger a crowd reaction
            var nearPocket = nearest && newDist < nearest.r + BALL_R + 15;
            var approaching = nearest && newDist < prevDist;
            if (
              nearPocket &&
              !approaching &&
              !nearPocketEdgeHit &&
              !pocketedAny
            ) {
              nearPocketEdgeHit = true;
              playShock(1);
            }
            if (!nearPocket || !approaching) {
              if (b.p.x < L) {
                b.p.x = L;
                b.v.x *= -BOUNCE;
                if (b.n === 0) b.spinApplied = true;
                if (i === 0 && shotInProgress && !firstHit) cueHitCushion = true;
                var diffY = nearest ? Math.abs(b.p.y - nearest.y) : Infinity;
                if (
                  nearPocket &&
                  diffY <= BALL_R * 3 &&
                  !nearPocketEdgeHit &&
                  !pocketedAny
                ) {
                  nearPocketEdgeHit = true;
                  playShock(1);
                }
              }
              if (b.p.x > R) {
                b.p.x = R;
                b.v.x *= -BOUNCE;
                if (b.n === 0) b.spinApplied = true;
                if (i === 0 && shotInProgress && !firstHit) cueHitCushion = true;
                var diffY2 = nearest ? Math.abs(b.p.y - nearest.y) : Infinity;
                if (
                  nearPocket &&
                  diffY2 <= BALL_R * 3 &&
                  !nearPocketEdgeHit &&
                  !pocketedAny
                ) {
                  nearPocketEdgeHit = true;
                  playShock(1);
                }
              }
              if (b.p.y < T) {
                b.p.y = T;
                b.v.y *= -BOUNCE;
                if (b.n === 0) b.spinApplied = true;
                if (i === 0 && shotInProgress && !firstHit) cueHitCushion = true;
                var diffX = nearest ? Math.abs(b.p.x - nearest.x) : Infinity;
                if (
                  nearPocket &&
                  diffX <= BALL_R * 3 &&
                  !nearPocketEdgeHit &&
                  !pocketedAny
                ) {
                  nearPocketEdgeHit = true;
                  playShock(1);
                }
              }
              if (b.p.y > B) {
                b.p.y = B;
                b.v.y *= -BOUNCE;
                if (b.n === 0) b.spinApplied = true;
                if (i === 0 && shotInProgress && !firstHit) cueHitCushion = true;
                var diffX2 = nearest ? Math.abs(b.p.x - nearest.x) : Infinity;
                if (
                  nearPocket &&
                  diffX2 <= BALL_R * 3 &&
                  !nearPocketEdgeHit &&
                  !pocketedAny
                ) {
                  nearPocketEdgeHit = true;
                  playShock(1);
                }
              }
            }
          }

          // Perplasje ball-ball
          var N = this.balls.length;
          for (i = 0; i < N; i++)
            for (j = i + 1; j < N; j++) {
              var a = this.balls[i],
                bb = this.balls[j];
              if (!a || !bb || a.pocketed || bb.pocketed) continue;
              var dx = bb.p.x - a.p.x,
                dy = bb.p.y - a.p.y,
                d = Math.hypot(dx, dy);
              if (d < BALL_R * 2) {
                var pairId = i + '-' + j;
                var firstPairCollision = !newCollisions.has(pairId);
                newCollisions.add(pairId);
                var nx = dx / (d || 1),
                  ny = dy / (d || 1),
                  over = (BALL_R * 2 - d) / 2;
                a.p.x -= nx * over;
                a.p.y -= ny * over;
                bb.p.x += nx * over;
                bb.p.y += ny * over;
                var rvx = bb.v.x - a.v.x,
                  rvy = bb.v.y - a.v.y,
                  vn = rvx * nx + rvy * ny;
                if (vn < 0) {
                  var imp = -vn;
                  a.v.x -= imp * nx;
                  a.v.y -= imp * ny;
                  bb.v.x += imp * nx;
                  bb.v.y += imp * ny;
                  a.v.x *= BOUNCE;
                  a.v.y *= BOUNCE;
                  bb.v.x *= BOUNCE;
                  bb.v.y *= BOUNCE;
                    if (
                      firstPairCollision &&
                      !this.prevCollisions.has(pairId)
                    ) {
                      // Scale collision volume by both impact impulse and the
                      // power of the shot that initiated the turn.
                      var vol =
                        clamp(imp / 4000, 0, 1) * Math.min(lastShotPower, 0.39) * 0.5;
                      playBallHit(vol);
                    }
                  if (a.n === 0 || bb.n === 0) {
                    var other = a.n === 0 ? bb : a;
                    if (!firstHit) {
                      firstHit = BALL_BY_N[other.n];
                      if (
                        ((isNineBall || isAmerican) &&
                          other.n !== currentTarget) ||
                        (!isAmerican &&
                          !isNineBall &&
                          assignedTypes[currentShooter] &&
                          BALL_BY_N[other.n].t !==
                            assignedTypes[currentShooter])
                      ) {
                        if (!foulShown) {
                          showCenterPopup('Foul', 'foul', 1500);
                          foulShown = true;
                          var opponent = currentShooter === 1 ? 2 : 1;
                          updateFooter(
                            opponent,
                            isNineBall
                              ? 'Foul!'
                              : 'Foul – opponent gets two shots.'
                          );
                        }
                      }
                    }
                    if (a.n === 0) a.spinApplied = true;
                    if (bb.n === 0) bb.spinApplied = true;
                  }
                }
              }
            }

          // Kontroll i gropave
          for (i = 0; i < this.pockets.length; i++) {
            var p = this.pockets[i];
            for (j = 0; j < this.balls.length; j++) {
              var b2 = this.balls[j];
              if (b2.pocketed) continue;
              var ddx = b2.p.x - p.x,
                ddy = b2.p.y - p.y;
              if (Math.hypot(ddx, ddy) < p.r - BALL_R * 0.1) {
                var spd = Math.hypot(b2.v.x, b2.v.y);
                playPocket(clamp(spd / 4000, 0, 1));
                if (!shotPocketRecorded) {
                  lastPocketCenter = { x: p.x, y: p.y };
                  shotPocketRecorded = true;
                }
                if (b2.n === 0) {
                  scratch = true;
                  foulShown = true;
                  showCenterPopup('Foul', 'foul', 1500);
                  var opponent = currentShooter === 1 ? 2 : 1;
                  updateFooter(
                    opponent,
                    isAmerican || isNineBall
                      ? 'Foul!'
                      : 'Foul – opponent gets two shots.'
                  );
                  cueBallFree = true;
                  aiming = false;
                  cueHintTime = Date.now();
                  b2.p.x = TABLE_W / 2;
                  b2.p.y = CUE_START_Y;
                  b2.v.x = 0;
                  b2.v.y = 0;
                } else if (b2.n === 8 && !isAmerican && !isNineBall) {
                  b2.pocketed = true;
                  pocketedAny = true;
                  eightBallPotted = true;
                  if (!foulShown) playCheer(1);
                } else {
                  b2.pocketed = true;
                  pocketedAny = true;
                  this.captured[currentShooter].push(b2.n);
                  if (isNineBall) {
                    if (b2.n === 9) {
                      nineBallPotted = true;
                    }
                    lastPocketedBall = b2.n;
                    pottedThisShot.push(b2.n);
                    pocketedOwn = true;
                  } else if (isAmerican) {
                    pottedThisShot.push(b2.n);
                    pocketedOwn = true;
                    lastPocketedBall = b2.n;
                  } else {
                    var tType = BALL_BY_N[b2.n].t;
                    if (!assignedTypes[1] && tType !== 'eight') {
                      assignedTypes[currentShooter] = tType;
                      assignedTypes[currentShooter === 1 ? 2 : 1] =
                        tType === 'red' ? 'yellow' : 'red';
                      pocketedOwn = true;
                      updateFooter(
                        currentShooter,
                        'He sinks a ' + tType + ' and is now ' + tType + '.'
                      );
                    } else {
                      if (assignedTypes[currentShooter] === tType)
                        pocketedOwn = true;
                      updateFooter(currentShooter, 'He sinks a ' + tType + '.');
                    }
                    lastPocketedBall = b2.n;
                  }
                  if (!foulShown) playCheer(1);
                }
              }
            }
          }
          // Update collision state for next frame.
          this.prevCollisions = newCollisions;
        };

        Table.prototype.render = function () {
          ctx.clearRect(0, 0, canvas.width, canvas.height);
          // Field dimensions
          var x0 = BORDER * sX,
            y0 = BORDER_TOP * sY,
            w = (TABLE_W - 2 * BORDER) * sX,
            h = (TABLE_H - BORDER_TOP - BORDER_BOTTOM) * sY;

          // Vija kufizuese e cueball-it dhe pika qendrore
          ctx.strokeStyle = '#fff';
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.moveTo(x0, LINE_Y * sY);
          ctx.lineTo(x0 + w, LINE_Y * sY);
          ctx.stroke();
          ctx.fillStyle = '#fff';
          ctx.beginPath();
          ctx.arc(
            (TABLE_W / 2) * sX,
            SPOT_Y * sY,
            5 * ((sX + sY) / 2),
            0,
            Math.PI * 2
          );
          ctx.fill();
          // Cushion and pocket guidelines removed
          // Topat
          for (var j = 0; j < this.balls.length; j++) {
            var b = this.balls[j];
            if (!b || b.pocketed) continue;
            var px = b.p.x * sX,
              py = b.p.y * sY;

            // hije eliptike 2.5D
            ctx.fillStyle = 'rgba(0,0,0,.35)';
            ctx.beginPath();
            ctx.ellipse(
              px,
              py + ballR * 0.35,
              ballR * 1.05,
              ballR * 0.45,
              0,
              0,
              Math.PI * 2
            );
            ctx.fill();

            // trup i topit
            ctx.save();
            ctx.translate(px, py);
            ctx.rotate(b.a);
            ctx.fillStyle = BALL_BY_N[b.n].c;
            ctx.beginPath();
            ctx.arc(0, 0, ballR, 0, Math.PI * 2);
            ctx.fill();

            // highlight
            var hl = ctx.createRadialGradient(
              -ballR * 0.4,
              -ballR * 0.4,
              2,
              -ballR * 0.4,
              -ballR * 0.4,
              ballR * 1.2
            );
            hl.addColorStop(0, 'rgba(255,255,255,.55)');
            hl.addColorStop(1, 'rgba(255,255,255,0)');
            ctx.fillStyle = hl;
            ctx.beginPath();
            ctx.arc(0, 0, ballR, 0, Math.PI * 2);
            ctx.fill();

            // stripe nese duhet
            var stripe =
              BALL_BY_N[b.n].t === 'stripe' && (isAmerican || isNineBall);
            if (stripe) {
              ctx.save();
              ctx.beginPath();
              ctx.arc(0, 0, ballR, 0, Math.PI * 2);
              ctx.clip();
              ctx.fillStyle = '#fff';
              ctx.fillRect(-ballR, -ballR * 0.3, ballR * 2, ballR * 0.6);
              ctx.restore();
            }

            // numri (vetem per varianten amerikane ose per topin e zi)
            if (
              b.n !== 0 &&
              (isAmerican || isNineBall || BALL_BY_N[b.n].t === 'eight')
            ) {
              ctx.fillStyle = stripe ? BALL_BY_N[b.n].c : '#fff';
              ctx.beginPath();
              ctx.arc(0, 0, ballR * 0.52, 0, Math.PI * 2);
              ctx.fill();
              ctx.fillStyle = stripe ? '#fff' : '#111';
              ctx.font = ballR * 0.9 + 'px system-ui,sans-serif';
              ctx.textAlign = 'center';
              ctx.textBaseline = 'middle';
              ctx.fillText(String(b.n), 0, 0);
            }

            // pika e spin-it te cue
            if (b.n === 0) {
              ctx.fillStyle = '#e63';
              ctx.beginPath();
              ctx.arc(
                spinVec.x * ballR * 0.75,
                spinVec.y * ballR * 0.75,
                ballR * 0.22,
                0,
                Math.PI * 2
              );
              ctx.fill();
            }
            ctx.restore();
          }

            // Yellow boundary lines stop before each pocket; no additional field guides.

          // Steka mbi felt + guida
          if (
            (cueStrike.active || !this.isMoving()) &&
            this.balls[0] &&
            !this.balls[0].pocketed &&
            cueVisible
          ) {
            const aim = this.aim;
            drawCueOnTable(this.balls[0].p, aim, cuePullVisual);
            if (!this.isMoving() && showGuides) drawGuides(this.balls[0], aim);
          }
        };

        /* ==========================================================
       TESTE – kapin gabime si "undefined .n" heret
       ========================================================= */
        function runSelfTests(tbl) {
          // BALLS duhet te kete TOTAL_BALLS elemente
          console.assert(
            Array.isArray(BALLS) && BALLS.length === TOTAL_BALLS,
            'TEST FAIL: BALLS duhet ' + TOTAL_BALLS
          );
          for (var i = 0; i < BALLS.length; i++) {
            var it = BALLS[i];
            console.assert(
              typeof it.n === 'number' &&
                typeof it.t === 'string' &&
                typeof it.c === 'string',
              'TEST FAIL: item pa fusha',
              it
            );
          }
          // tavolina 16 topa (perfshi cue)
          console.assert(
            tbl.balls.length === TOTAL_BALLS,
            'TEST FAIL: tavolina ka',
            tbl.balls.length,
            'topa (duhet ' + TOTAL_BALLS + ')'
          );
          // asnje top undefined
          for (var j = 0; j < tbl.balls.length; j++) {
            var b = tbl.balls[j];
            console.assert(
              b && typeof b.n === 'number',
              'TEST FAIL: ball undefined ose pa n te index',
              j,
              b
            );
          }
          // 6 gropa
          console.assert(
            tbl.pockets.length === 6,
            'TEST FAIL: pockets',
            tbl.pockets.length
          );
          // vlera fillestare te aim/cue te vlefshme
          console.assert(
            typeof tbl.aim.x === 'number' && typeof tbl.aim.y === 'number',
            'TEST FAIL: aim i pavlefshem'
          );
        }

        /* ==========================================================
       GJENDJE GLOBALE E LOJES
       ========================================================= */
        var table = new Table();
        var last = 0; // koha e frame te fundit
        var aiming = false; // a po caktohet drejtimi
        var aimMoved = false; // a eshte levizur drejtimi gjate drag
        var showGuides = false; // a shfaqen pikat
        var cuePullVisual = 0; // shfaqje e terheqjes ne felt
        var cueVisible = true; // a shfaqet steka gjate animimit
        var cueStrike = { active: false, speed: 0, stage: 'forward' }; // animimi i goditjes se stekes
        var spinVec = { x: 0, y: 0 }; // spini i zgjedhur
        var lastGuideDir = { x: 0, y: -1 }; // drejtimi i fundit i guides
        var power = 0; // fuqi [0..1]
        // Track the power of the most recent shot so collision volume can
        // be scaled based on how hard the cue was struck.
        var lastShotPower = 0;
        var isBreakShot = true;
        var cueBallFree = true; // a mund te vendoset cueball
        var cueHintTime = Date.now();
        var draggingCue = false;
        var shotInProgress = false;
        var currentShooter = 1;
        var pocketedAny = false;
        var pocketedOwn = false;
        var scratch = false;
        var foulShown = false;
        var assignedTypes = { 1: null, 2: null };
        var freeShots = { 1: 0, 2: 0 };
        var firstHit = null;
        var lastTurn = table.turn;
        var cpuThinking = false;
        // Allow the CPU up to 4 seconds to take its shot
        var CPU_SHOT_DELAY = 3500;
        // Track timers for the human player's turn
        var turnTimer = null;
        var warnTimer = null;
        var countdownInterval = null;
        var countdownRemaining = 0;
        var scores = { 1: 0, 2: 0 };
        var lastPocketedBall = null;
        var currentTarget = null;
        var pottedThisShot = [];
        var eightBallPotted = false;
        var nineBallPotted = false;
        var lastShotAim = null;
        var lastPocketCenter = null;
        var shotPocketRecorded = false;
        var lastCueStart = null;
        var cueHitCushion = false;
        var nearPocketEdgeHit = false;

        function remainingPoints() {
          var sum = 0;
          for (var i = 1; i < table.balls.length; i++) {
            var bb = table.balls[i];
            if (bb && !bb.pocketed) sum += bb.n;
          }
          return sum;
        }

        function checkGameOver() {
          if (!isAmerican) return;
          var rem = remainingPoints();
          if (scores[1] >= 100 || scores[1] > scores[2] + rem) {
            endGame(1);
          } else if (scores[2] >= 100 || scores[2] > scores[1] + rem) {
            endGame(2);
          } else if (rem === 0) {
            if (scores[1] === scores[2]) {
              table.captured[1] = table.captured[1].filter(function (n) {
                return n !== 8;
              });
              table.captured[2] = table.captured[2].filter(function (n) {
                return n !== 8;
              });
              table.balls.push(new Ball(BALL_BY_N[8], TABLE_W / 2, SPOT_Y));
              cueBallFree = true;
              cueHintTime = Date.now();
              var cue = table.balls[0];
              cue.p.x = TABLE_W / 2;
              cue.p.y = CUE_START_Y;
              cue.v.x = 0;
              cue.v.y = 0;
              updateCapturedUI();
              updateFooter(table.turn, 'Shoot the 8-ball to win!');
            } else {
              endGame(scores[1] > scores[2] ? 1 : 2);
            }
          }
        }

        function lowestBallOnTable() {
          var lowest = null;
          for (var i = 1; i < table.balls.length; i++) {
            var bb = table.balls[i];
            if (!bb || bb.pocketed || bb.n === 0) continue;
            if (lowest === null || bb.n < lowest) lowest = bb.n;
          }
          return lowest;
        }

        function createMiniBall(n) {
          var info = BALL_BY_N[n];
          var canv = document.createElement('canvas');
          canv.className = 'ball';
          canv.width = 20;
          canv.height = 20;
          var ctx = canv.getContext('2d');
          var r = 8,
            cx = 10,
            cy = 10;
          ctx.fillStyle = info.c;
          ctx.beginPath();
          ctx.arc(cx, cy, r, 0, Math.PI * 2);
          ctx.fill();
          var hl = ctx.createRadialGradient(
            cx - r * 0.4,
            cy - r * 0.4,
            2,
            cx - r * 0.4,
            cy - r * 0.4,
            r * 1.2
          );
          hl.addColorStop(0, 'rgba(255,255,255,.55)');
          hl.addColorStop(1, 'rgba(255,255,255,0)');
          ctx.fillStyle = hl;
          ctx.beginPath();
          ctx.arc(cx, cy, r, 0, Math.PI * 2);
          ctx.fill();
          var stripe = info.t === 'stripe' && (isAmerican || isNineBall);
          if (stripe) {
            ctx.save();
            ctx.beginPath();
            ctx.arc(cx, cy, r, 0, Math.PI * 2);
            ctx.clip();
            ctx.fillStyle = '#fff';
            ctx.fillRect(cx - r, cy - r * 0.3, r * 2, r * 0.6);
            ctx.restore();
          }
          if (n !== 0 && (isAmerican || isNineBall || info.t === 'eight')) {
            ctx.fillStyle = stripe ? info.c : '#fff';
            ctx.beginPath();
            ctx.arc(cx, cy, r * 0.52, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = stripe ? '#fff' : '#111';
            ctx.font = '8px system-ui,sans-serif';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(String(n), cx, cy);
          }
          return canv;
        }

        function updateCapturedUI() {
          function render(el, arr) {
            el.innerHTML = '';
            arr.forEach(function (n) {
              el.appendChild(createMiniBall(n));
            });
          }
          render(pottedP1, table.captured[1]);
          render(pottedP2, table.captured[2]);
        }

        function updateScoresUI() {
          scoreP1.textContent = scores[1];
          scoreP2.textContent = scores[2];
          checkGameOver();
        }
        if (isAmerican) updateScoresUI();

        function updateFooter(player, msg) {
          var srcAvatar = player === 1 ? avatarP1 : avatarCPU;
          footerAvatar.style.cssText = srcAvatar.style.cssText;
          footerAvatar.textContent = srcAvatar.textContent;
          footerName.textContent =
            player === 1 ? nameP1.textContent : nameCPU.textContent;
          statusMsg.innerHTML = msg || '';
          clearTimeout(footerTimeout);
          if (msg) {
            footerTimeout = setTimeout(function () {
              statusMsg.innerHTML = '';
            }, 1500);
          }
        }

          function hasBallsLeft(type) {
            for (var k = 1; k < table.balls.length; k++) {
              var rb = table.balls[k];
              if (rb && !rb.pocketed && BALL_BY_N[rb.n].t === type) return true;
            }
            return false;
          }

          function clearTurnTimer() {
            if (turnTimer) clearTimeout(turnTimer);
            if (warnTimer) clearTimeout(warnTimer);
            if (countdownInterval) clearInterval(countdownInterval);
            turnTimer = null;
            warnTimer = null;
            countdownInterval = null;
            countdownRemaining = 0;
            if (timerDisplay) timerDisplay.textContent = '';
          }

          function startTurnTimer() {
            clearTurnTimer();
            if (table.turn !== 1) return;
            countdownRemaining = 30;
            if (timerDisplay) {
              timerDisplay.style.color = '#facc15';
              timerDisplay.textContent = countdownRemaining;
            }
            countdownInterval = setInterval(function () {
              countdownRemaining--;
              if (timerDisplay) timerDisplay.textContent = countdownRemaining;
              if (countdownRemaining <= 0) {
                clearInterval(countdownInterval);
                countdownInterval = null;
              }
            }, 1000);
            warnTimer = setTimeout(function () {
              playTurnSound();
            }, 25000);
            turnTimer = setTimeout(function () {
              updateFooter(2, "Time's up! Turn passes to the opponent.");
              table.turn = 2;
              updateTurnIndicator(true);
              showTurnInfo();
              cpuTurn();
            }, 30000);
          }

          function startCpuTimer() {
            clearTurnTimer();
            countdownRemaining = Math.ceil(CPU_SHOT_DELAY / 1000);
            if (timerDisplay) {
              timerDisplay.style.color = '#fff';
              timerDisplay.textContent = countdownRemaining;
            }
            countdownInterval = setInterval(function () {
              countdownRemaining--;
              if (timerDisplay) timerDisplay.textContent = countdownRemaining;
              if (countdownRemaining <= 0) {
                clearInterval(countdownInterval);
                countdownInterval = null;
              }
            }, 1000);
          }

          function showTurnInfo() {
            var msg;
            if (isNineBall || isAmerican) {
              if (!currentTarget) currentTarget = lowestBallOnTable();
              msg = 'Pot the ' + currentTarget + '-ball';
            } else {
              if (!assignedTypes[table.turn]) {
                msg = 'Choose a color';
              } else if (!hasBallsLeft(assignedTypes[table.turn])) {
                msg = 'Shoot the 8-ball to win!';
              } else {
                msg = 'Pot a ' + assignedTypes[table.turn];
              }
            }
            updateFooter(table.turn, msg);
          }

        function updateTurnIndicator(force) {
          if (window.trainingMode && window.trainingSolo) table.turn = 1;
          if (force || table.turn !== lastTurn) {
            avatarP1.classList.toggle('turn', table.turn === 1);
            avatarCPU.classList.toggle('turn', table.turn === 2);
            if (table.turn === 1) startTurnTimer(); else clearTurnTimer();
            if (!force && freeShots[table.turn] > 1) {
              showCenterPopup('2 shots', 'shots', 1500);
            }
            lastTurn = table.turn;
          }
        }

        function updateCueHint() {
          var cue = table.balls[0];
          if (
            cueBallFree &&
            cue &&
            !cue.pocketed &&
            Date.now() - cueHintTime < 2000
          ) {
            cueHint.style.display = 'block';
            cueHint.style.left = cue.p.x * sX + ballR + 'px';
            cueHint.style.top = cue.p.y * sY - ballR * 2 + 'px';
          } else {
            cueHint.style.display = 'none';
          }
        }

        function showCenterPopup(text, cls, duration) {
          centerPopup.textContent = text;
          centerPopup.className = cls;
          centerPopup.style.display = 'block';
          if (cls === 'foul') playShock(1);
          setTimeout(function () {
            centerPopup.style.display = 'none';
          }, duration);
        }

        function isFoul(firstHit, scratch) {
          if (isNineBall || isAmerican) {
            return !firstHit || firstHit.n !== currentTarget || scratch;
          }
          if (!firstHit || scratch) return true;
          var shooterType = assignedTypes[currentShooter];
          var ownLeft = shooterType && hasBallsLeft(shooterType);
          if (firstHit.t === 'eight' || eightBallPotted) {
            return ownLeft;
          }
          if (shooterType && firstHit.t !== shooterType) return true;
          return false;
        }

        function endShot() {
          shotInProgress = false;
          // Reset shot power so stray collisions don't carry over volume.
          lastShotPower = 0;
          cueVisible = true;
          cuePullVisual = 0;
          if (window.trainingMode && window.trainingSolo) {
            table.turn = 1;
            updateTurnIndicator(true);
            lastShotAim = null;
            lastPocketCenter = null;
            lastCueStart = null;
            pottedThisShot = [];
            pocketedAny = false;
            pocketedOwn = false;
            scratch = false;
            foulShown = false;
            firstHit = null;
            cueHitCushion = false;
            nearPocketEdgeHit = false;
            currentTarget = null;
            eightBallPotted = false;
            nineBallPotted = false;
            lastPocketedBall = null;
            return;
          }
          var opponent = currentShooter === 1 ? 2 : 1;
          var foul = isFoul(firstHit, scratch);
          var shotPoints = pottedThisShot.reduce(function (a, b) {
            return a + b;
          }, 0);
          if (foul) {
            if (isAmerican) {
              cueBallFree = true;
              if (shotPoints > 0) {
                scores[opponent] += shotPoints;
                updateScoresUI();
                updateFooter(
                  opponent,
                  'That\u2019s a foul – opponent gets ' + shotPoints + ' points.'
                );
                pottedThisShot.forEach(function (n) {
                  var arr = table.captured[currentShooter];
                  var idx = arr.indexOf(n);
                  if (idx !== -1) arr.splice(idx, 1);
                  table.captured[opponent].push(n);
                });
                updateCapturedUI();
              } else {
                var foulMsg = scratch
                  ? 'the cue ball went in'
                  : 'wrong first contact';
                updateFooter(opponent, 'That\u2019s a foul – ' + foulMsg + '.');
              }
            } else if (isNineBall) {
              cueBallFree = true;
              var foulMsg = scratch
                ? 'the cue ball went in'
                : 'wrong first contact';
              updateFooter(opponent, 'That\u2019s a foul – ' + foulMsg + '.');
            } else {
              updateFooter(opponent, 'Foul – opponent gets two shots.');
            }
            if (!foulShown) {
              showCenterPopup('Foul', 'foul', 1500);
              foulShown = true;
            }
            if (nineBallPotted) {
              endGame(opponent);
              return;
            }
            if (eightBallPotted) {
              endGame(opponent);
              return;
            }
            freeShots[opponent] = isAmerican || isNineBall ? 1 : 2;
            freeShots[currentShooter] = 0;
            table.turn = opponent;
            setTimeout(showTurnInfo, 1500);
          } else {
            if (nineBallPotted) {
              endGame(currentShooter);
              return;
            }
            if (eightBallPotted) {
              endGame(currentShooter);
              return;
            }
            if (shotPoints > 0 && isAmerican) {
              scores[currentShooter] += shotPoints;
              updateScoresUI();
            }
            if (freeShots[currentShooter] > 0) {
              freeShots[currentShooter]--;
              if (freeShots[currentShooter] === 0 && !pocketedOwn) {
                table.turn = opponent;
              }
            } else if (!pocketedOwn) {
              table.turn = opponent;
            }
            if (lastPocketedBall !== null) {
              var msg;
              if (isAmerican) {
                var total = scores[currentShooter];
                var closing = 100 - total;
                msg =
                  'He sinks the ' +
                  lastPocketedBall +
                  '-ball, that\u2019s ' +
                  lastPocketedBall +
                  ' points on the scoreboard.';
                if (total >= 63 && closing > 0) {
                  msg +=
                    ' Solid run — he\u2019s already at ' +
                    total +
                    ' points, just needs ' +
                    closing +
                    ' more to close the game.';
                }
              } else if (isNineBall) {
                msg = 'He sinks the ' + lastPocketedBall + '-ball.';
              } else {
                var col = BALL_BY_N[lastPocketedBall].t;
                msg = 'He sinks a ' + col + '.';
              }
              updateFooter(currentShooter, msg);
              lastPocketedBall = null;
              setTimeout(showTurnInfo, 1500);
            } else {
              updateFooter(
                table.turn,
                'Close call! The ball hit the cushion but nothing dropped, turn passes to the opponent.'
              );
              setTimeout(showTurnInfo, 1500);
            }
          }
          if (table.turn === currentShooter) startTurnTimer();
          lastShotAim = null;
          lastPocketCenter = null;
          lastCueStart = null;
          pottedThisShot = [];
          pocketedAny = false;
          pocketedOwn = false;
          scratch = false;
          foulShown = false;
          firstHit = null;
          lastCueStart = null;
          cueHitCushion = false;
          nearPocketEdgeHit = false;
          currentTarget = null;
          eightBallPotted = false;
          nineBallPotted = false;
          lastPocketedBall = null;
        }

        /* ==========================================================
       RENDER + UPDATE LOOP
       ========================================================= */
        function loop(t) {
          var dt = (t - last) / 1000 || 0;
          last = t;
          if (table.running) {
            animateCueStrike(dt);
            table.update(Math.min(dt, 0.033));
            table.render();
            updateCapturedUI();
            updateCueHint();
            updateTurnIndicator();
            if (shotInProgress && !table.isMoving()) endShot();
            if (
              !table.isMoving() &&
              table.turn === 2 &&
              !shotInProgress &&
              !cpuThinking
            )
              setTimeout(cpuTurn, 200);
          }
          requestAnimationFrame(loop);
        }
        requestAnimationFrame(loop);
        updateTurnIndicator(true);
        showTurnInfo();

        /* ==========================================================
       INPUT – Aiming & Glow
       ========================================================= */
        function screenToTable(x, y) {
          var r = canvas.getBoundingClientRect();
          return {
            x: ((x - r.left) / r.width) * TABLE_W,
            y: ((y - r.top) / r.height) * TABLE_H
          };
        }

        canvas.addEventListener('pointerdown', function (e) {
          if (!table.running || table.isMoving() || table.turn !== 1) return;
          canvas.setPointerCapture(e.pointerId);
          var t = screenToTable(e.clientX, e.clientY);
          var cue = table.balls[0];
          var dist = Math.hypot(t.x - cue.p.x, t.y - cue.p.y);
          if (cueBallFree && dist <= BALL_R * 1.5) {
            draggingCue = true;
            cueHintTime = 0;
            cueHint.style.display = 'none';
            return;
          }
          // Allow aiming anywhere by clicking on the table or balls
          // (do not snap to ball center so players can target specific sides)
          aiming = true;
          aimMoved = false;
          showGuides = true;
          table.aim.x = t.x;
          table.aim.y = t.y;
          placeAimGlow(table.aim);
          updateAutoCue();
        });

        document.addEventListener('pointermove', function (e) {
          if (table.turn !== 1) return;
          var t = screenToTable(e.clientX, e.clientY);
          var cue = table.balls[0];
          if (draggingCue && cueBallFree) {
            var minX = BORDER + BALL_R,
              maxX = TABLE_W - BORDER - BALL_R;
            var minY = LINE_Y + BALL_R,
              maxY = TABLE_H - BORDER_BOTTOM - BALL_R;
            var nx = clamp(t.x, minX, maxX);
            var ny = clamp(t.y, minY, maxY);
            var valid = true;
            for (var i = 1; i < table.balls.length; i++) {
              var b = table.balls[i];
              if (b.pocketed) continue;
              if (Math.hypot(b.p.x - nx, b.p.y - ny) < BALL_R * 2) {
                valid = false;
                break;
              }
            }
            if (valid) {
              cue.p.x = nx;
              cue.p.y = ny;
            }
            return;
          }
          if (!aiming || !table.running) return;
          table.aim.x = t.x;
          table.aim.y = t.y;
          placeAimGlow(table.aim);
          aimMoved = true;
          updateAutoCue();
        });

        document.addEventListener('pointerup', function (e) {
          if (table.turn !== 1) return;
          canvas.releasePointerCapture && canvas.releasePointerCapture(e.pointerId);
          if (draggingCue) {
            draggingCue = false;
            var cue = table.balls[0];
            table.aim = { x: cue.p.x, y: cue.p.y - BALL_R * 4 };
            showGuides = true;
            return;
          }
          aiming = false;
        });

        function placeAimGlow() {
          /* shadow removed */
        }

        /* ==========================================================
       GUIDES + CUE ON TABLE
       ========================================================= */
        function drawGuides(cue, aim) {
          var dx = aim.x - cue.p.x,
            dy = aim.y - cue.p.y;
          var L = len(dx, dy) || 1;
          var dir = { x: dx / L, y: dy / L };
          lastGuideDir = dir;
          var tHit = Infinity;
          var target = null;
          var railNormal = null;

          function checkRail(t, normal) {
            if (t >= 0 && t < tHit) {
              tHit = t;
              railNormal = normal;
              target = null;
            }
          }

          if (dir.x < 0)
            checkRail((BORDER + BALL_R - cue.p.x) / dir.x, { x: 1, y: 0 });
          if (dir.x > 0)
            checkRail(
              (TABLE_W - BORDER - BALL_R - cue.p.x) / dir.x,
              { x: -1, y: 0 }
            );
          if (dir.y < 0)
            checkRail(
              (BORDER_TOP + BALL_R - cue.p.y) / dir.y,
              { x: 0, y: 1 }
            );
          if (dir.y > 0)
            checkRail(
              (TABLE_H - BORDER_BOTTOM - BALL_R - cue.p.y) / dir.y,
              { x: 0, y: -1 }
            );

          var diam = BALL_R * 2;
          var diam2 = diam * diam;
          for (var j = 0; j < table.balls.length; j++) {
            var b = table.balls[j];
            if (b === cue || b.pocketed) continue;
            var v = { x: b.p.x - cue.p.x, y: b.p.y - cue.p.y };
            var proj = v.x * dir.x + v.y * dir.y;
            if (proj <= 0) continue;
            var perp2 = v.x * v.x + v.y * v.y - proj * proj;
            if (perp2 > diam2) continue;
            var thc = Math.sqrt(diam2 - perp2);
            var t = proj - thc;
            if (t >= 0 && t < tHit) {
              tHit = t;
              target = b;
              railNormal = null;
            }
          }

          var impactX = cue.p.x + dir.x * tHit,
            impactY = cue.p.y + dir.y * tHit;
          var contactX = impactX,
            contactY = impactY,
            hitN = null;
          if (target) {
            var tx0 = target.p.x,
              ty0 = target.p.y;
            hitN = { x: tx0 - impactX, y: ty0 - impactY };
            var nL0 = len(hitN.x, hitN.y) || 1;
            hitN.x /= nL0;
            hitN.y /= nL0;
            contactX = tx0 - hitN.x * BALL_R;
            contactY = ty0 - hitN.y * BALL_R;
          }
          const guaranteedHit = target && !railNormal;
          ctx.save();
          ctx.strokeStyle = guaranteedHit
            ? 'rgba(255,255,0,1)'
            : 'rgba(255,255,255,.7)';
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.moveTo(cue.p.x * sX, cue.p.y * sY);
          ctx.lineTo(contactX * sX, contactY * sY);
          ctx.stroke();
          ctx.restore();

          if (!target && railNormal) {
            var dotIn = dir.x * railNormal.x + dir.y * railNormal.y;
            var refl = {
              x: dir.x - 2 * dotIn * railNormal.x,
              y: dir.y - 2 * dotIn * railNormal.y
            };
            // adjust the reflection based on selected spin
            refl.x += spinVec.x * 0.3;
            refl.y += spinVec.y * 0.3;
            var rL = Math.hypot(refl.x, refl.y) || 1;
            refl.x /= rL;
            refl.y /= rL;
            ctx.save();
            ctx.strokeStyle = 'rgba(255,255,255,.5)';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(impactX * sX, impactY * sY);
            ctx.lineTo(
              (impactX + refl.x * BALL_R * 4) * sX,
              (impactY + refl.y * BALL_R * 4) * sY
            );
            ctx.stroke();
            ctx.restore();
          }

          if (target) {
            var tx = target.p.x,
              ty = target.p.y;
            var impactCueX = impactX,
              impactCueY = impactY;
            // hitN already normalized above when computing contactX/contactY

            // Draw marker circle with a plus at the contact point
            var hitSpotX = tx - hitN.x * BALL_R;
            var hitSpotY = ty - hitN.y * BALL_R;
            var canvasHitX = hitSpotX * sX;
            var canvasHitY = hitSpotY * sY;
            var markerR = ballR;
            ctx.save();
            ctx.strokeStyle = 'rgba(255,255,255,.8)';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.arc(canvasHitX, canvasHitY, markerR, 0, Math.PI * 2);
            ctx.stroke();
            // plus sign
            ctx.beginPath();
            ctx.moveTo(canvasHitX - markerR / 2, canvasHitY);
            ctx.lineTo(canvasHitX + markerR / 2, canvasHitY);
            ctx.moveTo(canvasHitX, canvasHitY - markerR / 2);
            ctx.lineTo(canvasHitX, canvasHitY + markerR / 2);
            ctx.stroke();
            ctx.restore();

            // Project the target ball's path along the line of centers
            var tMax = Infinity;
            if (hitN.x > 0)
              tMax = Math.min(tMax, (TABLE_W - BORDER - BALL_R - tx) / hitN.x);
            if (hitN.x < 0)
              tMax = Math.min(tMax, (BORDER + BALL_R - tx) / hitN.x);
            if (hitN.y > 0)
              tMax = Math.min(
                tMax,
                (TABLE_H - BORDER_BOTTOM - BALL_R - ty) / hitN.y
              );
            if (hitN.y < 0)
              tMax = Math.min(tMax, (BORDER_TOP + BALL_R - ty) / hitN.y);
            var ex = tx + hitN.x * tMax;
            var ey = ty + hitN.y * tMax;

            ctx.save();
            ctx.strokeStyle = 'rgba(255,255,255,.3)';
            ctx.lineWidth = 1;
            ctx.beginPath();
            // start the target path from the center of the marker so it connects with the aim line
            ctx.moveTo(canvasHitX, canvasHitY);
            ctx.lineTo(
              (ex - hitN.x * BALL_R) * sX,
              (ey - hitN.y * BALL_R) * sY
            );
            ctx.stroke();
            ctx.restore();

            // Calculate cue ball deflection direction
            var dot = dir.x * hitN.x + dir.y * hitN.y;
            var cbDir = { x: dir.x - hitN.x * dot, y: dir.y - hitN.y * dot };
            var cbL = len(cbDir.x, cbDir.y);
            if (cbL > 0.0001) {
              cbDir.x /= cbL;
              cbDir.y /= cbL;
              var cbEndX = impactCueX + cbDir.x * BALL_R * 4;
              var cbEndY = impactCueY + cbDir.y * BALL_R * 4;
              ctx.save();
              ctx.strokeStyle = 'rgba(255,255,255,.5)';
              ctx.lineWidth = 1;
              ctx.beginPath();
              ctx.moveTo(impactCueX * sX, impactCueY * sY);
              ctx.lineTo(cbEndX * sX, cbEndY * sY);
              ctx.stroke();
              ctx.restore();
            }
          }
        }

        function drawCueOnTable(cuePos, aim, pull) {
          // Align the cue with the guideline and pull it back based on the power slider
          var dx = aim.x - cuePos.x,
            dy = aim.y - cuePos.y;
          var len = Math.hypot(dx, dy) || 1;
          var dir = { x: dx / len, y: dy / len };
          var angle = Math.atan2(dir.y, dir.x) + Math.PI / 2;

          // Cue dimensions and offset to position the butt slightly lower
          var cueLength = BALL_R * 20;
          // Move cue image down by a little more than six ball diameters
          var cueShift = BALL_R * 2 * 6.3;

          if (cueImg.complete) {
            var scale = (cueLength * sX) / cueImg.width;
            var drawW = cueImg.width * scale;
            var drawH = cueImg.height * scale;
            var shiftPx = cueShift * sX;

            ctx.save();
            // Move origin away from the cue ball to simulate pullback
            ctx.translate(
              (cuePos.x - dir.x * pull) * sX,
              (cuePos.y - dir.y * pull) * sY
            );
            ctx.rotate(angle);
            // Offset the butt slightly downward
            ctx.translate(shiftPx, 0);
            ctx.drawImage(cueImg, -drawW / 2 - shiftPx, 0, drawW, drawH);
            ctx.restore();
          }
        }

        function drawUPocket(ctx, x, y, r, angle, fill) {
          ctx.save();
          ctx.translate(x * sX, y * sY);
          ctx.rotate(angle);
          var R = r * scaleFactor;
          var halfHeight = R; // distance to straight short sides
          var halfWidth = R * 1.1; // width of rounded long sides
          var w = halfWidth * 0.52; // shorten straight edges a bit more on the outer side
          ctx.beginPath();
          // Top straight edge
          ctx.moveTo(-w, -halfHeight);
          ctx.lineTo(w, -halfHeight);
          // Rounded right side
          ctx.arc(w, 0, halfHeight, -Math.PI / 2, Math.PI / 2);
          // Bottom straight edge
          ctx.lineTo(-w, halfHeight);
          // Rounded left side
          ctx.arc(-w, 0, halfHeight, Math.PI / 2, -Math.PI / 2);
          ctx.closePath();
          if (fill) ctx.fill();
          ctx.stroke();
          ctx.restore();
        }

        /* ==========================================================
       SPIN CONTROL – disk i bardhe me pike te kuqe
       ========================================================= */
        var spinTimer = null,
          spinMoved = false;
        function setSpin(nx, ny) {
          spinDot.style.left = 50 + nx * 50 + '%';
          spinDot.style.top = 50 + ny * 50 + '%';
          spinVec = { x: nx, y: ny };
        }
        setSpin(0, 0);
        function updateSpin(e) {
          var r = spinBox.getBoundingClientRect();
          var x = ((e.clientX - r.left) / r.width) * 2 - 1,
            y = ((e.clientY - r.top) / r.height) * 2 - 1;
          var L = Math.hypot(x, y);
          x = (x / (L || 1)) * Math.min(1, L);
          y = (y / (L || 1)) * Math.min(1, L);
          setSpin(x, y);
          spinMoved = true;
        }
        spinBox.addEventListener('pointerdown', function (e) {
          if (table.turn !== 1) return;
          spinMoved = false;
          spinBox.style.transform = 'translate(-50%, -50%) scale(1.4)';
          clearTimeout(spinTimer);
          updateSpin(e);
          spinBox.setPointerCapture(e.pointerId);
          spinTimer = setTimeout(function () {
            if (!spinMoved)
              spinBox.style.transform = 'translate(-50%, -50%) scale(1)';
          }, 1500);
        });
        spinBox.addEventListener('pointermove', function (e) {
          if (table.turn !== 1 || e.buttons !== 1) return;
          updateSpin(e);
        });
        spinBox.addEventListener('pointerup', function () {
          if (table.turn !== 1) return;
          clearTimeout(spinTimer);
          setTimeout(function () {
            spinBox.style.transform = 'translate(-50%, -50%) scale(1)';
          }, 50);
        });

        /* ==========================================================
       PULL & RELEASE – fuqi e goditjes
       ========================================================= */
        var pulling = false,
          pullMoved = false;
        function updatePullHandle() {
          var rect = pullArea.getBoundingClientRect();
          // Move the cue handle lower so it doesn't overlap the table
          var minY = -powerCue.offsetHeight * 0.3;
          var maxY = rect.height - powerCue.offsetHeight * 0.4;
          var y = minY + (maxY - minY) * power;
          powerCue.style.top = y + 'px';
          pullHandle.style.top = y + 'px';
          // Keep the power percentage above the pull handle as it moves
          powerTxt.style.top = y - 30 + 'px';
          var barWidth = 12;
          var barHeight = maxY - minY;
          powerBg.style.width = barWidth + 'px';
          powerBg.style.height = barHeight + 'px';
          powerBg.style.top = minY + 'px';
          powerBox.style.width = barWidth + 'px';
          powerBox.style.height = barHeight + 'px';
          powerBox.style.top = minY + 'px';
        }
        function updatePowerUI() {
          powerFill.style.height = Math.round(power * 100) + '%';
          powerPercent.textContent = Math.round(power * 100) + '%';
          pullArea.style.background = 'none';
          if (power > 0) {
            var pct = Math.round(power * 100);
            cueRail.style.background =
              'linear-gradient(to bottom, rgba(255,255,255,0.6) 0%, rgba(255,255,255,0.6) ' +
              pct +
              '%, transparent ' +
              pct +
              '%, transparent 100%)';
          } else {
            cueRail.style.background = 'none';
          }
          updatePullHandle();
        }

        function startCueStrikeAnimation(initialPull, p) {
          cueVisible = true;
          cueStrike.active = true;
          cueStrike.speed = BALL_R * 120 * (0.25 + 0.75 * p);
          cueStrike.stage = 'forward';
          cuePullVisual = initialPull;
        }

        function animateCueStrike(dt) {
          if (!cueStrike.active) return;
          if (cueStrike.stage === 'forward') {
            cuePullVisual -= cueStrike.speed * dt;
            if (cuePullVisual <= 0) {
              if (spinVec.y < -0.1) {
                cuePullVisual = -BALL_R * 0.2; // small push for top spin
                cueStrike.stage = 'recover';
              } else if (spinVec.y > 0.1) {
                cuePullVisual = BALL_R * 0.2; // slight pullback for back spin
                cueStrike.stage = 'recover';
              } else {
                cuePullVisual = 0;
                cueStrike.active = false;
                cueVisible = false;
              }
            }
          } else if (cueStrike.stage === 'recover') {
            if (spinVec.y < -0.1) {
              cuePullVisual += cueStrike.speed * dt;
              if (cuePullVisual >= 0) {
                cuePullVisual = 0;
                cueStrike.active = false;
                cueVisible = false;
              }
            } else if (spinVec.y > 0.1) {
              cuePullVisual -= cueStrike.speed * dt;
              if (cuePullVisual <= 0) {
                cuePullVisual = 0;
                cueStrike.active = false;
                cueVisible = false;
              }
            }
          }
        }
        function updateFromEvent(e) {
          var rect = pullArea.getBoundingClientRect();
          power = clamp((e.clientY - rect.top) / rect.height, 0, 1);
          updatePowerUI();
          cuePullVisual = power * (BALL_R * 14);
          placeAimGlow(table.aim);
        }
        pullHandle.addEventListener('pointerdown', function (e) {
          if (!table.running || table.isMoving() || table.turn !== 1) return;
          pulling = true;
          pullMoved = false;
          pullHandle.setPointerCapture(e.pointerId);
        });
        pullHandle.addEventListener('pointermove', function (e) {
          if (!pulling || table.turn !== 1) return;
          pullMoved = true;
          updateFromEvent(e);
        });
        pullHandle.addEventListener('pointerup', function () {
          if (!pulling || table.turn !== 1) return;
          pulling = false;
          if (pullMoved && power > 0) {
            startCueStrikeAnimation(cuePullVisual, power);
            shoot(power);
          }
          power = 0;
          updatePowerUI();
        });

        updatePowerUI();

        let diceRolling = false;

        function shoot(p) {
          if (!table.running || table.isMoving() || diceRolling) return;
          clearTurnTimer();
          var cue = table.balls[0];
          if (!cue || cue.pocketed) return;
          isBreakShot = false;
          var aimPoint = table.aim;
          var dx = aimPoint.x - cue.p.x;
          var dy = aimPoint.y - cue.p.y;
          var L = Math.hypot(dx, dy) || 1;
          var d = { x: dx / L, y: dy / L };
          lastShotAim = { x: aimPoint.x, y: aimPoint.y };
          lastCueStart = { x: cue.p.x, y: cue.p.y };
          shotPocketRecorded = false;
          cueHitCushion = false;
          var base = 950 * 3 * 1.6 * 1.5;
          // Reduce the overall shot power by 50%
          base *= 0.5;
            playCueHit(p * 0.5);
            lastShotPower = p;
            currentShooter = table.turn;
            if (isNineBall || isAmerican)
              currentTarget = lowestBallOnTable();
          shotInProgress = true;
          pocketedAny = false;
          pocketedOwn = false;
          scratch = false;
          firstHit = null;
          pottedThisShot = [];
          eightBallPotted = false;
          nineBallPotted = false;
          cue.v.x = d.x * base * (0.25 + 0.75 * p);
          cue.v.y = d.y * base * (0.25 + 0.75 * p);
          cue.spin = { x: spinVec.x, y: spinVec.y };
          cue.spinApplied = false;
          cueBallFree = false;
          setSpin(0, 0);
          showGuides = false;
        }

        /* ==========================================================
       CPU – turn i thjeshte (normal skill)
       ========================================================= */
        async function cpuTurn() {
          if (window.trainingMode && window.trainingSolo) return;
          if (table.isMoving() || table.turn !== 2) return;
          cpuThinking = true;
          startCpuTimer();
          const { default: planShot } = await planShotPromise;
          var cue = table.balls[0];
          if (cueBallFree) {
            cue.p.x = TABLE_W / 2;
            cue.p.y = CUE_START_Y;
            cue.v.x = cue.v.y = 0;
          }
          const balls = table.balls
            .filter(Boolean)
            .map(b => ({ id: b.n, x: b.p.x, y: b.p.y, vx: b.v.x, vy: b.v.y, pocketed: !!b.pocketed }));
          const pockets = table.pockets.map(p => ({ x: p.x, y: p.y }));
          const req = {
            game: isNineBall
              ? 'NINE_BALL'
              : isAmerican
              ? 'AMERICAN_BILLIARDS'
              : 'EIGHT_POOL_UK',
            maxCutAngle: Math.PI / 6,
            minViewScore: 0.5,
            state: {
              balls,
              pockets,
              width: TABLE_W,
              height: TABLE_H,
              ballRadius: BALL_R,
              friction: 0.015,
              ballOn: assignedTypes[2] || null,
              myGroup:
                assignedTypes[2] === 'red'
                  ? 'SOLIDS'
                  : assignedTypes[2] === 'yellow'
                  ? 'STRIPES'
                  : 'UNASSIGNED',
              ballInHand: cueBallFree,
              mustPlayFromBaulk: cueBallFree,
              baulkLineY: LINE_Y + BALL_R
            }
          };
          let shot = planShot(req);
          if (!shot && !isNineBall && !isAmerican) {
            const { default: selectShot } = await import('/lib/poolUkAdvancedAi.js');
            const advState = {
              balls: balls.map(b => ({
                id: b.id,
                colour:
                  b.id === 0
                    ? 'cue'
                    : b.id === 8
                    ? 'black'
                    : b.id >= 1 && b.id <= 7
                    ? 'red'
                    : 'yellow',
                x: b.x,
                y: b.y,
                pocketed: b.pocketed
              })),
              pockets: table.pockets.map((p, i) => ({
                x: p.x,
                y: p.y,
                name: ['TL', 'TR', 'ML', 'MR', 'BL', 'BR'][i]
              })),
              width: TABLE_W,
              height: TABLE_H,
              ballRadius: BALL_R,
              ballOn:
                assignedTypes[2] === 'yellow'
                  ? 'yellow'
                  : assignedTypes[2] === 'red'
                  ? 'red'
                  : null,
              isOpenTable: !assignedTypes[2],
              freeBallAvailable: cueBallFree,
              shotsRemaining: 1,
              mustPlayFromBaulk: cueBallFree,
              baulkLineX: TABLE_W / 2,
              baulkLineY: LINE_Y + BALL_R
            };
            const plan = selectShot(advState);
            if (plan) {
              const angleRad = Math.atan2(
                plan.aimPoint.y - cue.p.y,
                plan.aimPoint.x - cue.p.x
              );
              const power =
                plan.cueParams.speed === 'soft'
                  ? 0.3
                  : plan.cueParams.speed === 'med'
                  ? 0.6
                  : 0.9;
              const spinMap = {
                stun: { top: 0, back: 0, side: 0 },
                followS: { top: 0.5, back: 0, side: 0 },
                followL: { top: 1, back: 0, side: 0 },
                drawS: { top: 0, back: 0.5, side: 0 },
                drawL: { top: 0, back: 1, side: 0 },
                sideL: { top: 0, back: 0, side: -0.5 },
                sideR: { top: 0, back: 0, side: 0.5 }
              };
              shot = {
                angleRad,
                power,
                spin: spinMap[plan.cueParams.spin] || { top: 0, back: 0, side: 0 },
                aimPoint: plan.aimPoint
              };
            }
          }
          if (!shot) {
            table.turn = 1;
            cpuThinking = false;
            clearTurnTimer();
            return;
          }
          if (shot.cueBallPosition) {
            var nx = clamp(
              shot.cueBallPosition.x,
              BORDER + BALL_R,
              TABLE_W - BORDER - BALL_R
            );
            var ny = clamp(
              shot.cueBallPosition.y,
              LINE_Y + BALL_R,
              TABLE_H - BORDER_BOTTOM - BALL_R
            );
            cue.p.x = nx;
            cue.p.y = ny;
            cue.v.x = cue.v.y = 0;
            cueBallFree = false;
          }
          var nd = { x: Math.cos(shot.angleRad), y: Math.sin(shot.angleRad) };
          var aimPoint = shot.aimPoint || { x: cue.p.x + nd.x * 100, y: cue.p.y + nd.y * 100 };
          var dist = Math.hypot(aimPoint.x - cue.p.x, aimPoint.y - cue.p.y);
          var bucket = dist <= SHORT_DIST ? 'short' : dist <= MED_DIST ? 'medium' : 'long';
          setCueVariant(bucket);
          if (isBreakShot) shot.power = 1;
          setSpin(shot.spin.side, shot.spin.top - shot.spin.back);
          showGuides = true;
          table.aim.x = aimPoint.x;
          table.aim.y = aimPoint.y;
          placeAimGlow(table.aim);
          cuePullVisual = shot.power * (BALL_R * 14);
          setTimeout(function () {
            cpuThinking = false;
            clearTurnTimer();
            startCueStrikeAnimation(cuePullVisual, shot.power);
            shoot(shot.power);
            showGuides = false;
          }, CPU_SHOT_DELAY);
        }

        /* ==========================================================
       START / RESIZE / RENDER fillestar
       ========================================================= */
        function startDiceRoll() {
          table.turn = 0;
          diceRolling = true;
          isBreakShot = true;
          const overlay = document.getElementById('diceOverlay');
          overlay.classList.remove('hidden');
          overlay.innerHTML = '<div class="dice-row" id="diceRow"></div><div id="diceMsg">Tap to roll dice</div>';

          const diceFaces = {
            1: [[0, 0, 0], [0, 1, 0], [0, 0, 0]],
            2: [[1, 0, 0], [0, 0, 0], [0, 0, 1]],
            3: [[1, 0, 0], [0, 1, 0], [0, 0, 1]],
            4: [[1, 0, 1], [0, 0, 0], [1, 0, 1]],
            5: [[1, 0, 1], [0, 1, 0], [1, 0, 1]],
            6: [[1, 0, 1], [1, 0, 1], [1, 0, 1]],
          };

          function createFace(value, className) {
            const face = document.createElement('div');
            face.className = 'dice-face ' + className;
            const grid = document.createElement('div');
            grid.style.display = 'grid';
            grid.style.gridTemplateColumns = 'repeat(3, 1fr)';
            grid.style.gridTemplateRows = 'repeat(3, 1fr)';
            grid.style.gap = '2px';
            diceFaces[value].flat().forEach((dot) => {
              const cell = document.createElement('div');
              cell.style.display = 'flex';
              cell.style.alignItems = 'center';
              cell.style.justifyContent = 'center';
              if (dot) {
                const d = document.createElement('div');
                d.className = 'dot';
                cell.appendChild(d);
              }
              grid.appendChild(cell);
            });
            face.appendChild(grid);
            return face;
          }

          function createDie(id) {
            const container = document.createElement('div');
            container.className = 'dice-container';
            container.id = id;
            const cube = document.createElement('div');
            cube.className = 'dice-cube';
            cube.style.transform = 'rotateX(-35deg) rotateY(45deg)';
            container.appendChild(cube);
            // initial faces
            cube.appendChild(createFace(2, 'dice-face--front'));
            cube.appendChild(createFace(5, 'dice-face--back'));
            cube.appendChild(createFace(3, 'dice-face--right'));
            cube.appendChild(createFace(4, 'dice-face--left'));
            cube.appendChild(createFace(1, 'dice-face--top'));
            cube.appendChild(createFace(6, 'dice-face--bottom'));
            return container;
          }

          function setDieValue(container, value) {
            const cube = container.querySelector('.dice-cube');
            const top = cube.querySelector('.dice-face--top');
            const bottom = cube.querySelector('.dice-face--bottom');
            top.replaceWith(createFace(value, 'dice-face--top'));
            bottom.replaceWith(createFace(7 - value, 'dice-face--bottom'));
          }

          function rollDie(container, cb) {
            const cube = container.querySelector('.dice-cube');
            cube.classList.add('animate-roll');
            const id = setInterval(() => {
              const v = Math.floor(Math.random() * 6) + 1;
              setDieValue(container, v);
            }, 50);
            setTimeout(() => {
              clearInterval(id);
              const final = Math.floor(Math.random() * 6) + 1;
              setDieValue(container, final);
              cube.classList.remove('animate-roll');
              cb(final);
            }, 1000);
          }

          const diceRow = document.getElementById('diceRow');
          const playerDie = createDie('playerDie');
          const cpuDie = createDie('cpuDie');
          diceRow.appendChild(playerDie);
          diceRow.appendChild(cpuDie);

          const diceMsg = document.getElementById('diceMsg');
          let playerRoll = null;
          let cpuRoll = null;
          let rolled = false;

          function checkResult() {
            if (playerRoll !== null && cpuRoll !== null) {
              if (playerRoll === cpuRoll) {
                diceMsg.textContent = 'Tie! Rolling again...';
                setTimeout(startDiceRoll, 1000);
                return;
              }
              const playerStarts = playerRoll > cpuRoll;
              diceMsg.textContent = playerStarts ? 'You break first' : 'CPU breaks first';
              setTimeout(() => {
                overlay.classList.add('hidden');
                diceRolling = false;
                table.turn = playerStarts ? 1 : 2;
                updateTurnIndicator(true);
                showTurnInfo();
                if (table.turn === 2) cpuTurn();
              }, 1000);
            }
          }

          function rollBoth() {
            if (rolled) return;
            rolled = true;
            rollDie(playerDie, (v) => {
              playerRoll = v;
              checkResult();
            });
            rollDie(cpuDie, (v) => {
              cpuRoll = v;
              checkResult();
            });
          }

          diceRow.addEventListener('click', rollBoth);
          setTimeout(rollBoth, 5000);
        }

        playBtn.addEventListener('click', function () {
          playBtn.style.display = 'none';
          table.running = true;
          resize();
          table.render();
          if (window.trainingMode && window.trainingSolo) {
            var cpuPlayer = document.querySelector('#header .player:last-child');
            if (cpuPlayer) cpuPlayer.style.display = 'none';
            table.turn = 1;
            isBreakShot = true;
            updateTurnIndicator(true);
            showTurnInfo();
          } else {
            startDiceRoll();
          }
        });
        resize();
        table.render();
      })();
    </script>

    <div id="trainingMenuWrapper" class="hidden">
      <button id="trainingMenuButton">☰</button>
    </div>
    <div id="trainingMenu" class="hidden">
      <div id="trainingMenuInner">
        <button id="practiceSolo">Practice Solo</button>
        <button id="practiceAi">Practice vs AI</button>
        <button id="restartTraining">New Game</button>
      </div>
    </div>

    <div id="tournamentOverlay" class="hidden">
      <canvas id="bracket"></canvas>
    </div>

    <script>
      const rulesBtn = document.getElementById('rulesBtn');
      const rulesModal = document.getElementById('rulesModal');
      const closeRules = document.getElementById('closeRules');
      const rulesTitle = document.getElementById('rulesTitle');
      const rulesList = document.getElementById('rulesList');
      const rulesSource = document.getElementById('rulesSource');

      const ruleSets = {
        uk: {
          title: '8 Ball UK Rules',
          items: [
            'On the break, any potted balls count for the breaker. If a single colour is potted, continue with that colour.',
            'Potting both colours on the break lets the breaker choose which colour to play.',
            'Potting on the break keeps the turn until a miss.',
            'Potting an opponent\'s ball is a foul that grants the opponent two shots.',
            'Hitting an opponent ball first is a foul and gives the opponent two shots.',
            'Failing to contact your colour, or the black when none remain, is a foul awarding two shots to the opponent.',
            'On the black 8, even after a foul, only one shot is allowed.',
            'Once your coloured balls are gone, pot the black 8 to win — it\'s not a foul.',
            'After a foul the incoming player may place the cue ball behind the line and aim anywhere.'
          ],
          source: 'Custom 8 Ball UK rules for Pool Royale.'
        },
          american: {
            title: 'American Billiards Rules',
            items: [
              'Balls must be struck in numerical order; failing to contact the lowest numbered ball first is a foul.',
              'Pocketed balls score their face value, but points from a fouled shot go to the opponent.',
              'Pocketing the cue ball awards any points from that shot to the opponent.',
              'When in hand, the cue ball must remain behind the head string.',
              'If scores are tied after all balls are potted, spot the 8-ball and place the cue ball behind the head string; the last scorer shoots first and whoever pots the 8-ball wins.'
            ],
            source: 'Based on traditional 15-ball rotation guidelines.'
          },
          '9ball': {
            title: '9-Ball Rules',
            items: [
              'Balls must be struck in numerical order from 1 to 9; failing to hit the next ball first is a foul.',
              'Any ball pocketed after correctly contacting the lowest ball keeps the turn.',
              'Pocketing the cue ball ends your turn and hands play to the opponent.',
              'The cue ball may be moved only behind the head line at the start or after a foul.',
              'Choose shots that favor balls near pockets or with clean angles.',
              'The AI draws a helper line—direct or off a rail—to guarantee the next ball is contacted first.',
              'On straight shots, the AI may use draw or spin to move other balls after the legal hit, prioritizing higher numbers when advantageous.',
              'Example: if the 2-ball is the target and the 9-ball sits by a pocket, hit the 2 then use the cue ball to push the 9 in to win.'
            ],
            source: 'Custom Pool Royale 9-ball guidelines.'
          }
      };

      rulesBtn.addEventListener('click', () => {
        const r = ruleSets[variant] || ruleSets.uk;
        rulesTitle.textContent = r.title;
        rulesList.innerHTML = r.items.map(i => `<li>${i}</li>`).join('');
        rulesSource.textContent = r.source;
        rulesModal.classList.remove('hidden');
      });

      closeRules.addEventListener('click', () => {
        rulesModal.classList.add('hidden');
      });

      rulesModal.addEventListener('click', (e) => {
        if (e.target === rulesModal) {
          rulesModal.classList.add('hidden');
        }
      });

      if (params.get('type') === 'training') {
        const wrapper = document.getElementById('trainingMenuWrapper');
        const menuBtn = document.getElementById('trainingMenuButton');
        const menu = document.getElementById('trainingMenu');
        wrapper.classList.remove('hidden');
        menuBtn.addEventListener('click', () => {
          menu.classList.remove('hidden');
        });
        menu.addEventListener('click', (e) => {
          if (e.target === menu) menu.classList.add('hidden');
        });
        document.getElementById('practiceSolo').addEventListener('click', () => {
          window.trainingSolo = true;
          menu.classList.add('hidden');
        });
        document.getElementById('practiceAi').addEventListener('click', () => {
          window.trainingSolo = false;
          menu.classList.add('hidden');
        });
        document.getElementById('restartTraining').addEventListener('click', () => {
          window.location.reload();
        });
      }

      if (params.get('type') === 'tournament') {
        window.handleTournamentResult = async function (winner) {
          try {
            var st = JSON.parse(localStorage.getItem(STATE_KEY) || '{}');
            if (!st.pendingMatch) {
              window.location.href = '/poll-royale-bracket.html?' + window.location.search.slice(1);
              return;
            }
            var r = st.pendingMatch.round;
            var m = st.pendingMatch.match;
            var oppSeed = st.pendingMatch.pair[0] === st.userSeed ? st.pendingMatch.pair[1] : st.pendingMatch.pair[0];
            var winNum = Number(winner);
            var winnerSeed = winNum === 1 ? st.userSeed : oppSeed;
            var next = st.rounds[r + 1];
            if (next) {
              next[Math.floor(m / 2)][m % 2] = winnerSeed;
            } else {
              st.championSeed = winnerSeed;
              st.complete = true;
            }
            if (winNum !== 1) {
              simulateRemaining(st, r);
            } else {
              simulateRoundAI(st, r);
              if (next && st.rounds[r].every((p, idx) => next[Math.floor(idx / 2)][idx % 2])) {
                st.currentRound++;
              }
            }
            if (st.complete && winNum === 1 && stake > 0 && accountId) {
              const total = stake * window.tournamentPlayers;
              const prize = Math.round(total * 0.91);
              try {
                await prApi.depositAccount(accountId, prize, { game: 'pollroyale-win' });
                if (tgId) await prApi.addTransaction(tgId, 0, 'win', { game: 'pollroyale', players: window.tournamentPlayers, accountId });
                const ops = [];
                if (devAccount1 || devAccount2) {
                  if (devAccount) ops.push(prApi.depositAccount(devAccount, Math.round(total * 0.09), { game: 'pollroyale-dev' }));
                  if (devAccount1) ops.push(prApi.depositAccount(devAccount1, Math.round(total * 0.01), { game: 'pollroyale-dev1' }));
                  if (devAccount2) ops.push(prApi.depositAccount(devAccount2, Math.round(total * 0.02), { game: 'pollroyale-dev2' }));
                } else if (devAccount) {
                  ops.push(prApi.depositAccount(devAccount, Math.round(total * 0.1), { game: 'pollroyale-dev' }));
                }
                if (ops.length) await Promise.all(ops);
              } catch {}
            }
            delete st.pendingMatch;
            localStorage.setItem(STATE_KEY, JSON.stringify(st));
            localStorage.removeItem(OPP_KEY);
          } catch (err) {
            console.error(err);
          }
          window.location.href = '/poll-royale-bracket.html?' + window.location.search.slice(1);
        };

        function simulateRoundAI(st, round) {
          var next = st.rounds[round + 1];
          var userSeed = st.userSeed;
          st.rounds[round].forEach(function (pair, idx) {
            if (pair.includes(userSeed)) return;
            if (next && next[Math.floor(idx / 2)][idx % 2]) return;
            var s1 = pair[0];
            var s2 = pair[1];
            var p1 = st.seedToPlayer[s1];
            var p2 = st.seedToPlayer[s2];
            var w;
            if (p1 && p1.name === 'BYE') w = s2;
            else if (p2 && p2.name === 'BYE') w = s1;
            else w = Math.random() < 0.5 ? s1 : s2;
            if (next) {
              next[Math.floor(idx / 2)][idx % 2] = w;
            } else {
              st.championSeed = w;
              st.complete = true;
            }
          });
        }

        function simulateRemaining(st, startRound) {
          for (var r = startRound; r < st.rounds.length; r++) {
            simulateRoundAI(st, r);
            if (st.complete) break;
          }
          st.currentRound = st.rounds.length - 1;
          st.complete = true;
        }
      }

      // Rotate corner holes diagonally; keep side holes horizontal
      const allHoles = document.querySelectorAll('.hole');
      if (allHoles.length === 6) {
        allHoles.forEach((hole, idx) => {
          if (idx === 2 || idx === 3) {
            hole.style.transform = 'rotate(0deg)';
          } else {
            hole.style.transform = 'rotate(-45deg)';
          }
        });
      }
</script>
<script>
if(window.tournamentMode){
  const tg = window.Telegram?.WebApp;
  function showExitPopup(){
    if(document.getElementById('tournExit')) return;
    const overlay=document.createElement('div');
    overlay.id='tournExit';
    overlay.style.position='fixed';overlay.style.inset='0';
    overlay.style.background='rgba(0,0,0,0.6)';
    overlay.style.display='flex';overlay.style.flexDirection='column';
    overlay.style.alignItems='center';overlay.style.justifyContent='center';
    const box=document.createElement('div');
    box.style.background='#11172a';box.style.padding='20px';box.style.borderRadius='8px';box.style.textAlign='center';box.style.maxWidth='90%';box.style.color='#dbe7ff';
    box.innerHTML='<p style="margin-bottom:12px;">If you quit the tournament, your funds will be lost.</p>';
    const quit=document.createElement('button');
    quit.textContent='Quit Tournament';
    quit.style.margin='4px';quit.style.padding='8px 12px';
    quit.style.background='#f97316';quit.style.border='none';
    quit.style.borderRadius='4px';quit.style.color='#fff';
    const ret=document.createElement('button');
    ret.textContent='Return to Lobby';
    ret.style.margin='4px';ret.style.padding='8px 12px';
    ret.style.background='#2563eb';ret.style.border='none';
    ret.style.borderRadius='4px';ret.style.color='#fff';
    box.appendChild(quit);box.appendChild(ret);overlay.appendChild(box);document.body.appendChild(overlay);
    quit.onclick=()=>{localStorage.removeItem(STATE_KEY);localStorage.removeItem(OPP_KEY);if(tg) tg.BackButton.hide();window.location.href='/games/pollroyale/lobby';};
    ret.onclick=()=>{if(tg) tg.BackButton.show();window.location.href='/poll-royale-bracket.html'+window.location.search;};
  }
  if(tg){ tg.BackButton.show(); tg.onEvent('backButtonClicked', showExitPopup); }
  history.pushState(null,'',location.href);
  window.addEventListener('popstate',(e)=>{ e.preventDefault(); showExitPopup(); history.pushState(null,'',location.href); });
}
</script>
</body>
</html>
