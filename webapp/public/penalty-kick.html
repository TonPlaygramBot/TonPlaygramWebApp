<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
<meta name="apple-mobile-web-app-capable" content="yes" />
<title>Penalty Kick Pro ‚Äî Mobile Elite</title>
<style>
  :root{
    --bg:#090f21; --txt:#dbe8ff; --muted:#9fb1df;
    --panel:#0b1225cc; --panel-b:#1c244a; --panel-solid:#0b1225;
    --accent:#2563eb; --accent-2:#22c55e; --warn:#ef4444;
    --turf1:#0c7a23; --turf2:#0a6c1d; --chalk:#ffffff; --goal:#ffffff; --net:#ececec;
    --hole:#e10600; --pts:#ffd400;
  }
  *{box-sizing:border-box}
  html,body{height:100%;margin:0;background:var(--bg);color:var(--txt);
    font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Helvetica,Arial,sans-serif;overflow:hidden}
  #game{position:fixed;inset:0;width:100vw;height:100svh;display:block;touch-action:none;z-index:1}

  /* ===== HUD ===== */
  .hud{position:fixed;left:env(safe-area-inset-left,12px);right:env(safe-area-inset-right,12px);
    z-index:100;display:grid;grid-template-columns:1fr auto 1fr;gap:10px;align-items:center}
  .panel{background:var(--panel);border:1px solid var(--panel-b);backdrop-filter:blur(8px);
    border-radius:14px;padding:8px 12px;display:flex;align-items:center;justify-content:space-between;gap:10px}
  .score{font-weight:900;font-size:20px}
  .meta{font-size:12px;color:var(--muted)}
  .btns{display:flex;gap:8px}
  button{appearance:none;border:0;border-radius:12px;padding:8px 12px;font-weight:800;letter-spacing:.3px;color:#fff;background:var(--accent);
    box-shadow:0 6px 16px rgba(0,0,0,.25)}
  button.ghost{background:#273154}
  button.warn{background:var(--warn)}

  /* ===== Rivals row ===== */
  .previews{position:fixed;left:env(safe-area-inset-left,12px);right:env(safe-area-inset-right,12px);
    top:env(safe-area-inset-top,10px);z-index:90;display:grid;grid-template-columns:repeat(3,1fr);gap:8px}
  .pcard{background:var(--panel);border:1px solid var(--panel-b);border-radius:18px;padding:6px;min-height:80px;display:grid;gap:6px}
  .phead{display:flex;align-items:center;justify-content:space-between;font-weight:800;gap:6px}
  .phead .avatar{width:20px;height:14px;border-radius:2px;object-fit:cover}
  .ppts{color:var(--pts);font-weight:900}
  .pcard canvas{display:block;width:100%;height:auto;border-radius:12px}

  /* ===== Player bar ===== */
  .pbar{position:fixed;left:env(safe-area-inset-left,12px);right:env(safe-area-inset-right,12px);
    z-index:95;display:flex;align-items:center;gap:8px;background:var(--panel);
    border:1px solid var(--panel-b);border-radius:16px;padding:10px 12px}
  .avatar{width:28px;height:28px;border-radius:50%;background:linear-gradient(135deg,#22c55e,#2563eb);box-shadow:0 0 0 2px #081027 inset}
  .badge{background:#0f1a3a;border:1px solid var(--panel-b);color:var(--txt);padding:6px 10px;border-radius:12px;font-weight:800;font-size:12px}
  .hearts{color:#ff4d6d;letter-spacing:2px}
  .scoreVal{color:var(--pts);font-size:18px}

  /* ===== Stage label area (visual only) ===== */
  .stage{position:fixed;left:env(safe-area-inset-left,12px);right:env(safe-area-inset-right,12px);
    top:calc(env(safe-area-inset-top,10px) + 70px + 128px + 16px + 56px + 10px);
    bottom:env(safe-area-inset-bottom,72px);z-index:80;pointer-events:none}
  .stage .frame{position:absolute;inset:0;border-radius:18px;border:1px solid var(--panel-b);pointer-events:none}

  /* ===== Bottom ribbon ===== */
  .bottom{position:fixed;left:env(safe-area-inset-left,12px);right:env(safe-area-inset-right,12px);
    bottom:env(safe-area-inset-bottom,10px);z-index:96}
  .ribbon{background:var(--panel);border:1px solid var(--panel-b);border-radius:12px;padding:8px 12px;text-align:center;font-size:14px}

  /* tests */

  @media (max-width: 420px){
    .hud{grid-template-columns:1fr}
  }
</style>
</head>
<body>
  <div class="previews" id="previews">
    <div class="pcard" id="pv0">
      <div class="phead">
        <div style="display:flex;align-items:center;gap:4px">
          <img id="pv0avatar" class="avatar" alt="" />
          <span id="pv0name"></span>
        </div>
        <div class="ppts" id="pv0pts">0</div>
      </div>
      <canvas width="240" height="120"></canvas>
    </div>
    <div class="pcard" id="pv1">
      <div class="phead">
        <div style="display:flex;align-items:center;gap:4px">
          <img id="pv1avatar" class="avatar" alt="" />
          <span id="pv1name"></span>
        </div>
        <div class="ppts" id="pv1pts">0</div>
      </div>
      <canvas width="240" height="120"></canvas>
    </div>
    <div class="pcard" id="pv2">
      <div class="phead">
        <div style="display:flex;align-items:center;gap:4px">
          <img id="pv2avatar" class="avatar" alt="" />
          <span id="pv2name"></span>
        </div>
        <div class="ppts" id="pv2pts">0</div>
      </div>
      <canvas width="240" height="120"></canvas>
    </div>
  </div>

  <div class="pbar" id="pbar">
    <div style="display:flex;align-items:center;gap:10px"><img class="avatar" id="userAvatar" alt="" /><div id="username">You</div></div>
    <div class="badge hearts">‚ù§‚ù§‚ù§</div>
      <div class="badge">Time <span id="timeShort">17</span>s</div>
    <div class="badge">Score <span id="playerScore" class="scoreVal">0</span></div>
  </div>

  <div class="stage"><div class="frame"></div></div>

  <canvas id="game" aria-label="Penalty field"></canvas>

<script>
(()=> {
  // ===== Canvas =====
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d', { alpha:true });
  let DPR=1, W=0, H=0;
  function resize(){
    DPR = Math.max(1, Math.min(2.5, window.devicePixelRatio||1));
    W = Math.floor(window.innerWidth); H = Math.floor(window.innerHeight);
    canvas.width = Math.floor(W*DPR); canvas.height = Math.floor(H*DPR);
    ctx.setTransform(DPR,0,0,DPR,0,0);
    positionLayout();
    layout();
    initBanners();
    initCameras();
    drawStaticOnce();
  }
  addEventListener('resize', resize);

  // ===== UI refs =====
  const timeShort = document.getElementById('timeShort');
  const previewsEl= document.getElementById('previews');
  const userAvatarEl = document.getElementById('userAvatar');
  const usernameEl = document.getElementById('username');
  const pvAvatars = [document.getElementById('pv0avatar'), document.getElementById('pv1avatar'), document.getElementById('pv2avatar')];
  const pvNames   = [document.getElementById('pv0name'), document.getElementById('pv1name'), document.getElementById('pv2name')];

  function positionLayout(){
    const pr = previewsEl.getBoundingClientRect();
    const pbar = document.getElementById('pbar');
    pbar.style.top = (pr.bottom + 8) + 'px';
    document.querySelector('.stage').style.top = (pbar.getBoundingClientRect().bottom + 16) + 'px';
  }

  const params = new URLSearchParams(location.search);
  const avatarParam = params.get('avatar') || '';
  let userName = params.get('name') || params.get('username') || '';
  const durationParam = parseInt(params.get('duration')) || 18;
  timeShort.textContent = durationParam;

  function emojiToDataUri(flag){
    return `data:image/svg+xml,${encodeURIComponent(`<svg xmlns='http://www.w3.org/2000/svg' width='64' height='64'><text x='50%' y='50%' font-size='48' text-anchor='middle' dominant-baseline='central'>${flag}</text></svg>`)}`;
  }
  const regionNames = new Intl.DisplayNames(['en'], { type: 'region' });
  function flagName(flag){
    const pts = [...flag].map(c=>c.codePointAt(0)-127397);
    const code = String.fromCharCode(...pts);
    return regionNames.of(code) || flag;
  }

  if(!userName){
    const userData = window?.Telegram?.WebApp?.initDataUnsafe?.user;
    userName = userData?.username || [userData?.first_name, userData?.last_name].filter(Boolean).join(' ') || 'Player';
  }
  usernameEl.textContent = userName;
  const hudNameEl = document.querySelector('#hud .panel .meta');
  if(hudNameEl) hudNameEl.textContent = userName;

  let userAvatar = avatarParam;
  const initUser = window?.Telegram?.WebApp?.initDataUnsafe?.user;
  if(!userAvatar && initUser?.photo_url){ userAvatar = initUser.photo_url; }
  if(!userAvatar){ userAvatar = 'assets/icons/profile.svg'; }
  else if(!(userAvatar.startsWith('http')||userAvatar.startsWith('/')||userAvatar.startsWith('data:'))){
    userAvatar = emojiToDataUri(userAvatar);
  }
  userAvatarEl.src = userAvatar;

  const flags = ['üá®üá¶','üá´üá∑','üá©üá™','üá™üá∏','üáßüá∑','üáØüáµ','üá∫üá∏','üá¨üáß'];
  for(let i=0;i<3;i++){
    const flag = flags[(Math.random()*flags.length)|0];
    if(pvAvatars[i]) pvAvatars[i].src = emojiToDataUri(flag);
    if(pvNames[i]) pvNames[i].textContent = flagName(flag);
  }
  positionLayout();

  // ===== Geometry =====
  const geom = { goal:{x:0,y:0,w:0,h:0,post:12}, spot:{x:0,y:0}, penaltySpot:{x:0,y:0}, scale:1, paDepth:0 };
  function layout(){
    const goalW = Math.min(W*0.92, 950) * 0.97;
    const goalH = Math.min(H*0.28, 260) * 0.92;
    const pbarBottom = document.getElementById('pbar').getBoundingClientRect().bottom;
    geom.goal = { x:(W-goalW)/2, y:pbarBottom + 10, w:goalW, h:goalH, post:12 };
    geom.scale = goalW / 860;
    geom.paDepth = Math.min(320*geom.scale, H*0.34);
    geom.penaltySpot = { x:W/2, y: geom.goal.y + geom.goal.h + geom.paDepth * (11/16.5) };
    // position the ball a bit higher near the bottom edge
    geom.spot = { x: W/2, y: H - BALL_R*geom.scale*1.8 };
    keeper.w = 40*geom.scale*4*0.85;
    keeper.h = 100*geom.scale*4*0.85;
    keeper.x = geom.goal.x + (geom.goal.w-keeper.w)/2;
    keeper.y = geom.goal.y + geom.goal.h - keeper.h + geom.goal.h*0.05;
    keeper.baseY = keeper.y;
    keeper.baseX = keeper.x;
  }

  // ===== Game state =====
  const ROUND_TIME = durationParam * 1000;
  let roundStart = 0; let timeLeft = ROUND_TIME; let running=false; let paused=false; let ended=false;
  let myScore = 0;

  const BALL_R = 40;
  // slightly faster initial shot speed
  const SHOT_SPEED = 14;
  const MIN_GOAL_POINTS = 5;
  const ball = { x:0,y:0,r:BALL_R, vx:0,vy:0, moving:false, trail:[], spin:0, angle:0, netSounded:false, firstContact:false, target:null, prevDist:null, points:0 };
  const ballImg = new Image();
  ballImg.src = '/assets/icons/file_0000000061d4620aaf506adfa605e1f3.webp';

  let holes=[]; let banners=[]; let cameras=[]; let fragments=[]; let looseBalls=[]; let punchEffects=[];
  let netHit={x:0,y:0,t:0,shake:0};
  let goalFlash=0;
  const NET_DECAY = 0.94; // decay factor for net pullback and shake
  const keeper={x:0,y:0,w:40,h:100,vx:0,vy:0,active:false,save:false,a:0,side:1,baseY:0,baseX:0,dive:0};
  const keeperImg = new Image();
  keeperImg.src = '/assets/icons/file_00000000945461f8bb9a2974fb9ee402.webp';
  const aimOn = false;

  const rivals=[
    { i:0, wrap:document.querySelector('#pv0'), ptsEl:document.querySelector('#pv0pts'), cvs:null, ctx:null, score:0, next:0, acc:0.68, rate:[1180,2180], shots:[] },
    { i:1, wrap:document.querySelector('#pv1'), ptsEl:document.querySelector('#pv1pts'), cvs:null, ctx:null, score:0, next:0, acc:0.62, rate:[1275,2360], shots:[] },
    { i:2, wrap:document.querySelector('#pv2'), ptsEl:document.querySelector('#pv2pts'), cvs:null, ctx:null, score:0, next:0, acc:0.58, rate:[1350,2510], shots:[] },
  ];
  const miniHolesCache=[[],[],[]];
  for(const r of rivals){ r.cvs = r.wrap.querySelector('canvas'); r.ctx = r.cvs.getContext('2d'); }

  // ===== Helpers =====
  const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));
  const rnd=(a,b)=>a+Math.random()*(b-a);
  function roundedRect(x,y,w,h,r){ ctx.beginPath(); ctx.moveTo(x+r,y); ctx.arcTo(x+w,y,x+w,y+h,r); ctx.arcTo(x+w,y+h,x,y+h,r); ctx.arcTo(x,y+h,x,y,r); ctx.arcTo(x,y,x+w,y,r); ctx.closePath(); }

  function reflectBall(nx,ny,damp=0.8){
    const dot = ball.vx*nx + ball.vy*ny;
    ball.vx -= 2*dot*nx;
    ball.vy -= 2*dot*ny;
    ball.vx *= damp;
    ball.vy *= damp;
  }
  function ballHitsKeeper(){
    const k=keeper;
    const px=k.x+k.w/2, py=k.y+k.h;
    const cos=Math.cos(-k.a), sin=Math.sin(-k.a);
    const dx=ball.x-px, dy=ball.y-py;
    const lx=dx*cos - dy*sin;
    const ly=dx*sin + dy*cos;
    const w=k.w*0.9, h=k.h*0.9;
    return lx>-w/2-ball.r && lx<w/2+ball.r && ly>-h-ball.r && ly<ball.r;
  }
  function ballScale(y){
    const g=geom.goal;
    const goalBottom=g.y+g.h;
    const progress=clamp((goalBottom - y)/g.h,0,1);
    return 1 - 0.15*progress;
  }

  // ===== Ads & Cameras =====
  function initBanners(){
    banners=[]; const g=geom.goal; const trackH=58; const trackY=g.y+g.h-trackH-8;
    const texts=['SPONSOR','ULTRA BOOTS','MEGA SPORTS','FAIR PLAY','STADIO TECH','HYDRATE','CLEAN PLAY'];
    let x=-W*0.5;
    for(let i=0;i<10;i++){ const w=rnd(240,320); banners.push({x,y:trackY,w,h:trackH,speed:rnd(0.6,1.1),hue:Math.floor(rnd(200,320)),text:texts[i%texts.length]}); x+=w+rnd(80,140); }
  }
  function initCameras(){ const g=geom.goal,cw=36,ch=24; cameras=[{x:g.x-cw-12,y:g.y+g.h-ch-6,w:cw,h:ch},{x:g.x+g.w+12,y:g.y+g.h-ch-6,w:cw,h:ch}]; }

  // ===== Targets =====
  function generateHoles(){
    const g=geom.goal; holes=[]; const cnt=6+Math.floor(Math.random()*7);
    const minR=Math.max(ball.r*1.05,22*geom.scale); const maxR=Math.max(minR+6,50*geom.scale);
    const pad=18; let tries=0;
    while(holes.length<cnt && tries<1600){
      tries++;
      const r=rnd(minR,maxR);
      let x;
      if(Math.random() < 0.6){
        const side = Math.random() < 0.5 ? 'l' : 'r';
        const range = g.w * 0.2;
        if(side === 'l') x = rnd(g.x+pad+r, g.x+pad+range);
        else x = rnd(g.x+g.w-pad-range, g.x+g.w-pad-r);
      } else {
        x = rnd(g.x+pad+r,g.x+g.w-pad-r);
      }
      const y=rnd(g.y+pad+r,g.y+g.h-pad-r);
      if(holes.every(h=>Math.hypot(h.x-x,h.y-y)>h.r+r+12)){
        const points=Math.max(10,Math.round(((maxR/r)*70)/5)*5);
        holes.push({x,y,r,points});
      }
    }
    for(let i=0;i<3;i++){ const cv=rivals[i].cvs; const g2={x:12,y:12,w:cv.width-24,h:cv.height-30}; miniHolesCache[i]=genMiniHoles(g2); }
  }
  function replaceHole(old){
    const idx=holes.indexOf(old);
    if(idx===-1) return;
    const g=geom.goal;
    const minR=Math.max(ball.r*1.05,22*geom.scale); const maxR=Math.max(minR+6,50*geom.scale);
    const pad=18; let tries=0;
    while(tries<600){
      tries++;
      const r=rnd(minR,maxR);
      let x;
      if(Math.random() < 0.6){
        const side = Math.random() < 0.5 ? 'l' : 'r';
        const range = g.w * 0.2;
        if(side === 'l') x = rnd(g.x+pad+r, g.x+pad+range);
        else x = rnd(g.x+g.w-pad-range, g.x+g.w-pad-r);
      } else {
        x = rnd(g.x+pad+r,g.x+g.w-pad-r);
      }
      const y=rnd(g.y+pad+r,g.y+g.h-pad-r);
      if(holes.every(h=>h===old||Math.hypot(h.x-x,h.y-y)>h.r+r+12)){
        const points=Math.max(10,Math.round(((maxR/r)*70)/5)*5);
        holes[idx]={x,y,r,points};
        break;
      }
    }
  }
  function genMiniHoles(g){ const out=[]; const cnt=6+Math.floor(Math.random()*7); let tries=0;
    while(out.length<cnt && tries<600){ tries++; const r=8+Math.random()*14; const x=g.x+12+r+Math.random()*(g.w-24-2*r); const y=g.y+12+r+Math.random()*(g.h-24-2*r);
      if(out.every(h=>Math.hypot(h.x-x,h.y-y)>h.r+r+8)){ out.push({x,y,r,p:Math.max(5,Math.round((22/r)*30))}); } }
    return out; }

  function createFragments(h){
    for(let i=0;i<8;i++){
      fragments.push({x:h.x,y:h.y,vx:rnd(-4,4),vy:rnd(-7,-2),a:rnd(0,Math.PI*2),va:rnd(-0.1,0.1),life:1});
    }
  }

  // ===== Drawing: Field & lines =====
  function drawField(){
    const stripe=44; for(let y=0;y<H;y+=stripe){
      ctx.fillStyle=(Math.floor(y/stripe)%2?getComputedStyle(document.documentElement).getPropertyValue('--turf2')||'#0a6c1d':'#0c7a23'); ctx.fillRect(0,y,W,stripe);
    }
    const vg=ctx.createRadialGradient(W/2,H,10,W/2,H,H/1.12); vg.addColorStop(0,'rgba(0,0,0,0)'); vg.addColorStop(1,'rgba(0,0,0,0.26)'); ctx.fillStyle=vg; ctx.fillRect(0,0,W,H);

    const g=geom.goal; ctx.strokeStyle='#fff'; ctx.lineJoin='round';
    const gl=g.y+g.h+2;
    // Removed middle lane in front of the goal
    // ctx.lineWidth=2; ctx.beginPath(); ctx.moveTo(0,gl); ctx.lineTo(W,gl); ctx.stroke();
    ctx.lineWidth=4;

    const paDepth=geom.paDepth, pad=Math.max(120*geom.scale,(W-g.w)/4);
    ctx.strokeRect(g.x-pad,gl,g.w+pad*2,paDepth);
    const sixDepth=Math.min(120*geom.scale,paDepth*0.45), sixPad=Math.max(140*geom.scale,pad*0.7);
    // Removed goal-area line close to the net
    // ctx.strokeRect(g.x-sixPad,gl,g.w+sixPad*2,sixDepth);

    // Removed penalty arc and spot for simplified field
  }

  // ===== Ads behind goal =====
  function drawAds(){
    const g=geom.goal, trackH=58, trackY=g.y+g.h-trackH-18;
    ctx.fillStyle='#0e1430'; ctx.fillRect(g.x-60,trackY,g.w+120,trackH);
    ctx.save(); ctx.beginPath(); ctx.rect(g.x-60,trackY,g.w+120,trackH); ctx.clip();
    for(const b of banners){
      b.x+=b.speed; if(b.x>g.x+g.w+160) b.x=g.x-220-b.w;
      ctx.fillStyle=`hsl(${b.hue} 70% 50%)`; ctx.fillRect(b.x,trackY+4,b.w,trackH-8);
      ctx.fillStyle='#fff'; ctx.font='700 14px system-ui'; ctx.textAlign='center'; ctx.textBaseline='middle';
      ctx.fillText(b.text,b.x+b.w/2,trackY+trackH/2);
    }
    ctx.restore();
  }

  // ===== Goal, net, cameras, targets =====
  function drawGoal(){
    const g=geom.goal;
    const innerW=g.w*0.8, innerH=g.h*0.8;
    const ix=g.x+(g.w-innerW)/2, iy=g.y+(g.h-innerH)/2;
    const netColor=goalFlash>0?'#ffd400':(getComputedStyle(document.documentElement).getPropertyValue('--net')||'#e6e6e6');
    const size=18; const h=size*Math.sqrt(3)/2;
    function drawNetMesh(){
      ctx.strokeStyle=netColor; ctx.lineWidth=1.2;
      for(let y=g.y-h; y<g.y+g.h+h; y+=h){
        for(let x=g.x-size; x<g.x+g.w+size; x+=size*1.5){
          const off = ((Math.round((y-g.y)/h))%2)*size*0.75;
          let cx=x+off, cy=y;
          // skip drawing net near the ground behind the keeper's feet
          if(cy > g.y + g.h - 8) continue;
          ctx.beginPath();
          for(let i=0;i<6;i++){
            const a=Math.PI/3*i; let px=cx+size*Math.cos(a); let py=cy+size*Math.sin(a);
            const dx=netHit.x-px, dy=netHit.y-py; const dist=Math.hypot(dx,dy);
            if(netHit.t>0 && dist>0){
              const impact=Math.exp(-dist/40)*12*netHit.t;
              const ripple=0.3*netHit.t;
              const pull=impact+ripple;
              px+=dx/dist*pull; py+=dy/dist*pull;
            }
            if(netHit.shake>0){ py+=Math.sin((px+py+i)*0.3+performance.now()*0.02)*netHit.shake*3; }
            if(i===0) ctx.moveTo(px,py); else ctx.lineTo(px,py);
          }
          ctx.closePath(); ctx.stroke();
        }
      }
    }
    function drawNetPanel(pathFn){
      ctx.save();
      ctx.beginPath();
      pathFn();
      ctx.clip();
      drawNetMesh();
      ctx.restore();
    }
    // back panel
    drawNetPanel(() => { ctx.rect(ix, iy, innerW, innerH); });
    // left side
    drawNetPanel(() => {
      ctx.moveTo(g.x, g.y);
      ctx.lineTo(ix, iy);
      ctx.lineTo(ix, iy + innerH);
      ctx.lineTo(g.x, g.y + g.h);
      ctx.closePath();
    });
    // right side
    drawNetPanel(() => {
      ctx.moveTo(g.x + g.w, g.y);
      ctx.lineTo(ix + innerW, iy);
      ctx.lineTo(ix + innerW, iy + innerH);
      ctx.lineTo(g.x + g.w, g.y + g.h);
      ctx.closePath();
    });
    // top
    drawNetPanel(() => {
      ctx.moveTo(g.x, g.y);
      ctx.lineTo(g.x + g.w, g.y);
      ctx.lineTo(ix + innerW, iy);
      ctx.lineTo(ix, iy);
      ctx.closePath();
    });
    ctx.strokeStyle='#fff'; ctx.lineWidth=2;
    ctx.beginPath();
    ctx.moveTo(g.x, g.y);
    ctx.lineTo(ix, iy);
    ctx.moveTo(g.x+g.w, g.y);
    ctx.lineTo(ix+innerW, iy);
    ctx.moveTo(g.x, g.y+g.h);
    ctx.lineTo(ix, iy+innerH);
    ctx.moveTo(g.x+g.w, g.y+g.h);
    ctx.lineTo(ix+innerW, iy+innerH);
    ctx.stroke();
    ctx.strokeStyle='#fff'; ctx.lineWidth=4;
    ctx.beginPath();
    ctx.moveTo(g.x, g.y+g.h);
    ctx.lineTo(ix, iy+innerH);
    ctx.moveTo(g.x+g.w, g.y+g.h);
    ctx.lineTo(ix+innerW, iy+innerH);
    ctx.moveTo(ix, iy+innerH);
    ctx.lineTo(ix+innerW, iy+innerH);
    ctx.moveTo(ix, iy+innerH);
    ctx.lineTo(ix, iy);
    ctx.lineTo(ix+innerW, iy);
    ctx.lineTo(ix+innerW, iy+innerH);
    ctx.stroke();
    ctx.strokeStyle='#fff'; ctx.lineWidth=12;
    ctx.beginPath();
    ctx.moveTo(g.x, g.y+g.h);
    ctx.lineTo(g.x, g.y);
    ctx.lineTo(g.x+g.w, g.y);
    ctx.lineTo(g.x+g.w, g.y+g.h);
    ctx.stroke();
    if(goalFlash>0){
      ctx.save();
      ctx.globalAlpha=goalFlash;
      ctx.font=`900 ${Math.min(innerH*0.8,120)}px system-ui`;
      ctx.textAlign='center';
      ctx.textBaseline='middle';
      ctx.lineWidth=8;
      ctx.strokeStyle='#000';
      ctx.fillStyle='#fff';
      ctx.strokeText('GOAL',ix+innerW/2,iy+innerH/2);
      ctx.fillText('GOAL',ix+innerW/2,iy+innerH/2);
      ctx.restore();
    }
    for(const c of cameras){ ctx.fillStyle='#111'; ctx.fillRect(c.x,c.y,c.w,c.h); ctx.fillStyle='#e10600'; ctx.beginPath(); ctx.arc(c.x+8,c.y+6,3,0,Math.PI*2); ctx.fill(); }
    for(const h of holes){ if(h.hit) continue; ctx.fillStyle='rgba(225,6,0,.9)'; ctx.beginPath(); ctx.arc(h.x,h.y,h.r,0,Math.PI*2); ctx.fill();
      ctx.fillStyle='#ffd400'; ctx.font=`800 ${Math.max(12,h.r*0.9)}px system-ui`; ctx.textAlign='center'; ctx.textBaseline='middle'; ctx.fillText(h.points,h.x,h.y); }
    for(const f of fragments){ ctx.save(); ctx.translate(f.x,f.y); ctx.rotate(f.a); ctx.fillStyle='#ffd400'; ctx.fillRect(-4,-2,8,4); ctx.restore(); }
    drawKeeper();
  }

  function drawKeeper(){
    const k=keeper;
    ctx.save();
    ctx.translate(k.x + k.w/2, k.y + k.h);
    ctx.rotate(k.a||0);
    ctx.translate(-k.w/2, -k.h + k.dive);
    ctx.drawImage(keeperImg, 0, 0, k.w, k.h);
    ctx.restore();
  }

  // ===== Ball & physics =====
  function drawBall(){
    const baseR=Math.max(BALL_R*geom.scale,22);
    ball.r=baseR;
    const drawR = baseR * ballScale(ball.y);
    // draw any loose balls continuing to fall
    for(const b of looseBalls){
      ctx.save();
      ctx.translate(b.x,b.y);
      ctx.rotate(b.angle||0);
      const sizeL = baseR*2*ballScale(b.y);
      ctx.drawImage(ballImg, -sizeL/2, -sizeL/2, sizeL, sizeL);
      ctx.restore();
    }
    ctx.globalAlpha=0.25;
    for(const t of ball.trail){ ctx.beginPath(); ctx.arc(t.x,t.y,drawR*0.9,0,Math.PI*2); ctx.fillStyle='#fff'; ctx.fill(); }
    ctx.globalAlpha=1;
    ctx.save();
    ctx.translate(ball.x,ball.y);
    ctx.rotate(ball.angle);
    const size = drawR*2;
    ctx.drawImage(ballImg, -size/2, -size/2, size, size);
    ctx.restore();
  }

  function drawPunchEffects(){
    for(const p of punchEffects){
      ctx.globalAlpha=p.life;
      ctx.font=`${42*geom.scale}px system-ui`;
      ctx.textAlign='center';
      ctx.textBaseline='middle';
      ctx.fillText('ü•ä',p.x,p.y);
      p.life-=0.01;
    }
    ctx.globalAlpha=1;
    punchEffects=punchEffects.filter(p=>p.life>0);
  }
  const FRICTION=0.985, AIR_DRAG=0.0015, GRAVITY=0.20;
  function stepBall(){
    if(!ball.moving) return;
    ball.trail.push({x:ball.x,y:ball.y}); if(ball.trail.length>15) ball.trail.shift();
    const speed=Math.hypot(ball.vx,ball.vy); const drag = 1 - AIR_DRAG*speed; const curve = ball.spin*0.5;
    const knuckle = Math.abs(ball.spin) < 0.1 ? (Math.random()-0.5)*0.3 : 0;
    ball.vx = (ball.vx + curve + knuckle)*FRICTION*drag; ball.vy = (ball.vy + GRAVITY)*FRICTION*drag;
    ball.x += ball.vx; ball.y += ball.vy; ball.angle += ball.spin*0.3;

    const g=geom.goal;
    if(ball.x>g.x && ball.x<g.x+g.w && ball.y>g.y && ball.y<g.y+g.h){
      for(const h of holes){
        if(h.hit) continue;
        if(Math.hypot(h.x-ball.x,h.y-ball.y) <= Math.max(2,h.r-ball.r*0.6)){
          h.hit=true; createFragments(h);
          ball.points += h.points;
          sfxPrize();
          ball.spin *= 0.6;
          setTimeout(()=>{replaceHole(h);},600);
          break;
        }
      }
    }
    if(keeper.save && ballHitsKeeper()){
      keeper.save=false; punchEffects.push({x:ball.x,y:ball.y,life:1});
      playKeeperSaveSound();
      playKickSound();
      const kc = keeper.x + keeper.w/2;
      const nx = ball.x < kc ? -0.6 : 0.6;
      reflectBall(nx,1,0.6);
      ball.spin *= 0.5;
      ball.y = keeper.y + keeper.h + ball.r;
      endShot(false,0); return;
    }
    const postR = g.post;
    const left={x:g.x, y:g.y+g.h}, right={x:g.x+g.w, y:g.y+g.h};
    let d=Math.hypot(ball.x-left.x, ball.y-left.y);
    if(d < ball.r + postR){
      triggerNetHit(ball.x, ball.y);
      sfxPost();
      const nx=(ball.x-left.x)/d, ny=(ball.y-left.y)/d;
      reflectBall(nx,ny,0.6);
      const overlap=ball.r+postR-d;
      ball.x+=nx*overlap; ball.y+=ny*overlap;
      return;
    }
    d=Math.hypot(ball.x-right.x, ball.y-right.y);
    if(d < ball.r + postR){
      triggerNetHit(ball.x, ball.y);
      sfxPost();
      const nx=(ball.x-right.x)/d, ny=(ball.y-right.y)/d;
      reflectBall(nx,ny,0.6);
      const overlap=ball.r+postR-d;
      ball.x+=nx*overlap; ball.y+=ny*overlap;
      return;
    }
    if(ball.y - ball.r <= g.y && ball.x > g.x - postR && ball.x < g.x + g.w + postR){
      if(ball.vy < 0){
        triggerNetHit(ball.x, ball.y);
        sfxPost();
        reflectBall(0,1,0.6);
        ball.y = g.y + ball.r;
        return;
      }
    }
    if(ball.target){
      const dx=ball.target.x-ball.x, dy=ball.target.y-ball.y;
      const dist=Math.hypot(dx,dy);
      if(dist < ball.r*0.8 || (ball.prevDist && dist>ball.prevDist)){
        ball.x=ball.target.x; ball.y=ball.target.y;
        ball.vx*=0.2; ball.vy=Math.max(0,ball.vy)*0.2; ball.spin*=0.2;
        triggerNetHit(ball.x, ball.y);
        endShot(true,ball.points); ball.target=null; ball.prevDist=null; return;
      }
      ball.prevDist=dist;
    }


    if(!ball.firstContact && ball.y >= geom.spot.y && ball.vy > 0){ ball.firstContact=true; endShot(false,0); return; }
    if(ball.y < -80 || ball.x < -80 || ball.x > W+80 || ball.y > H+80 || Math.hypot(ball.vx,ball.vy)<0.3){ endShot(false,0); }
  }

  function stepLooseBalls(){
    const r=Math.max(BALL_R*geom.scale*1.08,22);
    const fieldGround=geom.spot.y;
    const goalGround=geom.goal.y + geom.goal.h;
    const now = performance.now();
    for(const b of looseBalls){
      b.vy += GRAVITY;
      b.vx *= 0.98;
      b.spin *= 0.98;
      b.x += b.vx;
      b.y += b.vy;
      b.angle += b.spin;
      const ground = b.insideGoal ? goalGround : fieldGround;
      if(b.y + r > ground){
        b.y = ground - r;
        if(b.insideGoal){
          if(!b.bounced){
            b.vy *= -0.25;
            b.spin *= 0.5;
            b.bounced=true;
          } else {
            b.vy = 0;
            b.vx *= 0.92;
            b.spin *= 0.8;
            if(Math.hypot(b.vx,b.vy)<0.2 && !b.landedAt) b.landedAt = now;
          }
        } else if(!b.bounced){
          b.vy *= -0.25;
          b.spin *= 0.5;
          b.bounced=true;
        } else {
          b.vy = 0;
          b.vx *= 0.92;
          b.spin *= 0.8;
          if(Math.hypot(b.vx,b.vy)<0.2 && !b.landedAt) b.landedAt = now;
        }
      }
      if(b.landedAt && now - b.landedAt > 3000){
        b.remove=true;
      }
    }
    looseBalls = looseBalls.filter(b=>!b.remove);
  }

  function stepFragments(){
    for(const f of fragments){
      f.x+=f.vx; f.y+=f.vy; f.vy+=0.3; f.a+=f.va; f.life-=0.02;
      const g=geom.goal;
      if(f.y>g.y && f.y<g.y+g.h && f.x>g.x && f.x<g.x+g.w){
        netHit = {x:f.x, y:f.y, t:Math.max(netHit.t,0.3), shake:Math.max(netHit.shake,0.3)};
      }
    }
    fragments = fragments.filter(f=>f.life>0);
  }

  function stepKeeper(){
    if(!ball.moving){
      keeper.a *= 0.9;
      keeper.x += (keeper.baseX - keeper.x) * 0.1;
      keeper.dive *= 0.9;
      keeper.save=false;
      return;
    }
    const t = ball.vy !== 0 ? (keeper.y - ball.y) / ball.vy : Infinity;
    if(t > 0 && t < 120){
      const predicted = ball.x + ball.vx * t;
      const diff = predicted - (keeper.baseX + keeper.w/2);
      const targetA = clamp(diff / 240, -0.8, 0.8);
      keeper.a += (targetA - keeper.a) * 0.05;
      const targetX = clamp(diff * 0.04, -keeper.w*0.25, keeper.w*0.25);
      keeper.x += (keeper.baseX + targetX - keeper.x) * 0.05;
      // keeper save probability between 40% and 65%
      keeper.save = Math.abs(diff) < keeper.w*0.30 && Math.random() < rnd(0.40,0.65);
      const targetDive = keeper.save ? 10 : 0;
      keeper.dive += (targetDive - keeper.dive) * 0.05;
    } else {
      keeper.a *= 0.9;
      keeper.x += (keeper.baseX - keeper.x) * 0.1;
      keeper.dive *= 0.9;
      keeper.save=false;
    }
  }

  // ===== Aim guide =====
  // aiming controls removed
  function drawAimPath(vx,vy,spin){
    if(!aimOn) return;
    const steps=28; let x=ball.x, y=ball.y, vx1=vx, vy1=vy;
    ctx.beginPath();
    for(let i=0;i<steps;i++){
      const speed=Math.hypot(vx1,vy1); const drag=1-AIR_DRAG*speed;
      vx1=(vx1+spin*0.25)*FRICTION*drag; vy1=(vy1+GRAVITY)*FRICTION*drag;
      x+=vx1; y+=vy1; if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
      if(y<geom.goal.y-40) break;
    }
    ctx.strokeStyle='rgba(125,211,252,.9)'; ctx.lineWidth=2; ctx.setLineDash([6,8]); ctx.stroke(); ctx.setLineDash([]);
  }

  // ===== Round / scoring =====
function endShot(hit,pts){
  // keep current ball falling while spawning the next one
  looseBalls.push({x:ball.x,y:ball.y,vx:ball.vx,vy:ball.vy,angle:ball.angle,spin:ball.spin,bounced:false,insideGoal:hit,landedAt:null});
  ball.moving=false;
  if(hit){
    const score=Math.max(pts,MIN_GOAL_POINTS);
    myScore += score;
    status('GOAL! +' + score);
    vibrate(25);
    goalFlash=1;
  } else {
    status('Missed.');
    vibrate(12);
  }
  updateHUD();
  resetBall();
}
  function updateHUD(){
    const ps = document.getElementById('playerScore');
    if(ps) ps.textContent = myScore;
    timeShort.textContent = Math.ceil(timeLeft/1000);
  }
  function fmtTime(ms){ const s=Math.max(0, Math.ceil(ms/1000)); const m=Math.floor(s/60); const ss=String(s%60).padStart(2,'0'); return `${m}:${ss}`; }
  function finish(){ running=false; ended=true; }
  function status(msg){ /* no-op */ }

  // ===== Input (swipe/flick + spin) =====
  let pointer={id:null,path:[],active:false,armed:false,t0:0,t1:0};
  function pos(e){ const r=canvas.getBoundingClientRect(); return {x:(e.clientX-r.left)*(W/r.width), y:(e.clientY-r.top)*(H/r.height)}; }
  function onDown(e){ if(!running||ended||paused) return; if(pointer.active) return; pointer.active=true; pointer.id=e.pointerId; const p=pos(e); pointer.path=[p]; pointer.t0=performance.now(); pointer.t1=pointer.t0; pointer.armed = Math.hypot(p.x-ball.x,p.y-ball.y) <= ball.r*2.4 && !ball.moving; if(pointer.armed){ status('Swipe upward. Curve for spin.'); } }
  function onMove(e){ if(!pointer.active||e.pointerId!==pointer.id) return; pointer.path.push(pos(e)); pointer.t1=performance.now();
    if(pointer.armed && aimOn && pointer.path.length>1){
      const path = pointer.path;
      const a = path[0], b = path[path.length - 1];
      const endDx = b.x - ball.x, endDy = b.y - ball.y;
      const dist = Math.hypot(endDx, endDy), power = clamp(dist / 150, 0.4, 3.0);
      const speed = SHOT_SPEED * power;
      const t = dist / speed;
      let curve = 0;
      for(let i = 2; i < path.length; i++){
        const p0 = path[i-2], p1 = path[i-1], p2 = path[i];
        curve += Math.atan2(p2.y - p1.y, p2.x - p1.x) - Math.atan2(p1.y - p0.y, p1.x - p0.x);
      }
      const spin = clamp((ball.x - a.x)/ball.r + curve*0.8, -10, 10);
      const adjDx = endDx - spin * 0.125 * t * t;
      const vx = adjDx / t, vy = (endDy - 0.5 * GRAVITY * t * t) / t;
      drawAimPath(vx, vy, spin);
    }
  }
  function onUp(e){ if(!pointer.active||e.pointerId!==pointer.id) return; pointer.active=false; if(!pointer.armed||ball.moving||!running||paused){ pointer.path=[]; return; } const path=pointer.path; pointer.path=[]; if(path.length<3){ status('Swipe longer/faster.'); return; } const a=path[0], b=path[path.length-1]; const totalDy=b.y-a.y; if(totalDy>-10){ status('Swipe upward.'); return; } const endDx=b.x-ball.x, endDy=b.y-ball.y; const dist=Math.hypot(endDx,endDy), power=clamp(dist/150, 0.4, 3.0); const speed=SHOT_SPEED*power; const t=dist/speed; let curve=0; for(let i=2;i<path.length;i++){ const p0=path[i-2], p1=path[i-1], p2=path[i]; curve+=Math.atan2(p2.y-p1.y,p2.x-p1.x)-Math.atan2(p1.y-p0.y,p1.x-p0.x); } const spin = clamp((ball.x - a.x)/ball.r + curve*0.8, -20, 20); const adjDx=endDx - spin*0.125*t*t; ball.vx=adjDx/t; ball.vy=(endDy - 0.5*GRAVITY*t*t)/t; ball.spin=spin; ball.moving=true; playKickSound(); ball.target={x:b.x,y:b.y}; ball.prevDist=Infinity; keeper.save=false; }
  canvas.addEventListener('pointerdown', onDown, {passive:true});
  canvas.addEventListener('pointermove', onMove, {passive:true});
  addEventListener('pointerup', onUp, {passive:true}); addEventListener('pointercancel', onUp, {passive:true});

  // ===== Rivals (mini boards + scoring) =====
  function drawMiniBoards(init=false){
    for(let i=0;i<rivals.length;i++){
      const r=rivals[i], c=r.ctx, cv=r.cvs, g={x:12,y:12,w:cv.width-24,h:cv.height-30};
      c.clearRect(0,0,cv.width,cv.height);
      c.fillStyle='#0e1430'; c.fillRect(g.x,g.y+g.h+4,g.w,14);
      roundRect(c,g.x-2,g.y-2,g.w+4,g.h+4,8,true,false,'#0f1530');
      c.save(); c.beginPath(); c.rect(g.x,g.y,g.w,g.h); c.clip();
      c.strokeStyle='#e6e6e6'; c.lineWidth=1;
      for(let x=g.x;x<=g.x+g.w;x+=14){ c.beginPath(); c.moveTo(x,g.y); c.lineTo(x,g.y+g.h); c.stroke(); }
      for(let y=g.y;y<=g.y+g.h;y+=14){ c.beginPath(); c.moveTo(g.x,y); c.lineTo(g.x+g.w,y); c.stroke(); }
      c.restore();
      c.strokeStyle='#fff'; c.lineWidth=6; roundRect(c,g.x,g.y,g.w,g.h,6,false,true);
      const kw = g.w * 0.16, kh = kw * 2.5;
      const kx = g.x + (g.w - kw) / 2, ky = g.y + g.h - kh + g.h * 0.05;
      const local = Array.isArray(miniHolesCache[i]) ? miniHolesCache[i] : [];
      if(init && !local.length){ miniHolesCache[i]=genMiniHoles(g); }
      const list = Array.isArray(miniHolesCache[i]) ? miniHolesCache[i] : [];
      for(const h of list){
        c.fillStyle='rgba(225,6,0,.9)';
        c.beginPath();
        c.arc(h.x,h.y,h.r,0,Math.PI*2);
        c.fill();
        c.fillStyle='#ffd400';
        c.font='bold 12px system-ui';
        c.textAlign='center';
        c.textBaseline='middle';
        c.fillText(h.p,h.x,h.y);
      }
      for(const s of r.shots){
        s.x+=s.vx; s.y+=s.vy; s.vy+=0.25; s.life-=0.02;
        // if keeper saves, stop the shot when it reaches the keeper
        if(s.saved && s.y <= ky + kh * 0.2){ s.life = 0; continue; }
        c.fillStyle='#fff';
        c.beginPath();
        c.arc(s.x,s.y,4,0,Math.PI*2);
        c.fill();
        if(s.life<0.6 && !s.fragments){
          s.fragments=[];
          for(let k=0;k<5;k++){
            s.fragments.push({x:s.x,y:s.y,vx:rnd(-2,2),vy:rnd(-2,2),life:0.4});
          }
        }
        if(s.fragments){
          for(const f of s.fragments){ f.x+=f.vx; f.y+=f.vy; f.life-=0.03; c.fillRect(f.x,f.y,2,2); }
        }
      }
      c.drawImage(keeperImg, kx, ky, kw, kh);
      r.shots = r.shots.filter(s=>s.life>0);
      r.ptsEl.textContent = r.score;
    }
  }
  function genMiniHolesForCard(i){ const cv=rivals[i].cvs; const g={x:12,y:12,w:cv.width-24,h:cv.height-30}; miniHolesCache[i]=genMiniHoles(g); }
  function roundRect(c,x,y,w,h,r,fill,stroke,fillColor){ c.beginPath(); c.moveTo(x+r,y); c.arcTo(x+w,y,x+w,y+h,r); c.arcTo(x+w,y+h,x,y+h,r); c.arcTo(x,y+h,x,y,r); c.arcTo(x,y,x+w,y,r); if(fill){ if(fillColor){ const old=c.fillStyle; c.fillStyle=fillColor; c.fill(); c.fillStyle=old; } else c.fill(); } if(stroke) c.stroke(); }
    function stepRivals(now){
    if(!running||paused) return;
    const t = 1 - (timeLeft/ROUND_TIME);
    for(let i=0;i<rivals.length;i++){
      const r=rivals[i];
      if(now>r.next){
        r.next = now + rnd(r.rate[0], r.rate[1]) * (1 - 0.45*t);
        const list = Array.isArray(miniHolesCache[i]) ? miniHolesCache[i] : [];
        if(list.length===0){ genMiniHolesForCard(i); continue; }
        const target = Math.random()<0.35 ? list.slice().sort((a,b)=>a.r-b.r)[0] : list[Math.floor(Math.random()*list.length)];
        const acc = clamp(r.acc * (0.9 + 0.5*t),0, 0.98);
        const chance = acc * (22/Math.max(10,target.r));
        if(Math.random() < chance){
          const saved = Math.random() < 0.5;
          if(!saved){ r.score += Math.max(5, Math.round(target.p)); }
          const cv=r.cvs; const g={x:12,y:12,w:cv.width-24,h:cv.height-30};
          r.shots.push({x:g.x+g.w/2,y:g.y+g.h,vx:(target.x-(g.x+g.w/2))/15,vy:(target.y-(g.y+g.h))/15,life:1,saved});
        }
      }
      r.ptsEl.textContent = r.score;
    }
  }

  // ===== Timer + loop =====
  function tick(now){ if(!running||paused) return; if(!roundStart) roundStart=now; timeLeft = Math.max(0, ROUND_TIME - (now - roundStart)); timeShort.textContent = Math.ceil(timeLeft/1000); if(timeLeft<=0){ finish(); } }
  function loop(now){ requestAnimationFrame(loop); drawField(); drawAds(); drawGoal(); drawBall(); drawPunchEffects(); stepBall(); stepLooseBalls(); stepFragments(); stepKeeper(); drawMiniBoards(); tick(now||performance.now()); stepRivals(now||performance.now()); updateHUD(); netHit.t*=NET_DECAY; netHit.shake*=NET_DECAY; goalFlash*=0.92; }

  // ===== Controls =====
  // controls removed

  function resetBall(){ ball.x=geom.spot.x; ball.y=geom.spot.y; ball.vx=ball.vy=ball.spin=0; ball.angle=0; ball.moving=false; ball.netSounded=false; ball.trail=[]; ball.firstContact=false; ball.target=null; ball.prevDist=null; ball.points=0; netHit={x:0,y:0,t:0,shake:0}; keeper.save=false; keeper.vx=0; keeper.vy=0; keeper.a=0; keeper.dive=0; keeper.x = keeper.baseX; keeper.y = keeper.baseY; }
  function startGame(){ running=true; paused=false; ended=false; roundStart=performance.now(); timeLeft=ROUND_TIME; myScore=0; looseBalls=[]; for(const r of rivals){ r.score=0; r.next=0; r.shots=[]; } resetBall(); generateHoles(); drawMiniBoards(true); updateHUD(); ensureAudio(); status('Go! Score as many as you can.'); }

  // ===== WebAudio SFX =====
  let audioCtx=null, masterGain=null; function ensureAudio(){ if(audioCtx) return; try{ const AC = window.AudioContext || window.webkitAudioContext; audioCtx = new AC(); masterGain = audioCtx.createGain(); masterGain.gain.value = 0.18; masterGain.connect(audioCtx.destination); }catch{} }
  // Prize break sound
  let prizeSoundBuf=null;
  async function loadPrizeSound(){
    try{
      const res=await fetch('/assets/sounds/glass-bottle-breaking-351297.mp3');
      const arr=await res.arrayBuffer();
      ensureAudio(); if(!audioCtx) return;
      prizeSoundBuf = await audioCtx.decodeAudioData(arr);
    }catch{}
  }
  loadPrizeSound();
  function playPrizeSound(){
    ensureAudio();
    if(!audioCtx || !prizeSoundBuf) return;
    const src=audioCtx.createBufferSource();
    src.buffer=prizeSoundBuf;
    src.connect(masterGain);
    src.start(0);
  }
  const sfxPrize = playPrizeSound;
  let postHitSoundBuf=null;
  let postHitSource=null;
  async function loadPostHitSound(){
    try{
      // Uses post-hit.mp3 from webapp/public/assets/sounds
      const res=await fetch('/assets/sounds/post-hit.mp3');
      const arr=await res.arrayBuffer();
      ensureAudio(); if(!audioCtx) return;
      postHitSoundBuf=await audioCtx.decodeAudioData(arr);
    }catch{}
  }
  loadPostHitSound();
  function playPostHitSound(){
    ensureAudio();
    if(!audioCtx || !postHitSoundBuf) return;
    if(postHitSource){
      try{ postHitSource.stop(); }catch{}
    }
    const src=audioCtx.createBufferSource();
    src.buffer=postHitSoundBuf;
    src.connect(masterGain);
    src.start(0);
    postHitSource=src;
    src.onended=()=>{ if(postHitSource===src) postHitSource=null; };
  }
  const sfxPost = playPostHitSound;
  let keeperSaveSoundBuf=null;
  async function loadKeeperSaveSound(){
      try{
        const res=await fetch('/assets/sounds/punch-03-352040.mp3');
        const arr=await res.arrayBuffer();
        ensureAudio(); if(!audioCtx) return;
        keeperSaveSoundBuf = await audioCtx.decodeAudioData(arr);
      }catch{}
    }
    loadKeeperSaveSound();
    function playKeeperSaveSound(){
      ensureAudio();
      if(!audioCtx || !keeperSaveSoundBuf) return;
      const src=audioCtx.createBufferSource();
      src.buffer=keeperSaveSoundBuf;
      src.connect(masterGain);
      src.start(0);
    }
    // Shared sound effect for kicking the ball and net impact.
    // Place "a-football-hits-the-net-goal-313216.mp3" in webapp/public/assets/sounds.
    const KICK_NET_SOUND = '/assets/sounds/a-football-hits-the-net-goal-313216.mp3';
    const NET_END_TRIM = 0.2; // seconds trimmed from the end when playing the net hit
    let kickNetSoundBuf = null;

  async function loadKickNetSound(){
    try {
      const res = await fetch(KICK_NET_SOUND);
      const arr = await res.arrayBuffer();
      ensureAudio(); if(!audioCtx) return;
      kickNetSoundBuf = await audioCtx.decodeAudioData(arr);
    } catch {}
  }
  loadKickNetSound();

  function playKickSound(){
    ensureAudio();
    if(!audioCtx || !kickNetSoundBuf) return;
    const src = audioCtx.createBufferSource();
    src.buffer = kickNetSoundBuf;
    const half = kickNetSoundBuf.duration / 2;
    src.connect(masterGain);
    // Play only the first half of the clip for the kick.
    src.start(0, 0, half);
  }

  function playNetSound(){
    ensureAudio();
    if(!audioCtx || !kickNetSoundBuf) return;
    const src = audioCtx.createBufferSource();
    src.buffer = kickNetSoundBuf;
    const half = kickNetSoundBuf.duration / 2;
    // Use the last half of the clip, but trim the final NET_END_TRIM seconds.
    const duration = Math.max(0, half - NET_END_TRIM);
    src.connect(masterGain);
    src.start(0, half, duration);
  }

  function triggerNetHit(x, y){
    // Pull the net back and add a brief shake on impact.
    netHit.x = x; netHit.y = y;
    netHit.t = Math.max(netHit.t, 1);
    netHit.shake = Math.max(netHit.shake, 1.2);
    if(!ball.netSounded){ ball.netSounded=true; playNetSound(); }
  }
  function vibrate(ms){ if(navigator.vibrate) try{ navigator.vibrate(ms); }catch{} }

  // ===== Static draw & tests =====
  function drawStaticOnce(){ drawField(); drawAds(); drawGoal(); resetBall(); drawBall(); drawMiniBoards(true); }

  // ===== Boot =====
  function startCountdown(n){
    const el=document.createElement('div');
    el.style.position='fixed';
    el.style.inset='0';
    el.style.display='flex';
    el.style.alignItems='center';
    el.style.justifyContent='center';
    el.style.fontSize='72px';
    el.style.fontWeight='800';
    el.style.background='rgba(0,0,0,0.4)';
    el.style.color='#fff';
    document.body.appendChild(el);
    const tick=()=>{
      if(n>0){
        el.textContent=n;
        setTimeout(()=>{ n--; tick(); },1000);
      } else {
        document.body.removeChild(el);
        startGame();
      }
    };
    tick();
  }

  function boot(){
    resize();
    requestAnimationFrame(loop);
    canvas.addEventListener('pointerdown', ()=>{ if(!running||ended) startCountdown(3); ensureAudio(); }, {once:false});
    startCountdown(3);
  }
  boot();
})();
</script>
</body>
</html>
