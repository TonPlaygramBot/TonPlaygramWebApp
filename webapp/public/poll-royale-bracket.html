<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Pool Royale Bracket</title>
<style>
  :root{
    --bg:#0b1020;
    --panel:#11172a;
    --ink:#dbe7ff;
    --accent:#2563eb;
    --accent-2:#f97316;
    --accent-3:#a855f7;
    --muted:#8aa0d1;
  }
  *{box-sizing:border-box}
  html,body{height:100%}
  body{
    margin:0;
    font-family:system-ui,Segoe UI,Roboto,Arial,Helvetica,sans-serif;
    background: radial-gradient(80% 60% at 50% 0%, #0f1735 0%, var(--bg) 60%);
    color:var(--ink);
    display:flex; flex-direction:column; gap:10px;
  }
  header{
    position:sticky; top:0; z-index:2;
    background:linear-gradient(180deg, rgba(17,23,42,.95) 0%, rgba(17,23,42,.85) 100%);
    backdrop-filter: blur(8px);
    border-bottom:1px solid rgba(255,255,255,.06);
  }
  .wrap{
    max-width:1100px;
    margin:0 auto;
    padding:10px 12px;
    display:flex; gap:10px; align-items:center; flex-wrap:wrap;
  }
  .title{font-weight:700; letter-spacing:.6px; margin-right:auto}
  .canvas-wrap{
    position:relative;
    overflow:auto; /* allow horizontal scroll on phones */
    border-top:1px solid rgba(255,255,255,.06);
    border-bottom:1px solid rgba(255,255,255,.06);
    background:
      radial-gradient(1000px 300px at 50% -50px, rgba(37,99,235,.25), transparent 70%),
      radial-gradient(800px 300px at 50% 100%, rgba(249,115,22,.15), transparent 70%);
  }
  canvas{ display:block; margin:0 auto; }
</style>
</head>
<body>
<header>
  <div class="wrap">
    <div class="title">üèÜ Pool Royale Bracket</div>
  </div>
</header>

<div class="canvas-wrap">
  <canvas id="board" width="1200" height="800" aria-label="Tournament bracket canvas"></canvas>
</div>

<script>
(function(){
  const DPR = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
  const canvas = document.getElementById('board');
  const ctx = canvas.getContext('2d');
  const players = window.bracketPlayers || [];
  const potTotal = window.bracketPot || 0;
  const tpcImage = new Image();
  tpcImage.src = 'assets/icons/ezgif-54c96d8a9b9236.webp';
  tpcImage.onload = () => layoutAndDraw();

  const theme = {
    bg:'#0b1020',
    panel:'#11172a',
    ink:'#dbe7ff',
    muted:'#8aa0d1',
    neonA:'#2563eb',
    neonB:'#f97316',
    neonC:'#a855f7',
    line:'#233155'
  };

  let state = {
    N: players.length,
    bracketN: 8,
    rounds: [],
    seedToName: {},
    seedToPlayer: {}
  };

  function nextPow2(n){ let p=1; while(p<n) p<<=1; return p; }

  function seedOrder(N){
    if(N===2) return [1,2];
    const prev = seedOrder(N/2);
    const mirror = prev.map(x => N + 1 - x);
    return prev.concat(mirror);
  }

  function round0PairsFromSeeds(N){
    const order = seedOrder(N);
    const pairs = [];
    for(let i=0;i<N;i+=2){
      pairs.push([order[i], order[i+1]]);
    }
    return pairs;
  }

  function createBracket(players){
    const Nrequested = players.length;
    const pow2 = nextPow2(Nrequested);
    state.N = Nrequested;
    state.bracketN = pow2;
    const seedToName = {};
    const seedToPlayer = {};
    for(let s=1; s<=pow2; s++){
      if(s<=Nrequested){
        const p = players[s-1];
        seedToName[s] = p.name;
        seedToPlayer[s] = p;
      }else{
        seedToName[s]='BYE';
      }
    }
    state.seedToName = seedToName;
    state.seedToPlayer = seedToPlayer;

    const r0 = round0PairsFromSeeds(pow2);
    state.rounds = [r0];
    let matches = r0.length;
    while(matches>1){
      matches = Math.ceil(matches/2);
      state.rounds.push(Array.from({length:matches}, _=>[0,0]));
    }
    layoutAndDraw();
  }

  function layoutAndDraw(){
    const rounds = state.rounds.length;
    const colW = 220;
    const colGap = 64;
    const padX = 24;
    const padY = 24;
    const widthCSS = padX*2 + rounds*colW + (rounds-1)*colGap;

    const matches0 = state.rounds[0].length;

    const boxH = 56;
    const slotH = boxH/2;
    const baseGap = 28;

    const centers = [];
    centers[0] = Array.from({length:matches0}, (_,i)=> padY + (boxH/2) + i*(boxH + baseGap));
    for(let r=1; r<rounds; r++){
      const prev = centers[r-1];
      const arr=[];
      for(let i=0;i<Math.ceil(prev.length/2);i++){
        const c = (prev[2*i] + prev[2*i+1]) / 2;
        arr.push(c);
      }
      centers[r]=arr;
    }

    const lastCenter = centers[rounds-1][0] || padY + boxH/2;
    const heightCSS = Math.max(600, lastCenter + padY + boxH/2);

    canvas.style.width = widthCSS + 'px';
    canvas.style.height = heightCSS + 'px';
    canvas.width = Math.floor(widthCSS * DPR);
    canvas.height = Math.floor(heightCSS * DPR);
    ctx.setTransform(DPR,0,0,DPR,0,0);

    ctx.clearRect(0,0,widthCSS,heightCSS);
    drawBackground(widthCSS, heightCSS);

    for(let r=0;r<rounds;r++){
      const x = padX + r*(colW + colGap);
      drawRoundTitle(r, x, 6 + (r==0? 10:0));

      const matchesR = state.rounds[r].length;
      for(let m=0;m<matchesR;m++){
        const yCenter = centers[r][m];
        drawMatchBox(r, m, x, yCenter - boxH/2, colW, boxH, slotH);
      }

      if(r>0){
        const xPrev = padX + (r-1)*(colW + colGap) + colW;
        const xConn = xPrev + 18;
        ctx.lineWidth = 2;
        ctx.strokeStyle = theme.line;
        ctx.beginPath();
        for(let m=0;m<state.rounds[r].length;m++){
          const cy = centers[r][m];
          const top = centers[r-1][2*m];
          const bot = centers[r-1][2*m+1];
          ctx.moveTo(xPrev, top);
          ctx.lineTo(xConn, top);
          ctx.moveTo(xPrev, bot);
          ctx.lineTo(xConn, bot);
          ctx.moveTo(xConn, top);
          ctx.lineTo(xConn, bot);
          ctx.moveTo(xConn, cy);
          ctx.lineTo(x, cy);
        }
        ctx.stroke();
      }
    }

    drawCenterLabels(widthCSS);
  }

  function drawBackground(w,h){
    const g = ctx.createLinearGradient(0,0,w,0);
    g.addColorStop(0,'rgba(168,85,247,.08)');
    g.addColorStop(.5,'rgba(37,99,235,.10)');
    g.addColorStop(1,'rgba(249,115,22,.08)');
    ctx.fillStyle = g;
    ctx.fillRect(0,0,w,h);
  }

  function drawRoundTitle(r, x, topPad){
    ctx.save();
    ctx.fillStyle = '#bcd0ff';
    ctx.font = '600 12px system-ui,Segoe UI,Roboto,Arial';
    ctx.textAlign = 'left';
    let label = '';
    const rounds = state.rounds.length;
    if(r === 0) label = 'ROUND OF ' + state.bracketN;
    else if(r === rounds-1) label = 'FINAL';
    else if(r === rounds-2) label = 'SEMIFINAL';
    else label = 'QUARTER / R' + (r+1);
    ctx.fillText(label, x, topPad + 10);
    ctx.restore();
  }

  function slotColor(r, slot){
    const palettes = [theme.neonC, theme.neonA, theme.neonB];
    const base = palettes[r % palettes.length];
    const alpha = .22;
    return hexToRgba(base, alpha);
  }

  function drawMatchBox(r, m, x, y, w, h, slotH){
    const radius = 12;
    roundRect(ctx, x, y, w, h, radius);
    const grad = ctx.createLinearGradient(x, y, x, y+h);
    grad.addColorStop(0, 'rgba(255,255,255,.04)');
    grad.addColorStop(1, 'rgba(0,0,0,.25)');
    ctx.fillStyle = grad;
    ctx.fill();

    ctx.fillStyle = slotColor(r,0);
    roundRect(ctx, x+4, y+4, w-8, slotH-6, 8);
    ctx.fill();
    ctx.fillStyle = slotColor(r,1);
    roundRect(ctx, x+4, y+slotH+2, w-8, slotH-6, 8);
    ctx.fill();

    ctx.strokeStyle = 'rgba(255,255,255,.06)';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(x+8, y+slotH);
    ctx.lineTo(x+w-8, y+slotH);
    ctx.stroke();

    ctx.fillStyle = '#e7efff';
    ctx.font = '600 13px system-ui,Segoe UI,Roboto,Arial';
    ctx.textAlign = 'left';

    const names = matchNames(r,m);
    if(r===0){
      const [sA, sB] = state.rounds[0][m];
      const pA = state.seedToPlayer[sA];
      const pB = state.seedToPlayer[sB];
      drawPlayerSlot(x, y, slotH, names[0], pA);
      drawPlayerSlot(x, y+slotH, slotH, names[1], pB);
    }else{
      drawPlayerSlot(x, y, slotH, names[0]);
      drawPlayerSlot(x, y+slotH, slotH, names[1]);
    }

  }

  function drawPlayerSlot(x, y, slotH, name, player){
    const textX = x + 40;
    ctx.fillText(name, textX, y + slotH/2 + 4);
    if(player){
      if(player.flag){
        ctx.font = '20px system-ui,Segoe UI,Roboto,Arial';
        ctx.fillText(player.flag, x+12, y + slotH/2 + 6);
        ctx.font = '600 13px system-ui,Segoe UI,Roboto,Arial';
      } else if(player.avatar){
        const img = new Image();
        img.src = player.avatar;
        img.onload = () => ctx.drawImage(img, x+8, y + slotH/2 - 12, 24, 24);
        if(img.complete) ctx.drawImage(img, x+8, y + slotH/2 - 12, 24, 24);
      }
    }
  }

  function matchNames(r,m){
    if(r===0){
      const [sA, sB] = state.rounds[0][m];
      return [state.seedToName[sA], state.seedToName[sB]];
    }
    const nameA = 'Winner '+labelForSource(r-1, 2*m);
    const nameB = 'Winner '+labelForSource(r-1, 2*m+1);
    return [nameA, nameB];
  }

  function labelForSource(r,m){
    if(r===0){
      const [sA,sB]=state.rounds[0][m];
      return `(${seedShort(sA)} vs ${seedShort(sB)})`;
    }else{
      return `R${r+1}-M${m+1}`;
    }
  }

  function seedShort(s){
    const n = state.seedToName[s];
    if(n==='BYE') return 'BYE';
    if(/^Team \d+$/i.test(n)) return n.replace('Team ', '#');
    return n.length>10? n.slice(0,10)+'‚Ä¶': n;
  }

  function drawCenterLabels(w){
    ctx.save();
    ctx.textAlign = 'center';
    ctx.font = '700 20px system-ui,Segoe UI,Roboto,Arial';
    ctx.fillStyle = '#e8f0ff';
    ctx.fillText('THE PLAYOFFS', w/2, 34);
    ctx.font = '600 12px system-ui,Segoe UI,Roboto,Arial';
    ctx.fillStyle = '#9fb3de';
    ctx.fillText('WORLD CHAMPIONSHIP', w/2, 54);
    ctx.restore();
  }

  function hexToRgba(hex, a){
    let c = hex.replace('#','');
    if(c.length===3){ c = c.split('').map(x=>x+x).join(''); }
    const num = parseInt(c,16);
    const r = (num>>16)&255, g=(num>>8)&255, b=num&255;
    return `rgba(${r},${g},${b},${a})`;
  }

  function roundRect(ctx, x, y, w, h, r){
    const rr = Math.min(r, w/2, h/2);
    ctx.beginPath();
    ctx.moveTo(x+rr, y);
    ctx.lineTo(x+w-rr, y);
    ctx.quadraticCurveTo(x+w, y, x+w, y+rr);
    ctx.lineTo(x+w, y+h-rr);
    ctx.quadraticCurveTo(x+w, y+h, x+w-rr, y+h);
    ctx.lineTo(x+rr, y+h);
    ctx.quadraticCurveTo(x, y+h, x, y+h-rr);
    ctx.lineTo(x, y+rr);
    ctx.quadraticCurveTo(x, y, x+rr, y);
    ctx.closePath();
  }

  let finalBox = null;

  function drawPlayerPot(){
    if(!finalBox) return;
    const centerY = finalBox.y + finalBox.h/2;
    const x = finalBox.x + finalBox.w + 10;
    ctx.textAlign = 'left';
    ctx.font = '20px system-ui,Segoe UI,Roboto,Arial';
    ctx.fillText('üèÜ', x, centerY+7);
    if(tpcImage.complete){
      ctx.drawImage(tpcImage, x+28, centerY-12, 24, 24);
    }
    ctx.fillText(String(potTotal), x+56, centerY+7);
  }

  function layoutAndDraw(){
    const rounds = state.rounds.length;
    const colW = 220;
    const colGap = 64;
    const padX = 24;
    const padY = 24;
    const widthCSS = padX*2 + rounds*colW + (rounds-1)*colGap;

    const matches0 = state.rounds[0].length;

    const boxH = 56;
    const slotH = boxH/2;
    const baseGap = 28;

    const centers = [];
    centers[0] = Array.from({length:matches0}, (_,i)=> padY + (boxH/2) + i*(boxH + baseGap));
    for(let r=1; r<rounds; r++){
      const prev = centers[r-1];
      const arr=[];
      for(let i=0;i<Math.ceil(prev.length/2);i++){
        const c = (prev[2*i] + prev[2*i+1]) / 2;
        arr.push(c);
      }
      centers[r]=arr;
    }

    const lastCenter = centers[rounds-1][0] || padY + boxH/2;
    const heightCSS = Math.max(600, lastCenter + padY + boxH/2);

    canvas.style.width = widthCSS + 'px';
    canvas.style.height = heightCSS + 'px';
    canvas.width = Math.floor(widthCSS * DPR);
    canvas.height = Math.floor(heightCSS * DPR);
    ctx.setTransform(DPR,0,0,DPR,0,0);

    ctx.clearRect(0,0,widthCSS,heightCSS);
    drawBackground(widthCSS, heightCSS);

    finalBox = null;
    for(let r=0;r<rounds;r++){
      const x = padX + r*(colW + colGap);
      drawRoundTitle(r, x, 6 + (r==0? 10:0));

      const matchesR = state.rounds[r].length;
      for(let m=0;m<matchesR;m++){
        const yCenter = centers[r][m];
        drawMatchBox(r, m, x, yCenter - boxH/2, colW, boxH, slotH);
        if(r===rounds-1 && m===0){
          finalBox = {x, y:yCenter - boxH/2, w:colW, h:boxH};
        }
      }

      if(r>0){
        const xPrev = padX + (r-1)*(colW + colGap) + colW;
        const xConn = xPrev + 18;
        ctx.lineWidth = 2;
        ctx.strokeStyle = theme.line;
        ctx.beginPath();
        for(let m=0;m<state.rounds[r].length;m++){
          const cy = centers[r][m];
          const top = centers[r-1][2*m];
          const bot = centers[r-1][2*m+1];
          ctx.moveTo(xPrev, top);
          ctx.lineTo(xConn, top);
          ctx.moveTo(xPrev, bot);
          ctx.lineTo(xConn, bot);
          ctx.moveTo(xConn, top);
          ctx.lineTo(xConn, bot);
          ctx.moveTo(xConn, cy);
          ctx.lineTo(x, cy);
        }
        ctx.stroke();
      }
    }

    drawCenterLabels(widthCSS);
    drawPlayerPot();
  }

  createBracket(players);
  window.addEventListener('resize', ()=> layoutAndDraw());
})();
</script>
</body>
</html>
