<!doctype html>
<html lang="sq">
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no,viewport-fit=cover"
    />
    <title>Deluxe Billiards ‚Ä¢ 2.5D Cartoon (Portrait)</title>
    <style>
      /* ------------------------------------------------------------------
       DELUXE BILLIARDS 2.5D CARTOON (PORTRAIT)
       - Tavoline vertikale, kornize druri, 6 gropa korrekte (meset anesore).
       - Panel djathtas: SPIN siper, STEKA poshte (pull & release).
       - Steke mbi felt; zgjatje vizuale sipas fuqise.
       - Guida me pika qe shkallezohen me fuqine; rrotullim topash me "spin".
       - Palete ngjyrash reale, hije 2.5D.
       - Teste konsole per integritet ‚Äì te ndihmojne te debug.
       ------------------------------------------------------------------ */

      * {
        box-sizing: border-box;
        touch-action: none;
      }

      html,
      body {
        margin: 0;
        height: 100%;
        background: #1a2b4d; /* blu me e ndritshme per kontrast me te mire */
        color: #fff;
        font-family:
          system-ui,
          -apple-system,
          Segoe UI,
          Roboto,
          Ubuntu,
          Cantarell,
          'Helvetica Neue',
          Arial,
          'Noto Sans';
        overscroll-behavior: none;
      }

      #app {
        position: fixed;
        inset: 0;
        display: flex;
        flex-direction: column;
      }

      #header,
      #footer {
        height: 56px;
        display: flex;
        align-items: center;
        justify-content: space-between;
        padding: 0 12px;
        background: linear-gradient(#20345a, #1a2b4d);
      }

      #header {
        position: relative;
      }

      #header {
        border-bottom: 1px solid #24375f;
      }
      #footer {
        border-top: 1px solid #24375f;
        justify-content: center;
        height: calc(56px + env(safe-area-inset-bottom));
        padding-bottom: env(safe-area-inset-bottom);
        position: relative;
      }

      .player {
        display: flex;
        align-items: center;
        gap: 8px;
      }

      .avatar {
        width: 36px;
        height: 36px;
        border-radius: 50%;
        background: #fff;
        color: #222;
        display: grid;
        place-items: center;
        font-weight: 700;
        border: 2px solid var(--player-frame-color, #000);
      }

      .avatar.turn {
        box-shadow: 0 0 0 2px #facc15;
        border-color: #facc15;
      }

      .name {
        font-weight: 700;
      }
      .name.turn {
        color: #facc15;
      }
      .name.small {
        font-size: 12px;
      }

      .player .info {
        display: flex;
        flex-direction: column;
        align-items: center;
      }

      .score {
        font-size: 18px;
        font-weight: 700;
        min-width: 32px;
        text-align: center;
      }

      .potted {
        display: flex;
        gap: 2px;
        margin-top: 2px;
      }

      .potted .ball {
        width: 14px;
        height: 14px;
        border-radius: 50%;
        display: block;
      }

      #statusMsg {
        font-size: 12px;
        margin-top: 2px;
      }

      .foul {
        color: red;
      }

      #centerPopup {
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        font-size: 32px;
        font-weight: 700;
        pointer-events: none;
        z-index: 200;
        display: none;
      }

      #centerPopup.foul {
        color: red;
        text-shadow: 2px 2px 0 #fff;
      }

      #centerPopup.shots {
        color: #fff;
        text-shadow: 2px 2px 0 #000;
      }

      #wrap {
        position: relative;
        flex: 1 1 auto;
        display: flex;
        overflow: hidden;
        /* Ensure background image fits exactly within the wrap so the
         wooden rails are clipped by the viewport, matching the expected
         field appearance. The brightness filter is applied to a
         pseudo-element so the balls and other children remain
         unaffected. */
      }
      #wrap::before {
        content: '';
        position: absolute;
        inset: 0;
        background: url('/assets/icons/64e79228-35e3-4fdc-b914-fca635a40220.webp')
          top center/100% 100% no-repeat;
        filter: brightness(var(--table-brightness));
        z-index: -1;
      }


      :root {
        --rpw: min(23vw, 115px);
        --player-frame-color: #000;
        --table-brightness: 1.1;
      }

      /* Canvas i tavolines (mbulon gjithcka, pervec panelit djathtas) */
      #table {
        position: absolute;
        top: 0;
        left: 0;
        transform: translateY(-2px);
        z-index: 4;
      }

      #cueHint {
        position: absolute;
        z-index: 7;
        display: none;
        font-size: 24px;
        pointer-events: none;
      }

      /* Paneli djathtas ‚Äì SPIN siper, STEKA poshte */
      #rightPanel {
        position: absolute;
        top: 56px;
        right: 0;
        bottom: calc(56px + env(safe-area-inset-bottom));
        width: var(--rpw);

        display: flex;
        flex-direction: column;
        align-items: flex-end;
        justify-content: flex-end;
        gap: 8px;
        padding: 12px 0 0 8px;
        z-index: 10;
        /* Let table receive touches except on interactive elements */
        pointer-events: none;
      }

      #spinBox {
        width: 70px;
        height: 70px;
        border-radius: 50%;
        background: #f6f6f6;
        position: absolute;
        left: 50%;
        top: 120%;
        transform: translate(-50%, -50%);
        box-shadow:
          0 4px 10px rgba(0, 0, 0, 0.4) inset,
          0 0 0 2px rgba(0, 0, 0, 0.15);
        transform-origin: center;
        z-index: 10;
        pointer-events: auto;
        touch-action: none;
        cursor: pointer;
      }

      #spinDot {
        position: absolute;
        width: 10px;
        height: 10px;
        border-radius: 50%;
        background: #e63; /* pika e kuqe */
        left: 50%;
        top: 50%;
        transform: translate(-50%, -50%);
        pointer-events: none;
      }

      #turnTimerText {
        position: absolute;
        left: 50%;
        top: -20px;
        transform: translateX(-50%);
        font-weight: 700;
        font-size: 20px;
        pointer-events: none;
        -webkit-text-stroke: 1px #000;
      }

      #pullArea {
        position: relative;
        width: 52px;
        height: 67%;
        border-radius: 16px;
        background: none;
        box-shadow: none;
        display: flex;
        align-items: center;
        justify-content: center;
        padding: 9px 0;
        /* Allow the handle to overflow so only half of it is visible */
        overflow: visible;
        z-index: 7;
        pointer-events: none;
        margin-right: 0;
      }

      #settingsBtn {
        position: absolute;
        right: 8px;
        bottom: 8px;
        background: none;
        border: none;
        font-size: 24px;
        color: #fff;
        cursor: pointer;
      }

      .settings-panel {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: #fff;
        color: #000;
        padding: 16px;
        border: 2px solid #000;
        border-radius: 8px;
        z-index: 200;
        display: none;
        min-width: 200px;
      }
      .settings-panel.active {
        display: block;
      }
      .settings-panel label {
        display: flex;
        align-items: center;
        gap: 6px;
        margin-top: 8px;
      }
      .settings-panel select,
      .settings-panel input[type='range'] {
        margin-left: 6px;
      }
      .settings-panel select option {
        color: #000;
      }
      .settings-actions {
        margin-top: 12px;
        display: flex;
        justify-content: flex-end;
        gap: 8px;
      }

      body.frame-style-1 .avatar {
        border-style: solid;
      }
      body.frame-style-2 .avatar {
        border-style: dashed;
      }
      body.frame-style-3 .avatar {
        border-style: dotted;
      }

      #cueRail {
        position: absolute;
        right: -8px;
        left: auto;
        transform: none;
        width: 12px;
        height: calc(100% - 28px);
        background: none;
        border-radius: 9px;
        box-shadow: none;
        pointer-events: none;
      }

      #powerBox {
        width: 12px;
        height: 100%;
        background: none;
        border-radius: 6px;
        position: absolute;
        overflow: hidden;
        border: none;
        box-shadow: none;
        left: calc(100% - 16px);
        top: 0;
        transform: translate(-50%, 0);
        pointer-events: none;
        z-index: 6;
      }

      #powerFill {
        position: absolute;
        left: 0;
        top: 0;
        width: 100%;
        height: 0%;
        background:
          repeating-linear-gradient(
            to bottom,
            transparent 0 calc(10% - 1px),
            rgba(0, 0, 0, 0.6) calc(10% - 1px) 10%
          ),
          linear-gradient(to bottom, #fde047 0%, #f97316 50%, #dc2626 100%);
      }

      #powerCue {
        position: absolute;
        /* Align cue image with pull handle and power text along the right edge */
        left: calc(100% - 16px);
        top: 0;
        transform: translate(-50%, 0) scaleY(1.2);
        transform-origin: top center;
        pointer-events: none;
        touch-action: none;
        z-index: 7;
      }

      #powerBg {
        position: absolute;
        left: calc(100% - 16px);
        top: 0;
        transform: translate(-50%, 0);
        width: 12px;
        height: 100%;
        background:
          repeating-linear-gradient(
            to bottom,
            transparent 0 calc(10% - 1px),
            rgba(0, 0, 0, 0.6) calc(10% - 1px) 10%
          ),
          linear-gradient(to bottom, #fde047 0%, #f97316 50%, #dc2626 100%);
        border-radius: 6px;
        pointer-events: none;
        opacity: 0.25;
        z-index: 5;
      }

      #pullLabel {
        position: absolute;
        top: 0;
        left: auto;
        right: -2px;
        transform: none;
        font-size: 12px;
        color: #fff;
        text-align: center;
        pointer-events: auto;
        width: 44px;
        height: 44px;
        border-radius: 50%;
        border: 1px solid #fff;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        background: none;
        cursor: pointer;
        touch-action: none;
        z-index: 8;
      }

      #cueOptions {
        position: absolute;
        /* Slightly raise the cue controls */
        bottom: calc(env(safe-area-inset-bottom) + 2px);
        left: 50%;
        transform: translateX(-50%);
        display: flex;
        flex-direction: row;
        align-items: center;
        gap: 6px;
        z-index: 20;
        pointer-events: auto;
      }
      #cueOptions .cue-label {
        font-size: 10px;
        margin: 0;
      }
      #cueOptions .cue-btn {
        width: 36px;
        height: 36px;
        border-radius: 50%;
        border: 1px solid #fff;
        background: none;
        color: #fff;
        font-size: 8px;
        cursor: pointer;
        margin: 0;
      }
      #cueOptions .cue-btn.active {
        background: #facc15;
        color: #000;
      }

      #pullLabel .pullArrow {
        display: block;
        /* shift arrow so it sits under the "u" in "Pull" */
        transform: translateX(-4px);
      }

      #powerTxt {
        position: absolute;
        right: -2px;
        top: -30px;
        font-size: 15px;
        opacity: 0.85;
        width: 44px;
        text-align: center;
        pointer-events: none;
        z-index: 9;
      }

      #play {
        position: absolute;
        left: 50%;
        top: 50%;
        transform: translate(-50%, -50%);
        background: #2b4f81;
        color: #fff;
        border: none;
        border-radius: 10px;
        padding: 14px 28px;
        font-size: 16px;
        cursor: pointer;
        z-index: 10;
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.45);
      }

      #play:hover {
        background: #3c67a3;
      }

      /* Removed the round shadow from the aiming line */
      #aimGlow {
        display: none;
      }

      .winnerOverlay {
        position: fixed;
        inset: 0;
        display: flex;
        align-items: center;
        justify-content: center;
        background: rgba(0, 0, 0, 0.6);
        z-index: 60;
      }
      .winnerOverlay.hidden {
        display: none;
      }
      .winnerOverlay img {
        width: 120px;
        height: 120px;
        border-radius: 50%;
      }
      .coin-confetti {
        position: fixed;
        top: -40px;
        width: 32px;
        height: 32px;
        pointer-events: none;
        animation: coin-fall var(--duration, 3s) linear forwards;
      }
      @keyframes coin-fall {
        from {
          transform: translateY(-10vh) rotate(0deg);
          opacity: 1;
        }
        to {
          transform: translateY(100vh) rotate(360deg);
          opacity: 0;
        }
      }

      .hidden {
        display: none;
      }

      #rulesBtn {
        position: fixed;
        left: 12px;
        bottom: 12px;
        width: 28px;
        height: 28px;
        border-radius: 50%;
        border: none;
        background: rgba(0, 0, 0, 0.5);
        color: #fff;
        font-size: 18px;
        line-height: 28px;
        text-align: center;
        cursor: pointer;
        z-index: 80;
      }

      #trainingMenuWrapper {
        position: fixed;
        left: 12px;
        bottom: 40px;
        z-index: 300;
      }
      #trainingMenuButton {
        width: 32px;
        height: 32px;
        border-radius: 8px;
        border: 1px solid #24375f;
        background: #20345a;
        color: #fff;
      }
      #trainingMenu {
        position: fixed;
        inset: 0;
        background: rgba(0, 0, 0, 0.7);
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 400;
      }
      #trainingMenu.hidden {
        display: none;
      }
      #trainingMenuInner {
        background: #20345a;
        padding: 8px;
        border-radius: 8px;
        display: flex;
        flex-direction: column;
        gap: 4px;
      }
      #trainingMenuInner button {
        background: #1a2b4d;
        border: 1px solid #24375f;
        color: #fff;
        padding: 4px 8px;
        border-radius: 4px;
      }

      #rulesModal {
        position: fixed;
        inset: 0;
        background: rgba(0, 0, 0, 0.7);
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 90;
        padding: 16px;
      }

      #rulesModal.hidden {
        display: none;
      }

      #rulesModal .rules-content {
        position: relative;
        background: #fff;
        color: #000;
        padding: 16px;
        border-radius: 8px;
        max-width: 90%;
        max-height: 80%;
        overflow-y: auto;
        line-height: 1.4;
      }

      #rulesModal h2 {
        margin-top: 0;
      }

      #closeRules {
        position: absolute;
        top: 8px;
        right: 8px;
        background: none;
        border: none;
        font-size: 18px;
        cursor: pointer;
      }

      #diceOverlay {
        position: absolute;
        inset: 0;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        background: none;
        z-index: 100;
        pointer-events: none;
      }
      #diceOverlay.hidden {
        display: none;
      }
      #diceOverlay .dice-row {
        display: flex;
        gap: 20px;
        margin-bottom: 20px;
        pointer-events: auto;
      }
      /* Dice styling copied from main app for consistent look */
      @keyframes roll {
        0% {
          transform: rotateX(0) rotateY(0) rotateZ(0) translateY(0);
        }
        50% {
          transform: rotateX(360deg) rotateY(360deg) rotateZ(360deg)
            translateY(-10px);
        }
        100% {
          transform: rotateX(720deg) rotateY(720deg) rotateZ(720deg)
            translateY(0);
        }
      }
      .animate-roll {
        animation: roll 0.5s ease-in-out;
      }
      .dice-container {
        width: 40px;
        height: 40px;
        perspective: 600px;
      }
      .dice-cube {
        position: relative;
        width: 100%;
        height: 100%;
        transform-style: preserve-3d;
        transition: transform 0.5s;
      }
      .dice-face {
        position: absolute;
        width: 100%;
        height: 100%;
        display: flex;
        align-items: center;
        justify-content: center;
        background: #fff;
        border-radius: 6px;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
      }
      .dice-face .dot {
        width: 6px;
        height: 6px;
        background: #000;
        border-radius: 50%;
      }
      .dice-face--front {
        transform: rotateY(0deg) translateZ(20px);
      }
      .dice-face--back {
        transform: rotateY(180deg) translateZ(20px);
      }
      .dice-face--right {
        transform: rotateY(90deg) translateZ(20px);
      }
      .dice-face--left {
        transform: rotateY(-90deg) translateZ(20px);
      }
      .dice-face--top {
        transform: rotateX(90deg) translateZ(20px);
      }
      .dice-face--bottom {
        transform: rotateX(-90deg) translateZ(20px);
      }
    </style>
  </head>
  <body>
    <div id="app">
      <div id="header">
        <div class="player">
          <div class="avatar">A</div>
          <div class="score" id="p1Score">0</div>
          <div class="info">
            <div class="name">Artur</div>
            <div class="potted" id="p1Potted"></div>
          </div>
        </div>
        <div id="spinBox">
          <div id="spinDot"></div>
          <div id="turnTimerText"></div>
        </div>
        <div class="player">
          <div class="info">
            <div class="name">CPU</div>
            <div class="potted" id="p2Potted"></div>
          </div>
          <div class="score" id="p2Score">0</div>
          <div class="avatar">C</div>
        </div>
      </div>

      <div id="wrap">
        <canvas id="table"></canvas>
        <div id="cueHint">‚úãÔ∏è</div>

        <div id="cueOptions">
          <div class="cue-label">Cue</div>
          <button class="cue-btn" data-cue="short">Short</button>
          <button class="cue-btn" data-cue="medium">Medium</button>
          <button class="cue-btn" data-cue="long">Long</button>
          <button class="cue-btn" data-cue="auto">Auto</button>
        </div>

        <!-- Panel djathtas: vetem slideri i fuqise -->
        <aside id="rightPanel">
          <div id="pullArea">
            <div id="powerBg"></div>
            <div id="powerBox"><div id="powerFill"></div></div>
            <img
              id="powerCue"
              src="/assets/icons/file_0000000019d86243a2f7757076cd7869.webp"
              alt="Cue"
            />
            <div id="cueRail"></div>
            <div id="powerTxt"><div id="powerPercent">0%</div></div>
            <div id="pullLabel">
              Pull<br /><span class="pullArrow">‚¨á</span>
            </div>
          </div>
        </aside>

        <button id="play">Play</button>
      </div>

      <div id="footer">
        <div id="turnPlayer" class="player">
          <div class="avatar"></div>
          <div class="info">
            <div class="name"></div>
            <div id="statusMsg"></div>
          </div>
        </div>
        <button id="settingsBtn">üéõÔ∏è</button>
      </div>
    </div>
    <div id="winnerOverlay" class="winnerOverlay hidden"></div>
    <div id="centerPopup"></div>

    <div id="diceOverlay" class="hidden"></div>

    <button id="rulesBtn" aria-label="Game rules">‚ÑπÔ∏è</button>
    <div id="rulesModal" class="hidden" role="dialog" aria-modal="true">
      <div class="rules-content">
        <button id="closeRules" aria-label="Close">‚úñ</button>
        <h2 id="rulesTitle"></h2>
        <ul id="rulesList"></ul>
        <p class="rule-source" id="rulesSource"></p>
      </div>
    </div>

    <div id="settingsPanel" class="settings-panel">
      <label
        >Crowd Volume<input
          type="range"
          id="crowdVolume"
          min="0"
          max="1"
          step="0.1"
      /></label>
      <label
        >Pocket Volume<input
          type="range"
          id="pocketVolume"
          min="0"
          max="1"
          step="0.1"
      /></label>
      <label
        >Ball Volume<input
          type="range"
          id="ballVolume"
          min="0"
          max="1"
          step="0.1"
      /></label>
      <label
        >Table Brightness<input
          type="range"
          id="tableBrightness"
          min="0.5"
          max="1.5"
          step="0.1"
      /></label>
      <label>Frame Style<select id="playerFrameStyle"></select></label>
      <label
        >Frame Color<select id="playerFrameColor" class="color-select"></select
      ></label>
      <div class="settings-actions">
        <button id="saveSettings">Save</button>
        <button id="closeSettings">Close</button>
      </div>
    </div>

    <script src="/flag-emojis.js"></script>
    <script src="/pool-royale-api.js"></script>

    <!--
    Shenim: Perdorim script me type="text/javascript" per te shmangur
    cdo interpretim si modul ose si gjuhe tjeter; kjo adreson gabimet e
    tipit "Unexpected token / (1:0)" ne disa rrethina.
  -->
    <script type="text/javascript">
      (function () {
        'use strict';

        document.addEventListener(
          'touchmove',
          function (e) {
            e.preventDefault();
          },
          { passive: false }
        );

        var params = new URLSearchParams(location.search);
        var tgKey = params.get('tgId') || 'anon';
        var STATE_KEY = `poolRoyaleTournamentState_${tgKey}`;
        var OPP_KEY = `poolRoyaleTournamentOpponent_${tgKey}`;
        var stake = parseInt(params.get('amount') || '0', 10);
        var accountId = params.get('accountId');
        var tgId = params.get('tgId');
        var devAccount = params.get('dev');
        var devAccount1 = params.get('dev1');
        var devAccount2 = params.get('dev2');
        var variant = params.get('variant') || 'uk';
        var isAmerican = variant === 'american';
        var isNineBall = variant === '9ball';
        var isSnooker = variant === 'snooker';
        var playType = params.get('type') || 'regular';
        window.trainingMode = playType === 'training';
        window.tournamentMode = playType === 'tournament';
        window.trainingSolo = false;
        window.trainingRules = true;
        window.tournamentPlayers = parseInt(params.get('players') || '0', 10);
        window.potAmount = parseInt(params.get('amount') || '0', 10);
        window.playerName = params.get('name') || 'Player';
        if (isSnooker && playType === 'training') {
          document.getElementById('wrap').classList.add('snooker-training');
        }
        const planShotPromise = import('/lib/poolAi.js');

        /* ==========================================================
       KONSTANTA TE LAYOUT-it DHE FIZIKES (sipas portrait)
       ========================================================= */
        var TABLE_W = 768; // gjeresi logjike e felt-it
        var TABLE_H = 1216; // lartesi logjike e felt-it
        var BORDER = 57; // korniza e drurit pak me e ngushte anash
        var BALL_R = isSnooker && playType === 'training' ? 18 : 22; // snooker training uses smaller balls
        var GREEN_LINE = 16; // thickness of the green boundary lines
        // Gropat pak me te vogla per t'u mbyllur me shume dhe jo per t'u zgjeruar
        var POCKET_R =
          isSnooker && playType === 'training' ? BALL_R * 0.68 : 34; // pockets slightly larger
        var SIDE_POCKET_R =
          isSnooker && playType === 'training' ? POCKET_R : 32; // side pockets also a touch larger
        // move pockets slightly closer to the center of the table
        var POCKET_SHORTEN = isSnooker ? 2 : 4; // gropat snooker pak me brenda
        var POCKET_INSET = 5; // additional inward shift for all pockets
        var SHORT_DIST = BALL_R * 28;
        var MED_DIST = BALL_R * 56;
        var BORDER_TOP =
          BORDER + BALL_R * 2 - 4 - GREEN_LINE; // extend field upward by two green lines
        // Raise only the bottom field line by the thickness of one green side
        // marking so the table's lower boundary sits slightly higher.
        var BORDER_BOTTOM = BORDER + GREEN_LINE; // anet e tjera mbeten te pandryshuara
        // Move the rack slightly upward on the table
        var SPOT_Y =
          BORDER_TOP +
          (TABLE_H - BORDER_TOP - BORDER_BOTTOM) * 0.25 -
          BALL_R * 0.5; // pika per trekendshin siper
        var LINE_Y = BORDER_TOP + (TABLE_H - BORDER_TOP - BORDER_BOTTOM) * 0.75; // vija e bardhe poshte
        var CUE_START_Y =
          LINE_Y + (TABLE_H - BORDER_BOTTOM - LINE_Y - BALL_R * 2) / 2; // pozicioni fillestar i cueball-it

        var FRICTION = 0.985; // ferkimi linear, pak me i vogel per te ruajtur shpejtesine
        var BOUNCE = 0.99; // koeficienti i rikthimit pak me i madh
        var POCKET_JAW_DAMPING = 0.3; // gropat ulin shpejtesine me rreth 70%
        var POCKET_JAW_POWER = 0.25; // energjia e mbetur pas prekje se gropes
        var INV_SQRT2 = 1 / Math.SQRT2;

        var MIN_V = 0.12; // shpejtesia min. qe konsiderohet "ne levizje"

        var POCKET_DIRS = [
          { x: 1, y: 1 },
          { x: -1, y: 1 },
          { x: 1, y: 0 },
          { x: -1, y: 0 },
          { x: 1, y: -1 },
          { x: -1, y: -1 }
        ];

        /* ==========================================================
       ELEMENTET DOM
       ========================================================= */
        var canvas = document.getElementById('table');
        var ctx = canvas.getContext('2d');
        var rightPanel = document.getElementById('rightPanel');
        var playBtn = document.getElementById('play');
        var turnPlayer = document.getElementById('turnPlayer');
        var footerAvatar = turnPlayer.querySelector('.avatar');
        var footerName = turnPlayer.querySelector('.name');
        var statusMsg = document.getElementById('statusMsg');
        var footerTimeout = null;
        var centerPopup = document.getElementById('centerPopup');
        var spinBox = document.getElementById('spinBox');
        var spinDot = document.getElementById('spinDot');
        var timerDisplay = document.getElementById('turnTimerText');
        var logoImg = new Image();
        logoImg.src = '/assets/icons/pool-royale.svg';
        var cueImg = new Image();
        cueImg.src = '/assets/icons/file_0000000019d86243a2f7757076cd7869.webp';
        var pullArea = document.getElementById('pullArea');
        var powerFill = document.getElementById('powerFill');
        var powerBox = document.getElementById('powerBox');
        var powerTxt = document.getElementById('powerTxt');
        var powerPercent = document.getElementById('powerPercent');
        var powerCue = document.getElementById('powerCue');
        var powerBg = document.getElementById('powerBg');
        var pullHandle = document.getElementById('pullLabel');
        var cueRail = document.getElementById('cueRail');
        var cueButtons = document.querySelectorAll('#cueOptions .cue-btn');
        var settingsBtn = document.getElementById('settingsBtn');
        var settingsPanel = document.getElementById('settingsPanel');
        var crowdVolumeInput = document.getElementById('crowdVolume');
        var pocketVolumeInput = document.getElementById('pocketVolume');
        var ballVolumeInput = document.getElementById('ballVolume');
        var brightnessInput = document.getElementById('tableBrightness');
        var frameStyleSelect = document.getElementById('playerFrameStyle');
        var frameColorSelect = document.getElementById('playerFrameColor');
        var saveSettingsBtn = document.getElementById('saveSettings');
        var closeSettingsBtn = document.getElementById('closeSettings');

        var currentCue = 'short';
        var autoCue = false;
        function setCueVariant(v, fromAuto) {
          if (v === 'auto') {
            autoCue = true;
          } else {
            currentCue = v;
            if (!fromAuto) autoCue = false;
          }
          cueButtons.forEach(function (b) {
            if (b.dataset.cue === 'auto') {
              b.classList.toggle('active', autoCue);
            } else {
              b.classList.toggle('active', b.dataset.cue === currentCue);
            }
          });
        }
        function updateAutoCue() {
          if (!autoCue || !table) return;
          var cue = table.balls[0];
          var aim = table.aim;
          var dist = Math.hypot(aim.x - cue.p.x, aim.y - cue.p.y);
          var bucket =
            dist <= SHORT_DIST ? 'short' : dist <= MED_DIST ? 'medium' : 'long';
          setCueVariant(bucket, true);
        }
        cueButtons.forEach(function (b) {
          b.addEventListener('click', function () {
            if (b.dataset.cue === 'auto') {
              autoCue = true;
              updateAutoCue();
            } else {
              setCueVariant(b.dataset.cue);
            }
          });
        });
        setCueVariant(currentCue);

        var avatarP1 = document.querySelector(
          '#header .player:first-child .avatar'
        );
        var nameP1 = document.querySelector(
          '#header .player:first-child .name'
        );
        var avatarCPU = document.querySelector(
          '#header .player:last-child .avatar'
        );
        var nameCPU = document.querySelector(
          '#header .player:last-child .name'
        );

        var crowdVolume = parseFloat(localStorage.getItem('poolCrowdVol')) || 1;
        var pocketVolume =
          parseFloat(localStorage.getItem('poolPocketVol')) || 1;
        var ballVolume = parseFloat(localStorage.getItem('poolBallVol')) || 1;
        var tableBrightness =
          parseFloat(localStorage.getItem('poolBrightness')) || 1.1;
        var frameStyleSetting = localStorage.getItem('poolFrameStyle') || '1';
        var frameColorSetting =
          localStorage.getItem('poolFrameColor') || '#000';

        document.body.classList.add('frame-style-' + frameStyleSetting);
        document.documentElement.style.setProperty(
          '--player-frame-color',
          frameColorSetting
        );

        if (frameStyleSelect) {
          for (var fs = 1; fs <= 3; fs++) {
            var opt = document.createElement('option');
            opt.value = fs;
            opt.textContent = 'Style ' + fs;
            frameStyleSelect.appendChild(opt);
          }
          frameStyleSelect.value = frameStyleSetting;
        }

        if (frameColorSelect) {
          [
            '#000',
            '#f00',
            '#0f0',
            '#00f',
            '#ff0',
            '#f0f',
            '#0ff',
            '#fff'
          ].forEach(function (c) {
            var opt = document.createElement('option');
            opt.value = c;
            opt.textContent = c;
            opt.style.background =
              'linear-gradient(to right, ' + c + ' 0 16px, #fff 16px)';
            frameColorSelect.appendChild(opt);
          });
          frameColorSelect.value = frameColorSetting;
        }

        if (crowdVolumeInput) crowdVolumeInput.value = crowdVolume;
        if (pocketVolumeInput) pocketVolumeInput.value = pocketVolume;
        if (ballVolumeInput) ballVolumeInput.value = ballVolume;
        if (brightnessInput) brightnessInput.value = tableBrightness;

        document.documentElement.style.setProperty(
          '--table-brightness',
          tableBrightness
        );

        function applySettings() {
          crowdVolume = parseFloat(crowdVolumeInput.value || crowdVolume);
          pocketVolume = parseFloat(pocketVolumeInput.value || pocketVolume);
          ballVolume = parseFloat(ballVolumeInput.value || ballVolume);
          tableBrightness = parseFloat(
            brightnessInput.value || tableBrightness
          );
          document.body.className = document.body.className.replace(
            /frame-style-\d+/g,
            ''
          );
          document.body.classList.add('frame-style-' + frameStyleSelect.value);
          document.documentElement.style.setProperty(
            '--player-frame-color',
            frameColorSelect.value
          );
          document.documentElement.style.setProperty(
            '--table-brightness',
            tableBrightness
          );
        }

        if (settingsBtn) {
          settingsBtn.addEventListener('click', function () {
            settingsPanel.classList.add('active');
          });
          closeSettingsBtn.addEventListener('click', function () {
            settingsPanel.classList.remove('active');
          });
          saveSettingsBtn.addEventListener('click', function () {
            localStorage.setItem('poolCrowdVol', crowdVolumeInput.value);
            localStorage.setItem('poolPocketVol', pocketVolumeInput.value);
            localStorage.setItem('poolBallVol', ballVolumeInput.value);
            localStorage.setItem('poolBrightness', brightnessInput.value);
            localStorage.setItem('poolFrameStyle', frameStyleSelect.value);
            localStorage.setItem('poolFrameColor', frameColorSelect.value);
            applySettings();
            settingsPanel.classList.remove('active');
          });
        }

        applySettings();

        function formatPlayerName(name, el) {
          el.classList.remove('small');
          if (name.length > 15) {
            var initials = name
              .trim()
              .split(/\s+/)
              .map(function (part) {
                return part.charAt(0);
              })
              .join('');
            el.textContent = initials;
          } else {
            el.textContent = name;
            if (name.length > 12) {
              el.classList.add('small');
            }
          }
        }

        formatPlayerName(nameP1.textContent, nameP1);
        formatPlayerName(nameCPU.textContent, nameCPU);
        var pottedP1 = document.getElementById('p1Potted');
        var pottedP2 = document.getElementById('p2Potted');
        var scoreP1 = document.getElementById('p1Score');
        var scoreP2 = document.getElementById('p2Score');
        var cueHint = document.getElementById('cueHint');

        if (!isAmerican && !isSnooker) {
          scoreP1.style.display = 'none';
          scoreP2.style.display = 'none';
        }

        var urlParams = new URLSearchParams(location.search);
        var avatarParam = urlParams.get('avatar');
        var nameParam = urlParams.get('name');
        if (nameParam) {
          formatPlayerName(nameParam, nameP1);
        }
        if (avatarParam) {
          avatarP1.style.backgroundImage = 'url(' + avatarParam + ')';
          avatarP1.style.backgroundSize = 'cover';
          avatarP1.textContent = '';
        }

        function coinConfetti(count, iconSrc) {
          count = count || 50;
          iconSrc = iconSrc || '/assets/icons/ezgif-54c96d8a9b9236.webp';
          for (var i = 0; i < count; i++) {
            var img = document.createElement('img');
            img.src = iconSrc;
            img.className = 'coin-confetti';
            img.style.left = Math.random() * 100 + 'vw';
            img.style.setProperty('--duration', 2 + Math.random() * 2 + 's');
            document.body.appendChild(img);
            setTimeout(
              (function (el) {
                return function () {
                  el.remove();
                };
              })(img),
              3000
            );
          }
        }

        function endGame(winner) {
          table.running = false;
          shotInProgress = false;
          if (
            window.tournamentMode &&
            typeof window.handleTournamentResult === 'function'
          ) {
            try {
              localStorage.setItem(
                `poolRoyaleLastResult_${tgKey}`,
                JSON.stringify({ scores, variant })
              );
            } catch {}
            const result = Number(winner) === 1 ? 1 : 2;
            window.handleTournamentResult(result);
            return;
          }
          var overlay = document.getElementById('winnerOverlay');
          var avatar = winner === 1 ? avatarP1 : avatarCPU;
          if (avatar) overlay.innerHTML = avatar.outerHTML;
          overlay.classList.remove('hidden');
          coinConfetti(50);
          setTimeout(function () {
            location.href =
              '/games/pollroyale/lobby?winner=' +
              winner +
              '&variant=' +
              variant;
          }, 2000);
        }

        if (window.tournamentMode) {
          async function awardDevShare(total) {
            const ops = [];
            if (devAccount1 || devAccount2) {
              if (devAccount)
                ops.push(
                  prApi.depositAccount(devAccount, Math.round(total * 0.09), {
                    game: 'poolroyale-dev'
                  })
                );
              if (devAccount1)
                ops.push(
                  prApi.depositAccount(devAccount1, Math.round(total * 0.01), {
                    game: 'poolroyale-dev1'
                  })
                );
              if (devAccount2)
                ops.push(
                  prApi.depositAccount(devAccount2, Math.round(total * 0.02), {
                    game: 'poolroyale-dev2'
                  })
                );
            } else if (devAccount) {
              ops.push(
                prApi.depositAccount(devAccount, Math.round(total * 0.1), {
                  game: 'poolroyale-dev'
                })
              );
            }
            if (ops.length) {
              try {
                await Promise.all(ops);
              } catch {}
            }
          }

          window.handleTournamentResult = async function (winner) {
            try {
              const st = JSON.parse(localStorage.getItem(STATE_KEY) || '{}');
              if (!st.pendingMatch) {
                window.location.href =
                  '/pool-royale-bracket.html?' +
                  window.location.search.slice(1);
                return;
              }
              const r = st.pendingMatch.round;
              const m = st.pendingMatch.match;
              const oppSeed =
                st.pendingMatch.pair[0] === st.userSeed
                  ? st.pendingMatch.pair[1]
                  : st.pendingMatch.pair[0];
              const winnerSeed = winner === 1 ? st.userSeed : oppSeed;
              const next = st.rounds[r + 1];
              if (next) {
                next[Math.floor(m / 2)][m % 2] = winnerSeed;
              } else {
                st.championSeed = winnerSeed;
                st.complete = true;
              }
              if (winnerSeed !== st.userSeed) {
                simulateRemaining(st, r);
              } else {
                simulateRoundAI(st, r);
                if (
                  next &&
                  st.rounds[r].every(function (p, idx) {
                    return next[Math.floor(idx / 2)][idx % 2];
                  })
                ) {
                  st.currentRound++;
                  simulateRoundAI(st, st.currentRound);
                }
              }
              if (
                st.complete &&
                winnerSeed === st.userSeed &&
                stake > 0 &&
                accountId
              ) {
                const total = stake * window.tournamentPlayers;
                const prize = Math.round(total * 0.91);
                try {
                  await prApi.depositAccount(accountId, prize, {
                    game: 'poolroyale-win'
                  });
                  if (tgId)
                    await prApi.addTransaction(tgId, 0, 'win', {
                      game: 'poolroyale',
                      players: window.tournamentPlayers,
                      accountId
                    });
                  await awardDevShare(total);
                } catch {}
              }
              delete st.pendingMatch;
              localStorage.setItem(STATE_KEY, JSON.stringify(st));
              localStorage.removeItem(OPP_KEY);
            } catch (err) {
              console.error(err);
            }
            window.location.href =
              '/pool-royale-bracket.html?' + window.location.search.slice(1);
          };

          function simulateRoundAI(st, round) {
            const next = st.rounds[round + 1];
            const userSeed = st.userSeed;
            st.rounds[round].forEach(function (pair, idx) {
              if (pair.includes(userSeed)) return;
              if (next && next[Math.floor(idx / 2)][idx % 2]) return;
              const s1 = pair[0];
              const s2 = pair[1];
              const p1 = st.seedToPlayer[s1];
              const p2 = st.seedToPlayer[s2];
              let w;
              if (p1 && p1.name === 'BYE') w = s2;
              else if (p2 && p2.name === 'BYE') w = s1;
              else w = Math.random() < 0.5 ? s1 : s2;
              if (next) {
                next[Math.floor(idx / 2)][idx % 2] = w;
              } else {
                st.championSeed = w;
                st.complete = true;
              }
            });
          }

          function simulateRemaining(st, startRound) {
            for (let rr = startRound; rr < st.rounds.length; rr++) {
              simulateRoundAI(st, rr);
              if (st.complete) break;
            }
            st.currentRound = st.rounds.length - 1;
            st.complete = true;
          }
        }

        // --------------------------------------------------
        // Audio setup
        // --------------------------------------------------
        var audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        var hitBuffer = null,
          ballHitBuffer = null,
          pocketBuffer = null,
          knockBuffer = null,
          cheerBuffer = null,
          shockBuffer = null,
          activeSound = null;

        fetch('/assets/sounds/billiard-pool-hit-371618.mp3')
          .then(function (r) {
            return r.arrayBuffer();
          })
          .then(function (b) {
            return audioCtx.decodeAudioData(b);
          })
          .then(function (buf) {
            hitBuffer = buf;
          });

        fetch(encodeURI('/assets/sounds/billiard-sound newhit.mp3'))
          .then(function (r) {
            return r.arrayBuffer();
          })
          .then(function (b) {
            return audioCtx.decodeAudioData(b);
          })
          .then(function (buf) {
            ballHitBuffer = buf;
          });

        fetch('/assets/sounds/billiard-sound-6-288417.mp3')
          .then(function (r) {
            return r.arrayBuffer();
          })
          .then(function (b) {
            return audioCtx.decodeAudioData(b);
          })
          .then(function (buf) {
            pocketBuffer = buf;
          });

        fetch('/assets/sounds/wooden-door-knock-102902.mp3')
          .then(function (r) {
            return r.arrayBuffer();
          })
          .then(function (b) {
            return audioCtx.decodeAudioData(b);
          })
          .then(function (buf) {
            knockBuffer = buf;
          });

        fetch('/assets/sounds/crowd-cheering-383111.mp3')
          .then(function (r) {
            return r.arrayBuffer();
          })
          .then(function (b) {
            return audioCtx.decodeAudioData(b);
          })
          .then(function (buf) {
            cheerBuffer = buf;
          });

        fetch('/assets/sounds/crowd-shocked-reaction-352766.mp3')
          .then(function (r) {
            return r.arrayBuffer();
          })
          .then(function (b) {
            return audioCtx.decodeAudioData(b);
          })
          .then(function (buf) {
            shockBuffer = buf;
          });

        function stopActiveSound() {
          if (activeSound) {
            try {
              activeSound.stop();
            } catch (e) {}
            activeSound = null;
          }
        }

        function playCueHit(vol) {
          audioCtx.resume();
          if (!hitBuffer) return;
          var src = audioCtx.createBufferSource();
          src.buffer = hitBuffer;
          var gain = audioCtx.createGain();
          gain.gain.value = clamp(vol, 0, 1);
          src.connect(gain).connect(audioCtx.destination);
          src.start(0, 0, 0.5);
        }

        function playBallHit(vol) {
          audioCtx.resume();
          if (!ballHitBuffer) return;
          var src = audioCtx.createBufferSource();
          src.buffer = ballHitBuffer;
          var gain = audioCtx.createGain();
          gain.gain.value = clamp(vol * ballVolume * 0.72, 0, 1);
          src.connect(gain).connect(audioCtx.destination);
          src.start(0);
        }

        function playPocket(vol) {
          audioCtx.resume();
          if (!pocketBuffer) return;
          var src = audioCtx.createBufferSource();
          src.buffer = pocketBuffer;
          var gain = audioCtx.createGain();
          gain.gain.value = clamp(vol * pocketVolume * 0.8, 0, 1);
          src.connect(gain).connect(audioCtx.destination);
          var d = pocketBuffer.duration;
          src.start(0, Math.max(0, d - 1), 1);
        }

        function playTurnSound() {
          audioCtx.resume();
          if (!knockBuffer) return;
          var src = audioCtx.createBufferSource();
          src.buffer = knockBuffer;
          var gain = audioCtx.createGain();
          gain.gain.value = 1;
          src.connect(gain).connect(audioCtx.destination);
          src.start(0);
        }

        function playCheer(vol) {
          if (!cheerBuffer) return;
          audioCtx.resume().then(function () {
            stopActiveSound();
            var src = audioCtx.createBufferSource();
            src.buffer = cheerBuffer;
            var gain = audioCtx.createGain();
            gain.gain.value = clamp(vol * crowdVolume, 0, 1);
            src.connect(gain).connect(audioCtx.destination);
            src.start(0);
            activeSound = src;
          });
        }

        function playShock(vol) {
          audioCtx.resume();
          if (!shockBuffer) return;
          stopActiveSound();
          var src = audioCtx.createBufferSource();
          src.buffer = shockBuffer;
          var gain = audioCtx.createGain();
          gain.gain.value = clamp(vol * crowdVolume, 0, 1);
          src.connect(gain).connect(audioCtx.destination);
          src.start(0);
          activeSound = src;
        }

        var tg = window.Telegram?.WebApp;
        var userData = tg?.initDataUnsafe?.user;
        if (userData) {
          if (!nameParam) {
            var fullName =
              [userData.first_name, userData.last_name]
                .filter(Boolean)
                .join(' ') || 'You';
            formatPlayerName(fullName, nameP1);
          }
          if (!avatarParam) {
            if (userData.photo_url) {
              avatarP1.style.backgroundImage =
                'url(' + userData.photo_url + ')';
              avatarP1.style.backgroundSize = 'cover';
              avatarP1.textContent = '';
            } else if (userData.first_name) {
              avatarP1.textContent = userData.first_name.charAt(0);
            }
          }
          tg?.expand();
        }

        var regionNames = new Intl.DisplayNames(['en'], { type: 'region' });
        function flagToName(flag) {
          try {
            var codes = Array.from(flag).map(function (c) {
              return c.codePointAt(0) - 0x1f1e6 + 65;
            });
            return regionNames.of(String.fromCharCode.apply(null, codes));
          } catch (e) {
            return 'AI';
          }
        }
        if (window.tournamentMode) {
          try {
            var opp = JSON.parse(localStorage.getItem(OPP_KEY) || '{}');
            if (opp.flag) avatarCPU.textContent = opp.flag;
            formatPlayerName(opp.name || 'CPU', nameCPU);
          } catch (e) {
            formatPlayerName('CPU', nameCPU);
          }
        } else if (window.FLAG_EMOJIS) {
          var flag = FLAG_EMOJIS[(Math.random() * FLAG_EMOJIS.length) | 0];
          avatarCPU.textContent = flag;
          formatPlayerName(flagToName(flag) || 'CPU', nameCPU);
        }

        /* ==========================================================
       SHKALlEZIMI / RESIZE
       ========================================================= */
        var sX = 1,
          sY = 1,
          scaleFactor = 1,
          ballR = BALL_R;
        function resize() {
          var wrap = document.getElementById('wrap');
          var w = wrap.clientWidth;
          var h = wrap.clientHeight;
          var ar = TABLE_W / TABLE_H;
          var cw = w,
            ch = h;
          if (cw / ch > ar) cw = ch * ar;
          else ch = cw / ar;
          canvas.width = cw;
          canvas.height = ch;
          canvas.style.width = cw + 'px';
          canvas.style.height = ch + 'px';
          canvas.style.left = (w - cw) / 2 + 'px';
          canvas.style.top = (h - ch) / 2 + 'px';
          sX = cw / TABLE_W;
          sY = ch / TABLE_H;
          scaleFactor = (sX + sY) / 2;
          ballR = BALL_R * scaleFactor;
          powerCue.style.height = BALL_R * 28 * sX + 'px';
          updatePullHandle();
        }
        window.addEventListener('resize', resize);

        /* ==========================================================
       UTILITARE
       ========================================================= */
        function clamp(v, a, b) {
          return Math.max(a, Math.min(b, v));
        }
        function shadeColor(hex, amt) {
          var c = hex.replace('#', '');
          if (c.length === 3) c = c.split('').map(function (ch) { return ch + ch; }).join('');
          var n = parseInt(c, 16);
          var r = (n >> 16) & 255,
            g = (n >> 8) & 255,
            b = n & 255;
          r = clamp(r + amt, 0, 255);
          g = clamp(g + amt, 0, 255);
          b = clamp(b + amt, 0, 255);
          return 'rgb(' + r + ',' + g + ',' + b + ')';
        }
        function len(x, y) {
          return Math.hypot(x, y);
        }
        function norm(x, y) {
          var L = len(x, y) || 1;
          return { x: x / L, y: y / L };
        }
        function d2(a, b) {
          var dx = a.x - b.x,
            dy = a.y - b.y;
          return dx * dx + dy * dy;
        }

        function reflectVelocity(v, nx, ny, bounce) {
          var dot = v.x * nx + v.y * ny;
          v.x = (v.x - 2 * dot * nx) * bounce;
          v.y = (v.y - 2 * dot * ny) * bounce;
        }

        function handleConnectorCollision(tbl, b, pk, nx, ny, cond) {
          var rx = b.p.x - pk.x;
          var ry = b.p.y - pk.y;
          if (!cond(rx, ry)) return;
          // Allow the ball to reach the cushion before bouncing
          // by removing the green line offset from the collision limit.
          var limit = pk.r + BALL_R;
          var dist = rx * nx + ry * ny;
          if (dist >= limit) return;
          var vn = b.v.x * nx + b.v.y * ny;
          if (vn <= 0) return;
          var pen = limit - dist;
          b.p.x -= nx * pen;
          b.p.y -= ny * pen;
          b.v.x -= vn * nx;
          b.v.y -= vn * ny;
          b.v.x *= POCKET_JAW_DAMPING;
          b.v.y *= POCKET_JAW_DAMPING;
          lastShotPower *= POCKET_JAW_POWER;
          if (b.n === 0) {
            b.impacted = true;
            applySpinImpulse(b);
          }
          if (b === tbl.balls[0] && shotInProgress && !firstHit)
            cueHitCushion = true;
        }

        function brighten(hex, amt) {
          var c = hex.slice(1);
          if (c.length === 3)
            c = c
              .split('')
              .map(function (ch) {
                return ch + ch;
              })
              .join('');
          var num = parseInt(c, 16);
          var r = num >> 16;
          var g = (num >> 8) & 0xff;
          var b = num & 0xff;
          r = Math.min(255, Math.round(r * (1 + amt)));
          g = Math.min(255, Math.round(g * (1 + amt)));
          b = Math.min(255, Math.round(b * (1 + amt)));
          return '#' + ((r << 16) | (g << 8) | b).toString(16).padStart(6, '0');
        }

        function applySpinImpulse(ball) {
          if (!ball.spin) return;
          // Apply stronger, immediate spin influence
          var SPIN_STRENGTH = 120;
          var SPIN_DECAY = 0.9;
          ball.v.x += ball.spin.x * SPIN_STRENGTH;
          ball.v.y += ball.spin.y * SPIN_STRENGTH;
          ball.spin.x *= SPIN_DECAY;
          ball.spin.y *= SPIN_DECAY;
        }

        /* ==========================================================
       PALETA E NGJYRAVE DHE LISTA E TOPAVE
       ========================================================= */
        var COL, BALLS;
        var snookerSpots = {};
        var snookerPottedColors = [];
        if (isAmerican) {
          COL = {
            cue: '#f5f5f5',
            1: '#f5c400',
            2: '#2256ff',
            3: '#d92d30',
            4: '#7c3aed',
            5: '#ff8c1a',
            6: '#1faa4a',
            7: '#7a2f2f',
            8: '#111'
          };
          // BALLS ‚Äì 0..15 ‚Äî cdo element ka { n, t, c }
          BALLS = [
            { n: 0, t: 'cue', c: COL.cue },
            { n: 1, t: 'solid', c: COL[1] },
            { n: 2, t: 'solid', c: COL[2] },
            { n: 3, t: 'solid', c: COL[3] },
            { n: 4, t: 'solid', c: COL[4] },
            { n: 5, t: 'solid', c: COL[5] },
            { n: 6, t: 'solid', c: COL[6] },
            { n: 7, t: 'solid', c: COL[7] },
            { n: 8, t: 'eight', c: COL[8] },
            { n: 9, t: 'stripe', c: COL[1] },
            { n: 10, t: 'stripe', c: COL[2] },
            { n: 11, t: 'stripe', c: COL[3] },
            { n: 12, t: 'stripe', c: COL[4] },
            { n: 13, t: 'stripe', c: COL[5] },
            { n: 14, t: 'stripe', c: COL[6] },
            { n: 15, t: 'stripe', c: COL[7] }
          ];
        } else if (isNineBall) {
          COL = {
            cue: '#f5f5f5',
            1: '#f5c400',
            2: '#2256ff',
            3: '#d92d30',
            4: '#7c3aed',
            5: '#ff8c1a',
            6: '#1faa4a',
            7: '#7a2f2f',
            8: '#111',
            9: '#f5c400'
          };
          BALLS = [
            { n: 0, t: 'cue', c: COL.cue },
            { n: 1, t: 'solid', c: COL[1] },
            { n: 2, t: 'solid', c: COL[2] },
            { n: 3, t: 'solid', c: COL[3] },
            { n: 4, t: 'solid', c: COL[4] },
            { n: 5, t: 'solid', c: COL[5] },
            { n: 6, t: 'solid', c: COL[6] },
            { n: 7, t: 'solid', c: COL[7] },
            { n: 8, t: 'solid', c: COL[8] },
            { n: 9, t: 'stripe', c: COL[9] }
          ];
        } else if (isSnooker) {
          COL = {
            cue: '#f5f5f5',
            red: '#d92d30',
            yellow: '#f2d24b',
            green: '#1faa4a',
            brown: '#7a2f2f',
            blue: '#2256ff',
            pink: '#ff69b4',
            black: '#111'
          };
          BALLS = [{ n: 0, t: 'cue', c: COL.cue, p: 0 }];
          for (var nn = 1; nn <= 15; nn++)
            BALLS.push({ n: nn, t: 'red', c: COL.red, p: 1 });
          var colors = [
            { t: 'yellow', c: COL.yellow, p: 2 },
            { t: 'green', c: COL.green, p: 3 },
            { t: 'brown', c: COL.brown, p: 4 },
            { t: 'blue', c: COL.blue, p: 5 },
            { t: 'pink', c: COL.pink, p: 6 },
            { t: 'black', c: COL.black, p: 7 }
          ];
          colors.forEach(function (col, idx) {
            BALLS.push({
              n: 15 + idx + 1,
              t: col.t,
              c: col.c,
              p: col.p
            });
          });
        } else {
          COL = {
            cue: '#f5f5f5',
            red: '#d92d30',
            // UK variant uses yellow balls instead of blue
            blue: '#f2d24b',
            eight: '#111'
          };
          BALLS = [{ n: 0, t: 'cue', c: COL.cue }];
          for (var nn = 1; nn <= 7; nn++)
            BALLS.push({ n: nn, t: 'red', c: COL.red });
          BALLS.push({ n: 8, t: 'eight', c: COL.eight });
          for (var mm = 9; mm <= 15; mm++)
            BALLS.push({ n: mm, t: 'blue', c: COL.blue });
        }
        var TOTAL_BALLS = BALLS.length;

        // Map i sigurt sipas numrit ‚Üí shmang akses jashte indekseve
        var BALL_BY_N = {};
        BALLS.forEach(function (b) {
          BALL_BY_N[b.n] = b;
        });

        /* ==========================================================
       KLASAT E ENTITETEVE
       ========================================================= */
        function Ball(info, x, y) {
          if (!info)
            throw new Error('Ball info undefined (nuk egziston ne BALLS)');
          this.n = info.n; // numri (0..15)
          this.t = info.t; // tipi (solid / stripe / eight / cue)
          this.c = info.c; // ngjyra
          this.p = { x: x, y: y }; // pozicioni
          this.v = { x: 0, y: 0 }; // shpejtesia
          this.pocketed = false; // ne grope
          this.a = 0; // kendi per vizualizim rrotullimi
          this.spin = { x: 0, y: 0 }; // spin aktiv
          this.impacted = false; // has the ball collided yet
        }

        function Pocket(x, y, r) {
          this.x = x;
          this.y = y;
          this.r = r || POCKET_R;
        }

        function Table() {
          this.balls = [];
          this.pockets = [];
          this.running = false;
          this.turn = 0; // 0: waiting for dice, 1: P1, 2: CPU
          this.captured = { 1: [], 2: [] };
          this.aim = { x: TABLE_W / 2, y: TABLE_H / 3 };
          // Track ball pairs that are currently colliding to avoid
          // triggering the collision sound more than once for a single
          // contact event.
          this.prevCollisions = new Set();
          this.reset();
        }

        function insetPockets(pockets, inset) {
          pockets[0].x += inset;
          pockets[0].y += inset;
          pockets[1].x -= inset;
          pockets[1].y += inset;
          pockets[2].x += inset;
          pockets[3].x -= inset;
          pockets[4].x += inset;
          pockets[4].y -= inset;
          pockets[5].x -= inset;
          pockets[5].y -= inset;
        }

        Table.prototype.reset = function () {
          var i, j;
          this.balls = [];
          this.prevCollisions.clear();
          snookerPottedColors = [];

          // Cue ball (center poshte vijes se bardhe)
          this.balls.push(new Ball(BALL_BY_N[0], TABLE_W / 2, CUE_START_Y));
          cueBallFree = true;
          aiming = false;
          cueHintTime = Date.now();

          // Trekendshi siper me 15 topa (8-shi ne qender rreshti 3)
          // Rrotulluar qe topi i verdhe te jete perballe cue ball-it
          var rowGap = BALL_R * 2.1;
          var colGap = BALL_R * 1.95;
          var cx = TABLE_W / 2;
          var cy = SPOT_Y - colGap * 2;

          if (isAmerican) {
            // Lista e numrave te tjere ‚Äì do perdoren gradualisht
            var pool = [];
            for (i = 1; i <= 15; i++) {
              if (i !== 1 && i !== 2 && i !== 8 && i !== 11) pool.push(i);
            }
            var cursor = 0;

            // 5 rreshta nga lart poshte - trekendesh me maje poshte
            for (var r = 0; r < 5; r++) {
              var count = 5 - r;
              var startX = cx - (rowGap * (count - 1)) / 2;
              var y = cy + r * colGap;
              for (j = 0; j < count; j++) {
                var x = startX + j * rowGap;
                var num;
                if (r === 4 && j === 0)
                  num = 1; // yellow ne maje (poshte)
                else if (r === 2 && j === 1)
                  num = 8; // qender
                else if (r === 0 && j === 0)
                  num = 2; // qoshe solid majtas
                else if (r === 0 && j === 4)
                  num = 11; // qoshe stripe djathtas
                else num = pool[cursor++];
                var info = BALL_BY_N[num];
                if (!info) {
                  console.warn('Rack: numer i papercaktuar', num);
                  continue;
                }
                this.balls.push(new Ball(info, x, y));
              }
            }
          } else if (isNineBall) {
            // Rregullimi per 9-ball (diamant), i rrotulluar qe topi i verdhe te jete perballe cue ball-it
            var pattern9 = [[8], [7, 6], [5, 9, 4], [3, 2], [1]];
            for (var r9 = 0; r9 < pattern9.length; r9++) {
              var cnt9 = pattern9[r9].length;
              var startX9 = cx - (rowGap * (cnt9 - 1)) / 2;
              var y9 = cy + r9 * colGap;
              for (var j9 = 0; j9 < cnt9; j9++) {
                var x9 = startX9 + j9 * rowGap;
                var num9 = pattern9[r9][j9];
                var info9 = BALL_BY_N[num9];
                if (!info9) {
                  console.warn('Rack: numer i papercaktuar', num9);
                  continue;
                }
                this.balls.push(new Ball(info9, x9, y9));
              }
            }
          } else if (isSnooker) {
            // Snooker layout with 15 reds and 6 colour balls
            rowGap = BALL_R * 2;
            colGap = BALL_R * 1.8;
            var redStartY = SPOT_Y;
            var idx = 1;
            for (var rS = 0; rS < 5; rS++) {
              var cntS = rS + 1;
              var startXS = cx - (rowGap * (cntS - 1)) / 2;
              var yS = redStartY - rS * colGap;
              for (var jS = 0; jS < cntS; jS++) {
                var infoS = BALL_BY_N[idx++];
                if (infoS) this.balls.push(new Ball(infoS, startXS + jS * rowGap, yS));
              }
            }
            // place the six colour balls on their spots
            snookerSpots = {
              yellow: { x: TABLE_W / 2 - BALL_R * 7, y: LINE_Y },
              green: { x: TABLE_W / 2 + BALL_R * 7, y: LINE_Y },
              brown: { x: TABLE_W / 2, y: LINE_Y },
              blue: { x: TABLE_W / 2, y: TABLE_H / 2 },
              pink: { x: TABLE_W / 2, y: SPOT_Y + colGap * 2 },
              black: { x: TABLE_W / 2, y: redStartY - colGap * 4 }
            };
            this.balls.push(
              new Ball(BALL_BY_N[16], snookerSpots.yellow.x, snookerSpots.yellow.y)
            );
            this.balls.push(
              new Ball(BALL_BY_N[17], snookerSpots.green.x, snookerSpots.green.y)
            );
            this.balls.push(
              new Ball(BALL_BY_N[18], snookerSpots.brown.x, snookerSpots.brown.y)
            );
            this.balls.push(
              new Ball(BALL_BY_N[19], snookerSpots.blue.x, snookerSpots.blue.y)
            );
            this.balls.push(
              new Ball(BALL_BY_N[20], snookerSpots.pink.x, snookerSpots.pink.y)
            );
            this.balls.push(
              new Ball(BALL_BY_N[21], snookerSpots.black.x, snookerSpots.black.y)
            );
          } else {
            // Rregullimi standart per 8-ball UK (red & blue)
            var pattern = [
              [9, 1, 10, 2, 11],
              [3, 12, 4, 13],
              [14, 8, 5],
              [15, 6],
              [7]
            ];
            for (var r2 = 0; r2 < pattern.length; r2++) {
              var cnt = pattern[r2].length;
              var startX2 = cx - (rowGap * (cnt - 1)) / 2;
              var y2 = cy + r2 * colGap;
              for (var j2 = 0; j2 < cnt; j2++) {
                var x2 = startX2 + j2 * rowGap;
                var num2 = pattern[r2][j2];
                var info2 = BALL_BY_N[num2];
                if (!info2) {
                  console.warn('Rack: numer i papercaktuar', num2);
                  continue;
                }
                this.balls.push(new Ball(info2, x2, y2));
              }
            }
          }

          // Pockets (4 qoshe + 2 te mesit anesore)
          // Shift all pockets pak jashte per t'i bere hapjet e drejta me te shkurtra,
          // dhe gropat anesore shtyhen edhe pak me shume majtas/djathtas.
          var holeEls = document.querySelectorAll('.hole');
          if (holeEls.length === 6) {
            var wrapRect = document
              .getElementById('wrap')
              .getBoundingClientRect();
            var pockets = Array.prototype.map.call(holeEls, function (el) {
              var r = el.getBoundingClientRect();
              var cx =
                ((r.left + r.width / 2 - wrapRect.left) / wrapRect.width) *
                TABLE_W;
              var cy =
                ((r.top + r.height / 2 - wrapRect.top) / wrapRect.height) *
                TABLE_H;
              var pr = (r.width / 2 / wrapRect.width) * TABLE_W + 2;
              return new Pocket(cx, cy, pr);
            });
            // Adjust specific pocket positions slightly (symmetrically)
            pockets[2].y -= 2;
            pockets[3].y -= 2;
            pockets[4].y += 2;
            pockets[5].y += 2;
            insetPockets(pockets, POCKET_INSET);
            this.pockets = pockets;
          } else {
            var pockets = [
              new Pocket(
                BORDER - POCKET_SHORTEN + 2,
                BORDER_TOP - POCKET_SHORTEN,
                POCKET_R
              ),
              new Pocket(
                TABLE_W - BORDER + POCKET_SHORTEN - 2,
                BORDER_TOP - POCKET_SHORTEN,
                POCKET_R
              ),
              // Lift middle pockets a touch more to align with the shifted field
              // boundary, matching the green marking thickness, and nudge them
              // slightly farther from center.
              new Pocket(
                BORDER - 16 - POCKET_SHORTEN,
                TABLE_H / 2 + BALL_R - 16,
                SIDE_POCKET_R
              ),
              new Pocket(
                TABLE_W - BORDER + 16 + POCKET_SHORTEN,
                TABLE_H / 2 + BALL_R - 16,
                SIDE_POCKET_R
              ),
              new Pocket(
                BORDER - POCKET_SHORTEN,
                TABLE_H - BORDER_BOTTOM + POCKET_SHORTEN + 2,
                POCKET_R
              ),
              new Pocket(
                TABLE_W - BORDER + POCKET_SHORTEN,
                TABLE_H - BORDER_BOTTOM + POCKET_SHORTEN + 2,
                POCKET_R
              )
            ];
            insetPockets(pockets, POCKET_INSET);
            this.pockets = pockets;
          }
          this.captured = { 1: [], 2: [] };
          this.turn = 1;
          freeShots = { 1: 0, 2: 0 };
          firstHit = null;

          // TESTE TE INTEGRITETIT (console.assert)
          runSelfTests(this);
        };

        Table.prototype.isMoving = function () {
          for (var i = 0; i < this.balls.length; i++) {
            var b = this.balls[i];
            if (b.pocketed) continue;
            if (Math.abs(b.v.x) > MIN_V || Math.abs(b.v.y) > MIN_V) return true;
          }
          return false;
        };

        Table.prototype.update = function (dt) {
          var i, j;
          // Track collisions in this frame so that audio for each
          // pair of balls is played only once per contact.
          var newCollisions = new Set();
          // Apply spin impulses immediately on collisions for more natural response
          // Levizje + ferkim + kufij
          for (i = 0; i < this.balls.length; i++) {
            var b = this.balls[i];
            if (b.pocketed) continue;
              b.p.x += b.v.x * dt;
              b.p.y += b.v.y * dt;
              b.v.x *= FRICTION;
              b.v.y *= FRICTION;
              // spin is applied directly during collisions
              b.a += (Math.hypot(b.v.x, b.v.y) * dt) / (BALL_R * 0.6);

                // Let balls travel up to the table border instead of
                // bouncing before the side lines by removing the
                // GREEN_LINE offset from the rail limits.
                var L = BORDER + BALL_R;
                var R = TABLE_W - BORDER - BALL_R;
                var T = BORDER_TOP + BALL_R;
                var B = TABLE_H - BORDER_BOTTOM - BALL_R;

              // Determine whether the ball is in the vicinity of any pocket.
              var nearLeft = false,
                nearRight = false,
                nearTop = false,
                nearBottom = false;
              for (var pkIdx = 0; pkIdx < this.pockets.length; pkIdx++) {
                var pp = this.pockets[pkIdx];
                var thresh = pp.r + BALL_R;
                if (Math.abs(b.p.y - pp.y) < thresh) {
                  if (pp.x < L) nearLeft = true;
                  if (pp.x > R) nearRight = true;
                }
                if (Math.abs(b.p.x - pp.x) < thresh) {
                  if (pp.y < T) nearTop = true;
                  if (pp.y > B) nearBottom = true;
                }
              }

              if (b.n === 0) {
                if (b.p.x - L < BALL_R * 1.5 && b.v.x < 0) applySpinImpulse(b);
                if (R - b.p.x < BALL_R * 1.5 && b.v.x > 0) applySpinImpulse(b);
                if (b.p.y - T < BALL_R * 1.5 && b.v.y < 0) applySpinImpulse(b);
                if (B - b.p.y < BALL_R * 1.5 && b.v.y > 0) applySpinImpulse(b);
              }
              if (b.p.x < L && !nearLeft) {
                b.p.x = L;
                reflectVelocity(b.v, 1, 0, BOUNCE);
                if (b.n === 0) {
                  b.impacted = true;
                  applySpinImpulse(b);
                }
                if (i === 0 && shotInProgress && !firstHit)
                  cueHitCushion = true;
              }
              if (b.p.x > R && !nearRight) {
                b.p.x = R;
                reflectVelocity(b.v, -1, 0, BOUNCE);
                if (b.n === 0) {
                  b.impacted = true;
                  applySpinImpulse(b);
                }
                if (i === 0 && shotInProgress && !firstHit)
                  cueHitCushion = true;
              }
              if (b.p.y < T && !nearTop) {
                b.p.y = T;
                reflectVelocity(b.v, 0, 1, BOUNCE);
                if (b.n === 0) {
                  b.impacted = true;
                  applySpinImpulse(b);
                }
                if (i === 0 && shotInProgress && !firstHit)
                  cueHitCushion = true;
              }
              if (b.p.y > B && !nearBottom) {
                b.p.y = B;
                reflectVelocity(b.v, 0, -1, BOUNCE);
                if (b.n === 0) {
                  b.impacted = true;
                  applySpinImpulse(b);
                }
                if (i === 0 && shotInProgress && !firstHit)
                  cueHitCushion = true;
              }
          }

          var pk = this.pockets;
          var inv = INV_SQRT2;
          handleConnectorCollision(this, b, pk[0], inv, inv, function (rx, ry) {
            return rx >= 0 && ry >= 0;
          });
          handleConnectorCollision(this, b, pk[1], -inv, inv, function (rx, ry) {
            return rx <= 0 && ry >= 0;
          });
          handleConnectorCollision(this, b, pk[4], inv, -inv, function (rx, ry) {
            return rx >= 0 && ry <= 0;
          });
          handleConnectorCollision(this, b, pk[5], -inv, -inv, function (rx, ry) {
            return rx <= 0 && ry <= 0;
          });
          handleConnectorCollision(this, b, pk[2], inv, inv, function (rx, ry) {
            return rx >= 0 && ry <= 0;
          });
          handleConnectorCollision(this, b, pk[2], inv, -inv, function (rx, ry) {
            return rx >= 0 && ry >= 0;
          });
          handleConnectorCollision(this, b, pk[3], -inv, inv, function (rx, ry) {
            return rx <= 0 && ry <= 0;
          });
          handleConnectorCollision(this, b, pk[3], -inv, -inv, function (rx, ry) {
            return rx <= 0 && ry >= 0;
          });

          // Perplasje ball-ball
          var N = this.balls.length;
          for (i = 0; i < N; i++)
            for (j = i + 1; j < N; j++) {
              var a = this.balls[i],
                bb = this.balls[j];
              if (!a || !bb || a.pocketed || bb.pocketed) continue;
              var dx = bb.p.x - a.p.x,
                dy = bb.p.y - a.p.y,
                d = Math.hypot(dx, dy);
              if (a.n === 0 || bb.n === 0) {
                var cueBall = a.n === 0 ? a : bb;
                if (cueBall.impacted && d < BALL_R * 2.5) {
                  applySpinImpulse(cueBall);
                }
              }
              if (d < BALL_R * 2) {
                var pairId = i + '-' + j;
                var firstPairCollision = !newCollisions.has(pairId);
                newCollisions.add(pairId);
                var nx = dx / (d || 1),
                  ny = dy / (d || 1),
                  over = (BALL_R * 2 - d) / 2;
                a.p.x -= nx * over;
                a.p.y -= ny * over;
                bb.p.x += nx * over;
                bb.p.y += ny * over;
                var rvx = bb.v.x - a.v.x,
                  rvy = bb.v.y - a.v.y,
                  vn = rvx * nx + rvy * ny;
                if (vn < 0) {
                  var imp = -vn;
                  a.v.x -= imp * nx;
                  a.v.y -= imp * ny;
                  bb.v.x += imp * nx;
                  bb.v.y += imp * ny;
                  a.v.x *= BOUNCE;
                  a.v.y *= BOUNCE;
                  bb.v.x *= BOUNCE;
                  bb.v.y *= BOUNCE;
                  if (firstPairCollision && !this.prevCollisions.has(pairId)) {
                    // Scale collision volume by both impact impulse and the
                    // power of the shot that initiated the turn.
                    var vol =
                      clamp(imp / 4000, 0, 1) *
                      Math.min(lastShotPower, 0.39) *
                      0.5;
                    playBallHit(vol);
                  }
                  if (a.n === 0 || bb.n === 0) {
                    var other = a.n === 0 ? bb : a;
                    if (!firstHit) {
                      firstHit = BALL_BY_N[other.n];
                      var shooterType = assignedTypes[currentShooter];
                      var ownLeft = shooterType && hasBallsLeft(shooterType);
                      var targetType = BALL_BY_N[other.n].t;
                      var illegal = false;
                      if (isNineBall || isAmerican) {
                        illegal = other.n !== currentTarget;
                      } else if (shooterType) {
                        illegal =
                          targetType !== shooterType &&
                          !(targetType === 'eight' && !ownLeft);
                      }
                      if (illegal && !foulShown) {
                        showCenterPopup('Foul', 'foul', 1500);
                        foulShown = true;
                        var opponent = currentShooter === 1 ? 2 : 1;
                        updateFooter(
                          opponent,
                          isNineBall
                            ? 'Foul!'
                            : 'Foul ‚Äì opponent gets two shots.'
                        );
                      }
                    }
                    if (a.n === 0) {
                      a.impacted = true;
                      applySpinImpulse(a);
                    }
                    if (bb.n === 0) {
                      bb.impacted = true;
                      applySpinImpulse(bb);
                    }
                  }
                }
              }
            }


          // Kontroll i gropave
          for (i = 0; i < this.pockets.length; i++) {
            var p = this.pockets[i];
            for (j = 0; j < this.balls.length; j++) {
              var b2 = this.balls[j];
              if (b2.pocketed) continue;
              var ddx = b2.p.x - p.x,
                ddy = b2.p.y - p.y;
              if (Math.hypot(ddx, ddy) < p.r - BALL_R * 0.1) {
                var spd = Math.hypot(b2.v.x, b2.v.y);
                playPocket(clamp(spd / 4000, 0, 1));
                if (!shotPocketRecorded) {
                  lastPocketCenter = { x: p.x, y: p.y };
                  shotPocketRecorded = true;
                }
                if (b2.n === 0) {
                  scratch = true;
                  foulShown = true;
                  showCenterPopup('Foul', 'foul', 1500);
                  var opponent = currentShooter === 1 ? 2 : 1;
                  updateFooter(
                    opponent,
                    isAmerican || isNineBall
                      ? 'Foul!'
                      : 'Foul ‚Äì opponent gets two shots.'
                  );
                  cueBallFree = true;
                  aiming = false;
                  cueHintTime = Date.now();
                  b2.p.x = TABLE_W / 2;
                  b2.p.y = CUE_START_Y;
                  b2.v.x = 0;
                  b2.v.y = 0;
                } else if (b2.n === 8 && !isAmerican && !isNineBall) {
                  b2.pocketed = true;
                  pocketedAny = true;
                  eightBallPotted = true;
                  if (!foulShown) playCheer(1);
                } else {
                  b2.pocketed = true;
                  pocketedAny = true;
                  if (isNineBall) {
                    this.captured[currentShooter].push(b2.n);
                    if (b2.n === 9) {
                      nineBallPotted = true;
                    }
                    lastPocketedBall = b2.n;
                    pottedThisShot.push(b2.n);
                    pocketedOwn = true;
                  } else if (isAmerican) {
                    this.captured[currentShooter].push(b2.n);
                    pottedThisShot.push(b2.n);
                    pocketedOwn = true;
                    lastPocketedBall = b2.n;
                  } else if (isSnooker) {
                    var infoSn = BALL_BY_N[b2.n];
                    pottedThisShot.push(infoSn.p);
                    pocketedOwn = true;
                    lastPocketedBall = b2.n;
                    if (infoSn.t === 'red') {
                      this.captured[currentShooter].push(b2.n);
                    } else {
                      snookerPottedColors.push(b2);
                    }
                  } else {
                    this.captured[currentShooter].push(b2.n);
                    var tType = BALL_BY_N[b2.n].t;
                    if (!assignedTypes[1] && tType !== 'eight') {
                      assignedTypes[currentShooter] = tType;
                      assignedTypes[currentShooter === 1 ? 2 : 1] =
                        tType === 'red' ? 'blue' : 'red';
                      assignedThisShot = true;
                      pocketedOwn = true;
                      updateFooter(
                        currentShooter,
                        'He sinks a ' + tType + ' and is now ' + tType + '.'
                      );
                    } else {
                      if (assignedTypes[currentShooter] === tType)
                        pocketedOwn = true;
                      updateFooter(currentShooter, 'He sinks a ' + tType + '.');
                    }
                    lastPocketedBall = b2.n;
                  }
                  if (!foulShown) playCheer(1);
                }
              }
            }
          }
          // Update collision state for next frame.
          this.prevCollisions = newCollisions;
        };

        Table.prototype.render = function () {
          ctx.clearRect(0, 0, canvas.width, canvas.height);
          // Field dimensions
          var x0 = BORDER * sX,
            y0 = BORDER_TOP * sY,
            w = (TABLE_W - 2 * BORDER) * sX,
            h = (TABLE_H - BORDER_TOP - BORDER_BOTTOM) * sY;

          if (!isSnooker) {
            ctx.save();
              ctx.fillStyle = 'rgba(255,255,0,0.05)';
              ctx.fillRect(x0, y0, w, h);
              ctx.strokeStyle = 'rgba(0,255,0,0)';
              ctx.lineWidth = 3;
              if (this.pockets) {
                var p = this.pockets;
                // Extend the green boundary lines directly to the pockets
                var cornerGap = 0;
                var sideGap = 0;
                ctx.beginPath();
                // top boundary
                var topY = y0;
                var topStart = (p[0].x + p[0].r) * sX + cornerGap;
                var topEnd = (p[1].x - p[1].r) * sX - cornerGap;
                ctx.moveTo(topStart, topY);
                ctx.lineTo(topEnd, topY);
                // bottom boundary
                var bottomY = (TABLE_H - BORDER_BOTTOM) * sY;
                var bottomStart = (p[4].x + p[4].r) * sX + cornerGap;
                var bottomEnd = (p[5].x - p[5].r) * sX - cornerGap;
                ctx.moveTo(bottomStart, bottomY);
                ctx.lineTo(bottomEnd, bottomY);
                // left boundary with side pocket
                var xLeft = x0;
                var leftTop = (p[0].y + p[0].r) * sY + cornerGap;
                var leftMidTop = (p[2].y - p[2].r) * sY - sideGap;
                var leftMidBottom = (p[2].y + p[2].r) * sY + sideGap;
                var leftBottom = (p[4].y - p[4].r) * sY - cornerGap;
                ctx.moveTo(xLeft, leftTop);
                ctx.lineTo(xLeft, leftMidTop);
                ctx.moveTo(xLeft, leftMidBottom);
                ctx.lineTo(xLeft, leftBottom);
                // right boundary with side pocket
                var xRight = (TABLE_W - BORDER) * sX;
                var rightTop = (p[1].y + p[1].r) * sY + cornerGap;
                var rightMidTop = (p[3].y - p[3].r) * sY - sideGap;
                var rightMidBottom = (p[3].y + p[3].r) * sY + sideGap;
                var rightBottom = (p[5].y - p[5].r) * sY - cornerGap;
                ctx.moveTo(xRight, rightTop);
                ctx.lineTo(xRight, rightMidTop);
                ctx.moveTo(xRight, rightMidBottom);
                ctx.lineTo(xRight, rightBottom);
                ctx.stroke();
                ctx.strokeStyle = 'rgba(255,0,0,0)';
                ctx.lineWidth = 2;
                var rScale = (sX + sY) / 2;
                this.pockets.forEach(function(pk) {
                  ctx.beginPath();
                  ctx.arc(pk.x * sX, pk.y * sY, pk.r * rScale, 0, Math.PI * 2);
                  ctx.stroke();
                });
              } else {
                ctx.strokeRect(x0, y0, w, h);
              }
              ctx.restore();
          }

          // Vija kufizuese e cueball-it dhe pika qendrore
          ctx.strokeStyle = '#fff';
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.moveTo(x0, LINE_Y * sY);
          ctx.lineTo(x0 + w, LINE_Y * sY);
          ctx.stroke();
          ctx.fillStyle = '#fff';
          ctx.beginPath();
          ctx.arc(
            (TABLE_W / 2) * sX,
            SPOT_Y * sY,
            5 * ((sX + sY) / 2),
            0,
            Math.PI * 2
          );
          ctx.fill();
          if (isSnooker && playType === 'training') {
            ctx.fillStyle = '#fff';
            ['yellow', 'green', 'brown', 'blue', 'pink', 'black'].forEach(function (k) {
              var sp = snookerSpots[k];
              if (!sp) return;
              ctx.beginPath();
              ctx.arc(sp.x * sX, sp.y * sY, 3 * ((sX + sY) / 2), 0, Math.PI * 2);
              ctx.fill();
            });
            ctx.strokeStyle = '#fff';
            ctx.beginPath();
            var dR = BALL_R * 11 * ((sX + sY) / 2);
            ctx.arc((TABLE_W / 2) * sX, LINE_Y * sY, dR, Math.PI, 0);
            ctx.stroke();
          }
          // Cushion and pocket guidelines removed
          // Topat
          for (var j = 0; j < this.balls.length; j++) {
            var b = this.balls[j];
            if (!b || b.pocketed) continue;
            var px = b.p.x * sX,
              py = b.p.y * sY;

            // hije eliptike 2.5D sipas stilit te trajnimit snooker
            ctx.save();
            ctx.globalAlpha = 0.28;
            ctx.fillStyle = '#000';
            ctx.beginPath();
            ctx.ellipse(
              px,
              py + ballR * 0.6,
              ballR * 1.2,
              ballR * 0.5,
              0,
              0,
              Math.PI * 2
            );
            ctx.fill();
            ctx.restore();

            // trup i topit me gradient 2.5D
            ctx.save();
            ctx.translate(px, py);
            // Snooker-style shading: subtle light on top-left and darker rim
            var grad = ctx.createRadialGradient(
              -ballR * 0.3,
              -ballR * 0.3,
              ballR * 0.1,
              0,
              0,
              ballR * 1.05
            );
            grad.addColorStop(0, shadeColor(BALL_BY_N[b.n].c, 50));
            grad.addColorStop(0.5, shadeColor(BALL_BY_N[b.n].c, 15));
            grad.addColorStop(1, shadeColor(BALL_BY_N[b.n].c, -35));

            // stripe nese duhet
            var stripe =
              BALL_BY_N[b.n].t === 'stripe' && (isAmerican || isNineBall);
            var stripeGrad;
            if (stripe) {
              stripeGrad = ctx.createRadialGradient(
                -ballR * 0.3,
                -ballR * 0.3,
                ballR * 0.1,
                0,
                0,
                ballR * 1.05
              );
              stripeGrad.addColorStop(0, shadeColor('#fff', 35));
              stripeGrad.addColorStop(0.5, '#fff');
              stripeGrad.addColorStop(1, shadeColor('#fff', -45));
            }

            // draw base shading without rotation so shadow stays fixed
            ctx.fillStyle = grad;
            ctx.beginPath();
            ctx.arc(0, 0, ballR, 0, Math.PI * 2);
            ctx.fill();
            ctx.strokeStyle = shadeColor(BALL_BY_N[b.n].c, -60);
            ctx.lineWidth = ballR * 0.05;
            ctx.stroke();

            // specular highlights (3)
            ctx.fillStyle = 'rgba(255,255,255,0.65)';
            [
              { x: -0.35, y: -0.35 },
              { x: -0.1, y: -0.4 },
              { x: -0.5, y: -0.1 }
            ].forEach(function (hl) {
              ctx.beginPath();
              ctx.ellipse(
                ballR * hl.x,
                ballR * hl.y,
                ballR * 0.3,
                ballR * 0.18,
                -0.5,
                0,
                Math.PI * 2
              );
              ctx.fill();
            });

            // features following ball rotation
            ctx.save();
            ctx.rotate(b.a);
            if (stripe) {
              ctx.save();
              ctx.beginPath();
              ctx.arc(0, 0, ballR, 0, Math.PI * 2);
              ctx.clip();
              ctx.fillStyle = stripeGrad;
              ctx.fillRect(-ballR, -ballR * 0.3, ballR * 2, ballR * 0.6);
              // thin white lines at stripe edges
              ctx.strokeStyle = '#fff';
              ctx.lineWidth = ballR * 0.06;
              ctx.beginPath();
              ctx.moveTo(-ballR, -ballR * 0.3);
              ctx.lineTo(ballR, -ballR * 0.3);
              ctx.moveTo(-ballR, ballR * 0.3);
              ctx.lineTo(ballR, ballR * 0.3);
              ctx.stroke();
              ctx.restore();
            }

            // numri (vetem per varianten amerikane ose per topin e zi)
            if (
              b.n !== 0 &&
              (isAmerican || isNineBall || BALL_BY_N[b.n].t === 'eight')
            ) {
              ctx.fillStyle = stripe
                ? brighten(BALL_BY_N[b.n].c, 0.05)
                : '#fff';
              ctx.beginPath();
              ctx.arc(0, 0, ballR * 0.52, 0, Math.PI * 2);
              ctx.fill();
              ctx.lineWidth = ballR * 0.05;
              ctx.strokeStyle = stripe ? '#fff' : '#000';
              ctx.stroke();
              ctx.fillStyle = stripe ? '#fff' : '#111';
              ctx.font = ballR * 0.9 + 'px system-ui,sans-serif';
              ctx.textAlign = 'center';
              ctx.textBaseline = 'middle';
              ctx.fillText(String(b.n), 0, 0);
            }

            // cue ball seam hint
            if (b.n === 0) {
              ctx.strokeStyle = 'rgba(0,0,0,0.08)';
              ctx.lineWidth = Math.max(1, ballR * 0.1);
              ctx.beginPath();
              ctx.arc(0, 0, ballR * 0.88, 0.2, Math.PI - 0.2);
              ctx.stroke();
            }

            // pika e spin-it te cue
            if (b.n === 0) {
              ctx.fillStyle = '#e63';
              ctx.beginPath();
              ctx.arc(
                spinVec.x * ballR * 0.75,
                spinVec.y * ballR * 0.75,
                ballR * 0.15,
                0,
                Math.PI * 2
              );
              ctx.fill();
            }
            ctx.restore();
            ctx.restore();
          }

          // Yellow boundary lines stop before each pocket; no additional field guides.

          // Steka mbi felt + guida
          if (
            (cueStrike.active || !this.isMoving()) &&
            this.balls[0] &&
            !this.balls[0].pocketed &&
            cueVisible
          ) {
            const aim = this.aim;
            drawCueOnTable(this.balls[0].p, aim, cuePullVisual);
            if (!this.isMoving() && showGuides) drawGuides(this.balls[0], aim);
          }
        };

        /* ==========================================================
       TESTE ‚Äì kapin gabime si "undefined .n" heret
       ========================================================= */
        function runSelfTests(tbl) {
          // BALLS duhet te kete TOTAL_BALLS elemente
          console.assert(
            Array.isArray(BALLS) && BALLS.length === TOTAL_BALLS,
            'TEST FAIL: BALLS duhet ' + TOTAL_BALLS
          );
          for (var i = 0; i < BALLS.length; i++) {
            var it = BALLS[i];
            console.assert(
              typeof it.n === 'number' &&
                typeof it.t === 'string' &&
                typeof it.c === 'string',
              'TEST FAIL: item pa fusha',
              it
            );
          }
          // tavolina 16 topa (perfshi cue)
          console.assert(
            tbl.balls.length === TOTAL_BALLS,
            'TEST FAIL: tavolina ka',
            tbl.balls.length,
            'topa (duhet ' + TOTAL_BALLS + ')'
          );
          // asnje top undefined
          for (var j = 0; j < tbl.balls.length; j++) {
            var b = tbl.balls[j];
            console.assert(
              b && typeof b.n === 'number',
              'TEST FAIL: ball undefined ose pa n te index',
              j,
              b
            );
          }
          // 6 gropa
          console.assert(
            tbl.pockets.length === 6,
            'TEST FAIL: pockets',
            tbl.pockets.length
          );
          // vlera fillestare te aim/cue te vlefshme
          console.assert(
            typeof tbl.aim.x === 'number' && typeof tbl.aim.y === 'number',
            'TEST FAIL: aim i pavlefshem'
          );
        }

        /* ==========================================================
       GJENDJE GLOBALE E LOJES
       ========================================================= */
        var table = new Table();
        var last = 0; // koha e frame te fundit
        var aiming = false; // a po caktohet drejtimi
        var aimMoved = false; // a eshte levizur drejtimi gjate drag
        var showGuides = false; // a shfaqen pikat
        var cuePullVisual = 0; // shfaqje e terheqjes ne felt
        var cueVisible = true; // a shfaqet steka gjate animimit
        var cueStrike = { active: false, speed: 0, stage: 'forward' }; // animimi i goditjes se stekes
        var spinVec = { x: 0, y: 0 }; // spini i zgjedhur
        var lastGuideDir = { x: 0, y: -1 }; // drejtimi i fundit i guides
        var power = 0; // fuqi [0..1]
        // Track the power of the most recent shot so collision volume can
        // be scaled based on how hard the cue was struck.
        var lastShotPower = 0;
        var isBreakShot = true;
        var cueBallFree = true; // a mund te vendoset cueball
        var cueHintTime = Date.now();
        var draggingCue = false;
        var shotInProgress = false;
        var currentShooter = 1;
        var pocketedAny = false;
        var pocketedOwn = false;
        var scratch = false;
        var foulShown = false;
        var assignedTypes = { 1: null, 2: null };
        var assignedThisShot = false;
        var freeShots = { 1: 0, 2: 0 };
        var firstHit = null;
        var lastTurn = table.turn;
        var cpuThinking = false;
        // Allow the CPU up to 4 seconds to take its shot
        var CPU_SHOT_DELAY = 3500;
        // Track timers for the human player's turn
        var turnTimer = null;
        var warnTimer = null;
        var countdownInterval = null;
        var countdownRemaining = 0;
        var scores = { 1: 0, 2: 0 };
        var lastPocketedBall = null;
        var snookerExpectColor = false;
        var currentTarget = null;
        var pottedThisShot = [];
        var eightBallPotted = false;
        var nineBallPotted = false;
        var lastShotAim = null;
        var lastPocketCenter = null;
        var shotPocketRecorded = false;
        var lastCueStart = null;
        var cueHitCushion = false;

        function remainingPoints() {
          var sum = 0;
          for (var i = 1; i < table.balls.length; i++) {
            var bb = table.balls[i];
            if (bb && !bb.pocketed) sum += bb.n;
          }
          return sum;
        }

        function checkGameOver() {
          if (!isAmerican) return;
          var rem = remainingPoints();
          if (scores[1] >= 100 || scores[1] > scores[2] + rem) {
            endGame(1);
          } else if (scores[2] >= 100 || scores[2] > scores[1] + rem) {
            endGame(2);
          } else if (rem === 0) {
            if (scores[1] === scores[2]) {
              table.captured[1] = table.captured[1].filter(function (n) {
                return n !== 8;
              });
              table.captured[2] = table.captured[2].filter(function (n) {
                return n !== 8;
              });
              table.balls.push(new Ball(BALL_BY_N[8], TABLE_W / 2, SPOT_Y));
              cueBallFree = true;
              cueHintTime = Date.now();
              var cue = table.balls[0];
              cue.p.x = TABLE_W / 2;
              cue.p.y = CUE_START_Y;
              cue.v.x = 0;
              cue.v.y = 0;
              updateCapturedUI();
              updateFooter(table.turn, 'Shoot the 8-ball to win!');
            } else {
              endGame(scores[1] > scores[2] ? 1 : 2);
            }
          }
        }

        function lowestBallOnTable() {
          var lowest = null;
          for (var i = 1; i < table.balls.length; i++) {
            var bb = table.balls[i];
            if (!bb || bb.pocketed || bb.n === 0) continue;
            if (lowest === null || bb.n < lowest) lowest = bb.n;
          }
          return lowest;
        }

        function createMiniBall(n) {
          var info = BALL_BY_N[n];
          var canv = document.createElement('canvas');
          canv.className = 'ball';
          canv.width = 20;
          canv.height = 20;
          var ctx = canv.getContext('2d');
          var r = 8,
            cx = 10,
            cy = 10;
          ctx.fillStyle = info.c;
          ctx.beginPath();
          ctx.arc(cx, cy, r, 0, Math.PI * 2);
          ctx.fill();
          var hl = ctx.createRadialGradient(
            cx - r * 0.4,
            cy - r * 0.4,
            2,
            cx - r * 0.4,
            cy - r * 0.4,
            r * 1.2
          );
          hl.addColorStop(0, 'rgba(255,255,255,.55)');
          hl.addColorStop(1, 'rgba(255,255,255,0)');
          ctx.fillStyle = hl;
          ctx.beginPath();
          ctx.arc(cx, cy, r, 0, Math.PI * 2);
          ctx.fill();
          var stripe = info.t === 'stripe' && (isAmerican || isNineBall);
          if (stripe) {
            ctx.save();
            ctx.beginPath();
            ctx.arc(cx, cy, r, 0, Math.PI * 2);
            ctx.clip();
            ctx.fillStyle = '#fff';
            ctx.fillRect(cx - r, cy - r * 0.3, r * 2, r * 0.6);
            ctx.strokeStyle = '#000';
            ctx.lineWidth = r * 0.15;
            ctx.beginPath();
            ctx.moveTo(cx - r, cy - r * 0.3);
            ctx.lineTo(cx + r, cy - r * 0.3);
            ctx.moveTo(cx - r, cy + r * 0.3);
            ctx.lineTo(cx + r, cy + r * 0.3);
            ctx.stroke();
            ctx.restore();
          }
          if (n !== 0 && (isAmerican || isNineBall || info.t === 'eight')) {
            ctx.fillStyle = stripe ? info.c : '#fff';
            ctx.beginPath();
            ctx.arc(cx, cy, r * 0.52, 0, Math.PI * 2);
            ctx.fill();
            ctx.lineWidth = r * 0.1;
            ctx.strokeStyle = stripe ? '#fff' : '#000';
            ctx.stroke();
            ctx.fillStyle = stripe ? '#fff' : '#111';
            ctx.font = '8px system-ui,sans-serif';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(String(n), cx, cy);
          }
          return canv;
        }

        function updateCapturedUI() {
          function render(el, arr) {
            el.innerHTML = '';
            arr.forEach(function (n) {
              el.appendChild(createMiniBall(n));
            });
          }
          render(pottedP1, table.captured[1]);
          render(pottedP2, table.captured[2]);
        }

        function updateScoresUI() {
          scoreP1.textContent = scores[1];
          scoreP2.textContent = scores[2];
          checkGameOver();
        }
        if (isAmerican || isSnooker) updateScoresUI();

        function updateFooter(player, msg) {
          var srcAvatar = player === 1 ? avatarP1 : avatarCPU;
          footerAvatar.style.cssText = srcAvatar.style.cssText;
          footerAvatar.textContent = srcAvatar.textContent;
          footerName.textContent =
            player === 1 ? nameP1.textContent : nameCPU.textContent;
          statusMsg.innerHTML = msg || '';
          clearTimeout(footerTimeout);
          if (msg) {
            footerTimeout = setTimeout(function () {
              statusMsg.innerHTML = '';
            }, 1500);
          }
        }

        function hasBallsLeft(type) {
          for (var k = 1; k < table.balls.length; k++) {
            var rb = table.balls[k];
            if (rb && !rb.pocketed && BALL_BY_N[rb.n].t === type) return true;
          }
          return false;
        }

        function clearTurnTimer() {
          if (turnTimer) clearTimeout(turnTimer);
          if (warnTimer) clearTimeout(warnTimer);
          if (countdownInterval) clearInterval(countdownInterval);
          turnTimer = null;
          warnTimer = null;
          countdownInterval = null;
          countdownRemaining = 0;
          if (timerDisplay) timerDisplay.textContent = '';
        }

        function startTurnTimer() {
          clearTurnTimer();
          if (table.turn !== 1) return;
          countdownRemaining = 30;
          if (timerDisplay) {
            timerDisplay.style.color = '#facc15';
            timerDisplay.textContent = countdownRemaining;
          }
          countdownInterval = setInterval(function () {
            countdownRemaining--;
            if (timerDisplay) timerDisplay.textContent = countdownRemaining;
            if (countdownRemaining <= 0) {
              clearInterval(countdownInterval);
              countdownInterval = null;
            }
          }, 1000);
          warnTimer = setTimeout(function () {
            playTurnSound();
          }, 25000);
          turnTimer = setTimeout(function () {
            updateFooter(2, "Time's up! Turn passes to the opponent.");
            table.turn = 2;
            updateTurnIndicator(true);
            showTurnInfo();
            cpuTurn();
          }, 30000);
        }

        function startCpuTimer() {
          clearTurnTimer();
          countdownRemaining = Math.ceil(CPU_SHOT_DELAY / 1000);
          if (timerDisplay) {
            timerDisplay.style.color = '#fff';
            timerDisplay.textContent = countdownRemaining;
          }
          countdownInterval = setInterval(function () {
            countdownRemaining--;
            if (timerDisplay) timerDisplay.textContent = countdownRemaining;
            if (countdownRemaining <= 0) {
              clearInterval(countdownInterval);
              countdownInterval = null;
            }
          }, 1000);
        }

        function showTurnInfo() {
          var msg;
          if (isNineBall || isAmerican) {
            if (!currentTarget) currentTarget = lowestBallOnTable();
            msg = 'Pot the ' + currentTarget + '-ball';
          } else {
            if (!assignedTypes[table.turn]) {
              msg = 'Choose a color';
            } else if (!hasBallsLeft(assignedTypes[table.turn])) {
              msg = 'Shoot the 8-ball to win!';
            } else {
              msg = 'Pot a ' + assignedTypes[table.turn];
            }
          }
          updateFooter(table.turn, msg);
        }

        function updateTurnIndicator(force) {
          if (window.trainingMode && window.trainingSolo) table.turn = 1;
          if (force || table.turn !== lastTurn) {
            avatarP1.classList.toggle('turn', table.turn === 1);
            avatarCPU.classList.toggle('turn', table.turn === 2);
            nameP1.classList.toggle('turn', table.turn === 1);
            nameCPU.classList.toggle('turn', table.turn === 2);
            if (table.turn === 1) startTurnTimer();
            else clearTurnTimer();
            if (!force && freeShots[table.turn] > 1) {
              showCenterPopup('2 shots', 'shots', 1500);
            }
            lastTurn = table.turn;
          }
        }

        function updateCueHint() {
          var cue = table.balls[0];
          if (
            cueBallFree &&
            cue &&
            !cue.pocketed &&
            Date.now() - cueHintTime < 2000
          ) {
            cueHint.style.display = 'block';
            cueHint.style.left = cue.p.x * sX + ballR + 'px';
            cueHint.style.top = cue.p.y * sY - ballR * 2 + 'px';
          } else {
            cueHint.style.display = 'none';
          }
        }

        function showCenterPopup(text, cls, duration) {
          centerPopup.textContent = text;
          centerPopup.className = cls;
          centerPopup.style.display = 'block';
          if (cls === 'foul') {
            playShock(1);
            updateFooter(currentShooter === 1 ? 2 : 1, text);
          }
          setTimeout(function () {
            centerPopup.style.display = 'none';
          }, duration);
        }

        function isFoul(firstHit, scratch) {
          if (window.trainingMode && !window.trainingRules) return false;
          if (isNineBall || isAmerican) {
            return !firstHit || firstHit.n !== currentTarget || scratch;
          } else if (isSnooker) {
            if (!firstHit || scratch) return true;
            if (snookerExpectColor && firstHit.t === 'red') return true;
            if (!snookerExpectColor && firstHit.t !== 'red') {
              var redLeft = table.balls.some(function (bb, idx) {
                return idx > 0 && bb && !bb.pocketed && BALL_BY_N[bb.n].t === 'red';
              });
              if (redLeft) return true;
            }
            return false;
          }
          if (!firstHit || scratch) return true;
          var shooterType = assignedTypes[currentShooter];
          var ownLeft = shooterType && hasBallsLeft(shooterType);
          if (firstHit.t === 'eight' || eightBallPotted) {
            return ownLeft;
          }
          if (shooterType && firstHit.t !== shooterType && !assignedThisShot) return true;
          return false;
        }

        function endShot() {
          shotInProgress = false;
          // Reset shot power so stray collisions don't carry over volume.
          lastShotPower = 0;
          cueVisible = true;
          cuePullVisual = 0;
          if (window.trainingMode && window.trainingSolo) {
            table.turn = 1;
            updateTurnIndicator(true);
            lastShotAim = null;
            lastPocketCenter = null;
            lastCueStart = null;
            pottedThisShot = [];
            pocketedAny = false;
            pocketedOwn = false;
            scratch = false;
            foulShown = false;
            firstHit = null;
            cueHitCushion = false;
            currentTarget = null;
            eightBallPotted = false;
            nineBallPotted = false;
            lastPocketedBall = null;
            snookerExpectColor = false;
            return;
          }
          var opponent = currentShooter === 1 ? 2 : 1;
          var foul = isFoul(firstHit, scratch);
          var shotPoints = pottedThisShot.reduce(function (a, b) {
            return a + b;
          }, 0);
          if (foul) {
            if (isAmerican) {
              cueBallFree = true;
              if (shotPoints > 0) {
                scores[opponent] += shotPoints;
                updateScoresUI();
                updateFooter(
                  opponent,
                  'That\u2019s a foul ‚Äì opponent gets ' +
                    shotPoints +
                    ' points.'
                );
                pottedThisShot.forEach(function (n) {
                  var arr = table.captured[currentShooter];
                  var idx = arr.indexOf(n);
                  if (idx !== -1) arr.splice(idx, 1);
                  table.captured[opponent].push(n);
                });
                updateCapturedUI();
              } else {
                var foulMsg = scratch
                  ? 'the cue ball went in'
                  : 'wrong first contact';
                updateFooter(opponent, 'That\u2019s a foul ‚Äì ' + foulMsg + '.');
              }
            } else if (isNineBall) {
              cueBallFree = true;
              var foulMsg = scratch
                ? 'the cue ball went in'
                : 'wrong first contact';
              updateFooter(opponent, 'That\u2019s a foul ‚Äì ' + foulMsg + '.');
            } else if (isSnooker) {
              var penalty = Math.max(firstHit ? firstHit.p : 0, 4);
              scores[opponent] += penalty;
              updateScoresUI();
              updateFooter(
                opponent,
                'That\u2019s a foul ‚Äì opponent gets ' +
                  penalty +
                  ' points.'
              );
            } else {
              updateFooter(opponent, 'Foul ‚Äì opponent gets two shots.');
            }
            if (!foulShown) {
              showCenterPopup('Foul', 'foul', 1500);
              foulShown = true;
            }
            if (nineBallPotted) {
              endGame(opponent);
              return;
            }
            if (eightBallPotted) {
              endGame(opponent);
              return;
            }
            if (!isSnooker) {
              freeShots[opponent] = isAmerican || isNineBall ? 1 : 2;
            }
            freeShots[currentShooter] = 0;
            table.turn = opponent;
            setTimeout(showTurnInfo, 1500);
          } else {
            if (nineBallPotted) {
              endGame(currentShooter);
              return;
            }
            if (eightBallPotted) {
              endGame(currentShooter);
              return;
            }
            if (shotPoints > 0 && (isAmerican || isSnooker)) {
              scores[currentShooter] += shotPoints;
              updateScoresUI();
            }
            if (isSnooker && pocketedAny) {
              snookerExpectColor = firstHit && firstHit.t === 'red';
            }
            if (freeShots[currentShooter] > 0) {
              freeShots[currentShooter]--;
              if (freeShots[currentShooter] === 0 && !pocketedOwn) {
                table.turn = opponent;
              }
            } else if (!pocketedOwn) {
              table.turn = opponent;
            }
            if (lastPocketedBall !== null) {
              var msg;
              if (isAmerican) {
                var total = scores[currentShooter];
                var closing = 100 - total;
                msg =
                  'He sinks the ' +
                  lastPocketedBall +
                  '-ball, that\u2019s ' +
                  lastPocketedBall +
                  ' points on the scoreboard.';
                if (total >= 63 && closing > 0) {
                  msg +=
                    ' Solid run ‚Äî he\u2019s already at ' +
                    total +
                    ' points, just needs ' +
                    closing +
                    ' more to close the game.';
                }
              } else if (isNineBall) {
                msg = 'He sinks the ' + lastPocketedBall + '-ball.';
              } else {
                var col = BALL_BY_N[lastPocketedBall].t;
                msg = 'He sinks a ' + col + '.';
              }
              updateFooter(currentShooter, msg);
              lastPocketedBall = null;
              setTimeout(showTurnInfo, 1500);
            } else {
              updateFooter(
                table.turn,
                'Close call! The ball hit the cushion but nothing dropped, turn passes to the opponent.'
              );
              setTimeout(showTurnInfo, 1500);
            }
          }
          if (isSnooker && snookerPottedColors.length > 0) {
            var redsLeft = hasBallsLeft('red');
            snookerPottedColors.forEach(function (ball) {
              if (redsLeft) {
                var spot = snookerSpots[BALL_BY_N[ball.n].t];
                ball.pocketed = false;
                ball.p.x = spot.x;
                ball.p.y = spot.y;
                ball.v.x = 0;
                ball.v.y = 0;
              } else {
                table.captured[currentShooter].push(ball.n);
              }
            });
            snookerPottedColors = [];
            updateCapturedUI();
          }
          if (table.turn === currentShooter) startTurnTimer();
          lastShotAim = null;
          lastPocketCenter = null;
          lastCueStart = null;
          pottedThisShot = [];
          pocketedAny = false;
          pocketedOwn = false;
          scratch = false;
          foulShown = false;
          firstHit = null;
          lastCueStart = null;
          cueHitCushion = false;
          currentTarget = null;
          eightBallPotted = false;
          nineBallPotted = false;
          lastPocketedBall = null;
        }

        /* ==========================================================
       RENDER + UPDATE LOOP
       ========================================================= */
        function loop(t) {
          var dt = (t - last) / 1000 || 0;
          last = t;
          if (table.running) {
            animateCueStrike(dt);
            table.update(Math.min(dt, 0.033));
            table.render();
            updateCapturedUI();
            updateCueHint();
            updateTurnIndicator();
            if (shotInProgress && !table.isMoving()) endShot();
            if (
              !table.isMoving() &&
              table.turn === 2 &&
              !shotInProgress &&
              !cpuThinking
            )
              setTimeout(cpuTurn, 200);
          }
          requestAnimationFrame(loop);
        }
        requestAnimationFrame(loop);
        updateTurnIndicator(true);
        showTurnInfo();

        /* ==========================================================
       INPUT ‚Äì Aiming & Glow
       ========================================================= */
        function screenToTable(x, y) {
          var r = canvas.getBoundingClientRect();
          return {
            x: ((x - r.left) / r.width) * TABLE_W,
            y: ((y - r.top) / r.height) * TABLE_H
          };
        }

        canvas.addEventListener('pointerdown', function (e) {
          if (!table.running || table.isMoving() || table.turn !== 1) return;
          canvas.setPointerCapture(e.pointerId);
          var t = screenToTable(e.clientX, e.clientY);
          var cue = table.balls[0];
          var dist = Math.hypot(t.x - cue.p.x, t.y - cue.p.y);
          if (cueBallFree && dist <= BALL_R * 1.5) {
            draggingCue = true;
            cueHintTime = 0;
            cueHint.style.display = 'none';
            return;
          }
          // Allow aiming anywhere by clicking on the table or balls
          // (do not snap to ball center so players can target specific sides)
          aiming = true;
          aimMoved = false;
          showGuides = true;
          table.aim.x = t.x;
          table.aim.y = t.y;
          placeAimGlow(table.aim);
          updateAutoCue();
        });

        document.addEventListener('pointermove', function (e) {
          if (table.turn !== 1) return;
          var t = screenToTable(e.clientX, e.clientY);
          var cue = table.balls[0];
          if (draggingCue && cueBallFree) {
            var minX = BORDER + BALL_R,
              maxX = TABLE_W - BORDER - BALL_R;
            var minY = LINE_Y + BALL_R,
              maxY = TABLE_H - BORDER_BOTTOM - BALL_R;
            var nx = clamp(t.x, minX, maxX);
            var ny = clamp(t.y, minY, maxY);
            var valid = true;
            for (var i = 1; i < table.balls.length; i++) {
              var b = table.balls[i];
              if (b.pocketed) continue;
              if (Math.hypot(b.p.x - nx, b.p.y - ny) < BALL_R * 2) {
                valid = false;
                break;
              }
            }
            if (valid) {
              cue.p.x = nx;
              cue.p.y = ny;
            }
            return;
          }
          if (!aiming || !table.running) return;
          table.aim.x = t.x;
          table.aim.y = t.y;
          placeAimGlow(table.aim);
          aimMoved = true;
          updateAutoCue();
        });

        document.addEventListener('pointerup', function (e) {
          if (table.turn !== 1) return;
          canvas.releasePointerCapture &&
            canvas.releasePointerCapture(e.pointerId);
          if (draggingCue) {
            draggingCue = false;
            var cue = table.balls[0];
            table.aim = { x: cue.p.x, y: cue.p.y - BALL_R * 4 };
            showGuides = true;
            return;
          }
          aiming = false;
        });

        function placeAimGlow() {
          /* shadow removed */
        }

        /* ==========================================================
       GUIDES + CUE ON TABLE
       ========================================================= */
        function drawGuides(cue, aim) {
          var dx = aim.x - cue.p.x,
            dy = aim.y - cue.p.y;
          var L = len(dx, dy) || 1;
          var dir = { x: dx / L, y: dy / L };
          lastGuideDir = dir;
          var tHit = Infinity;
          var target = null;
          var railNormal = null;

          function checkRail(t, normal) {
            if (t >= 0 && t < tHit) {
              tHit = t;
              railNormal = normal;
              target = null;
            }
          }

          if (dir.x < 0)
            checkRail((BORDER + BALL_R - cue.p.x) / dir.x, {
              x: 1,
              y: 0
            });
          if (dir.x > 0)
            checkRail((TABLE_W - BORDER - BALL_R - cue.p.x) / dir.x, {
              x: -1,
              y: 0
            });
          if (dir.y < 0)
            checkRail((BORDER_TOP + BALL_R - cue.p.y) / dir.y, { x: 0, y: 1 });
          if (dir.y > 0)
            checkRail((TABLE_H - BORDER_BOTTOM - BALL_R - cue.p.y) / dir.y, {
              x: 0,
              y: -1
            });

          var diam = BALL_R * 2;
          var diam2 = diam * diam;
          for (var j = 0; j < table.balls.length; j++) {
            var b = table.balls[j];
            if (b === cue || b.pocketed) continue;
            var v = { x: b.p.x - cue.p.x, y: b.p.y - cue.p.y };
            var proj = v.x * dir.x + v.y * dir.y;
            if (proj <= 0) continue;
            var perp2 = v.x * v.x + v.y * v.y - proj * proj;
            if (perp2 > diam2) continue;
            var thc = Math.sqrt(diam2 - perp2);
            var t = proj - thc;
            if (t >= 0 && t < tHit) {
              tHit = t;
              target = b;
              railNormal = null;
            }
          }

          var impactX = cue.p.x + dir.x * tHit,
            impactY = cue.p.y + dir.y * tHit;
          var contactX = impactX,
            contactY = impactY,
            hitN = null;
          if (target) {
            var tx0 = target.p.x,
              ty0 = target.p.y;
            hitN = { x: tx0 - impactX, y: ty0 - impactY };
            var nL0 = len(hitN.x, hitN.y) || 1;
            hitN.x /= nL0;
            hitN.y /= nL0;
            contactX = tx0 - hitN.x * BALL_R;
            contactY = ty0 - hitN.y * BALL_R;
          }
          const guaranteedHit = target && !railNormal;
          ctx.save();
          ctx.strokeStyle = guaranteedHit
            ? 'rgba(255,255,0,1)'
            : 'rgba(255,255,255,.7)';
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.moveTo(cue.p.x * sX, cue.p.y * sY);
          ctx.lineTo(contactX * sX, contactY * sY);
          ctx.stroke();
          ctx.restore();

          if (!target && railNormal) {
            var dotIn = dir.x * railNormal.x + dir.y * railNormal.y;
            var refl = {
              x: dir.x - 2 * dotIn * railNormal.x,
              y: dir.y - 2 * dotIn * railNormal.y
            };
            // rotate spin into table coordinates and adjust reflection
            var perp = { x: -dir.y, y: dir.x };
            var forward = -spinVec.y;
            var side = spinVec.x;
            var spinWorld = {
              x: side * perp.x + forward * dir.x,
              y: side * perp.y + forward * dir.y
            };
            refl.x += spinWorld.x * 0.6;
            refl.y += spinWorld.y * 0.6;
            var rL = Math.hypot(refl.x, refl.y) || 1;
            refl.x /= rL;
            refl.y /= rL;
            ctx.save();
            ctx.strokeStyle = 'rgba(255,255,255,.5)';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(impactX * sX, impactY * sY);
            ctx.lineTo(
              (impactX + refl.x * BALL_R * 4) * sX,
              (impactY + refl.y * BALL_R * 4) * sY
            );
            ctx.stroke();
            ctx.restore();
          }

          if (target) {
            var tx = target.p.x,
              ty = target.p.y;
            var impactCueX = impactX,
              impactCueY = impactY;
            // hitN already normalized above when computing contactX/contactY

            // Draw marker circle with a plus at the contact point
            var hitSpotX = tx - hitN.x * BALL_R;
            var hitSpotY = ty - hitN.y * BALL_R;
            var canvasHitX = hitSpotX * sX;
            var canvasHitY = hitSpotY * sY;
            var markerR = ballR;
            ctx.save();
            ctx.strokeStyle = 'rgba(255,255,255,.8)';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.arc(canvasHitX, canvasHitY, markerR, 0, Math.PI * 2);
            ctx.stroke();
            // plus sign
            ctx.beginPath();
            ctx.moveTo(canvasHitX - markerR / 2, canvasHitY);
            ctx.lineTo(canvasHitX + markerR / 2, canvasHitY);
            ctx.moveTo(canvasHitX, canvasHitY - markerR / 2);
            ctx.lineTo(canvasHitX, canvasHitY + markerR / 2);
            ctx.stroke();
            ctx.restore();

            // Project the target ball's path along the line of centers
            var tMax = Infinity;
            if (hitN.x > 0)
              tMax = Math.min(
                tMax,
                (TABLE_W - BORDER - BALL_R - tx) / hitN.x
              );
            if (hitN.x < 0)
              tMax = Math.min(
                tMax,
                (BORDER + BALL_R - tx) / hitN.x
              );
            if (hitN.y > 0)
              tMax = Math.min(
                tMax,
                (TABLE_H - BORDER_BOTTOM - BALL_R - ty) / hitN.y
              );
            if (hitN.y < 0)
              tMax = Math.min(tMax, (BORDER_TOP + BALL_R - ty) / hitN.y);
            var ex = tx + hitN.x * tMax;
            var ey = ty + hitN.y * tMax;

            ctx.save();
            ctx.strokeStyle = 'rgba(255,255,255,.3)';
            ctx.lineWidth = 1;
            ctx.beginPath();
            // start the target path from the center of the marker so it connects with the aim line
            ctx.moveTo(canvasHitX, canvasHitY);
            ctx.lineTo(
              (ex - hitN.x * BALL_R) * sX,
              (ey - hitN.y * BALL_R) * sY
            );
            ctx.stroke();
            ctx.restore();

            // Calculate cue ball deflection direction
            var dot = dir.x * hitN.x + dir.y * hitN.y;
            var cbDir = { x: dir.x - hitN.x * dot, y: dir.y - hitN.y * dot };
            var cbL = len(cbDir.x, cbDir.y);
            if (cbL > 0.0001) {
              cbDir.x /= cbL;
              cbDir.y /= cbL;
              var cbEndX = impactCueX + cbDir.x * BALL_R * 4;
              var cbEndY = impactCueY + cbDir.y * BALL_R * 4;
              ctx.save();
              ctx.strokeStyle = 'rgba(255,255,255,.5)';
              ctx.lineWidth = 1;
              ctx.beginPath();
              ctx.moveTo(impactCueX * sX, impactCueY * sY);
              ctx.lineTo(cbEndX * sX, cbEndY * sY);
              ctx.stroke();
              ctx.restore();
            }
          }
        }

        function drawCueOnTable(cuePos, aim, pull) {
          // Align the cue with the guideline and pull it back based on the power slider
          var dx = aim.x - cuePos.x,
            dy = aim.y - cuePos.y;
          var len = Math.hypot(dx, dy) || 1;
          var dir = { x: dx / len, y: dy / len };
          var angle = Math.atan2(dir.y, dir.x) + Math.PI / 2;

          // Cue dimensions and offset to position the butt slightly lower
          var cueLength = BALL_R * 20;
          // Move cue image down by a little more than six ball diameters
          var cueShift = BALL_R * 2 * 6.3;

          if (cueImg.complete) {
            var scale = (cueLength * sX) / cueImg.width;
            var drawW = cueImg.width * scale;
            var drawH = cueImg.height * scale;
            var shiftPx = cueShift * sX;

            ctx.save();
            // Move origin away from the cue ball to simulate pullback
            ctx.translate(
              (cuePos.x - dir.x * pull) * sX,
              (cuePos.y - dir.y * pull) * sY
            );
            ctx.rotate(angle);
            // Offset the butt slightly downward
            ctx.translate(shiftPx, 0);
            ctx.drawImage(cueImg, -drawW / 2 - shiftPx, 0, drawW, drawH);
            ctx.restore();
          }
        }

        function drawUPocket(ctx, x, y, r, angle, fill) {
          ctx.save();
          ctx.translate(x * sX, y * sY);
          ctx.rotate(angle);
          var R = r * scaleFactor;
          var halfHeight = R; // distance to straight short sides
          var halfWidth = R * 1.1; // width of rounded long sides
          var w = halfWidth * 0.52; // shorten straight edges a bit more on the outer side
          ctx.beginPath();
          // Top straight edge
          ctx.moveTo(-w, -halfHeight);
          ctx.lineTo(w, -halfHeight);
          // Rounded right side
          ctx.arc(w, 0, halfHeight, -Math.PI / 2, Math.PI / 2);
          // Bottom straight edge
          ctx.lineTo(-w, halfHeight);
          // Rounded left side
          ctx.arc(-w, 0, halfHeight, Math.PI / 2, -Math.PI / 2);
          ctx.closePath();
          if (fill) ctx.fill();
          ctx.stroke();
          ctx.restore();
        }

        /* ==========================================================
       SPIN CONTROL ‚Äì disk i bardhe me pike te kuqe
       ========================================================= */
        var spinTimer = null,
          spinMoved = false;
        function setSpin(nx, ny) {
          spinDot.style.left = 50 + nx * 50 + '%';
          spinDot.style.top = 50 + ny * 50 + '%';
          spinVec = { x: nx, y: ny };
        }
        setSpin(0, 0);
        function updateSpin(e) {
          var r = spinBox.getBoundingClientRect();
          var x = ((e.clientX - r.left) / r.width) * 2 - 1,
            y = ((e.clientY - r.top) / r.height) * 2 - 1;
          var L = Math.hypot(x, y);
          x = (x / (L || 1)) * Math.min(1, L);
          y = (y / (L || 1)) * Math.min(1, L);
          setSpin(x, y);
          spinMoved = true;
        }
        spinBox.addEventListener('pointerdown', function (e) {
          if (table.turn !== 1) return;
          spinMoved = false;
          spinBox.style.transform = 'translate(-50%, -50%) scale(1.4)';
          clearTimeout(spinTimer);
          updateSpin(e);
          spinBox.setPointerCapture(e.pointerId);
          spinTimer = setTimeout(function () {
            if (!spinMoved)
              spinBox.style.transform = 'translate(-50%, -50%) scale(1)';
          }, 1500);
        });
        spinBox.addEventListener('pointermove', function (e) {
          if (table.turn !== 1 || e.buttons !== 1) return;
          updateSpin(e);
        });
        spinBox.addEventListener('pointerup', function () {
          if (table.turn !== 1) return;
          clearTimeout(spinTimer);
          setTimeout(function () {
            spinBox.style.transform = 'translate(-50%, -50%) scale(1)';
          }, 50);
        });

        /* ==========================================================
       PULL & RELEASE ‚Äì fuqi e goditjes
       ========================================================= */
        var pulling = false,
          pullMoved = false;
        function updatePullHandle() {
          var rect = pullArea.getBoundingClientRect();
          // Move the cue handle lower so it doesn't overlap the table
          var minY = -powerCue.offsetHeight * 0.3;
          var maxY = rect.height - powerCue.offsetHeight * 0.4;
          var y = minY + (maxY - minY) * power;
          powerCue.style.top = y + 'px';
          pullHandle.style.top = y + 'px';
          // Keep the power percentage above the pull handle as it moves
          powerTxt.style.top = y - 30 + 'px';
          var barWidth = 12;
          var barHeight = maxY - minY;
          powerBg.style.width = barWidth + 'px';
          powerBg.style.height = barHeight + 'px';
          powerBg.style.top = minY + 'px';
          powerBox.style.width = barWidth + 'px';
          powerBox.style.height = barHeight + 'px';
          powerBox.style.top = minY + 'px';
        }
        function updatePowerUI() {
          powerFill.style.height = Math.round(power * 100) + '%';
          powerPercent.textContent = Math.round(power * 100) + '%';
          pullArea.style.background = 'none';
          if (power > 0) {
            var pct = Math.round(power * 100);
            cueRail.style.background =
              'linear-gradient(to bottom, rgba(255,255,255,0.6) 0%, rgba(255,255,255,0.6) ' +
              pct +
              '%, transparent ' +
              pct +
              '%, transparent 100%)';
          } else {
            cueRail.style.background = 'none';
          }
          updatePullHandle();
        }

        function startCueStrikeAnimation(initialPull, p) {
          cueVisible = true;
          cueStrike.active = true;
          cueStrike.speed = BALL_R * 120 * (0.25 + 0.75 * p);
          cueStrike.stage = 'forward';
          cuePullVisual = initialPull;
        }

        function animateCueStrike(dt) {
          if (!cueStrike.active) return;
          if (cueStrike.stage === 'forward') {
            cuePullVisual -= cueStrike.speed * dt;
            if (cuePullVisual <= 0) {
              if (spinVec.y < -0.1) {
                cuePullVisual = -BALL_R * 0.2; // small push for top spin
                cueStrike.stage = 'recover';
              } else if (spinVec.y > 0.1) {
                cuePullVisual = BALL_R * 0.2; // slight pullback for back spin
                cueStrike.stage = 'recover';
              } else {
                cuePullVisual = 0;
                cueStrike.active = false;
                cueVisible = false;
              }
            }
          } else if (cueStrike.stage === 'recover') {
            if (spinVec.y < -0.1) {
              cuePullVisual += cueStrike.speed * dt;
              if (cuePullVisual >= 0) {
                cuePullVisual = 0;
                cueStrike.active = false;
                cueVisible = false;
              }
            } else if (spinVec.y > 0.1) {
              cuePullVisual -= cueStrike.speed * dt;
              if (cuePullVisual <= 0) {
                cuePullVisual = 0;
                cueStrike.active = false;
                cueVisible = false;
              }
            }
          }
        }
        function updateFromEvent(e) {
          var rect = pullArea.getBoundingClientRect();
          power = clamp((e.clientY - rect.top) / rect.height, 0, 1);
          updatePowerUI();
          cuePullVisual = power * (BALL_R * 14);
          placeAimGlow(table.aim);
        }
        pullHandle.addEventListener('pointerdown', function (e) {
          if (!table.running || table.isMoving() || table.turn !== 1) return;
          pulling = true;
          pullMoved = false;
          pullHandle.setPointerCapture(e.pointerId);
        });
        pullHandle.addEventListener('pointermove', function (e) {
          if (!pulling || table.turn !== 1) return;
          pullMoved = true;
          updateFromEvent(e);
        });
        pullHandle.addEventListener('pointerup', function () {
          if (!pulling || table.turn !== 1) return;
          pulling = false;
          if (pullMoved && power > 0) {
            startCueStrikeAnimation(cuePullVisual, power);
            shoot(power);
          }
          power = 0;
          updatePowerUI();
        });

        updatePowerUI();

        let diceRolling = false;

        function shoot(p) {
          if (!table.running || table.isMoving() || diceRolling) return;
          clearTurnTimer();
          var cue = table.balls[0];
          if (!cue || cue.pocketed) return;
          isBreakShot = false;
          var aimPoint = table.aim;
          var dx = aimPoint.x - cue.p.x;
          var dy = aimPoint.y - cue.p.y;
          var L = Math.hypot(dx, dy) || 1;
          var d = { x: dx / L, y: dy / L };
          lastShotAim = { x: aimPoint.x, y: aimPoint.y };
          lastCueStart = { x: cue.p.x, y: cue.p.y };
          shotPocketRecorded = false;
          cueHitCushion = false;
          var base = 950 * 3 * 1.6 * 1.5;
          // Reduce the overall shot power but keep it slightly stronger
          base *= 0.6;
          playCueHit(p * 0.6);
          lastShotPower = p;
          currentShooter = table.turn;
          if (isNineBall || isAmerican) currentTarget = lowestBallOnTable();
          shotInProgress = true;
          pocketedAny = false;
          pocketedOwn = false;
          scratch = false;
          firstHit = null;
          pottedThisShot = [];
          assignedThisShot = false;
          eightBallPotted = false;
          nineBallPotted = false;
          cue.v.x = d.x * base * (0.25 + 0.75 * p);
          cue.v.y = d.y * base * (0.25 + 0.75 * p);
          var perp = { x: -d.y, y: d.x };
          var forward = -spinVec.y;
          var side = spinVec.x;
          cue.spin = {
            x: side * perp.x + forward * d.x,
            y: side * perp.y + forward * d.y
          };
          cue.impacted = false;
          cueBallFree = false;
          setSpin(0, 0);
          showGuides = false;
        }

        /* ==========================================================
       CPU ‚Äì turn i thjeshte (normal skill)
       ========================================================= */
        async function cpuTurn() {
          if (window.trainingMode && window.trainingSolo) return;
          if (table.isMoving() || table.turn !== 2) return;
          cpuThinking = true;
          startCpuTimer();
          const { default: planShot } = await planShotPromise;
          var cue = table.balls[0];
          if (cueBallFree) {
            cue.p.x = TABLE_W / 2;
            cue.p.y = CUE_START_Y;
            cue.v.x = cue.v.y = 0;
          }
          const balls = table.balls.filter(Boolean).map((b) => ({
            id: b.n,
            x: b.p.x,
            y: b.p.y,
            vx: b.v.x,
            vy: b.v.y,
            pocketed: !!b.pocketed
          }));
          const pockets = table.pockets.map((p) => ({ x: p.x, y: p.y }));
          const req = {
            game: isNineBall
              ? 'NINE_BALL'
              : isAmerican
                ? 'AMERICAN_BILLIARDS'
                : 'EIGHT_POOL_UK',
            maxCutAngle: Math.PI / 6,
            minViewScore: 0.5,
            state: {
              balls,
              pockets,
              width: TABLE_W,
              height: TABLE_H,
              ballRadius: BALL_R,
              friction: 0.015,
              ballOn: assignedTypes[2] || null,
              myGroup:
                assignedTypes[2] === 'red'
                  ? 'SOLIDS'
                  : assignedTypes[2] === 'blue'
                    ? 'STRIPES'
                    : 'UNASSIGNED',
              ballInHand: cueBallFree,
              mustPlayFromBaulk: cueBallFree,
              baulkLineY: LINE_Y + BALL_R
            }
          };
          let shot = planShot(req);
          if (!shot && !isNineBall && !isAmerican) {
            const { default: selectShot } = await import(
              '/lib/poolUkAdvancedAi.js'
            );
            const advState = {
              balls: balls.map((b) => ({
                id: b.id,
                colour:
                  b.id === 0
                    ? 'cue'
                    : b.id === 8
                      ? 'black'
                      : b.id >= 1 && b.id <= 7
                        ? 'red'
                        : 'blue',
                x: b.x,
                y: b.y,
                pocketed: b.pocketed
              })),
              pockets: table.pockets.map((p, i) => ({
                x: p.x,
                y: p.y,
                name: ['TL', 'TR', 'ML', 'MR', 'BL', 'BR'][i]
              })),
              width: TABLE_W,
              height: TABLE_H,
              ballRadius: BALL_R,
              ballOn:
                assignedTypes[2] === 'blue'
                  ? 'blue'
                  : assignedTypes[2] === 'red'
                    ? 'red'
                    : null,
              isOpenTable: !assignedTypes[2],
              freeBallAvailable: cueBallFree,
              shotsRemaining: 1,
              mustPlayFromBaulk: cueBallFree,
              baulkLineX: TABLE_W / 2,
              baulkLineY: LINE_Y + BALL_R
            };
            const plan = selectShot(advState);
            if (plan) {
              const angleRad = Math.atan2(
                plan.aimPoint.y - cue.p.y,
                plan.aimPoint.x - cue.p.x
              );
              const power =
                plan.cueParams.speed === 'soft'
                  ? 0.3
                  : plan.cueParams.speed === 'med'
                    ? 0.6
                    : 0.9;
              const spinMap = {
                stun: { top: 0, back: 0, side: 0 },
                followS: { top: 0.5, back: 0, side: 0 },
                followL: { top: 1, back: 0, side: 0 },
                drawS: { top: 0, back: 0.5, side: 0 },
                drawL: { top: 0, back: 1, side: 0 },
                sideL: { top: 0, back: 0, side: -0.5 },
                sideR: { top: 0, back: 0, side: 0.5 }
              };
              shot = {
                angleRad,
                power,
                spin: spinMap[plan.cueParams.spin] || {
                  top: 0,
                  back: 0,
                  side: 0
                },
                aimPoint: plan.aimPoint
              };
            }
          }
          if (!shot) {
            table.turn = 1;
            cpuThinking = false;
            clearTurnTimer();
            return;
          }
          if (shot.cueBallPosition) {
            var nx = clamp(
              shot.cueBallPosition.x,
              BORDER + BALL_R,
              TABLE_W - BORDER - BALL_R
            );
            var ny = clamp(
              shot.cueBallPosition.y,
              LINE_Y + BALL_R,
              TABLE_H - BORDER_BOTTOM - BALL_R
            );
            cue.p.x = nx;
            cue.p.y = ny;
            cue.v.x = cue.v.y = 0;
            cueBallFree = false;
          }
          var nd = { x: Math.cos(shot.angleRad), y: Math.sin(shot.angleRad) };
          var aimPoint = shot.aimPoint || {
            x: cue.p.x + nd.x * 100,
            y: cue.p.y + nd.y * 100
          };
          var dist = Math.hypot(aimPoint.x - cue.p.x, aimPoint.y - cue.p.y);
          var bucket =
            dist <= SHORT_DIST ? 'short' : dist <= MED_DIST ? 'medium' : 'long';
          setCueVariant(bucket);
          if (isBreakShot) shot.power = 1;
          setSpin(shot.spin.side, shot.spin.top - shot.spin.back);
          showGuides = true;
          table.aim.x = aimPoint.x;
          table.aim.y = aimPoint.y;
          placeAimGlow(table.aim);
          cuePullVisual = shot.power * (BALL_R * 14);
          setTimeout(function () {
            cpuThinking = false;
            clearTurnTimer();
            startCueStrikeAnimation(cuePullVisual, shot.power);
            shoot(shot.power);
            showGuides = false;
          }, CPU_SHOT_DELAY);
        }

        /* ==========================================================
       START / RESIZE / RENDER fillestar
       ========================================================= */
        function startDiceRoll() {
          table.turn = 0;
          diceRolling = true;
          isBreakShot = true;
          spinVec = { x: 0, y: 0 }; // reset cue ball spin for break
          const overlay = document.getElementById('diceOverlay');
          overlay.classList.remove('hidden');
          overlay.innerHTML =
            '<div class="dice-row" id="diceRow"></div><div id="diceMsg">Tap to roll dice</div>';

          const diceFaces = {
            1: [
              [0, 0, 0],
              [0, 1, 0],
              [0, 0, 0]
            ],
            2: [
              [1, 0, 0],
              [0, 0, 0],
              [0, 0, 1]
            ],
            3: [
              [1, 0, 0],
              [0, 1, 0],
              [0, 0, 1]
            ],
            4: [
              [1, 0, 1],
              [0, 0, 0],
              [1, 0, 1]
            ],
            5: [
              [1, 0, 1],
              [0, 1, 0],
              [1, 0, 1]
            ],
            6: [
              [1, 0, 1],
              [1, 0, 1],
              [1, 0, 1]
            ]
          };

          function createFace(value, className) {
            const face = document.createElement('div');
            face.className = 'dice-face ' + className;
            const grid = document.createElement('div');
            grid.style.display = 'grid';
            grid.style.gridTemplateColumns = 'repeat(3, 1fr)';
            grid.style.gridTemplateRows = 'repeat(3, 1fr)';
            grid.style.gap = '2px';
            diceFaces[value].flat().forEach((dot) => {
              const cell = document.createElement('div');
              cell.style.display = 'flex';
              cell.style.alignItems = 'center';
              cell.style.justifyContent = 'center';
              if (dot) {
                const d = document.createElement('div');
                d.className = 'dot';
                cell.appendChild(d);
              }
              grid.appendChild(cell);
            });
            face.appendChild(grid);
            return face;
          }

          function createDie(id) {
            const container = document.createElement('div');
            container.className = 'dice-container';
            container.id = id;
            const cube = document.createElement('div');
            cube.className = 'dice-cube';
            cube.style.transform = 'rotateX(-35deg) rotateY(45deg)';
            container.appendChild(cube);
            // initial faces
            cube.appendChild(createFace(2, 'dice-face--front'));
            cube.appendChild(createFace(5, 'dice-face--back'));
            cube.appendChild(createFace(3, 'dice-face--right'));
            cube.appendChild(createFace(4, 'dice-face--left'));
            cube.appendChild(createFace(1, 'dice-face--top'));
            cube.appendChild(createFace(6, 'dice-face--bottom'));
            return container;
          }

          function setDieValue(container, value) {
            const cube = container.querySelector('.dice-cube');
            const top = cube.querySelector('.dice-face--top');
            const bottom = cube.querySelector('.dice-face--bottom');
            top.replaceWith(createFace(value, 'dice-face--top'));
            bottom.replaceWith(createFace(7 - value, 'dice-face--bottom'));
          }

          function rollDie(container, cb) {
            const cube = container.querySelector('.dice-cube');
            cube.classList.add('animate-roll');
            const id = setInterval(() => {
              const v = Math.floor(Math.random() * 6) + 1;
              setDieValue(container, v);
            }, 50);
            setTimeout(() => {
              clearInterval(id);
              const final = Math.floor(Math.random() * 6) + 1;
              setDieValue(container, final);
              cube.classList.remove('animate-roll');
              cb(final);
            }, 1000);
          }

          const diceRow = document.getElementById('diceRow');
          const playerDie = createDie('playerDie');
          const cpuDie = createDie('cpuDie');
          diceRow.appendChild(playerDie);
          diceRow.appendChild(cpuDie);

          const diceMsg = document.getElementById('diceMsg');
          let playerRoll = null;
          let cpuRoll = null;
          let rolled = false;

          function checkResult() {
            if (playerRoll !== null && cpuRoll !== null) {
              if (playerRoll === cpuRoll) {
                diceMsg.textContent = 'Tie! Rolling again...';
                setTimeout(startDiceRoll, 1000);
                return;
              }
              const playerStarts = playerRoll > cpuRoll;
              diceMsg.textContent = playerStarts
                ? 'You break first'
                : 'CPU breaks first';
              setTimeout(() => {
                overlay.classList.add('hidden');
                diceRolling = false;
                table.turn = playerStarts ? 1 : 2;
                updateTurnIndicator(true);
                showTurnInfo();
                if (table.turn === 2) cpuTurn();
              }, 1000);
            }
          }

          function rollBoth() {
            if (rolled) return;
            rolled = true;
            rollDie(playerDie, (v) => {
              playerRoll = v;
              checkResult();
            });
            rollDie(cpuDie, (v) => {
              cpuRoll = v;
              checkResult();
            });
          }

          diceRow.addEventListener('click', rollBoth);
          setTimeout(rollBoth, 5000);
        }

        playBtn.addEventListener('click', function () {
          playBtn.style.display = 'none';
          table.running = true;
          resize();
          table.render();
          spinVec = { x: 0, y: 0 }; // center cue ball dot at game start
          if (window.trainingMode && window.trainingSolo) {
            var cpuPlayer = document.querySelector(
              '#header .player:last-child'
            );
            if (cpuPlayer) cpuPlayer.style.display = 'none';
            table.turn = 1;
            isBreakShot = true;
            updateTurnIndicator(true);
            showTurnInfo();
          } else {
            startDiceRoll();
          }
        });
        resize();
        table.render();
      })();
    </script>

    <div id="trainingMenuWrapper" class="hidden">
      <button id="trainingMenuButton">‚ò∞</button>
    </div>
    <div id="trainingMenu" class="hidden">
      <div id="trainingMenuInner">
        <button id="practiceSolo">Practice Solo</button>
        <button id="practiceAi">Practice vs AI</button>
        <button id="enableRules">With Rules</button>
        <button id="disableRules">No Rules</button>
        <button id="restartTraining">New Game</button>
      </div>
    </div>

    <script>
      const rulesBtn = document.getElementById('rulesBtn');
      const rulesModal = document.getElementById('rulesModal');
      const closeRules = document.getElementById('closeRules');
      const rulesTitle = document.getElementById('rulesTitle');
      const rulesList = document.getElementById('rulesList');
      const rulesSource = document.getElementById('rulesSource');

      const ruleSets = {
        uk: {
          title: '8 Ball UK Rules',
          items: [
            'On the break, any potted balls count for the breaker. If a single colour is potted, continue with that colour.',
            'Potting both colours on the break lets the breaker choose which colour to play.',
            'Potting on the break keeps the turn until a miss.',
            "Potting an opponent's ball is a foul that grants the opponent two shots.",
            'Hitting an opponent ball first is a foul and gives the opponent two shots.',
            'Failing to contact your colour, or the black when none remain, is a foul awarding two shots to the opponent.',
            'On the black 8, even after a foul, only one shot is allowed.',
            "Once your coloured balls are gone, pot the black 8 to win ‚Äî it's not a foul.",
            'After a foul the incoming player may place the cue ball behind the line and aim anywhere.'
          ],
          source: 'Custom 8 Ball UK rules for Pool Royale.'
        },
        american: {
          title: 'American Billiards Rules',
          items: [
            'Balls must be struck in numerical order; failing to contact the lowest numbered ball first is a foul.',
            'Pocketed balls score their face value, but points from a fouled shot go to the opponent.',
            'Pocketing the cue ball awards any points from that shot to the opponent.',
            'When in hand, the cue ball must remain behind the head string.',
            'If scores are tied after all balls are potted, spot the 8-ball and place the cue ball behind the head string; the last scorer shoots first and whoever pots the 8-ball wins.'
          ],
          source: 'Based on traditional 15-ball rotation guidelines.'
        },
        '9ball': {
          title: '9-Ball Rules',
          items: [
            'Balls must be struck in numerical order from 1 to 9; failing to hit the next ball first is a foul.',
            'Any ball pocketed after correctly contacting the lowest ball keeps the turn.',
            'Pocketing the cue ball ends your turn and hands play to the opponent.',
            'The cue ball may be moved only behind the head line at the start or after a foul.',
            'Choose shots that favor balls near pockets or with clean angles.',
            'The AI draws a helper line‚Äîdirect or off a rail‚Äîto guarantee the next ball is contacted first.',
            'On straight shots, the AI may use draw or spin to move other balls after the legal hit, prioritizing higher numbers when advantageous.',
            'Example: if the 2-ball is the target and the 9-ball sits by a pocket, hit the 2 then use the cue ball to push the 9 in to win.'
          ],
          source: 'Custom Pool Royale 9-ball guidelines.'
        }
      };

      rulesBtn.addEventListener('click', () => {
        const r = ruleSets[variant] || ruleSets.uk;
        rulesTitle.textContent = r.title;
        rulesList.innerHTML = r.items.map((i) => `<li>${i}</li>`).join('');
        rulesSource.textContent = r.source;
        rulesModal.classList.remove('hidden');
      });

      closeRules.addEventListener('click', () => {
        rulesModal.classList.add('hidden');
      });

      rulesModal.addEventListener('click', (e) => {
        if (e.target === rulesModal) {
          rulesModal.classList.add('hidden');
        }
      });

      if (params.get('type') === 'training') {
        const wrapper = document.getElementById('trainingMenuWrapper');
        const menuBtn = document.getElementById('trainingMenuButton');
        const menu = document.getElementById('trainingMenu');
        wrapper.classList.remove('hidden');
        menuBtn.addEventListener('click', () => {
          menu.classList.remove('hidden');
        });
        menu.addEventListener('click', (e) => {
          if (e.target === menu) menu.classList.add('hidden');
        });
        document
          .getElementById('practiceSolo')
          .addEventListener('click', () => {
            window.trainingSolo = true;
            menu.classList.add('hidden');
          });
        document.getElementById('practiceAi').addEventListener('click', () => {
          window.trainingSolo = false;
          menu.classList.add('hidden');
        });
        document.getElementById('enableRules').addEventListener('click', () => {
          window.trainingRules = true;
          menu.classList.add('hidden');
        });
        document.getElementById('disableRules').addEventListener('click', () => {
          window.trainingRules = false;
          menu.classList.add('hidden');
        });
        document
          .getElementById('restartTraining')
          .addEventListener('click', () => {
            window.location.reload();
          });
      }

      // Tournament mode removed

      // Rotate corner holes diagonally in the same direction; keep side holes horizontal
      const allHoles = document.querySelectorAll('.hole');
      if (allHoles.length === 6) {
        allHoles.forEach((hole, idx) => {
          if (idx === 0 || idx === 1 || idx === 4 || idx === 5) {
            hole.style.transform = 'rotate(-45deg)';
          } else {
            hole.style.transform = 'rotate(0deg)';
          }
        });
      }
    </script>
    <script>
      if (window.tournamentMode) {
        const tg = window.Telegram?.WebApp;
        function showExitPopup() {
          if (document.getElementById('tournExit')) return;
          const overlay = document.createElement('div');
          overlay.id = 'tournExit';
          overlay.style.position = 'fixed';
          overlay.style.inset = '0';
          overlay.style.background = 'rgba(0,0,0,0.6)';
          overlay.style.display = 'flex';
          overlay.style.flexDirection = 'column';
          overlay.style.alignItems = 'center';
          overlay.style.justifyContent = 'center';
          const box = document.createElement('div');
          box.style.background = '#11172a';
          box.style.padding = '20px';
          box.style.borderRadius = '8px';
          box.style.textAlign = 'center';
          box.style.maxWidth = '90%';
          box.style.color = '#dbe7ff';
          box.innerHTML =
            '<p style="margin-bottom:12px;">If you quit the tournament, your funds will be lost and you will be placed last.</p>';
          const quit = document.createElement('button');
          quit.textContent = 'Quit Tournament';
          quit.style.margin = '4px';
          quit.style.padding = '8px 12px';
          quit.style.background = '#f97316';
          quit.style.border = 'none';
          quit.style.borderRadius = '4px';
          quit.style.color = '#fff';
          const ret = document.createElement('button');
          ret.textContent = 'Return to Lobby';
          ret.style.margin = '4px';
          ret.style.padding = '8px 12px';
          ret.style.background = '#2563eb';
          ret.style.border = 'none';
          ret.style.borderRadius = '4px';
          ret.style.color = '#fff';
          box.appendChild(quit);
          box.appendChild(ret);
          overlay.appendChild(box);
          document.body.appendChild(overlay);
          quit.onclick = () => {
            localStorage.removeItem(STATE_KEY);
            localStorage.removeItem(OPP_KEY);
            if (tg) tg.BackButton.hide();
            window.location.href = '/games/pollroyale/lobby';
          };
          ret.onclick = () => {
            if (tg) tg.BackButton.show();
            window.location.href =
              '/pool-royale-bracket.html' + window.location.search;
          };
        }
        if (tg) {
          tg.BackButton.show();
          tg.onEvent('backButtonClicked', showExitPopup);
          tg.onEvent('close', showExitPopup);
        }
        history.pushState(null, '', location.href);
        window.addEventListener('popstate', (e) => {
          e.preventDefault();
          showExitPopup();
          history.pushState(null, '', location.href);
        });
      }
    </script>
  </body>
</html>
