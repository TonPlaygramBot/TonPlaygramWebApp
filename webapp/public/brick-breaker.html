<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"
    />
    <title>Brick Breaker Royale â€” TonPlaygram (Local Test)</title>
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link href="https://fonts.googleapis.com/css2?family=Luckiest+Guy&display=swap" rel="stylesheet" />
    <style>
      :root {
        --bg: #0c1020;
        --panel: #11172a;
        --primary: #2563eb;
        --gold: #d4af37;
        --text: #e7eefc;
        --muted: #8fa1d2;
        --danger: #ff5a6b;
        --success: #34d399;
      }
      * {
        box-sizing: border-box;
        font-family: 'Luckiest Guy','Comic Sans MS',cursive;
        -webkit-text-stroke: 0.3px #000;
        text-shadow: 0 0 4px #000;
      }
      html,
      body {
        height: 100dvh;
        overscroll-behavior: none;
      }
      body {
        margin: 0;
        background: radial-gradient(
            1200px 800px at 70% -10%,
            #1a2450 0%,
            #0c1020 38%,
            #0c1020 100%
          )
          fixed;
        color: var(--text);
        position: relative;
        overflow: hidden;
      }

      .app {
        height: 100dvh;
        display: flex;
        flex-direction: column;
      }
      .tetris-grid-bg{
        background:
          repeating-linear-gradient(45deg,rgba(255,255,255,0.05) 0 2px,transparent 2px 4px),
          radial-gradient(circle at center,#243375 0%,#18234d 80%);
        background-size:100px 100px,cover;
        background-position:0 0,center;
        animation:canvasDepthMove 30s linear infinite;
      }
      .card {
        background: linear-gradient(180deg, #0f1530, #0a0f24);
        border: 1px solid #1f2a58;
        border-radius: 14px;
        padding: 14px;
      }
      .settings {
        display: grid;
        grid-template-columns: repeat(4, 1fr) auto;
        gap: 10px;
        align-items: end;
      }
      label {
        font-size: 12px;
        color: var(--muted);
        display: block;
        margin-bottom: 6px;
      }
      input,
      select,
      button {
        width: 100%;
        padding: 10px 12px;
        border-radius: 10px;
        border: 1px solid #223063;
        background: #0e1430;
        color: var(--text);
        outline: none;
      }
      input:focus,
      select:focus {
        border-color: var(--primary);
      }
      .btn {
        background: linear-gradient(180deg, #2a6cf0, #2156c8);
        border: none;
        cursor: pointer;
        font-weight: 600;
      }
      .btn:disabled {
        opacity: 0.6;
        cursor: not-allowed;
      }
      /* HUD removed - time and pot moved inline with user info */
      .timer {
        font-variant-numeric: tabular-nums;
        font-weight: 700;
      }

      .game-layout {
        display: grid;
        grid-template-rows: 20vh 1fr;
        gap: 12px;
        min-height: 0;
        flex: 1;
      }
      .strip {
        display: grid;
        grid-template-columns: repeat(3, 1fr);
        gap: 12px;
        min-height: 0;
      }
      .mini {
        position: relative;
        border-radius: 14px;
        border: 1px solid #223063;
        background: linear-gradient(180deg, #0f1530, #0a0f24);
        padding: 10px;
        display: flex;
        flex-direction: column;
      }
      .mini h3 {
        margin: 0 0 6px 0;
        font-size: 13px;
        color: var(--muted);
        display: flex;
        gap: 6px;
        align-items: center;
      }
      .mini .avatar {
        width: 24px;
        height: 24px;
        border-radius: 50%;
      }
      .mini canvas {
        width: 100%;
        height: 100%;
        border-radius: 10px;
        display: block;
        image-rendering: pixelated;
        filter: saturate(1.2);
      }

      .user-area {
        min-height: 0;
        display: flex;
        flex-direction: column;
        gap: 8px;
      }
      .user-board {
        position: relative;
        border-radius: 14px;
        border: 1px solid #223063;
        background: linear-gradient(180deg, #0f1530, #0a0f24);
        padding: 10px;
        display: flex;
        flex-direction: column;
        min-height: 0;
        flex: 1;
      }
      .user-board h3 {
        margin: 0 0 4px 0;
        font-size: 13px;
        color: var(--muted);
        display: flex;
        align-items: center;
        gap: 8px;
      }
      .user-board .avatar {
        width: 32px;
        height: 32px;
        border-radius: 50%;
      }
      canvas.main {
        width: 100%;
        height: 100%;
        display: block;
        border-radius: 10px;
        touch-action: none;
        image-rendering: pixelated;
        filter: saturate(1.2);
        transform-origin: bottom center;
        transform: perspective(1000px) rotateX(25deg) scaleY(1.2);
      }

      .pill {
        display: inline-flex;
        align-items: center;
        gap: 6px;
        background: #0f1736;
        border: 1px solid #223063;
        border-radius: 999px;
        padding: 4px 8px;
        font-size: 12px;
      }
      .life {
        color: var(--danger);
        font-size: 16px;
      }
      .score {
        color: var(--gold);
        font-weight: 700;
        font-size: 18px;
      }
      .toast {
        position: fixed;
        left: 50%;
        transform: translateX(-50%);
        bottom: 18px;
        background: #0d1536;
        border: 1px solid #223063;
        padding: 8px 12px;
        border-radius: 10px;
        font-size: 13px;
        opacity: 0;
        transition: opacity 0.25s;
      }
      .toast.show {
        opacity: 1;
      }
      dialog {
        border: none;
        border-radius: 16px;
        padding: 0;
        background: #0d1330;
        color: var(--text);
        max-width: 520px;
        width: calc(100% - 24px);
      }
      .modal {
        padding: 16px;
        border: 1px solid #223063;
        border-radius: 16px;
        background: linear-gradient(180deg, #0f1736, #0b1126);
      }
      .modal h2 {
        margin: 6px 0 10px 0;
      }
      .grid {
        display: grid;
        gap: 10px;
      }
      .grid.two {
        grid-template-columns: 1fr 1fr;
      }
      .kpi {
        background: #0b1228;
        border: 1px solid #223063;
        border-radius: 12px;
        padding: 10px;
        text-align: center;
      }
      .kpi .v {
        font-size: 22px;
        font-weight: 800;
      }
      .split {
        font-size: 12px;
        color: var(--muted);
      }
      .actions {
        display: flex;
        gap: 8px;
        flex-wrap: wrap;
        margin-top: 8px;
      }
      .ghost {
        background: #0f1736;
        border: 1px solid #223063;
      }
      .success {
        background: linear-gradient(180deg, #37d493, #1ea76e);
      }
      .countdown {
        position: fixed;
        inset: 0;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 48px;
        font-weight: 700;
        background: rgba(0, 0, 0, 0.5);
        z-index: 50;
      }
      .countdown.hidden {
        display: none;
      }
      .winner-popup {
        position: fixed;
        inset: 0;
        background: rgba(0, 0, 0, 0.7);
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        gap: 16px;
        z-index: 60;
      }
      .winner-popup.hidden {
        display: none;
      }
      .winner-popup img {
        width: 120px;
        height: 120px;
        border-radius: 50%;
      }
      .winner-popup .buttons {
        display: flex;
        gap: 12px;
      }
      .coin-confetti {
        position: fixed;
        top: -40px;
        width: 32px;
        height: 32px;
        pointer-events: none;
        animation: coin-fall var(--duration, 3s) linear forwards;
        z-index: 70;
      }
      @keyframes coin-fall {
        from {
          transform: translateY(-10vh) rotate(0deg);
          opacity: 1;
        }
        to {
          transform: translateY(100vh) rotate(360deg);
          opacity: 0;
        }
      }
    
      @keyframes canvasDepthMove{from{background-position:0 0,center}to{background-position:100px 100px,center}}
    </style>
  </head>
  <body>
    <div class="app">
      <div class="game-layout">
        <div id="strip" class="strip"></div>
        <div class="user-area">
          <div class="user-board">
            <h3>
              <img class="avatar" id="userAvatar" alt="avatar" />
              <span id="userLabel">USER</span>
              <span class="pill"
                ><span class="life" id="userLives">â™¥â™¥â™¥</span></span
              >
              <span class="pill">
                Time <span class="timer" id="time">00:00</span>
              </span>
              <span class="pill">
                Pot (TPC) <span id="pot" class="score">0</span>
              </span>
            </h3>
            <canvas
              id="userCanvas"
              class="main tetris-grid-bg"
              width="720"
              height="1120"
            ></canvas>
          </div>
        </div>
      </div>
    </div>

    <div id="toast" class="toast"></div>

    <div id="winnerPopup" class="winner-popup hidden">
      <img id="winnerAvatar" alt="winner avatar" />
      <div id="winnerName"></div>
      <div class="buttons">
        <button class="btn success" id="playAgain">Play Again</button>
        <button class="btn ghost" id="lobbyBtn">Return Lobby</button>
      </div>
    </div>
    <div id="countdown" class="countdown hidden"></div>

    <script src="/flag-emojis.js"></script>
    <script src="/brick-breaker-api.js"></script>
    <script>
      if (!window.__BBR_INITED__) {
        window.__BBR_INITED__ = true;
        (() => {
          const params = new URLSearchParams(location.search);
          const RESOLUTION = parseFloat(params.get('resolution') || '2');
          const OUTLINE = parseFloat(params.get('outline') || '1');
          let GAME_DURATION_MS = 60000;
          const CANVAS_W = 720,
            CANVAS_H = 1120,
            DPR = window.devicePixelRatio || 1,
            VIEW_W = CANVAS_W / DPR,
            VIEW_H = CANVAS_H / DPR;
          const COLORS = {
            bg: '#ffffff',
            wall: '#000000',
            paddle: '#00bfff',
            ball: '#5aa2ff',
            text: '#ffffff',
            power: '#ffa600',
            danger: '#ef476f'
          };
          const POWERUPS = ['multiball', 'fireball', 'wide', 'slow', 'x2', 'life', 'shrink'];
          const POWERUP_COLORS = {
            multiball: '#a78bfa',
            fireball: '#ff5a6b',
            wide: '#34d399',
            slow: '#5aa2ff',
            x2: '#d4af37',
            life: '#fbbf24',
            shrink: '#9ca3af'
          };
          const POINTS = { standard: 10, tough: 20, explosive: 10 };

          const BRICK_COLORS = [
            '#00bfff',
            '#ff7f00',
            '#ff1493',
            '#ffd700',
            '#32cd32',
            '#8a2be2',
            '#ff69b4'
          ];

          // Bomb explosion sound reused from Snake & Ladder
          const bombAudio = new Audio('/assets/sounds/a-bomb-139689.mp3');
          bombAudio.volume = 0.6;

          const drawBall = (ctx, x, y, r, color) => {
            ctx.beginPath();
            ctx.arc(x, y, r, 0, Math.PI * 2);
            ctx.fillStyle = color;
            ctx.fill();
            ctx.lineWidth = Math.max(2, r * 0.1);
            ctx.strokeStyle = '#000';
            ctx.lineJoin = 'round';
            ctx.lineCap = 'round';
            ctx.stroke();
            ctx.fillStyle = 'rgba(255,255,255,0.6)';
            ctx.beginPath();
            ctx.arc(x - r * 0.3, y - r * 0.3, r * 0.25, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(x - r * 0.45, y - r * 0.45, r * 0.07, 0, Math.PI * 2);
            ctx.fill();
          };

          const drawBlock = (ctx, x, y, w, h, color) => {
            const r = Math.min(w, h);
            ctx.fillStyle = color;
            ctx.fillRect(x, y, w, h);
            ctx.lineWidth = Math.max(1, r * 0.05);
            ctx.strokeStyle = '#000';
            ctx.lineJoin = 'miter';
            ctx.lineCap = 'butt';
            ctx.strokeRect(x, y, w, h);
            ctx.save();
            ctx.beginPath();
            ctx.rect(x, y, w, h);
            ctx.clip();
            const sizeLargeW = Math.floor(w * 0.55);
            const sizeLargeH = Math.floor(h * 0.55);
            const sizeSmallW = Math.floor(w * 0.2);
            const sizeSmallH = Math.floor(h * 0.2);
            const extra = Math.floor(r * 0.02);
            ctx.fillStyle = 'rgba(255,255,255,0.3)';
            ctx.fillRect(x, y + h - sizeLargeH, sizeLargeW + extra, sizeLargeH);
            ctx.fillStyle = 'rgba(255,255,255,0.5)';
            ctx.fillRect(x, y + h - sizeSmallH, sizeSmallW + extra, sizeSmallH);
            ctx.restore();
          };

          const state = {
            match: null,
            timerId: null,
            endAt: 0,
            running: false,
            last: performance.now(),
            userInputX: null
          };

          const $strip = document.getElementById('strip');
          const $userCanvas = document.getElementById('userCanvas');
          $userCanvas.width = CANVAS_W;
          $userCanvas.height = CANVAS_H;
          const $userLives = document.getElementById('userLives');
          const $time = document.getElementById('time');
          const $pot = document.getElementById('pot');
          const $toast = document.getElementById('toast');
          const $winnerPopup = document.getElementById('winnerPopup');
          const $winnerAvatar = document.getElementById('winnerAvatar');
          const $winnerName = document.getElementById('winnerName');
          const $playAgain = document.getElementById('playAgain');
          const $lobbyBtn = document.getElementById('lobbyBtn');
          const $countdown = document.getElementById('countdown');

          const showToast = (msg) => {
            $toast.textContent = msg;
            $toast.classList.add('show');
            setTimeout(() => $toast.classList.remove('show'), 1700);
          };

          const clamp = (v, mi, ma) => Math.max(mi, Math.min(ma, v));
          const rand = (a, b) => Math.random() * (b - a) + a;
          const choice = (arr) => arr[(Math.random() * arr.length) | 0];
          const formatTime = (ms) => {
            const s = Math.max(0, Math.ceil(ms / 1000));
            const m = String((s / 60) | 0).padStart(2, '0');
            const ss = String(s % 60).padStart(2, '0');
            return `${m}:${ss}`;
          };
          const flagToDataUri = (flag) =>
            `data:image/svg+xml,${encodeURIComponent(`<svg xmlns='http://www.w3.org/2000/svg' width='64' height='64'><text x='50%' y='50%' font-size='48' text-anchor='middle' dominant-baseline='central'>${flag}</text></svg>`)}`;
          const regionNames = new Intl.DisplayNames(['en'], { type: 'region' });
          const flagToCountryCode = (flag) =>
            [...flag]
              .map((c) =>
                String.fromCharCode(c.codePointAt(0) - 0x1f1e6 + 0x41)
              )
              .join('');
          const flagToName = (flag) => regionNames.of(flagToCountryCode(flag));
          function coinConfetti(
            count = 50,
            iconSrc = '/assets/icons/ezgif-54c96d8a9b9236.webp'
          ) {
            const container = document.createElement('div');
            container.style.position = 'fixed';
            container.style.top = '0';
            container.style.left = '0';
            container.style.width = '100%';
            container.style.height = '0';
            container.style.pointerEvents = 'none';
            container.style.zIndex = '70';
            container.style.overflow = 'visible';
            document.body.appendChild(container);
            for (let i = 0; i < count; i++) {
              const img = document.createElement('img');
              img.src = iconSrc;
              img.alt = 'confetti icon';
              img.className = 'coin-confetti';
              const left = Math.random() * 100;
              const delay = Math.random() * 0.2;
              const duration = 2 + Math.random() * 2;
              img.style.left = left + 'vw';
              img.style.animationDelay = delay + 's';
              img.style.setProperty('--duration', duration + 's');
              container.appendChild(img);
            }
            setTimeout(() => container.remove(), 5000);
          }

          const rawPlayers = parseInt(params.get('players'), 10);
          const settings = {
            players: Math.max(
              2,
              Math.min(4, isNaN(rawPlayers) ? 4 : rawPlayers)
            ),
            stake: Math.max(0, parseInt(params.get('amount') || '0', 10)),
            density: params.get('density') || 'medium',
            duration: parseInt(params.get('duration'), 10) || 1
          };
          const avatars = params.get('avatars')
            ? params.get('avatars').split(',').map(decodeURIComponent)
            : [];
          const accounts = params.get('accounts')
            ? params.get('accounts').split(',')
            : [];
          const tgIds = params.get('tgIds')
            ? params.get('tgIds').split(',')
            : [];
          const userAvatar = params.get('avatar');
          const userName =
            params.get('name') ||
            window?.Telegram?.WebApp?.initDataUnsafe?.user?.first_name;
          const userAccount = params.get('accountId');
          const userTgId = params.get('tgId');
          const devAccountId = params.get('dev');
          const initParam = params.get('init');
          if (initParam && !window.Telegram) {
            window.Telegram = {
              WebApp: { initData: decodeURIComponent(initParam) }
            };
          }

          async function fetchPlayerName(tgId, accountId) {
            try {
              const headers = { 'Content-Type': 'application/json' };
              const initData = window?.Telegram?.WebApp?.initData;
              if (initData) headers['X-Telegram-Init-Data'] = initData;
              let res;
              if (tgId) {
                res = await fetch('/api/profile/telegram-info', {
                  method: 'POST',
                  headers,
                  body: JSON.stringify({ telegramId: tgId })
                });
              } else if (accountId) {
                res = await fetch('/api/profile/by-account', {
                  method: 'POST',
                  headers,
                  body: JSON.stringify({ accountId })
                });
              }
              if (res && res.ok) {
                const data = await res.json();
                return data.nickname || data.firstName || '';
              }
            } catch {}
            return '';
          }

          function genBricks(density) {
            const cols = 10,
              rows = density === 'high' ? 9 : density === 'medium' ? 8 : 7;
            const bricks = [];
            for (let r = 0; r < rows; r++) {
              for (let c = 0; c < cols; c++) {
                const roll = Math.random();
                let type = 'standard',
                  hits = 1,
                  pts = POINTS.standard;
                // Tough bricks remain a random chance
                if (roll > 0.55) {
                  type = 'tough';
                  hits = 2;
                  pts = POINTS.tough;
                }
                const powerup = Math.random() < 0.12 ? choice(POWERUPS) : null;
                bricks.push({
                  col: c,
                  row: r,
                  x: c * (VIEW_W / cols) + 4,
                  y: 72 + r * 28,
                  w: VIEW_W / cols - 8,
                  h: 20,
                  type,
                  hits,
                  pts,
                  color: choice(BRICK_COLORS),
                  alive: true,
                  powerup
                });
              }
            }
            // Randomly place 5-10 bombs after the grid is generated
            const bombCount = 5 + Math.floor(Math.random() * 6); // 5..10
            for (let i = 0; i < bombCount; i++) {
              let idx;
              do {
                idx = Math.floor(Math.random() * bricks.length);
              } while (bricks[idx].type === 'explosive');
              bricks[idx].type = 'explosive';
              bricks[idx].hits = 1;
              bricks[idx].pts = POINTS.explosive;
            }
            return bricks;
          }

          function createBoardState(index) {
            return {
              index,
              paddle: { x: VIEW_W / 2 - 45, y: VIEW_H - 80, w: 90, h: 18 },
              balls: [
                {
                  x: VIEW_W / 2,
                  y: VIEW_H - 80,
                  r: 6,
                  vx: 2.2 * (Math.random() < 0.5 ? -1 : 1),
                  vy: -3.2,
                  fire: false
                }
              ],
              lives: 3,
              score: 0,
              mult: 1,
              slow: false,
              bricks: genBricks(settings.density),
              powerups: [],
              activePowers: [],
              explosions: [],
              over: false
            };
          }

          function addMiniSlot(label, avatar) {
            const wrap = document.createElement('div');
            wrap.className = 'mini';
            wrap.innerHTML = `<h3><img class="avatar" src="${avatar}" alt="avatar"/>${label}</h3>`;
            const cv = document.createElement('canvas');
            cv.className = 'tetris-grid-bg';
            cv.width = CANVAS_W;
            cv.height = CANVAS_H;
            const ctx = cv.getContext('2d');
            ctx.scale(DPR, DPR);
            wrap.appendChild(cv);
            $strip.appendChild(wrap);
            return ctx;
          }

          function drawBoard(ctx, b) {
            const W = VIEW_W,
              H = VIEW_H;
            ctx.clearRect(0, 0, W, H);
            ctx.strokeStyle = COLORS.wall;
            ctx.lineWidth = OUTLINE;
            ctx.strokeRect(8, 52, W - 16, H - 82);
            ctx.fillStyle = COLORS.text;
            ctx.font = '14px system-ui';
            ctx.fillText(`Score: ${b.score}`, 12, 44);
            ctx.fillStyle = COLORS.danger;
            ctx.fillText('â™¥'.repeat(b.lives), W - 40, 44);
            for (const br of b.bricks) {
              if (!br.alive) continue;
              drawBlock(ctx, br.x, br.y, br.w, br.h, br.color);
              if (br.type === 'tough' && br.hits === 1) {
                ctx.fillStyle = 'rgba(255,255,255,0.5)';
                ctx.fillRect(br.x, br.y, br.w, br.h);
              }
              if (br.type === 'explosive') {
                ctx.fillStyle = COLORS.text;
                ctx.font = `${br.h - 4}px system-ui`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText('ðŸ’£', br.x + br.w / 2, br.y + br.h / 2 + 1);
                ctx.textAlign = 'left';
                ctx.textBaseline = 'alphabetic';
              }
              if (br.powerup) {
                if (br.powerup === 'life') {
                  ctx.fillStyle = COLORS.text;
                  ctx.font = `${br.h - 4}px system-ui`;
                  ctx.textAlign = 'center';
                  ctx.textBaseline = 'middle';
                  ctx.fillText('â¤ï¸', br.x + br.w / 2, br.y + br.h / 2 + 1);
                  ctx.textAlign = 'left';
                  ctx.textBaseline = 'alphabetic';
                } else {
                  const color = POWERUP_COLORS[br.powerup] || COLORS.power;
                  drawBall(ctx, br.x + br.w / 2, br.y + br.h / 2, 6, color);
                }
              }
            }
            for (const p of b.powerups) {
              const color = POWERUP_COLORS[p.kind] || COLORS.power;
              drawBall(ctx, p.x, p.y, 7, color);
            }
            for (const ex of b.explosions) {
              const size = (b.bricks[0]?.w || 20) * 3;
              ctx.save();
              ctx.globalAlpha = ex.timer / 300;
              ctx.fillStyle = COLORS.text;
              ctx.font = `${size}px system-ui`;
              ctx.textAlign = 'center';
              ctx.textBaseline = 'middle';
              ctx.fillText('ðŸ’¥', ex.x, ex.y);
              ctx.restore();
            }
            let paddleColor = COLORS.paddle;
            if (b.activePowers.length) {
              paddleColor = POWERUP_COLORS[b.activePowers[0]] || COLORS.paddle;
            }
            drawBlock(ctx, b.paddle.x, b.paddle.y, b.paddle.w, b.paddle.h, paddleColor);
            if (b.activePowers.length) {
              ctx.fillStyle = COLORS.text;
              ctx.font = '10px system-ui';
              ctx.textAlign = 'center';
              ctx.textBaseline = 'middle';
              ctx.fillText(
                b.activePowers[0],
                b.paddle.x + b.paddle.w / 2,
                b.paddle.y + b.paddle.h / 2
              );
              ctx.textAlign = 'left';
              ctx.textBaseline = 'alphabetic';
            }
            for (const ball of b.balls) {
              let color = COLORS.ball;
              if (ball.fire) color = POWERUP_COLORS.fireball;
              else if (b.balls.length > 1) color = POWERUP_COLORS.multiball;
              else if (b.slow) color = POWERUP_COLORS.slow;
              else if (b.mult > 1) color = POWERUP_COLORS.x2;
              else if (b.paddle.w > 90) color = POWERUP_COLORS.wide;
              drawBall(ctx, ball.x, ball.y, ball.r, color);
            }
          }

          function applyPowerup(b, kind) {
            const addLabel = (label, ms) => {
              if (!b.activePowers.includes(label)) b.activePowers.push(label);
              setTimeout(() => {
                b.activePowers = b.activePowers.filter((x) => x !== label);
              }, ms);
            };
            if (kind === 'multiball') {
              addLabel('multiball', 10000);
              const base = b.balls[0] || {
                x: VIEW_W / 2,
                y: VIEW_H - 100,
                r: 6,
                vx: 2.1,
                vy: -3.0
              };
              while (b.balls.length < 3) {
                b.balls.push({
                  x: base.x,
                  y: base.y,
                  r: 6,
                  vx: rand(-2.5, 2.5),
                  vy: -rand(2.5, 3.8),
                  fire: false
                });
              }
              setTimeout(() => {
                b.balls = [b.balls[0]];
              }, 10000);
            }
            if (kind === 'fireball') {
              addLabel('fireball', 5000);
              b.balls.forEach((ball) => (ball.fire = true));
              setTimeout(
                () => b.balls.forEach((ball) => (ball.fire = false)),
                5000
              );
            }
            if (kind === 'wide') {
              addLabel('wide', 10000);
              b.paddle.w = Math.min(150, b.paddle.w + 40);
              setTimeout(() => (b.paddle.w = 90), 10000);
            }
            if (kind === 'slow') {
              addLabel('slow', 5000);
              b.slow = true;
              setTimeout(() => (b.slow = false), 5000);
            }
            if (kind === 'x2') {
              addLabel('x2', 5000);
              b.mult = 2;
              setTimeout(() => (b.mult = 1), 5000);
            }
            if (kind === 'life') {
              addLabel('life', 2000);
              b.lives++;
              if (state.match && b.index === state.match.userIdx)
                $userLives.textContent = 'â™¥'.repeat(Math.max(0, b.lives));
            }
            if (kind === 'shrink') {
              addLabel('shrink', 10000);
              b.paddle.w = Math.max(60, b.paddle.w - 30);
              setTimeout(() => (b.paddle.w = 90), 10000);
            }
          }

          function updateBoard(b, dt, inputX = null) {
            if (b.over) return;
            for (const ex of [...b.explosions]) {
              ex.timer -= dt;
              if (ex.timer <= 0) b.explosions = b.explosions.filter((x) => x !== ex);
            }
            if (inputX != null) {
              const target = clamp(
                inputX - b.paddle.w / 2,
                12,
                VIEW_W - b.paddle.w - 12
              );
              b.paddle.x = target;
            } else if (!state.match || b.index !== state.match.userIdx) {
              const balls = b.balls.filter((ball) => ball.vy > 0);
              let target = b.paddle.x;
              if (balls.length) {
                const ball = balls.reduce((a, c) => (c.y > a.y ? c : a));
                const time = (b.paddle.y - ball.y) / ball.vy;
                let projected = ball.x + ball.vx * time;
                const left = 10 + ball.r;
                const right = VIEW_W - 10 - ball.r;
                while (projected < left || projected > right) {
                  if (projected < left) projected = left + (left - projected);
                  else if (projected > right)
                    projected = right - (projected - right);
                }
                target = projected - b.paddle.w / 2 + rand(-6, 6);
              }
              const speed = 3.5;
              b.paddle.x += clamp(target - b.paddle.x, -speed, speed);
              b.paddle.x = clamp(b.paddle.x, 12, VIEW_W - b.paddle.w - 12);
            }

            for (const ball of [...b.balls]) {
              ball.x += ball.vx * (dt * 0.06) * (b.slow ? 0.75 : 1);
              ball.y += ball.vy * (dt * 0.06) * (b.slow ? 0.75 : 1);
              if (ball.x - ball.r < 10) {
                ball.x = 10 + ball.r;
                ball.vx = Math.abs(ball.vx);
              }
              if (ball.x + ball.r > VIEW_W - 10) {
                ball.x = VIEW_W - 10 - ball.r;
                ball.vx = -Math.abs(ball.vx);
              }
              if (ball.y - ball.r < 54) {
                ball.y = 54 + ball.r;
                ball.vy = Math.abs(ball.vy);
              }
              if (ball.y - ball.r > VIEW_H - 20) {
                b.balls = b.balls.filter((x) => x !== ball);
                if (b.balls.length === 0) {
                  b.lives--;
                  if (inputX != null)
                    $userLives.textContent = 'â™¥'.repeat(Math.max(0, b.lives));
                  if (b.lives <= 0) {
                    b.over = true;
                    continue;
                  }
                  b.balls.push({
                    x: VIEW_W / 2,
                    y: VIEW_H - 80,
                    r: 6,
                    vx: 2.2 * (Math.random() < 0.5 ? -1 : 1),
                    vy: -3.2,
                    fire: false
                  });
                }
                continue;
              }
              const p = b.paddle;
              if (
                ball.y + ball.r >= p.y &&
                ball.y - ball.r <= p.y + p.h &&
                ball.x >= p.x &&
                ball.x <= p.x + p.w &&
                ball.vy > 0
              ) {
                ball.y = p.y - ball.r;
                const hit = ((ball.x - p.x) / p.w - 0.5) * 2;
                const speedBoost = 3.1 + Math.min(2.0, Math.abs(hit) * 1.6);
                ball.vx = hit * speedBoost;
                ball.vy = -Math.abs(speedBoost);
              }
              for (const br of b.bricks) {
                if (!br.alive) continue;
                if (
                  ball.x > br.x &&
                  ball.x < br.x + br.w &&
                  ball.y > br.y &&
                  ball.y < br.y + br.h
                ) {
                  b.score += br.pts * b.mult;
                  if (br.type === 'explosive') {
                    br.alive = false;
                    b.explosions.push({
                      x: br.x + br.w / 2,
                      y: br.y + br.h / 2,
                      timer: 300
                    });
                    bombAudio.currentTime = 0;
                    bombAudio.play().catch(() => {});
                    for (const nb of b.bricks) {
                      if (!nb.alive || nb === br) continue;
                      const isNeighbor =
                        (nb.row === br.row && Math.abs(nb.col - br.col) === 1) ||
                        (nb.col === br.col && Math.abs(nb.row - br.row) === 1);
                      if (isNeighbor) {
                        nb.alive = false;
                        b.score += nb.pts * b.mult;
                      }
                    }
                    if (!ball.fire) ball.vy *= -1;
                  } else {
                    br.hits--;
                    if (br.hits <= 0) br.alive = false;
                    if (!ball.fire) ball.vy *= -1;
                  }
                  if (br.powerup) {
                    b.powerups.push({
                      x: ball.x,
                      y: br.y + br.h,
                      vy: 1.6,
                      kind: br.powerup
                    });
                  }
                  break;
                }
              }
            }

            for (const pu of [...b.powerups]) {
              pu.y += pu.vy * (dt * 0.06);
              const p = b.paddle;
              if (pu.y >= p.y - 4 && pu.x >= p.x && pu.x <= p.x + p.w) {
                applyPowerup(b, pu.kind);
                b.powerups = b.powerups.filter((x) => x !== pu);
              }
              if (pu.y > VIEW_H + 10) {
                b.powerups = b.powerups.filter((x) => x !== pu);
              }
            }
            if (b.bricks.every((br) => !br.alive)) {
              b.bricks = genBricks(settings.density);
            }
          }

          async function startMatch() {
            const n = settings.players;
            const stake = settings.stake;
            GAME_DURATION_MS = settings.duration * 60000;
            $pot.textContent = String(stake * n);

            const states = [];
            for (let i = 0; i < n; i++) states.push(createBoardState(i));
            const players = [];
            for (let i = 0; i < n; i++) {
              const playerTgId = i === n - 1 ? userTgId : tgIds[i];
              const playerAccount = i === n - 1 ? userAccount : accounts[i];
              let avatar = i === n - 1 ? userAvatar || avatars[i] : avatars[i];
              let name;
              if (playerTgId || playerAccount) {
                name = await fetchPlayerName(playerTgId, playerAccount);
              }
              if (!name && i === n - 1) name = userName;
              if (!avatar || !name) {
                const flag = choice(FLAG_EMOJIS);
                if (!avatar) avatar = flagToDataUri(flag);
                if (!name) name = flagToName(flag);
              }
              players.push({
                name: name || `P${i + 1}`,
                avatar,
                accountId: playerAccount,
                telegramId: playerTgId
              });
            }
            document.getElementById('userLabel').textContent =
              players[n - 1].name;
            document.getElementById('userAvatar').src = players[n - 1].avatar;
            $strip.innerHTML = '';
            const miniCtxs = [];
            const oppCount = Math.min(3, n - 1);
            for (let i = 0; i < oppCount; i++) {
              miniCtxs[i] = addMiniSlot(players[i].name, players[i].avatar);
            }

            const userCtx = $userCanvas.getContext('2d');
            userCtx.scale(DPR, DPR);
            state.match = {
              n,
              stakeTPC: stake,
              states,
              miniCtxs,
              userIdx: n - 1,
              userCtx,
              players
            };

            const setUserX = (clientX) => {
              const r = $userCanvas.getBoundingClientRect();
              state.userInputX = ((clientX - r.left) / r.width) * VIEW_W;
            };
            $userCanvas.onpointerdown = (e) => setUserX(e.clientX);
            $userCanvas.onpointermove = (e) => {
              if (e.buttons === 1) setUserX(e.clientX);
            };
            $userCanvas.onpointerup = () => (state.userInputX = null);
            $userCanvas.onpointerleave = () => (state.userInputX = null);
            $userCanvas.onpointercancel = () => (state.userInputX = null);

            state.endAt = performance.now() + GAME_DURATION_MS;
            state.running = true;
            state.last = performance.now();
            loop();
            if (state.timerId) cancelAnimationFrame(state.timerId);
            updateTimer();
          }

          function updateTimer() {
            if (!state.running) return;
            const ms = state.endAt - performance.now();
            $time.textContent = formatTime(ms);
            if (ms <= 0) {
              endMatch();
              return;
            }
            state.timerId = requestAnimationFrame(updateTimer);
          }

          function checkEarlyWin() {
            const user = state.match.states[state.match.userIdx];
            const others = state.match.states.filter(
              (_, i) => i !== state.match.userIdx
            );
            const allOut = others.every((s) => s.lives <= 0);
            const ahead = others.every((s) => user.score > s.score);
            const timeLeft = state.endAt - performance.now();
            if (allOut && ahead && timeLeft > 0) {
              endMatch();
            }
          }

          function loop() {
            if (!state.running) return;
            const now = performance.now();
            const dt = now - state.last;
            state.last = now;
            const oppCount = Math.min(3, state.match.n - 1);
            for (let i = 0; i < oppCount; i++) {
              const st = state.match.states[i];
              updateBoard(st, dt, null);
              drawBoard(state.match.miniCtxs[i], st);
            }
            const u = state.match.states[state.match.userIdx];
            updateBoard(u, dt, state.userInputX);
            drawBoard(state.match.userCtx, u);
            checkEarlyWin();
            requestAnimationFrame(loop);
          }

          function countdownAndStart() {
            if (
              document.documentElement.requestFullscreen &&
              !document.fullscreenElement
            ) {
              document.documentElement.requestFullscreen().catch(() => {});
            }
            let c = 3;
            $countdown.textContent = c;
            $countdown.classList.remove('hidden');
            const timer = setInterval(() => {
              c--;
              if (c > 0) {
                $countdown.textContent = c;
              } else {
                clearInterval(timer);
                $countdown.classList.add('hidden');
                startMatch();
              }
            }, 1000);
          }

          async function awardDevShare(total) {
            if (!devAccountId) return;
            try {
              await bbApi.depositAccount(
                devAccountId,
                Math.round(total * 0.1),
                { game: 'brickbreaker-dev' }
              );
            } catch {}
          }

          function endMatch() {
            state.running = false;
            const scores = state.match.states.map((s, i) => ({
              i,
              score: s.score,
              lives: s.lives
            }));
            const max = Math.max(...scores.map((s) => s.score));
            const winners = scores.filter((s) => s.score === max);
            const potGross = state.match.stakeTPC * state.match.n;
            const fee = Math.round(potGross * 0.1);
            const potNet = potGross - fee;
            const payoutEach = winners.length
              ? Math.floor(potNet / winners.length)
              : 0;
            awardDevShare(potGross);
            winners.forEach((w) => {
              const info = state.match.players[w.i];
              if (info && info.accountId && payoutEach > 0) {
                bbApi.depositAccount(info.accountId, payoutEach, {
                  game: 'brickbreaker-win'
                });
                if (info.telegramId)
                  bbApi.addTransaction(info.telegramId, 0, 'win', {
                    game: 'brickbreaker',
                    players: state.match.n,
                    accountId: info.accountId
                  });
              }
            });
            const winInfo = state.match.players[winners[0].i];
            $winnerAvatar.src = winInfo.avatar;
            $winnerName.textContent = `${winInfo.name} wins ${payoutEach} TPC`;
            $winnerPopup.classList.remove('hidden');
            coinConfetti(50);
          }

          $playAgain.addEventListener('click', () => {
            $winnerPopup.classList.add('hidden');
            countdownAndStart();
          });
          $lobbyBtn.addEventListener('click', () => {
            location.href = '/games/brickbreaker/lobby';
          });

          countdownAndStart();
        })();
      }
    </script>
  </body>
</html>
