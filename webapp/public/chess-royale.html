<!doctype html>
<!--
Open‑source 3D Chess (Three.js, ES Modules) — ABeautifulGame asset
• Engine: three.js r159 (MIT)
• Controls/Loader: OrbitControls.js, GLTFLoader.js from three.js examples (MIT)
• Model: “A Beautiful Game” chess set (glTF) from KhronosGroup/glTF‑Sample‑Assets (CC‑BY 4.0)
This is a fresh codebase (different from previous) with ES Module imports and robust multi‑CDN fallback.
Tone mapping: ACESFilmic, exposure 1.85. +Y up. Mobile orbit + pinch zoom enabled.
-->
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Chess Battle Royal — 3D ABeautifulGame set</title>
  <style>
    html,body{margin:0;height:100%;overflow:hidden;background:#0b0f16;color:#e8eef7;font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif}
    #app{position:fixed;inset:0}
    canvas{display:block;width:100%;height:100%}
    .hud{position:fixed;left:10px;top:10px;display:flex;gap:8px;align-items:center;background:rgba(255,255,255,.06);border:1px solid rgba(255,255,255,.12);backdrop-filter:blur(8px);padding:8px 10px;border-radius:10px;font-size:12px;z-index:2}
    .btn{cursor:pointer;background:rgba(255,255,255,.08);border:1px solid rgba(255,255,255,.25);color:#e8eef7;padding:6px 10px;border-radius:8px}
    .btn:active{transform:translateY(1px)}
    .badge{position:fixed;right:12px;bottom:12px;font-size:12px;padding:6px 10px;border-radius:8px;background:rgba(12,180,75,.15);border:1px solid rgba(12,180,75,.35);color:#c7f7da;z-index:2}
    .badge.fail{background:rgba(200,20,20,.15);border-color:rgba(200,20,20,.45);color:#ffd8d8}
    .failbox{position:fixed;inset:0;display:none;place-items:center;text-align:center;padding:24px}
    .failbox.show{display:grid}
    .failbox>div{max-width:760px;background:rgba(255,255,255,.06);border:1px solid rgba(255,255,255,.18);padding:18px 20px;border-radius:12px}
    a{color:#9cd1ff}
    .toolbar{position:fixed;left:10px;bottom:10px;display:flex;gap:8px;background:rgba(255,255,255,.06);border:1px solid rgba(255,255,255,.12);backdrop-filter:blur(8px);padding:8px 10px;border-radius:10px;font-size:12px;z-index:2}
    .toggle{display:inline-flex;align-items:center;gap:6px}
    input[type="checkbox"]{accent-color:#3fbf7f}
  </style>
</head>
<body>
  <div class="hud">
    <button id="reset" class="btn">Reset view</button>
    <span>Drag = orbit · Pinch/Wheel = zoom</span>
  </div>
  <div id="app"></div>
  <div id="badge" class="badge">Loading open‑source chess…</div>
  <div id="fail" class="failbox"><div>
    <h3>Preview nuk u ngarkua</h3>
    <p>Skriptet ose modeli nuk u shkarkuan nga CDN‑të. Ky projekt është plotësisht open‑source (Three.js MIT, model “A Beautiful Game” CC‑BY 4.0). Provoje përsëri, ose hap <a href="https://github.com/KhronosGroup/glTF-Sample-Assets/tree/main/Models/ABeautifulGame" target="_blank" rel="noopener">burimin e modelit</a>.</p>
  </div></div>
  <div class="toolbar">
    <label class="toggle"><input id="hdr" type="checkbox" checked /> HDR env</label>
    <label class="toggle"><input id="focus" type="checkbox" /> Focus highlight</label>
    <label class="toggle"><input id="turn" type="checkbox" /> Turntable</label>
  </div>

  <script type="module">
  const badge = document.getElementById('badge');
  const failBox = document.getElementById('fail');
  let MODEL_LOADED=false;

  // ESM CDN fallbacks (prefer ESM CDNs first)
  const THREE_URLS = [
    'https://cdn.jsdelivr.net/npm/three@0.159.0/build/three.module.js',
    'https://unpkg.com/three@0.159.0/build/three.module.js',
    'https://esm.sh/three@0.159.0',
    'https://cdn.skypack.dev/three@0.159.0'
  ];
  const ORBIT_URLS = [
    'https://cdn.jsdelivr.net/npm/three@0.159.0/examples/jsm/controls/OrbitControls.js',
    'https://unpkg.com/three@0.159.0/examples/jsm/controls/OrbitControls.js',
    'https://esm.sh/three@0.159.0/examples/jsm/controls/OrbitControls.js',
    'https://cdn.skypack.dev/three@0.159.0/examples/jsm/controls/OrbitControls.js'
  ];
  const GLTF_URLS = [
    'https://cdn.jsdelivr.net/npm/three@0.159.0/examples/jsm/loaders/GLTFLoader.js',
    'https://unpkg.com/three@0.159.0/examples/jsm/loaders/GLTFLoader.js',
    'https://esm.sh/three@0.159.0/examples/jsm/loaders/GLTFLoader.js',
    'https://cdn.skypack.dev/three@0.159.0/examples/jsm/loaders/GLTFLoader.js'
  ];

  // ABeautifulGame (glTF JSON with external BIN & textures) — use mirrors
  const MODEL_URLS = [
    'https://raw.githubusercontent.com/KhronosGroup/glTF-Sample-Assets/main/Models/ABeautifulGame/glTF/ABeautifulGame.gltf',
    'https://cdn.jsdelivr.net/gh/KhronosGroup/glTF-Sample-Assets@main/Models/ABeautifulGame/glTF/ABeautifulGame.gltf',
    'https://fastly.jsdelivr.net/gh/KhronosGroup/glTF-Sample-Assets@main/Models/ABeautifulGame/glTF/ABeautifulGame.gltf'
  ];

  const HDRI_URLS = [
    // Royal Esplanade (three.js examples) — optional
    'https://raw.githubusercontent.com/mrdoob/three.js/dev/examples/textures/equirectangular/royal_esplanade_1k.hdr',
    'https://raw.githubusercontent.com/mrdoob/three.js/master/examples/textures/equirectangular/royal_esplanade_1k.hdr'
  ];

  async function tryUrls(urls, importer){
    let lastErr; for(const u of urls){
      try{ const v = await importer(u); return v; }catch(e){ lastErr=e; }
    }
    throw lastErr || new Error('All attempts failed');
  }

  (async function boot(){
    try{
      badge.textContent = 'Importing three.module.js…';
      const THREE_NS = await tryUrls(THREE_URLS, u=>import(u));

      // Clone namespace to a mutable object to avoid "object not extensible" errors
      const THREE = Object.assign({}, THREE_NS);
      window.THREE = THREE;
      if(THREE.REVISION && THREE.REVISION!=='159') console.warn('Three.js revision', THREE.REVISION);

      badge.textContent = 'Importing OrbitControls & GLTFLoader…';
      const { OrbitControls } = await tryUrls(ORBIT_URLS, u=>import(u));
      const { GLTFLoader }  = await tryUrls(GLTF_URLS, u=>import(u));
      THREE.OrbitControls = OrbitControls; // attach to mutable clone
      THREE.GLTFLoader   = GLTFLoader;

      badge.textContent = 'Starting scene…';
      start(THREE);
    }catch(e){
      console.error(e);
      badge.textContent = 'Init failed';
      badge.classList.add('fail');
      failBox.classList.add('show');
    }
  })();

  function start(THREE){
    const app = document.getElementById('app');
    const renderer = new THREE.WebGLRenderer({ antialias:true });
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.setSize(innerWidth, innerHeight);
    renderer.outputColorSpace = THREE.SRGBColorSpace;
    renderer.toneMapping = THREE.ACESFilmicToneMapping; // ACES
    renderer.toneMappingExposure = 1.85;
    renderer.shadowMap.enabled = true;
    app.appendChild(renderer.domElement);

    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x0b0f16);

    const camera = new THREE.PerspectiveCamera(45, innerWidth/innerHeight, 0.1, 2000);
    camera.position.set(10, 12, 18);

    const controls = new THREE.OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true; controls.dampingFactor = 0.06;
    controls.minDistance = 6; controls.maxDistance = 60; controls.target.set(0,2,0); controls.update();

    // Three‑point lighting
    const ambient = new THREE.AmbientLight(0xffffff, 0.35); scene.add(ambient);
    const key = new THREE.DirectionalLight(0xffffff, 1.2); key.position.set(12,16,10); key.castShadow = true; scene.add(key);
    const fill = new THREE.DirectionalLight(0xffffff, 0.6); fill.position.set(-10,8,4); scene.add(fill);
    const rim = new THREE.DirectionalLight(0xffffff, 0.9); rim.position.set(0,10,-12); scene.add(rim);

    // Ground plane for contact shadows
    const ground = new THREE.Mesh(
      new THREE.PlaneGeometry(140,140),
      new THREE.MeshStandardMaterial({ color: 0x0a0d12, roughness: 0.9, metalness: 0.0 })
    );
    ground.rotation.x = -Math.PI/2; ground.receiveShadow = true; scene.add(ground);

    // Optional HDRI environment toggle
    const hdrToggle = document.getElementById('hdr');
    let hdrTex=null;
    async function setHDR(on){
      if(!on){ scene.environment=null; renderer.toneMappingExposure=1.85; return; }
      try{
        const { RGBELoader } = await import('https://cdn.jsdelivr.net/npm/three@0.159.0/examples/jsm/loaders/RGBELoader.js');
        const url = await tryUrls(HDRI_URLS, u=>fetch(u,{mode:'cors'}).then(r=>r.ok?u:Promise.reject(new Error('hdr fetch fail'))));
        const l = new RGBELoader();
        hdrTex = await new Promise((res,rej)=> l.load(url, res, undefined, rej));
        hdrTex.mapping = THREE.EquirectangularReflectionMapping;
        scene.environment = hdrTex;
        renderer.toneMappingExposure = 1.35;
      }catch(e){ console.warn('HDRI failed', e); }
    }
    setHDR(true); hdrToggle.addEventListener('change', e=>setHDR(e.target.checked));

    // Load the chess model (glTF JSON + external resources)
    const loader = new THREE.GLTFLoader();
    (async()=>{
      try{
        badge.textContent = 'Downloading ABeautifulGame (glTF)…';
        const modelUrl = await tryUrls(MODEL_URLS, u=>new Promise((res,rej)=>loader.load(u,()=>res(u),undefined,rej)));
        badge.textContent = 'Model URL OK: '+modelUrl;
        loader.load(modelUrl, (gltf)=>{
          const root = gltf.scene; root.traverse(o=>{ if(o.isMesh){ o.castShadow = true; o.receiveShadow = true; }});
          // Center & scale to nice view
          const box = new THREE.Box3().setFromObject(root); const size=new THREE.Vector3(); box.getSize(size); const center=new THREE.Vector3(); box.getCenter(center);
          const s = 0.85 * (12 / Math.max(size.x, size.z));
          root.scale.setScalar(s);
          root.position.sub(center.multiplyScalar(s));
          root.position.y = 0.02;
          scene.add(root);
          MODEL_LOADED=true;
          badge.textContent = 'Loaded: ABeautifulGame (CC‑BY 4.0)';
        }, undefined, (err)=>{ throw err; });
      }catch(e){ console.error(e); badge.textContent='Model failed'; badge.classList.add('fail'); failBox.classList.add('show'); }
    })();

    // Picking/highlight (optional)
    const focusToggle = document.getElementById('focus');
    const ray = new THREE.Raycaster();
    const mouse = new THREE.Vector2();
    let lastPick=null, lastMat=null; let highlightOn=false;
    function onPointer(ev){ if(!highlightOn) return; const rect=renderer.domElement.getBoundingClientRect(); const x=(ev.clientX-rect.left)/rect.width; const y=(ev.clientY-rect.top)/rect.height; mouse.set(x*2-1, -(y*2-1)); ray.setFromCamera(mouse, camera); const hits = ray.intersectObjects(scene.children, true); if(hits.length){ const m = hits[0].object; if(lastPick!==m){ if(lastPick){ lastPick.material=lastMat; lastPick=null; } lastPick=m; lastMat=m.material; m.material = lastMat.clone(); m.material.emissive = new THREE.Color(0x88ffcc); m.material.emissiveIntensity=0.4; } } }
    focusToggle.addEventListener('change', e=>{ highlightOn=e.target.checked; if(!highlightOn && lastPick){ lastPick.material=lastMat; lastPick=null; } });
    addEventListener('pointermove', onPointer);

    // Turntable animation toggle
    const turnToggle = document.getElementById('turn');
    let spin=false; turnToggle.addEventListener('change', e=>{ spin=e.target.checked; });

    function resize(){
      renderer.setSize(innerWidth, innerHeight);
      camera.aspect = innerWidth/innerHeight; camera.updateProjectionMatrix();
    }
    addEventListener('resize', resize);

    document.getElementById('reset').addEventListener('click', ()=>{
      camera.position.set(10,12,18); controls.target.set(0,2,0); controls.update();
    });

    (function loop(){
      requestAnimationFrame(loop);
      if(spin){ camera.position.applyAxisAngle(new THREE.Vector3(0,1,0), 0.003); controls.update(); }
      controls.update(); renderer.render(scene, camera);
    })();

    // ===== Tests (leave logic intact; add a couple more) =====
    try{
      if(!window.THREE) throw new Error('THREE not found');
      if(THREE.REVISION && THREE.REVISION !== '159') throw new Error('Unexpected THREE revision: '+THREE.REVISION);
      if(!THREE.OrbitControls) throw new Error('OrbitControls not found');
      if(!THREE.GLTFLoader) throw new Error('GLTFLoader not found');
      if(!Object.isExtensible(THREE)) throw new Error('THREE object is not extensible');
      if(renderer.getContext() == null) throw new Error('WebGL context missing');
      const lights = scene.children.filter(o=>o.isLight).length; if(lights<3) throw new Error('Lights missing');
      // async test for model within timeout
      setTimeout(()=>{ if(!MODEL_LOADED){ badge.textContent='Tests failed: model not loaded (network/CDN blocked)'; badge.classList.add('fail'); } }, 9000);
      badge.textContent = 'Ready';
    }catch(err){ badge.textContent = 'Tests failed: '+err.message; badge.classList.add('fail'); }
  }
  </script>
</body>
</html>
