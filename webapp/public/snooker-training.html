<!DOCTYPE html>
<html lang="sq">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Tavolinë Snooker – Canvas (Portret, Fullscreen)</title>
  <style>
    :root {
      --felt: #0f6b3a;
      --felt-light: #178a4b;
      --felt-dark: #0d5a30;
      --wood-1: #c86f2b;
      --wood-2: #a6571e;
      --wood-3: #de8a42;
      --cushion: #1a7a42;
      --line: #e8f7e9;
      --pocket: #141414;
    }
    html, body { height: 100%; margin: 0; background: #0b0f1a; }
    #table {
      width: 97vw;
      height: 97vh;
      display: block;
      margin: auto;
      border-radius: 22px;
    }
  </style>
</head>
<body>
  <canvas id="table"></canvas>
  <script>
    const CONFIG = {
      rail: 48,
      cushion: 22,
      pocketRadius: 26,
      sightSpacing: 120,
      sightRadius: 3.5,
      lineWidth: 2,
      spotRadius: 3.2,
      rotate90: false,
      rotate180: true,
      baulkFromCushion: 0.206,
      pinkFromTop: 0.75,
      blackFromTop: 0.89,
      cornerCurve: 28, // radius i harkut te cepat
      sideCurve: 34    // radius i harkut anësor
    };

    const canvas = document.getElementById('table');
    const ctx = canvas.getContext('2d');

    function resize() {
      const dpr = Math.max(1, window.devicePixelRatio || 1);
      const w = canvas.clientWidth;
      const h = canvas.clientHeight;
      canvas.width = Math.floor(w * dpr);
      canvas.height = Math.floor(h * dpr);
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
      draw();
    }

    function draw() {
      let W = canvas.clientWidth;
      let H = canvas.clientHeight;

      ctx.save();
      if (CONFIG.rotate90) {
        ctx.translate(W, 0);
        ctx.rotate(Math.PI / 2);
        const tmp = W; W = H; H = tmp;
      }
      if (CONFIG.rotate180) {
        ctx.translate(W / 2, H / 2);
        ctx.rotate(Math.PI);
        ctx.translate(-W / 2, -H / 2);
      }

      const R = CONFIG.rail;
      const C = CONFIG.cushion;
      const ix = R + C;
      const iy = R + C;
      const iw = W - 2 * (R + C);
      const ih = H - 2 * (R + C);

      ctx.clearRect(0, 0, W, H);
      drawShadow(W, H);
      drawWoodRail(W, H, R);
      drawCushions(ix, iy, iw, ih, R, C);
      drawFelt(ix, iy, iw, ih);
      const pockets = drawPockets(W, H, R, C);
      drawPocketGuides(pockets, ix, iy, iw, ih);
      drawRailSights(W, H, R);
      drawSnookerMarkings(ix, iy, iw, ih);

      ctx.restore();
    }

    function drawShadow(W, H) {
      const g = ctx.createLinearGradient(0, 0, 0, H);
      g.addColorStop(0, 'rgba(0,0,0,.35)');
      g.addColorStop(1, 'rgba(0,0,0,.55)');
      ctx.fillStyle = g;
      roundRect(ctx, 6, 6, W - 12, H - 12, 24);
      ctx.fill();
    }

    function drawWoodRail(W, H, R) {
      const g = ctx.createLinearGradient(0, 0, 0, H);
      g.addColorStop(0, getVar('--wood-3'));
      g.addColorStop(.5, getVar('--wood-1'));
      g.addColorStop(1, getVar('--wood-2'));
      ctx.fillStyle = g;
      roundRect(ctx, 0, 0, W, H, 20);
      ctx.fill();

      ctx.save();
      ctx.globalCompositeOperation = 'destination-out';
      roundRect(ctx, R, R, W - 2 * R, H - 2 * R, 15);
      ctx.fill();
      ctx.restore();
    }

    function drawCushions(ix, iy, iw, ih, R, C) {
      const x = R, y = R, w = (ix - R) + iw + C, h = (iy - R) + ih + C;
      const g = ctx.createLinearGradient(0, y, 0, y + C);
      g.addColorStop(0, '#0e4d2a');
      g.addColorStop(1, getVar('--cushion'));
      ctx.fillStyle = g;
      roundRect(ctx, x, y, w, h, 12);
      ctx.fill();

      ctx.save();
      ctx.globalCompositeOperation = 'destination-out';
      ctx.beginPath();
      moveInnerWithCurves(ctx, ix, iy, iw, ih);
      ctx.fill();
      ctx.restore();
    }

    function moveInnerWithCurves(c, x, y, w, h) {
      const top = y, bottom = y + h, left = x, right = x + w;
      const midY = y + h / 2;
      const cornerR = CONFIG.cornerCurve;
      const sideR = CONFIG.sideCurve;

      c.moveTo(left + cornerR, top);
      c.lineTo(right - cornerR, top);
      c.quadraticCurveTo(right, top, right, top + cornerR);

      c.lineTo(right, midY - sideR);
      c.quadraticCurveTo(right, midY, right - sideR, midY);
      c.quadraticCurveTo(right, midY, right, midY + sideR);

      c.lineTo(right, bottom - cornerR);
      c.quadraticCurveTo(right, bottom, right - cornerR, bottom);

      c.lineTo(left + cornerR, bottom);
      c.quadraticCurveTo(left, bottom, left, bottom - cornerR);

      c.lineTo(left, midY + sideR);
      c.quadraticCurveTo(left, midY, left + sideR, midY);
      c.quadraticCurveTo(left, midY, left, midY - sideR);

      c.lineTo(left, top + cornerR);
      c.quadraticCurveTo(left, top, left + cornerR, top);
      c.closePath();
    }

    function drawFelt(ix, iy, iw, ih) {
      const g = ctx.createRadialGradient(
        ix + iw * 0.5,
        iy + ih * 0.45,
        Math.min(iw, ih) * 0.05,
        ix + iw * 0.5,
        iy + ih * 0.5,
        Math.max(iw, ih) * 0.8
      );
      g.addColorStop(0, getVar('--felt-light'));
      g.addColorStop(0.6, getVar('--felt'));
      g.addColorStop(1, getVar('--felt-dark'));
      ctx.fillStyle = g;
      ctx.fillRect(ix, iy, iw, ih);
    }

    function drawPockets(W, H, R, C) {
      const ix = R + C, iy = R + C, iw = W - 2 * (R + C), ih = H - 2 * (R + C);
      const pr = CONFIG.pocketRadius;
      ctx.fillStyle = getVar('--pocket');
      const midY = iy + ih / 2;
      const pockets = [
        { x: ix - 6, y: iy - 6, r: pr },
        { x: ix + iw + 6, y: iy - 6, r: pr },
        { x: ix - 6, y: iy + ih + 6, r: pr },
        { x: ix + iw + 6, y: iy + ih + 6, r: pr },
        { x: ix - 6, y: midY, r: pr },
        { x: ix + iw + 6, y: midY, r: pr }
      ];
      pockets.forEach(p => {
        ctx.beginPath();
        ctx.arc(p.x, p.y, p.r, 0, Math.PI * 2);
        ctx.fill();
      });
      return pockets;
    }

    function drawRailSights(W, H, R) {
      const spacing = CONFIG.sightSpacing;
      ctx.fillStyle = 'rgba(0,0,0,.7)';
      for (let x = R + spacing; x <= W - R - spacing; x += spacing) {
        ctx.beginPath(); ctx.arc(x, R * 0.55, CONFIG.sightRadius, 0, Math.PI * 2); ctx.fill();
        ctx.beginPath(); ctx.arc(x, H - R * 0.55, CONFIG.sightRadius, 0, Math.PI * 2); ctx.fill();
      }
      for (let y = R + spacing; y <= H - R - spacing; y += spacing) {
        ctx.beginPath(); ctx.arc(R * 0.55, y, CONFIG.sightRadius, 0, Math.PI * 2); ctx.fill();
        ctx.beginPath(); ctx.arc(W - R * 0.55, y, CONFIG.sightRadius, 0, Math.PI * 2); ctx.fill();
      }
    }

    function drawSnookerMarkings(ix, iy, iw, ih) {
      // Snooker-specific markings are omitted to match the pool-style field
    }

    function drawPocketGuides(pockets, ix, iy, iw, ih) {
      ctx.strokeStyle = 'rgba(0,255,0,0.8)';
      ctx.lineWidth = 2;
      const cornerGap = ctx.lineWidth * 4;
      const sideGap = ctx.lineWidth * 2;
      const topY = iy;
      const bottomY = iy + ih;
      const xLeft = ix;
      const xRight = ix + iw;
      ctx.beginPath();
      ctx.moveTo(pockets[0].x + pockets[0].r + cornerGap, topY);
      ctx.lineTo(pockets[1].x - pockets[1].r - cornerGap, topY);
      ctx.moveTo(pockets[2].x + pockets[2].r + cornerGap, bottomY);
      ctx.lineTo(pockets[3].x - pockets[3].r - cornerGap, bottomY);
      ctx.moveTo(xLeft, pockets[0].y + pockets[0].r + cornerGap);
      ctx.lineTo(xLeft, pockets[4].y - pockets[4].r - sideGap);
      ctx.moveTo(xLeft, pockets[4].y + pockets[4].r + sideGap);
      ctx.lineTo(xLeft, pockets[2].y - pockets[2].r - cornerGap);
      ctx.moveTo(xRight, pockets[1].y + pockets[1].r + cornerGap);
      ctx.lineTo(xRight, pockets[5].y - pockets[5].r - sideGap);
      ctx.moveTo(xRight, pockets[5].y + pockets[5].r + sideGap);
      ctx.lineTo(xRight, pockets[3].y - pockets[3].r - cornerGap);
      ctx.stroke();
      ctx.strokeStyle = '#ff0';
      drawVPocketGuide(pockets[4], 1);
      drawVPocketGuide(pockets[5], -1);
      drawUPocketGuide(pockets[0], 1, 1);
      drawUPocketGuide(pockets[1], -1, 1);
      drawUPocketGuide(pockets[2], 1, -1);
      drawUPocketGuide(pockets[3], -1, -1);
      ctx.strokeStyle = 'red';
      pockets.forEach(p => { ctx.beginPath(); ctx.arc(p.x, p.y, p.r, 0, Math.PI * 2); ctx.stroke(); });
    }

    function drawVPocketGuide(p, dir) {
      const R = p.r * 1.2;
      const x = p.x - R * 0.5 * dir;
      const y = p.y;
      const dx = R * 1.1 * dir;
      const dy = R * 1.25;
      const trim = R * 0.1;
      ctx.beginPath();
      ctx.moveTo(x - dx, y);
      ctx.lineTo(x + dx, y - dy + trim);
      ctx.moveTo(x - dx, y);
      ctx.lineTo(x + dx, y + dy - trim);
      ctx.stroke();
    }

    function drawUPocketGuide(p, sx, sy) {
      const R = p.r * 1.1;
      ctx.save();
      ctx.translate(p.x, p.y);
      ctx.scale(sx, sy);
      ctx.rotate(-Math.PI / 4);
      ctx.beginPath();
      ctx.arc(0, 0, R, Math.PI, 0);
      const lineLen = R * 1.2;
      const lineStart = R * 0.1;
      ctx.moveTo(-R, lineStart);
      ctx.lineTo(-R, lineLen);
      ctx.moveTo(R, lineStart);
      ctx.lineTo(R, lineLen);
      ctx.stroke();
      ctx.restore();
    }

    function roundRect(c, x, y, w, h, r) {
      c.beginPath();
      c.moveTo(x + r, y);
      c.arcTo(x + w, y, x + w, y + h, r);
      c.arcTo(x + w, y + h, x, y + h, r);
      c.arcTo(x, y + h, x, y, r);
      c.arcTo(x, y, x + w, y, r);
      c.closePath();
    }

    function getVar(name) { return getComputedStyle(document.documentElement).getPropertyValue(name); }

    resize();
    window.addEventListener('resize', resize);
  </script>
</body>
</html>
