<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <title>Snooker 2.5D — Mobile Portrait</title>
  <link rel="stylesheet" href="power-slider.css" />
  <style>
    :root{
      --bg:#0b0f1c;--felt:#105a3b;--felt-dark:#0d4a31;--rail:#3a2a1a;--cushion:#0f7a4a;--line:#d9e3f0;--ring:#1a1a1a;--ring2:#333;--hud:#0b1224cc;--hud-border:#21305f;--accent:#6ee7ff;--text:#e5e7eb;--muted:#a0aec0
    }
    *{box-sizing:border-box}
    html,body{height:100%;margin:0;background:radial-gradient(1200px 700px at 70% 10%,#0f1733,var(--bg));color:var(--text);font-family:Inter,ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial}
    body{touch-action:none;overscroll-behavior:none}
    .wrap{position:fixed;inset:0;display:grid;place-items:center}
    /* use dynamic viewport for mobile chrome */
    canvas{width:100vw;height:100dvh;display:block}
    .hud{position:fixed;inset:0;pointer-events:none;display:flex;justify-content:space-between;align-items:flex-start;padding:12px}
    .pill{pointer-events:auto;background:var(--hud);border:1px solid var(--hud-border);border-radius:999px;padding:8px 12px;box-shadow:0 6px 24px #0009, inset 0 0 0 1px #ffffff12;backdrop-filter:blur(6px);font-size:13px}
    .stack{display:flex;gap:8px;align-items:center}
    .btn{pointer-events:auto;user-select:none;cursor:pointer;background:linear-gradient(180deg,#1b2350,#12183b);border:1px solid #2b3a73;border-radius:12px;padding:8px 12px;color:var(--text);font-weight:600;box-shadow:0 8px 24px #0008, inset 0 0 0 1px #ffffff12}
    .btn.ghost{background:transparent}
    .centerOverlay{position:fixed;inset:0;display:none;place-items:center;background:linear-gradient(180deg,#0c102099,#0c102099);backdrop-filter:blur(4px)}
    .panel{background:#0b1224d0;border:1px solid #233261;border-radius:16px;padding:20px;width:min(520px,92%);box-shadow:0 20px 60px #000a, inset 0 0 0 1px #ffffff10}
    .panel h1{margin:0 0 6px;font-size:22px}
    .panel p{margin:6px 0 12px;color:#c7d2fe}
    #psContainer{position:fixed;top:50%;right:12px;transform:translateY(-50%);pointer-events:auto}
    #spinBox{position:fixed;top:60px;left:50%;transform:translate(-50%,-50%);width:70px;height:70px;border-radius:50%;background:#f6f6f6;box-shadow:0 4px 10px rgba(0,0,0,0.4) inset,0 0 0 2px rgba(0,0,0,0.15);pointer-events:auto;touch-action:none;z-index:20;cursor:pointer}
    #spinDot{position:absolute;width:10px;height:10px;border-radius:50%;background:#e63;left:50%;top:50%;transform:translate(-50%,-50%);pointer-events:none}
    .hint{position:fixed;left:50%;transform:translateX(-50%);top:54px;font-size:12px;color:var(--muted)}
    #header,#footer{position:fixed;left:0;right:0;height:56px;display:flex;align-items:center;justify-content:space-between;padding:0 12px;background:linear-gradient(#20345a,#1a2b4d);}
    #header{top:0;border-bottom:1px solid #24375f;}
    #footer{bottom:0;border-top:1px solid #24375f;justify-content:center;height:calc(56px + env(safe-area-inset-bottom));padding-bottom:env(safe-area-inset-bottom);}
    .player{display:flex;align-items:center;gap:8px;}
    .avatar{width:36px;height:36px;border-radius:50%;background:#fff;color:#222;display:grid;place-items:center;font-weight:700;border:2px solid var(--player-frame-color,#000);}
    .name{font-weight:700;}
    .player .info{display:flex;flex-direction:column;align-items:center;}
    .score{font-size:18px;font-weight:700;min-width:32px;text-align:center;}
    .potted{display:flex;gap:2px;margin-top:2px;}
    .potted .ball{width:14px;height:14px;border-radius:50%;display:block;}
    #statusMsg{font-size:12px;margin-top:2px;}
  </style>
</head>
<body>
  <div class="wrap">
    <canvas id="game"></canvas>
  </div>
  <div id="psContainer"></div>
  <div id="spinBox"><div id="spinDot"></div></div>
  <div id="header">
    <div class="player">
      <div class="avatar">P</div>
      <div class="info">
        <div class="name" id="playerName">Player</div>
        <div class="potted" id="potted"></div>
      </div>
      <div class="score" id="playerScore">0</div>
    </div>
  </div>
  <div id="footer">
    <div id="turnPlayer" class="player">
      <div class="avatar"></div>
      <div class="info">
        <div class="name"></div>
        <div id="statusMsg"></div>
      </div>
    </div>
  </div>

  <script type="module">
  import { PowerSlider } from './power-slider.js';
  ;(() => {
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const scoreEl = document.getElementById('playerScore');
    const pottedEl = document.getElementById('potted');
    const statusMsg = document.getElementById('statusMsg');
    let sliderPower = 0;
    const ps = new PowerSlider({
      mount: document.getElementById('psContainer'),
      cueSrc: '/assets/icons/file_0000000019d86243a2f7757076cd7869.webp',
      onChange: v => { sliderPower = v / 100; },
      onCommit: shoot
    });
    const spinBox = document.getElementById('spinBox');
    const spinDot = document.getElementById('spinDot');
    let spinVec = {x:0, y:0};
    function setSpin(nx, ny){
      spinDot.style.left = 50 + nx*50 + '%';
      spinDot.style.top = 50 + ny*50 + '%';
      spinVec = {x:nx, y:ny};
    }
    function updateSpin(e){
      const r = spinBox.getBoundingClientRect();
      const nx = ((e.clientX - r.left)/r.width - 0.5) * 2;
      const ny = ((e.clientY - r.top)/r.height - 0.5) * 2;
      const l = Math.hypot(nx, ny) || 1;
      const cl = Math.min(l,1);
      setSpin((nx/l)*cl, (ny/l)*cl);
    }
    spinBox.addEventListener('pointerdown', e=>{
      spinBox.setPointerCapture(e.pointerId);
      spinBox.style.transform='translate(-50%,-50%) scale(1.4)';
      updateSpin(e);
    });
    spinBox.addEventListener('pointermove', e=>{
      if(!spinBox.hasPointerCapture(e.pointerId)) return;
      updateSpin(e);
    });
    spinBox.addEventListener('pointerup', e=>{
      spinBox.releasePointerCapture(e.pointerId);
      spinBox.style.transform='translate(-50%,-50%) scale(1)';
    });
    const cueImg = new Image();
    cueImg.src = '/assets/icons/file_0000000019d86243a2f7757076cd7869.webp';

    // --- DPI / Resize ------------------------------------------------------
    const state = { w: 0, h: 0, dpr: 1 };
    const table = { x:0, y:0, w:0, h:0, rail:0, inner:{} };

    function resize(){
      state.dpr = Math.min(window.devicePixelRatio || 1, 2);
      state.w = Math.floor(window.innerWidth * state.dpr);
      state.h = Math.floor(window.innerHeight * state.dpr);
      canvas.width = state.w; canvas.height = state.h;
      canvas.style.width = window.innerWidth + 'px';
      canvas.style.height = window.innerHeight + 'px';
      layoutTable();
    }

    function layoutTable(){
      const margin = Math.floor(Math.min(state.w, state.h) * 0.04);
      // Keep geometry aligned with Pool Royale (768×1216 playing field)
      const playRatio = 768 / 1216; // w:h matches Pool Royale table ratio
      let innerH = state.h - margin*2;    // fill HEIGHT first
      let innerW = innerH * playRatio;    // then derive WIDTH
      if(innerW > state.w - margin*2){    // if too wide, fallback to fit width
        innerW = state.w - margin*2;
        innerH = innerW / playRatio;
      }
      // Border thickness uses same proportion as Pool Royale (57/768)
      const rail = Math.floor(innerW * (57 / 768));
      const shift = Math.floor(80 * state.dpr);
      table.x = Math.max(0, Math.floor((state.w - innerW) / 2) - shift);
      table.y = Math.floor((state.h - innerH) / 2);
      table.w = Math.floor(innerW);
      table.h = Math.floor(innerH);
      table.rail = rail;
      table.inner = {
        x: table.x + rail,
        y: table.y + rail,
        w: table.w - rail*2,
        h: table.h - rail*2
      };
      computeGeometry();
    }

    // --- Table geometry & spots -------------------------------------------
    const geom = { pockets:[], spots:{}, baulkY:0, dRadius:0, ballR:0 };

    function computeGeometry(){
      const I = table.inner;
      const W = I.w, H = I.h;
      geom.ballR = Math.floor(Math.min(W,H) / 35); // scale ball size to table
      // Pocket radius mirrors Pool Royale's ratio (32/22)
      const pr = Math.floor(geom.ballR * (32 / 22));

      // pocket centers follow the same layout as Pool Royale
      geom.pockets = [
        {x:I.x,         y:I.y,         r:pr}, // top-left
        {x:I.x + W/2,   y:I.y,         r:pr}, // top-middle
        {x:I.x + W,     y:I.y,         r:pr}, // top-right
        {x:I.x,         y:I.y + H,     r:pr}, // bottom-left
        {x:I.x + W/2,   y:I.y + H,     r:pr}, // bottom-middle
        {x:I.x + W,     y:I.y + H,     r:pr}, // bottom-right
      ];

      // baulk line & D
      geom.baulkY = I.y + H * 0.78; // approximate
      geom.dRadius = W * 0.18; // approximate D radius

      // spots (approximate, proportionate)
      const cx = I.x + W/2;
      geom.spots = {
        black: { x: cx, y: I.y + H * 0.12 },
        pink:  { x: cx, y: I.y + H * 0.28 },
        blue:  { x: cx, y: I.y + H * 0.50 },
        brown: { x: cx, y: geom.baulkY },
        green: { x: I.x + W * 0.25, y: geom.baulkY },
        yellow:{ x: I.x + W * 0.75, y: geom.baulkY },
      };

      // build initial rack when geometry changes
      if(game.initialized) rack();
    }

    // --- Game objects ------------------------------------------------------
    const balls = [];

    const game = {
      running:false,
      placingCue:false,
      aiming:false,
      drag:{active:false, sx:0, sy:0, x:0, y:0, power:0},
      score:0,
      initialized:false
    };

    function makeBall(x,y,color,value,type,spot){
      return {x,y,vx:0,vy:0,r:geom.ballR,color,value,type,active:true,spot,spin:{x:0,y:0}, id:Math.random().toString(36).slice(2)}
    }

    function rack(){
      balls.length = 0;
      game.score = 0;
      updateScore();
      pottedEl.innerHTML = '';
      statusMsg.textContent = '';
      const s = geom.spots;
      const r = geom.ballR;
      // colours on spots
      balls.push(makeBall(s.yellow.x, s.yellow.y, '#f5d10a', 2, 'color', 'yellow'));
      balls.push(makeBall(s.green.x,  s.green.y,  '#1f7a2e', 3, 'color', 'green'));
      balls.push(makeBall(s.brown.x,  s.brown.y,  '#6b4f2e', 4, 'color', 'brown'));
      balls.push(makeBall(s.blue.x,   s.blue.y,   '#1e58b8', 5, 'color', 'blue'));
      balls.push(makeBall(s.pink.x,   s.pink.y,   '#f19cc4', 6, 'color', 'pink'));
      balls.push(makeBall(s.black.x,  s.black.y,  '#0d0d0d', 7, 'color', 'black'));

      // reds triangle with apex near pink (toward baulk)
      const startY = s.pink.y + r*3.6;
      const cx = s.pink.x;
      const gap = r*2.05;
      for(let row=0; row<5; row++){
        const y = startY + row*gap;
        const n = row+1;
        const offsetX = cx - (n-1)*gap/2;
        for(let i=0;i<n;i++) balls.push(makeBall(offsetX + i*gap, y, '#b11a1a', 1, 'red', null));
      }

      // cue ball in hand (start placed near baulk)
      const cueStart = { x: s.brown.x, y: geom.baulkY + (table.inner.h - (geom.baulkY - table.inner.y)) * 0.15 };
      const cue = makeBall(cueStart.x, cueStart.y, '#ffffff', 0, 'cue', null);
      balls.push(cue);

      game.placingCue = false; // start with placed cue
      game.aiming = true;
      game.initialized = true;
    }
    function updateScore(){ scoreEl.textContent = game.score.toString(); }
    function addPotted(color){
      const el = document.createElement('div');
      el.className = 'ball';
      el.style.background = color;
      pottedEl.appendChild(el);
    }

    // --- Physics -----------------------------------------------------------
    const phys = {
      fric: 0.992,           // velocity retained per frame at 60fps
      minSpeed: 2e-3,        // threshold to stop
      cushionRest: 0.92,
      spin: 30,              // spin impulse strength
      spinFric: 0.9          // spin decay per frame at 60fps
    };

    function step(dt){
      // integrate
      for(const b of balls){
        if(!b.active) continue;
        b.x += b.vx * dt;
        b.y += b.vy * dt;
        // apply spin impulse
        b.vx += b.spin.x * phys.spin * dt;
        b.vy += b.spin.y * phys.spin * dt;
        b.spin.x *= Math.pow(phys.spinFric, dt*60);
        b.spin.y *= Math.pow(phys.spinFric, dt*60);
        // friction
        b.vx *= Math.pow(phys.fric, dt*60);
        b.vy *= Math.pow(phys.fric, dt*60);
        if(Math.hypot(b.vx,b.vy) < phys.minSpeed){ b.vx = b.vy = 0; }
      }

      // ball-ball collisions (naive O(n^2))
      for(let i=0;i<balls.length;i++){
        const a = balls[i]; if(!a.active) continue;
        for(let j=i+1;j<balls.length;j++){
          const b = balls[j]; if(!b.active) continue;
          resolveCollision(a,b);
        }
      }

      // cushion collisions & pockets
      for(const b of balls){
        if(!b.active) continue;
        cushionCollision(b);
        checkPocket(b);
      }
    }

    function resolveCollision(a,b){
      const dx = b.x - a.x, dy = b.y - a.y;
      const r = a.r + b.r;
      const dist2 = dx*dx + dy*dy;
      if(dist2 === 0) return;
      if(dist2 < r*r){
        const dist = Math.sqrt(dist2) || r;
        const nx = dx / dist, ny = dy / dist;
        // separate
        const overlap = r - dist;
        const total = (Math.hypot(a.vx,a.vy) + Math.hypot(b.vx,b.vy) + 0.01);
        const wa = (Math.hypot(b.vx,b.vy)+0.01) / total;
        const wb = 1 - wa;
        a.x -= nx * overlap * wa;
        a.y -= ny * overlap * wa;
        b.x += nx * overlap * wb;
        b.y += ny * overlap * wb;
        // velocities (equal mass elastic)
        const dvx = a.vx - b.vx, dvy = a.vy - b.vy;
        const p = dvx*nx + dvy*ny;
        if(p > 0) return;
        const k = -p; // coefficient 1
        a.vx -= nx * k; a.vy -= ny * k;
        b.vx += nx * k; b.vy += ny * k;
      }
    }

    function cushionCollision(b){
      const I = table.inner;
      // simple rectangular cushions
      if(b.x - b.r < I.x){ b.x = I.x + b.r; b.vx = Math.abs(b.vx) * phys.cushionRest; }
      if(b.x + b.r > I.x + I.w){ b.x = I.x + I.w - b.r; b.vx = -Math.abs(b.vx) * phys.cushionRest; }
      if(b.y - b.r < I.y){ b.y = I.y + b.r; b.vy = Math.abs(b.vy) * phys.cushionRest; }
      if(b.y + b.r > I.y + I.h){ b.y = I.y + I.h - b.r; b.vy = -Math.abs(b.vy) * phys.cushionRest; }
    }

    function checkPocket(b){
      if(!b.active) return;
      for(const p of geom.pockets){
        const dx = b.x - p.x, dy = b.y - p.y;
        if(dx*dx + dy*dy < (p.r*0.9) * (p.r*0.9)){
          // potted
          b.active = false; b.vx = b.vy = 0;
          if(b.type === 'cue'){
            game.placingCue = true; game.aiming = false;
            statusMsg.textContent = 'Cue ball potted';
          } else if(b.type === 'red'){
            game.score += 1; updateScore();
            addPotted(b.color);
            statusMsg.textContent = 'Red potted';
          } else if(b.type === 'color'){
            game.score += b.value; updateScore();
            addPotted(b.color);
            statusMsg.textContent = b.spot + ' potted';
            // respot colour
            respotColor(b);
          }
          break;
        }
      }
    }

    function respotColor(b){
      const target = geom.spots[b.spot];
      if(!target){return}
      // try original spot, then spiral search
      const step = geom.ballR * 0.6;
      for(let r=0;r<20;r++){
        const ang = (r*137.5) * Math.PI/180; // golden angle
        const rad = r*step;
        const x = target.x + Math.cos(ang)*rad;
        const y = target.y + Math.sin(ang)*rad;
        if(inBoundsForBall(x,y) && !overlapsAny(x,y,geom.ballR)){
          b.x = x; b.y = y; b.active = true; return;
        }
      }
      // if no space, keep it off the table
      b.active = false;
    }

    function inBoundsForBall(x,y){
      const I = table.inner; const r = geom.ballR;
      return (x-r>I.x && x+r<I.x+I.w && y-r>I.y && y+r<I.y+I.h);
    }

    function overlapsAny(x,y,r){
      for(const o of balls){ if(!o.active) continue; const dx=o.x-x, dy=o.y-y; if(dx*dx+dy*dy < (o.r+r)*(o.r+r)) return true; }
      return false;
    }
    // --- Input (Touch / Mouse) --------------------------------------------
    function getXY(e){
      let clientX, clientY;
      if(e.touches && e.touches.length){
        const t = e.touches[0]; clientX = t.clientX; clientY = t.clientY;
        
      } else if (e.changedTouches && e.changedTouches.length){
        const t = e.changedTouches[0]; clientX = t.clientX; clientY = t.clientY;
      } else {
        clientX = e.clientX; clientY = e.clientY;
      }
      const rect = canvas.getBoundingClientRect();
      const x = (clientX - rect.left) * (canvas.width / rect.width);
      const y = (clientY - rect.top) * (canvas.height / rect.height);
      return {x,y};
    }

    function anyBallsMoving(){
      return balls.some(b => b.active && (Math.abs(b.vx)>0.01 || Math.abs(b.vy)>0.01));
    }

    function cueBall(){ return balls.find(b => b.type==='cue'); }

    const drag = {active:false, sx:0, sy:0, x:0, y:0, power:0, aimX:0, aimY:0};

    function onDown(e){
      e.preventDefault();
      const {x,y} = getXY(e);
      if(game.placingCue){
        // place cue in baulk area
        if(inBaulk(x,y) && !overlapsAny(x,y,geom.ballR)){
          const c = cueBall(); c.x=x; c.y=y; c.vx=c.vy=0; c.active=true; game.placingCue=false; game.aiming=true;
        }
        return;
      }
      if(anyBallsMoving()) return;
      const c = cueBall();
      if(!c || !c.active) return;
      drag.active = true; drag.sx = drag.x = x; drag.sy = drag.y = y; drag.power = sliderPower; game.aiming = true;
    }

    function onMove(e){
      if(!drag.active) return;
      const {x,y} = getXY(e);
      drag.x = x; drag.y = y;
      drag.power = sliderPower;
      const c = cueBall();
      const dirx = c.x - drag.x, diry = c.y - drag.y;
      const len = Math.hypot(dirx, diry) || 1;
      drag.aimX = dirx/len;
      drag.aimY = diry/len;
    }

    function onUp(e){
      if(!drag.active) return;
      const c = cueBall();
      const dirx = c.x - drag.x, diry = c.y - drag.y;
      const len = Math.hypot(dirx, diry) || 1;
      drag.aimX = dirx/len;
      drag.aimY = diry/len;
      drag.active = false; game.aiming = false;
    }

    function shoot(){
      if(anyBallsMoving()) return;
      const c = cueBall();
      if(!c || !c.active) return;
      const aimX = drag.aimX, aimY = drag.aimY;
      if(aimX === undefined || aimY === undefined) return;
      const power = sliderPower;
      const maxSpeed = geom.ballR * 28; // a tad faster
      c.vx = aimX * maxSpeed * power;
      c.vy = aimY * maxSpeed * power;
      c.spin = {x:spinVec.x, y:spinVec.y};
      setSpin(0,0);
      game.aiming = false;
    }

    function inBaulk(x,y){
      return y > geom.baulkY && x > table.inner.x && x < table.inner.x + table.inner.w;
    }

    canvas.addEventListener('touchstart', onDown, {passive:false});
    canvas.addEventListener('touchmove', onMove, {passive:false});
    canvas.addEventListener('touchend', onUp, {passive:false});
    canvas.addEventListener('mousedown', onDown);
    canvas.addEventListener('mousemove', onMove);
    window.addEventListener('mouseup', onUp);

    // --- Render ------------------------------------------------------------
    function draw(){
      ctx.clearRect(0,0,state.w,state.h);
      drawBackground();
      drawTable();
      drawGuides();
      drawCue();
      drawBalls();
      drawVignette();
    }

    function drawBackground(){
      const g = ctx.createLinearGradient(0,0,0,state.h);
      g.addColorStop(0,'#0e1430');
      g.addColorStop(1,'#0a1024');
      ctx.fillStyle = g; ctx.fillRect(0,0,state.w,state.h);
    }

    function pathRoundedRect(x,y,w,h,r){
      const rr = Math.min(r, w/2, h/2);
      ctx.beginPath();
      ctx.moveTo(x+rr,y);
      ctx.arcTo(x+w,y,x+w,y+h,rr);
      ctx.arcTo(x+w,y+h,x,y+h,rr);
      ctx.arcTo(x,y+h,x,y,rr);
      ctx.arcTo(x,y,x+w,y,rr);
      ctx.closePath();
    }

    function drawTable(){
      const T = table; const I = table.inner; const r = T.rail;
      // wood rail
      pathRoundedRect(T.x, T.y, T.w, T.h, r*0.8);
      const wood = ctx.createLinearGradient(T.x, T.y, T.x, T.y+T.h);
      wood.addColorStop(0,'#4a3522'); wood.addColorStop(1,'#2c2117');
      ctx.fillStyle = wood; ctx.fill();
      // inner shadow for rail
      ctx.strokeStyle = '#00000055'; ctx.lineWidth = r*0.6; ctx.stroke();

      // felt
      pathRoundedRect(I.x, I.y, I.w, I.h, r*0.4);
      const felt = ctx.createLinearGradient(I.x, I.y, I.x, I.y+I.h);
      felt.addColorStop(0, '#0f6a43');
      felt.addColorStop(0.6, '#0f5f3e');
      felt.addColorStop(1, '#0c5034');
      ctx.fillStyle = felt; ctx.fill();

      // cushions glow
      ctx.save();
      ctx.globalAlpha = 0.35;
      ctx.strokeStyle = '#14b86b44'; ctx.lineWidth = r*0.35;
      pathRoundedRect(I.x, I.y, I.w, I.h, r*0.4); ctx.stroke();
      ctx.restore();

      // baulk line
      ctx.strokeStyle = '#e9f2ffaa'; ctx.lineWidth = Math.max(1, state.dpr);
      ctx.beginPath(); ctx.moveTo(I.x, geom.baulkY); ctx.lineTo(I.x+I.w, geom.baulkY); ctx.stroke();
      // D semicircle
      ctx.beginPath();
      ctx.arc(I.x+I.w/2, geom.baulkY, geom.dRadius, Math.PI, 0);
      ctx.stroke();

      // spots
      const s = geom.spots;
      ctx.fillStyle = '#e9f2ffcc';
      for(const k of Object.keys(s)){
        ctx.beginPath(); ctx.arc(s[k].x, s[k].y, Math.max(1.2*state.dpr, geom.ballR*0.15), 0, Math.PI*2); ctx.fill();
      }

      // pockets (rings)
      for(const p of geom.pockets){
        // dark hole
        const hole = ctx.createRadialGradient(p.x-6, p.y-6, 4, p.x, p.y, p.r);
        hole.addColorStop(0,'#000'); hole.addColorStop(1,'#0008');
        ctx.fillStyle = hole; ctx.beginPath(); ctx.arc(p.x, p.y, p.r, 0, Math.PI*2); ctx.fill();
        // ring
        ctx.strokeStyle = '#111'; ctx.lineWidth = Math.max(2, p.r*0.18);
        ctx.beginPath(); ctx.arc(p.x, p.y, p.r*0.86, 0, Math.PI*2); ctx.stroke();
      }
    }

    function drawBalls(){
      // depth sort by y for subtle 2.5D look
      const drawables = balls.slice().sort((a,b)=>a.y-b.y);
      for(const b of drawables){ if(!b.active) continue; drawBall(b); }
    }
    function drawBall(b){
      // shadow
      ctx.save();
      ctx.globalAlpha = 0.28;
      ctx.fillStyle = '#000';
      ctx.beginPath();
      ctx.ellipse(b.x, b.y + b.r*0.65, b.r*1.2, b.r*0.5, 0, 0, Math.PI*2);
      ctx.fill();
      ctx.restore();
      // body gradient (light from top-left)
      const grad = ctx.createRadialGradient(b.x - b.r*0.4, b.y - b.r*0.6, b.r*0.2, b.x, b.y, b.r*1.2);
      grad.addColorStop(0, shadeColor(b.color, 40));
      grad.addColorStop(0.6, b.color);
      grad.addColorStop(1, shadeColor(b.color, -40));
      ctx.fillStyle = grad;
      ctx.beginPath(); ctx.arc(b.x, b.y, b.r, 0, Math.PI*2); ctx.fill();
      // specular
      ctx.fillStyle = 'rgba(255,255,255,0.65)';
      ctx.beginPath(); ctx.ellipse(b.x - b.r*0.45, b.y - b.r*0.55, b.r*0.22, b.r*0.12, -0.5, 0, Math.PI*2); ctx.fill();
      // cue ball seam hint
      if(b.type==='cue'){
        ctx.strokeStyle = 'rgba(0,0,0,0.08)'; ctx.lineWidth = Math.max(1, state.dpr);
        ctx.beginPath(); ctx.arc(b.x, b.y, b.r*0.88, 0.2, Math.PI-0.2); ctx.stroke();
      }
    }

    function drawCue(){
      if(!game.aiming || anyBallsMoving() || game.placingCue) return;
      const c = cueBall(); if(!c || !c.active) return;
      const pull = Math.min(Math.hypot(c.x - drag.x, c.y - drag.y), geom.ballR*10);
      drawCueOnTable({x:c.x,y:c.y}, {x:drag.x,y:drag.y}, pull);
    }

    function drawCueOnTable(cuePos, aim, pull){
      const dx = aim.x - cuePos.x, dy = aim.y - cuePos.y;
      const len = Math.hypot(dx, dy) || 1;
      const dir = {x:dx/len, y:dy/len};
      const angle = Math.atan2(dir.y, dir.x) + Math.PI/2;
      const cueLength = geom.ballR * 20;
      const cueShift = geom.ballR * 2 * 6.3;
      if(!cueImg.complete) return;
      const scale = cueLength / cueImg.width;
      const drawW = cueImg.width * scale;
      const drawH = cueImg.height * scale;
      ctx.save();
      ctx.translate(cuePos.x - dir.x * pull, cuePos.y - dir.y * pull);
      ctx.rotate(angle);
      ctx.translate(cueShift,0);
      ctx.drawImage(cueImg, -drawW/2 - cueShift, 0, drawW, drawH);
      ctx.restore();
    }

    function shadeColor(hex, amt){
      const c = hex.replace('#','');
      const n = parseInt(c.length===3 ? c.split('').map(ch=>ch+ch).join('') : c, 16);
      let r=(n>>16)&255, g=(n>>8)&255, b=n&255;
      r = clamp(r + amt, 0, 255); g = clamp(g + amt, 0, 255); b = clamp(b + amt, 0, 255);
      return `rgb(${r},${g},${b})`;
    }

    function drawGuides(){
      if(!game.aiming || anyBallsMoving() || game.placingCue) return;
      const c = cueBall(); if(!c || !c.active || !drag.active) return;
      const aim = {x:drag.x, y:drag.y};
      const dx = aim.x - c.x, dy = aim.y - c.y;
      const L = Math.hypot(dx, dy) || 1;
      const dir = {x:dx/L, y:dy/L};
      let tHit = Infinity;
      let target = null;
      let railNormal = null;
      function checkRail(t, normal){ if(t>=0 && t<tHit){ tHit=t; railNormal=normal; target=null; } }
      const I = table.inner;
      const ballR = geom.ballR;
      if(dir.x < 0) checkRail((I.x + ballR - c.x) / dir.x, {x:1, y:0});
      if(dir.x > 0) checkRail((I.x + I.w - ballR - c.x) / dir.x, {x:-1, y:0});
      if(dir.y < 0) checkRail((I.y + ballR - c.y) / dir.y, {x:0, y:1});
      if(dir.y > 0) checkRail((I.y + I.h - ballR - c.y) / dir.y, {x:0, y:-1});
      const diam = ballR * 2, diam2 = diam * diam;
      for(const b of balls){
        if(b === c || !b.active) continue;
        const v = {x:b.x - c.x, y:b.y - c.y};
        const proj = v.x*dir.x + v.y*dir.y;
        if(proj <= 0) continue;
        const perp2 = v.x*v.x + v.y*v.y - proj*proj;
        if(perp2 > diam2) continue;
        const thc = Math.sqrt(diam2 - perp2);
        const t = proj - thc;
        if(t >= 0 && t < tHit){ tHit = t; target = b; railNormal = null; }
      }
      const impactX = c.x + dir.x * tHit;
      const impactY = c.y + dir.y * tHit;
      let contactX = impactX, contactY = impactY, hitN = null;
      if(target){
        hitN = {x: target.x - impactX, y: target.y - impactY};
        const nL0 = Math.hypot(hitN.x, hitN.y) || 1;
        hitN.x /= nL0; hitN.y /= nL0;
        contactX = target.x - hitN.x * ballR;
        contactY = target.y - hitN.y * ballR;
      }
      const guaranteedHit = target && !railNormal;
      ctx.save();
      ctx.strokeStyle = guaranteedHit ? 'rgba(255,255,0,1)' : 'rgba(255,255,255,.7)';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(c.x, c.y);
      ctx.lineTo(contactX, contactY);
      ctx.stroke();
      ctx.restore();
      if(!target && railNormal){
        let dotIn = dir.x*railNormal.x + dir.y*railNormal.y;
        let refl = {x:dir.x - 2*dotIn*railNormal.x, y:dir.y - 2*dotIn*railNormal.y};
        refl.x += spinVec.x * 0.4;
        refl.y += spinVec.y * 0.4;
        const rL = Math.hypot(refl.x, refl.y) || 1;
        refl.x /= rL; refl.y /= rL;
        ctx.save();
        ctx.strokeStyle = 'rgba(255,255,255,.5)';
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(impactX, impactY);
        ctx.lineTo(impactX + refl.x * ballR * 4, impactY + refl.y * ballR * 4);
        ctx.stroke();
        ctx.restore();
      }
      if(target){
        const hitSpotX = target.x - hitN.x * ballR;
        const hitSpotY = target.y - hitN.y * ballR;
        const markerR = ballR;
        ctx.save();
        ctx.strokeStyle = 'rgba(255,255,255,.8)';
        ctx.lineWidth = 1;
        ctx.beginPath(); ctx.arc(hitSpotX, hitSpotY, markerR, 0, Math.PI*2); ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(hitSpotX - markerR/2, hitSpotY);
        ctx.lineTo(hitSpotX + markerR/2, hitSpotY);
        ctx.moveTo(hitSpotX, hitSpotY - markerR/2);
        ctx.lineTo(hitSpotX, hitSpotY + markerR/2);
        ctx.stroke();
        ctx.restore();
        let tMax = Infinity;
        if(hitN.x > 0) tMax = Math.min(tMax, (I.x + I.w - ballR - target.x) / hitN.x);
        if(hitN.x < 0) tMax = Math.min(tMax, (I.x + ballR - target.x) / hitN.x);
        if(hitN.y > 0) tMax = Math.min(tMax, (I.y + I.h - ballR - target.y) / hitN.y);
        if(hitN.y < 0) tMax = Math.min(tMax, (I.y + ballR - target.y) / hitN.y);
        const ex = target.x + hitN.x * tMax;
        const ey = target.y + hitN.y * tMax;
        ctx.save();
        ctx.strokeStyle = 'rgba(255,255,255,.3)';
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(hitSpotX, hitSpotY);
        ctx.lineTo(ex - hitN.x * ballR, ey - hitN.y * ballR);
        ctx.stroke();
        ctx.restore();
        const dot = dir.x*hitN.x + dir.y*hitN.y;
        const cbDir = {x:dir.x - hitN.x*dot, y:dir.y - hitN.y*dot};
        const cbL = Math.hypot(cbDir.x, cbDir.y);
        if(cbL > 0.0001){
          cbDir.x /= cbL; cbDir.y /= cbL;
          const cbEndX = impactX + cbDir.x * ballR * 4;
          const cbEndY = impactY + cbDir.y * ballR * 4;
          ctx.save();
          ctx.strokeStyle = 'rgba(255,255,255,.5)';
          ctx.lineWidth = 1;
          ctx.beginPath();
          ctx.moveTo(impactX, impactY);
          ctx.lineTo(cbEndX, cbEndY);
          ctx.stroke();
          ctx.restore();
        }
      }
    }

    function drawVignette(){
      const g = ctx.createRadialGradient(state.w/2, state.h*0.45, Math.min(state.w,state.h)*0.4, state.w/2, state.h*0.5, Math.max(state.w,state.h)*0.8);
      g.addColorStop(0,'transparent'); g.addColorStop(1,'#0007');
      ctx.fillStyle = g; ctx.fillRect(0,0,state.w,state.h);
    }

    function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }

    // --- Game Loop ---------------------------------------------------------
    let last = 0; let rafId = 0;
    function loop(t){
      rafId = requestAnimationFrame(loop);
      const dt = Math.min((t - last) / 16.6667, 2); // ~60fps units
      last = t;
      if(game.running){ step(dt); }
      draw();
    }

    // --- Init -------------------------------------------------------------
    resize();
    window.addEventListener('resize', resize);
    rack();
    game.running = true;
    requestAnimationFrame(loop);

  })();
  </script>
</body>
</html>
