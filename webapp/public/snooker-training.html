<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <title>Snooker 2.5D â€” Mobile Portrait</title>
  <link rel="stylesheet" href="/power-slider.css" />
  <style>
    :root{--bg:#0b0f1c;--felt:#105a3b;--rail:#3a2a1a;--rail2:#2c2117;--line:#e8f0ff;--hud:#0b1224cc;--hud-b:#21305f;--text:#e5e7eb}
    *{box-sizing:border-box}
    body{margin:0;background:#1a2b4d url('/assets/icons/64e79228-35e3-4fdc-b914-fca635a40220.webp') top center/cover no-repeat;touch-action:none;overscroll-behavior:none;overflow:hidden;font-family:system-ui,Segoe UI,Roboto,Helvetica,Arial}
    canvas{width:100vw;height:100dvh;display:block;background:transparent}
    .hud{position:fixed;bottom:0;left:0;right:0;display:flex;justify-content:center;align-items:center;padding:10px 12px;background:rgba(0,0,0,0.4);color:var(--text)}
    .btn{background:#1f2b4d;border:1px solid #3a5599;color:#e5e7eb;border-radius:10px;padding:10px 14px;font-weight:600;cursor:pointer}
    .overlay{position:fixed;inset:0;display:grid;place-items:center;background:rgba(0,0,0,0.5)}
    .panel{background:#101827;border:1px solid #26385f;color:#e5e7eb;padding:16px 18px;border-radius:12px;box-shadow:0 12px 40px #000a;text-align:center}
    #header{position:fixed;top:0;left:0;right:0;height:56px;display:flex;align-items:center;justify-content:space-between;padding:0 12px;background:rgba(0,0,0,0.6);color:#fff;z-index:10}
    .player{display:flex;align-items:center;gap:8px}
    .avatar{width:36px;height:36px;border-radius:50%;background:#fff;color:#222;display:grid;place-items:center;font-weight:700}
    .name{font-weight:700}
    .score{font-size:18px;font-weight:700;min-width:32px;text-align:center}
    #power{position:fixed;top:50%;right:20px;transform:translateY(-50%);z-index:10}
    #spinBox{position:fixed;top:80px;left:50%;width:80px;height:80px;transform:translateX(-50%);background:rgba(0,0,0,0.4);border:2px solid #fff;border-radius:50%;touch-action:none;z-index:10}
    #spinDot{position:absolute;width:12px;height:12px;border-radius:50%;background:#fff;top:50%;left:50%;transform:translate(-50%,-50%)}
  </style>
</head>
<body>
  <div id="header">
    <div class="player">
      <div class="avatar" id="userAvatar">U</div>
      <div class="info">
        <div class="name" id="userName">Player ðŸ‡ºðŸ‡¸</div>
        <div class="score" id="score">0</div>
      </div>
    </div>
    <div class="player">
      <div class="info">
        <div class="name" id="aiName">CPU ðŸ‡¬ðŸ‡§</div>
        <div class="score" id="aiScore">0</div>
      </div>
      <div class="avatar">ðŸ¤–</div>
    </div>
  </div>
  <canvas id="game"></canvas>
  <div id="spinBox"><div id="spinDot"></div></div>
  <div id="power"></div>
  <div class="hud">
    <button id="reset" class="btn">New Rack</button>
  </div>
  <div class="overlay" id="overlay">
    <div class="panel">
      <h3 style="margin:0 0 6px">Snooker 2.5D â€” Mobile Portrait</h3>
      <p style="margin:0 0 12px;font-size:14px">TÃ«rhiq nga topi i bardhÃ« pÃ«r tÃ« marrÃ« shenjÃ«. Rregullo fuqinÃ« me slider. LÃ«sho pÃ«r tÃ« goditur.</p>
      <button id="startBtn" class="btn">Start</button>
    </div>
  </div>
  <script type="module">
  import { PowerSlider } from '/power-slider.js';
  ;(()=>{
    const canvas=document.getElementById('game');
    const ctx=canvas.getContext('2d');
    const overlay=document.getElementById('overlay');
    const startBtn=document.getElementById('startBtn');
    const powerMount=document.getElementById('power');
    const spinBox=document.getElementById('spinBox');
    const spinDot=document.getElementById('spinDot');

    let W,H;function resize(){W=canvas.width=window.innerWidth;H=canvas.height=window.innerHeight;}resize();window.addEventListener('resize',resize);

    // Table frame + inner play area (do NOT move table center)
    let FR=Math.round(Math.min(W,H)*0.04); // frame thickness
    const balls=[];const pockets=[];const R=22;let score=0;let running=false;

    const scoreEl=document.getElementById('score');

    const table={get ix(){return FR},get iy(){return FR},get iw(){return W-FR*2},get ih(){return H-FR*2}};

    const powerSlider = new PowerSlider({
      mount: powerMount,
      value: 55,
      cueSrc: '/assets/icons/file_0000000019d86243a2f7757076cd7869.webp'
    });
    let spinVec = { x: 0, y: 0 };

    function makeBall(x,y,color,type){return{x,y,vx:0,vy:0,r:R,color,active:true,type,spinX:0,spinY:0}};

    function rack(){
      balls.length=0; score=0; scoreEl.textContent=score;
      // cue ball near baulk (bottom side)
      balls.push(makeBall(W/2, table.iy + table.ih*0.78, '#fff', 'cue'));

      // === Reds triangle (ROTATED as requested) ===
      // Apex should be closer to the PINK (towards bottom). That means rows shrink towards bottom.
      const gap=R*2.05;
      const apexY = table.iy + table.ih*0.32 + gap*4; // apex near pink/bottom side of pack
      const cx = W/2;
      for(let row=0; row<5; row++){
        const n = 5 - row; // 5,4,3,2,1 (apex at bottom)
        const y = apexY - row*gap; // building upward
        const offsetX = cx - (n-1)*gap/2;
        for(let i=0;i<n;i++) balls.push(makeBall(offsetX + i*gap, y, '#b11a1a','red'));
      }

      // colours (kept same spots, portrait proportions)
      balls.push(makeBall(W/2, table.iy + table.ih*0.14, '#0d0d0d','black'));
      balls.push(makeBall(W/2, table.iy + table.ih*0.24, '#f19cc4','pink'));
      balls.push(makeBall(W/2, table.iy + table.ih*0.50, '#1e58b8','blue'));
      balls.push(makeBall(W/2, table.iy + table.ih*0.78, '#6b4f2e','brown'));
      balls.push(makeBall(table.ix + table.iw*0.35, table.iy + table.ih*0.78, '#1f7a2e','green'));
      balls.push(makeBall(table.ix + table.iw*0.65, table.iy + table.ih*0.78, '#f5d10a','yellow'));
    }

    function setupPockets(){
      pockets.length=0;
      // 6 pockets on the LONG SIDES: 3 left rail, 3 right rail
      const pr = R*1.7;
      const Lx = table.ix; const Rx = table.ix + table.iw;
      const topY = table.iy; const midY = table.iy + table.ih/2; const botY = table.iy + table.ih;
      pockets.push({x:Lx, y:topY, r:pr});
      pockets.push({x:Lx, y:midY, r:pr});
      pockets.push({x:Lx, y:botY, r:pr});
      pockets.push({x:Rx, y:topY, r:pr});
      pockets.push({x:Rx, y:midY, r:pr});
      pockets.push({x:Rx, y:botY, r:pr});
    }

    function handleSpin(e){
      const rect = spinBox.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;
      const nx = Math.min(Math.max((x / rect.width) * 2 - 1, -1), 1);
      const ny = Math.min(Math.max((y / rect.height) * 2 - 1, -1), 1);
      spinVec = { x: nx, y: ny };
      spinDot.style.left = 50 + nx * 50 + '%';
      spinDot.style.top = 50 + ny * 50 + '%';
    }
    spinBox.addEventListener('pointerdown', e => {
      spinBox.setPointerCapture(e.pointerId);
      handleSpin(e);
      spinBox.addEventListener('pointermove', handleSpin);
      spinBox.addEventListener('pointerup', () => {
        spinBox.releasePointerCapture(e.pointerId);
        spinBox.removeEventListener('pointermove', handleSpin);
      }, { once: true });
    });

    // Physics
    const FRIC = 0.99, STOP=0.05, REST=0.92;

    function physics(){
      // integrate & cushions & pockets
      for(const b of balls){ if(!b.active) continue;
        b.x+=b.vx; b.y+=b.vy;
        b.vx*=FRIC; b.vy*=FRIC;
        if(b.type==='cue'){ b.vx+=b.spinX*0.05; b.vy+=b.spinY*0.05; b.spinX*=0.98; b.spinY*=0.98; }
        if(Math.hypot(b.vx,b.vy) < STOP){ b.vx=b.vy=0; }
        // cushions inside frame
        const L = table.ix + R*0.05, T = table.iy + R*0.05, Rr = table.ix+table.iw - R*0.05, Bb = table.iy+table.ih - R*0.05;
        if(b.x - b.r < L){ b.x=L + b.r; b.vx = Math.abs(b.vx)*REST; }
        if(b.x + b.r > Rr){ b.x=Rr - b.r; b.vx = -Math.abs(b.vx)*REST; }
        if(b.y - b.r < T){ b.y=T + b.r; b.vy = Math.abs(b.vy)*REST; }
        if(b.y + b.r > Bb){ b.y=Bb - b.r; b.vy = -Math.abs(b.vy)*REST; }
        // pockets on rails
        for(const p of pockets){
          const dx=b.x-p.x, dy=b.y-p.y; const rad=p.r*0.85; if(dx*dx+dy*dy < rad*rad){ b.active=false; b.vx=b.vy=0; if(b.type==='red'){ score++; scoreEl.textContent=score; } }
        }
      }
      // collisions elastic equal mass
      for(let i=0;i<balls.length;i++){
        const a=balls[i]; if(!a.active) continue;
        for(let j=i+1;j<balls.length;j++){
          const b=balls[j]; if(!b.active) continue;
          let dx=b.x-a.x, dy=b.y-a.y; let dist=Math.hypot(dx,dy);
          const min = a.r + b.r; if(dist===0){dist=0.001; dx=min; dy=0;}
          if(dist < min){
            const nx = dx / dist, ny = dy / dist;
            // separate
            const overlap = (min - dist) / 2; a.x -= nx*overlap; a.y -= ny*overlap; b.x += nx*overlap; b.y += ny*overlap;
            // relative velocity along normal
            const rvx = a.vx - b.vx, rvy = a.vy - b.vy; const vn = rvx*nx + rvy*ny; if(vn>0) continue;
            const impulse = -(1.0)*vn;
            a.vx -= impulse*nx; a.vy -= impulse*ny;
            b.vx += impulse*nx; b.vy += impulse*ny;
          }
        }
      }
    }

    // Drawing
    function draw(){
      ctx.clearRect(0,0,W,H);
      const drawables = balls.filter(b=>b.active).sort((a,b)=>a.y-b.y);
      for(const b of drawables){ drawBall(b); }
      if(aiming && cue && cue.active){
        drawAim();
      }
    }

    function drawBall(b){
      // shadow
      ctx.save(); ctx.globalAlpha=0.28; ctx.fillStyle='#000'; ctx.beginPath(); ctx.ellipse(b.x, b.y + b.r*0.6, b.r*1.2, b.r*0.5, 0, 0, Math.PI*2); ctx.fill(); ctx.restore();
      // body
      const grad = ctx.createRadialGradient(b.x-b.r*0.4, b.y-b.r*0.6, b.r*0.2, b.x, b.y, b.r*1.2);
      grad.addColorStop(0, 'rgba(255,255,255,0.6)'); grad.addColorStop(0.6, b.color); grad.addColorStop(1, 'rgba(0,0,0,0.35)');
      ctx.fillStyle=grad; ctx.beginPath(); ctx.arc(b.x,b.y,b.r,0,Math.PI*2); ctx.fill();
    }

    function drawAim(){
      // pull-back direction from cue -> pointer
      ctx.setLineDash([6,6]); ctx.strokeStyle='rgba(255,255,255,0.9)'; ctx.lineWidth=2;
      ctx.beginPath(); ctx.moveTo(cue.x, cue.y); ctx.lineTo(aimX, aimY); ctx.stroke(); ctx.setLineDash([]);
      // target point
      ctx.beginPath(); ctx.arc(aimX,aimY,6,0,Math.PI*2); ctx.strokeStyle='#ff4d4f'; ctx.lineWidth=2; ctx.stroke();
    }

    // Loop
    function loop(){ if(running){ physics(); } draw(); requestAnimationFrame(loop); }

    // Pointer helpers
    function getXY(ev){
      let cx, cy; const rect = canvas.getBoundingClientRect();
      if(ev.touches && ev.touches.length){ cx = ev.touches[0].clientX; cy = ev.touches[0].clientY; }
      else if(ev.changedTouches && ev.changedTouches.length){ cx = ev.changedTouches[0].clientX; cy = ev.changedTouches[0].clientY; }
      else { cx = ev.clientX; cy = ev.clientY; }
      const x = (cx - rect.left) * (canvas.width / rect.width);
      const y = (cy - rect.top) * (canvas.height / rect.height);
      return {x,y};
    }

    let aiming=false, aimX=0, aimY=0; let cue=null;

    function onDown(e){ e.preventDefault(); if(!running) return; cue = balls.find(b=>b.type==='cue' && b.active); if(!cue) return; const {x,y}=getXY(e); aiming=true; aimX=x; aimY=y; }
    function onMove(e){ if(!aiming) return; const {x,y}=getXY(e); aimX=x; aimY=y; }
    function onUp(e){
      if(!aiming) return;
      aiming=false;
      if(!cue||!cue.active) return;
      const {x,y}=getXY(e);
      const dx = cue.x - x;
      const dy = cue.y - y;
      const pow = powerSlider.get()/50;
      cue.vx = dx * 0.25 * pow;
      cue.vy = dy * 0.25 * pow;
      cue.spinX = spinVec.x;
      cue.spinY = spinVec.y;
      spinVec = { x: 0, y: 0 };
      spinDot.style.left = '50%';
      spinDot.style.top = '50%';
    }

    canvas.addEventListener('touchstart', onDown, {passive:false});
    canvas.addEventListener('touchmove', onMove, {passive:false});
    canvas.addEventListener('touchend', onUp, {passive:false});
    canvas.addEventListener('mousedown', onDown);
    canvas.addEventListener('mousemove', onMove);
    window.addEventListener('mouseup', onUp);

    document.getElementById('reset').onclick = ()=>{ rack(); };

    startBtn.addEventListener('click', ()=>{ overlay.style.display='none'; running=true; });

    // init
    setupPockets(); rack(); loop();
  })();
  </script>
</body>
</html>
