<!doctype html>
<html lang="sq">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
  <title>Urban Ops â€¢ Battle Royale</title>
  <style>
    html,body{margin:0;height:100%;background:#f3e3c7;overflow:hidden;font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif}
    body,.hud{touch-action:none}
    #wrap{position:fixed;inset:0}
    canvas{width:100%;height:100%;display:block;touch-action:none;user-select:none}
    .hud{position:fixed;inset:0;pointer-events:none}
    .row{position:absolute;left:10px;right:10px;display:flex;gap:8px;align-items:center}
    .top{top:8px;justify-content:space-between}
    .bottom{bottom:10px;justify-content:space-between}
    .chip{background:rgba(0,0,0,.35);color:#fff;border-radius:999px;padding:6px 10px;font-size:12px;backdrop-filter:blur(4px);pointer-events:auto}
    .btn{background:rgba(0,0,0,.35);color:#fff;border:0;border-radius:14px;padding:10px 14px;font-size:14px;cursor:pointer;pointer-events:auto}
    .btn:active{transform:translateY(1px)}
    .btn[disabled]{opacity:.45;cursor:not-allowed}

    /* Joysticks */
    #armory{z-index:10}
    .joy{position:absolute;width:300px;height:300px;border-radius:50%;background:rgba(0,0,0,.08);border:1px solid rgba(0,0,0,.25);opacity:.96;pointer-events:auto;touch-action:none;display:block;z-index:20}
    .knob{position:absolute;left:50%;top:50%;width:160px;height:160px;transform:translate(-50%,-50%);border-radius:50%;background:rgba(0,0,0,.25);border:1px solid rgba(0,0,0,.35)}
    #joyMove{left:18px;bottom:220px}
    #shootPad{right:18px;bottom:220px}
    #aimPad{right:18px;bottom:220px;display:none}
    #shootPad .knob{background:radial-gradient(circle at 50% 50%, rgba(255,70,70,1) 0 30%, rgba(0,0,0,.28) 31%), rgba(0,0,0,.25);}
    #shootPad .knob::after{content:'SHOOT';position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);color:#fff;font-weight:900;font-size:18px;letter-spacing:.6px;text-shadow:0 1px 2px rgba(0,0,0,.65);}

    /* Circular RELOAD above shoot pad */
    #reloadMini{position:absolute;left:50%;top:-190px;transform:translateX(-50%);width:160px;height:160px;display:flex;align-items:center;justify-content:center;border-radius:50%;border:1px solid rgba(0,0,0,.35);background:radial-gradient(circle at 50% 50%, rgba(255,70,70,1) 0 30%, rgba(0,0,0,.28) 31%), rgba(0,0,0,.25);color:#fff;font-size:18px;font-weight:900;letter-spacing:.6px;pointer-events:auto;box-shadow:0 6px 16px rgba(0,0,0,.35)}

    /* Crosshair */
    #crosshair{position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);width:30px;height:30px;pointer-events:none;z-index:50;display:block}
    #crosshair:before,#crosshair:after{content:"";position:absolute;left:50%;top:50%;background:var(--aimColor,#ff3c3c);box-shadow:0 0 0 2px rgba(255,255,255,0.9) inset, 0 0 6px rgba(0,0,0,.35)}
    #crosshair:before{width:24px;height:3px;transform:translate(-50%,-50%);opacity:.98}
    #crosshair:after{width:3px;height:24px;transform:translate(-50%,-50%);opacity:.98}

    #ammo{position:absolute;right:10px;top:40px;color:#fff;font-weight:600;background:rgba(0,0,0,.35);padding:8px 12px;border-radius:10px;pointer-events:auto}
    #healthbar{position:absolute;left:10px;top:46px;width:260px;height:16px;background:rgba(0,0,0,.2);border-radius:999px;overflow:hidden}
    #healthfill{width:100%;height:100%;background:linear-gradient(90deg,#29ff9a,#00c876)}

    /* Armory */
    #armory{position:absolute;left:10px;right:10px;bottom:86px;display:flex;gap:8px;overflow:auto;padding:8px;border-radius:14px;background:rgba(0,0,0,.25);backdrop-filter:blur(6px);pointer-events:auto}
    .armBtn{position:relative;flex:0 0 auto;min-width:138px;max-width:168px;padding:8px;border-radius:12px;border:1px solid rgba(255,255,255,.16);background:rgba(0,0,0,.35);color:#e6eefc;font-weight:700;cursor:pointer;display:flex;flex-direction:column;align-items:center;gap:6px}
    .armBtn img{width:124px;height:76px;object-fit:contain;display:block;filter:drop-shadow(0 1px 1px rgba(0,0,0,.3))}
    .armBtn span{font-size:12px;opacity:.95}
    .armBtn.active{outline:2px solid #ffd966;background:rgba(17,23,42,.55)}
    .modeToggle{position:absolute;right:6px;top:6px;padding:3px 6px;border-radius:10px;border:1px solid rgba(255,255,255,.25);background:rgba(0,0,0,.45);color:#fff;font-size:10px;cursor:pointer}

    #mini{position:absolute;left:10px;bottom:56px;color:#0b1324;background:rgba(255,255,255,.6);padding:4px 8px;border-radius:8px;font-size:11px;pointer-events:auto}

    #br{position:absolute;left:50%;top:8px;transform:translateX(-50%);background:rgba(0,0,0,.35);color:#fff;padding:6px 10px;border-radius:999px;font-weight:700;pointer-events:auto}

    /* Mode selector */
    #modeBox{position:absolute;right:10px;top:46px;display:flex;gap:6px;pointer-events:auto}
    .modeBtn{padding:6px 10px;border-radius:999px;border:1px solid rgba(255,255,255,.25);background:rgba(0,0,0,.35);color:#fff;font-size:12px;cursor:pointer}
    .modeBtn.active{background:#2a7fff}

    /* Car HUD */
    #useCarBtn{position:absolute;left:50%;bottom:168px;transform:translateX(-50%);padding:10px 14px;border-radius:12px;border:1px solid rgba(255,255,255,.25);background:rgba(0,0,0,.6);color:#fff;pointer-events:auto;display:none}
    #exitCarBtn{position:absolute;right:12px;bottom:168px;padding:10px 14px;border-radius:12px;border:1px solid rgba(255,255,255,.25);background:rgba(0,0,0,.6);color:#fff;pointer-events:auto;display:none}
    #hornBtn{position:absolute;left:50%;bottom:118px;transform:translateX(-50%);padding:10px 14px;border-radius:12px;border:1px solid rgba(255,255,255,.25);background:rgba(0,0,0,.6);color:#fff;pointer-events:auto;display:none}
    #brakeBtn{position:absolute;left:calc(50% - 170px);bottom:118px;padding:10px 14px;border-radius:12px;border:1px solid rgba(255,255,255,.25);background:rgba(220,0,0,.75);color:#fff;pointer-events:auto;display:none}

    /* Ladder UI */
    #climbBtn{position:absolute;left:50%;bottom:156px;transform:translateX(-50%);padding:8px 12px;border-radius:12px;border:1px solid rgba(255,255,255,.25);background:rgba(0,0,0,.7);color:#fff;font-size:14px;pointer-events:auto;display:none}

    /* AK47 Zoom slider */
    #zoomBox{position:absolute;right:4px;bottom:540px;display:none;pointer-events:auto;z-index:25}
    #zoomSlider{appearance:none;width:360px;height:64px;transform:rotate(-90deg);background:rgba(0,0,0,.4);border-radius:999px;outline:none;border:1px solid rgba(255,255,255,.2)}
    #zoomSlider::-webkit-slider-thumb{appearance:none;width:50px;height:50px;border-radius:50%;background:#ffd966;border:1px solid rgba(0,0,0,.4)}
    #zoomSlider::-moz-range-thumb{width:50px;height:50px;border-radius:50%;background:#ffd966;border:1px solid rgba(0,0,0,.4)}

    /* Win/Lose banner */
    #result{position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);padding:18px 22px;border-radius:14px;font-weight:900;color:#fff;background:rgba(0,0,0,.6);display:none}
  </style>
</head>
<body>
  <div id="wrap"></div>

  <div class="hud">
    <div class="row top">
      <div style="display:flex;gap:6px;align-items:center">
        <div class="chip" id="status">Urban Ops â€¢ Ready</div>
        <div id="br" class="chip">BR: ON</div>
      </div>
      <div style="display:flex;gap:6px;align-items:center">
        <div id="modeBox">
          <button id="modeA" class="modeBtn active">A: Drag Aim</button>
          <button id="modeB" class="modeBtn">B: Dual Sticks</button>
        </div>
        <button id="muteBtn" class="btn">ðŸ”Š</button>
      </div>
    </div>

    <div id="healthbar"><div id="healthfill"></div></div>
    <div id="ammo">â€”</div>
    <div id="crosshair"></div>

    <div id="joyMove" class="joy"><div class="knob"></div></div>
    <div id="shootPad" class="joy"><div class="knob"></div><button id="reloadMini" class="btn">RELOAD</button></div>
    <div id="aimPad" class="joy"><div class="knob"></div></div>

    <div id="zoomBox"><input id="zoomSlider" type="range" min="1" max="3" step="0.01" value="1" /></div>

    <div id="armory"></div>

    <button id="useCarBtn">ðŸš— Enter Car</button>
    <button id="exitCarBtn">â¬… Exit Car</button>
    <button id="hornBtn">ðŸ“£ Horn</button>
    <button id="brakeBtn">ðŸ…¿ Handbrake</button>
    <button id="climbBtn">â¬† Climb Ladder</button>

    <div id="mini">fps: â€”</div>
    <div id="result"></div>

    <div class="row bottom">
      <div class="chip">Move (â¤´ï¸Ž left)=WASD â€¢ Aim = drag screen (A) or right stick (B) â€¢ tap right=Shoot</div>
      <button id="resetBtn" class="btn">Reset</button>
    </div>
  </div>

  <script type="module">
    import * as THREE from 'https://esm.sh/three@0.160.0';
    import * as CANNON from 'https://esm.sh/cannon-es@0.20.0';
    import { GLTFLoader } from 'https://esm.sh/three@0.160.0/examples/jsm/loaders/GLTFLoader.js';
    import { DRACOLoader } from 'https://esm.sh/three@0.160.0/examples/jsm/loaders/DRACOLoader.js';
    import * as SkeletonUtils from 'https://esm.sh/three@0.160.0/examples/jsm/utils/SkeletonUtils.js';
    import { Water } from 'https://esm.sh/three@0.160.0/examples/jsm/objects/Water2.js';

    (async function main(){
      const $ = (id)=>document.getElementById(id);
      const wrap = $('wrap');
      const isTouch = ('ontouchstart' in window) || (navigator.maxTouchPoints>0);
      const isMobile = isTouch || /Android|webOS|iPhone|iPad|iPod|Opera Mini|IEMobile/i.test(navigator.userAgent);

      const TARGET_FPS = 90;
      const PHYS_HZ    = 90;
      const AIM_RATE_A   = 0.52;
      const AIM_SMOOTH_A = 3.8;
      const LOOK_SENS_A  = isMobile ? 0.14 : 0.12;
      const AIM_SENS_B_X = 0.0014;
      const AIM_SENS_B_Y = 0.0012;

      const renderer = new THREE.WebGLRenderer({ antialias:true, powerPreference:'high-performance', precision:'mediump', alpha:false, stencil:false });
      renderer.outputColorSpace = THREE.SRGBColorSpace;
      renderer.toneMapping = THREE.ACESFilmicToneMapping;
      renderer.toneMappingExposure = 1.85;
      const allowShadows = !isMobile;
      renderer.shadowMap.enabled = allowShadows; renderer.shadowMap.type = THREE.PCFSoftShadowMap;
      wrap.appendChild(renderer.domElement);
      THREE.Cache.enabled = true;
      let dprBase = Math.min(window.devicePixelRatio||1, isMobile ? 0.9 : 1.5);
      let dprScale = isMobile ? 0.72 : 1.0;
      function fit(){ const w=wrap.clientWidth||innerWidth, h=wrap.clientHeight||innerHeight; renderer.setPixelRatio(dprBase*dprScale); renderer.setSize(w,h,false); camera.aspect=w/h; camera.updateProjectionMatrix(); }
      addEventListener('resize', fit);

      const scene = new THREE.Scene(); scene.background = new THREE.Color('#f3e3c7'); scene.fog = new THREE.Fog('#ffe8c7', 700, 2600);
      const camera = new THREE.PerspectiveCamera(70, 9/16, 0.01, 8000); camera.position.set(0,1.7,5.6); scene.add(camera);
      let camDist = 4.2; fit();

      const hemi = new THREE.HemisphereLight(0xfff3d6, 0x8a7a6a, 0.55);
      const key  = new THREE.DirectionalLight(0xffd6a0, allowShadows?1.25:1.0); key.position.set(220, 350, 180); key.castShadow=allowShadows; if(allowShadows){ key.shadow.mapSize.set(isMobile?1024:2048,isMobile?1024:2048); key.shadow.camera.near=1; key.shadow.camera.far=3000; key.shadow.camera.left=-900; key.shadow.camera.right=900; key.shadow.camera.top=900; key.shadow.camera.bottom=-900; }
      scene.add(hemi, key);
      const muzzleLight = new THREE.PointLight(0xfff1c6, 0.0, 2.0); scene.add(muzzleLight);

      const world = new CANNON.World({ gravity: new CANNON.Vec3(0,-9.81,0) });
      world.broadphase = new CANNON.SAPBroadphase(world); world.allowSleep = true;
      const matGround=new CANNON.Material('ground'), matPlayer=new CANNON.Material('player'), matEnemy=new CANNON.Material('enemy'), matCar=new CANNON.Material('car'), matBall=new CANNON.Material('bball');
      world.addContactMaterial(new CANNON.ContactMaterial(matGround, matPlayer, { friction:.2, restitution:0 }));
      world.addContactMaterial(new CANNON.ContactMaterial(matGround, matCar, { friction:.9, restitution:0 }));
      world.addContactMaterial(new CANNON.ContactMaterial(matGround, matBall, { friction:.45, restitution:0.86 }));
      const groundBody = new CANNON.Body({ mass:0, material:matGround, shape:new CANNON.Plane() });
      groundBody.quaternion.setFromEuler(-Math.PI/2,0,0); world.addBody(groundBody);

      // ===== City base
      function makeAsphalt(size=1024){ const c=document.createElement('canvas'); c.width=c.height=size; const x=c.getContext('2d'); x.fillStyle='#2b313a'; x.fillRect(0,0,size,size); for(let i=0;i<3800;i++){ const a=Math.random()*0.12; x.fillStyle=`rgba(255,255,255,${a})`; x.fillRect(Math.random()*size,Math.random()*size,1,1);} const t=new THREE.CanvasTexture(c); t.wrapS=t.wrapT=THREE.RepeatWrapping; t.repeat.set(16,16); t.anisotropy=2; t.colorSpace=THREE.SRGBColorSpace; return t; }
      function makeSidewalk(size=512){ const c=document.createElement('canvas'); c.width=c.height=size; const x=c.getContext('2d'); x.fillStyle='#c9ced6'; x.fillRect(0,0,size,size); x.strokeStyle='#9aa0a8'; x.lineWidth=6; for(let s=0;s<size;s+=64){ x.beginPath(); x.moveTo(s,0); x.lineTo(s,size); x.stroke(); x.beginPath(); x.moveTo(0,s); x.lineTo(size,s); x.stroke(); } const t=new THREE.CanvasTexture(c); t.wrapS=t.wrapT=THREE.RepeatWrapping; t.repeat.set(32,32); t.anisotropy=2; t.colorSpace=THREE.SRGBColorSpace; return t; }
      function facadeTex(hue=200){ const W=256,H=512; const c=document.createElement('canvas'); c.width=W; c.height=H; const ctx=c.getContext('2d'); ctx.fillStyle=`hsl(${hue},16%,74%)`; ctx.fillRect(0,0,W,H); for(let i=0;i<1800;i++){ const a=Math.random()*0.08; ctx.fillStyle=`rgba(0,0,0,${a})`; ctx.fillRect(Math.random()*W,Math.random()*H,1,1);} const cols=6+Math.floor(Math.random()*4), rows=14+Math.floor(Math.random()*6); const padX=12,padY=16; const cellW=(W-2*padX)/cols, cellH=(H-2*padY)/rows; for(let r=0;r<rows;r++){ for(let cix=0;cix<cols;cix++){ const x=padX+cix*cellW+6, y=padY+r*cellH+6, w=cellW-12, h=cellH-12; const g=ctx.createLinearGradient(0,y,0,y+h); g.addColorStop(0,'rgba(240,245,255,0.95)'); g.addColorStop(0.5,'rgba(150,180,220,0.92)'); g.addColorStop(1,'rgba(60,80,120,0.9)'); ctx.fillStyle=g; ctx.fillRect(x,y,w,h); ctx.strokeStyle='rgba(24,28,38,0.9)'; ctx.lineWidth=2; ctx.strokeRect(x,y,w,h); } } const tex=new THREE.CanvasTexture(c); tex.anisotropy=2; tex.colorSpace=THREE.SRGBColorSpace; return tex; }

      const asphaltTex = makeAsphalt(); const sidewalkTex = makeSidewalk();
      const city = new THREE.Group(); scene.add(city);
      const BLOCKS_X=6, BLOCKS_Z=6; const CELL=120; const ROAD=22; const PLOT=CELL-ROAD*2; const startX = -(BLOCKS_X*CELL)/2 + CELL/2; const startZ = -(BLOCKS_Z*CELL)/2 + CELL/2;

      const groundGeo = new THREE.PlaneGeometry((CELL)*BLOCKS_X + ROAD*2, (CELL)*BLOCKS_Z + ROAD*2);
      const groundMat = new THREE.MeshLambertMaterial({ color: 0xf0e4cf });
      const gnd = new THREE.Mesh(groundGeo, groundMat); gnd.rotation.x=-Math.PI/2; gnd.receiveShadow=allowShadows; city.add(gnd);

      const roadMat = new THREE.MeshLambertMaterial({ map: asphaltTex });
      for(let ix=0; ix<=BLOCKS_X; ix++){ const geo=new THREE.PlaneGeometry(ROAD,(CELL)*BLOCKS_Z + ROAD); const m=new THREE.Mesh(geo, roadMat); m.rotation.x=-Math.PI/2; m.position.set(ix*CELL-(BLOCKS_X*CELL)/2, 0.01, ROAD*0.5-(BLOCKS_Z*CELL)/2); m.receiveShadow=allowShadows; city.add(m); }
      for(let iz=0; iz<=BLOCKS_Z; iz++){ const geo=new THREE.PlaneGeometry((CELL)*BLOCKS_X + ROAD, ROAD); const m=new THREE.Mesh(geo, roadMat); m.rotation.x=-Math.PI/2; m.position.set(ROAD*0.5-(BLOCKS_X*CELL)/2, 0.01, iz*CELL-(BLOCKS_Z*CELL)/2); m.receiveShadow=allowShadows; city.add(m); }

      const sidewalkMat = new THREE.MeshLambertMaterial({ map: sidewalkTex });
      function addSidewalk(xc,zc){ const w=CELL-ROAD, h=CELL-ROAD; const geo=new THREE.BoxGeometry(w,2,h); const m=new THREE.Mesh(geo, sidewalkMat); m.castShadow=false; m.receiveShadow=allowShadows; m.position.set(xc,1,zc); city.add(m); }

      // ======== NEW: Park base (grass center + ring sidewalk + trees perimeter) ========
      const trunkGeo=new THREE.CylinderGeometry(0.5,0.8,6,8);
      const crownGeo=new THREE.IcosahedronGeometry(3.2,1);
      const trunks=new THREE.InstancedMesh(trunkGeo, new THREE.MeshLambertMaterial({ color:0x6e4f2f }), 1200);
      const crowns=new THREE.InstancedMesh(crownGeo, new THREE.MeshLambertMaterial({ color:0x3a6f42 }), 1200);
      let ti=0; function placeTree(x,z){ const m1=new THREE.Matrix4(); m1.makeTranslation(x,3,z); trunks.setMatrixAt(ti,m1); const m2=new THREE.Matrix4(); m2.makeTranslation(x,9,z); crowns.setMatrixAt(ti,m2); ti++; }
      function treesOnPerimeter(cx,cz){ const half=PLOT*0.45; const step=8; for(let x=-half;x<=half;x+=step){ placeTree(cx+x, cz-half); placeTree(cx+x, cz+half); } for(let z=-half;z<=half;z+=step){ placeTree(cx-half, cz+z); placeTree(cx+half, cz+z); } }

      // Shared tennis-like grass texture for all parks/fountains/tennis
      const maxAniso = renderer.capabilities.getMaxAnisotropy?.() || 8;
      function makeGrassTex(size=1024){ const c=document.createElement('canvas'); c.width=c.height=size; const g=c.getContext('2d'); const grd=g.createLinearGradient(0,0,size,size); grd.addColorStop(0,'#2d6b33'); grd.addColorStop(1,'#3b8c44'); g.fillStyle=grd; g.fillRect(0,0,size,size); g.globalAlpha=0.14; g.fillStyle='#1f5125'; for(let i=0;i<12000;i++){ g.fillRect(Math.random()*size,Math.random()*size,1,1);} g.globalAlpha=1; const t=new THREE.CanvasTexture(c); t.wrapS=t.wrapT=THREE.RepeatWrapping; t.repeat.set(4,8); t.anisotropy=Math.min(16,maxAniso); t.colorSpace=THREE.SRGBColorSpace; return t; }
      const grassTexCommon = makeGrassTex();
      const grassMatCommon = new THREE.MeshStandardMaterial({ map: grassTexCommon, roughness: 0.95, metalness: 0.0 });

      function addParkBase(cx,cz){
        const w=PLOT, h=PLOT; // full plot size
        const grass=new THREE.Mesh(new THREE.PlaneGeometry(w-6, h-6), grassMatCommon);
        grass.rotation.x=-Math.PI/2; grass.position.set(cx,0.012,cz); city.add(grass);
        const ring=6; // sidewalk ring width
        function strip(px,pz,sw,sh){ const s=new THREE.Mesh(new THREE.PlaneGeometry(sw,sh), sidewalkMat); s.rotation.x=-Math.PI/2; s.position.set(px,0.014,pz); city.add(s); }
        strip(cx, cz - (h/2 - ring/2), w, ring); // north
        strip(cx, cz + (h/2 - ring/2), w, ring); // south
        strip(cx - (w/2 - ring/2), cz, ring, h-2*ring); // west
        strip(cx + (w/2 - ring/2), cz, ring, h-2*ring); // east
        treesOnPerimeter(cx,cz);
      }
      // ======== END Park base ========

      // ======== NEW: Pro court + decor helpers ========
      function trackTex(w = 1024, h = 1024) {
        const c = document.createElement('canvas'); c.width = w; c.height = h; const g = c.getContext('2d');
        g.fillStyle = '#b33a2c'; g.fillRect(0, 0, w, h);
        const dots = Math.floor(w * h * 0.004);
        for (let i = 0; i < dots; i++) {
          const x = Math.random() * w, y = Math.random() * h; const r = Math.random() * 1.6 + 0.2;
          g.fillStyle = Math.random() < 0.5 ? 'rgba(255,190,180,0.35)' : 'rgba(40,12,10,0.35)';
          g.beginPath(); g.arc(x, y, r, 0, Math.PI * 2); g.fill();
        }
        const t = new THREE.CanvasTexture(c); t.anisotropy = Math.min(16, maxAniso); t.wrapS = t.wrapT = THREE.RepeatWrapping; t.colorSpace = THREE.SRGBColorSpace; t.repeat.set(1,1); return t;
      }
      function tennisLinesTex(courtW, courtL) {
        const w = 2048, h = 4096; const c = document.createElement('canvas'); c.width=w; c.height=h; const g=c.getContext('2d');
        const s = h / courtL; const lineW=12; g.strokeStyle='#ffffff'; g.lineWidth=lineW; g.lineJoin='round'; g.lineCap='round';
        const halfW=courtW/2, halfL=courtL/2; const X=(x)=> (w/2 + x*s), Z=(z)=> (h/2 + z*s);
        const line=(x1,z1,x2,z2)=>{ g.beginPath(); g.moveTo(X(x1),Z(z1)); g.lineTo(X(x2),Z(z2)); g.stroke(); };
        const box=(x1,z1,x2,z2)=>{ line(x1,z1,x2,z1); line(x2,z1,x2,z2); line(x2,z2,x1,z2); line(x1,z2,x1,z1); };
        const serviceZ = 6.4; box(-halfW,-halfL,halfW,halfL);
        line(-halfW,-halfL,halfW,-halfL); line(-halfW,halfL,halfW,halfL);
        line(-halfW,-serviceZ,halfW,-serviceZ); line(-halfW,serviceZ,halfW,serviceZ); line(0,-serviceZ,0,serviceZ);
        const t = new THREE.CanvasTexture(c); t.anisotropy=Math.min(16,maxAniso); t.wrapS=t.wrapT=THREE.ClampToEdgeWrapping; return t;
      }
      function basketLinesTex(w=28,h=15){
        const W=4096,H=4096; const c=document.createElement('canvas'); c.width=W; c.height=H; const g=c.getContext('2d'); g.clearRect(0,0,W,H);
        g.strokeStyle='#ffffff'; g.lineWidth=26; g.lineJoin='round'; g.lineCap='round';
        const Sx=W/w, Sz=H/h; const X=(x)=> x*Sx + W/2; const Z=(z)=> z*Sz + H/2;
        const rect=(x1,z1,x2,z2)=>{ g.strokeRect(X(x1), Z(z1), (x2-x1)*Sx, (z2-z1)*Sz); };
        // Outer
        rect(-w/2,-h/2,w/2,h/2);
        // Center line & circle (râ‰ˆ1.8m)
        g.beginPath(); g.moveTo(X(-w/2), Z(0)); g.lineTo(X(w/2), Z(0)); g.stroke();
        g.beginPath(); g.arc(X(0), Z(0), 1.8*Sx, 0, Math.PI*2); g.stroke();
        // Keys 4.9 x 5.8
        rect(-w/2, -h/2, -w/2+4.9, -h/2+5.8); rect(w/2-4.9, h/2-5.8, w/2, h/2);
        // Free-throw circles râ‰ˆ1.8
        g.beginPath(); g.arc(X(-w/2+4.9/2), Z(-h/2+5.8/2+2.9), 1.8*Sx, 0, Math.PI*2); g.stroke();
        g.beginPath(); g.arc(X(w/2-4.9/2), Z(h/2-5.8/2-2.9), 1.8*Sx, 0, Math.PI*2); g.stroke();
        // Restricted area (semi-circles râ‰ˆ1.25)
        const rRA=1.25; const hoopOffset=1.575;
        g.beginPath(); g.arc(X(0), Z(-h/2+hoopOffset), rRA*Sx, 0, Math.PI); g.stroke();
        g.beginPath(); g.arc(X(0), Z(h/2-hoopOffset), rRA*Sx, Math.PI, Math.PI*2); g.stroke();
        // 3pt arcs râ‰ˆ6.75
        const r3=6.75;
        g.beginPath(); g.arc(X(0), Z(-h/2+hoopOffset), r3*Sx, -0.85, Math.PI+0.85); g.stroke();
        g.beginPath(); g.arc(X(0), Z(h/2-hoopOffset), r3*Sx, Math.PI-0.85, Math.PI*2+0.85); g.stroke();
        const t=new THREE.CanvasTexture(c); t.anisotropy=Math.min(16,maxAniso); t.wrapS=t.wrapT=THREE.ClampToEdgeWrapping; t.needsUpdate=true; return t;
      }
      function fenceTex(w=512,h=512,cell=16){ const c=document.createElement('canvas'); c.width=w; c.height=h; const g=c.getContext('2d'); g.clearRect(0,0,w,h); g.strokeStyle='rgba(180,188,198,0.85)'; g.lineWidth=2; for(let y=cell;y<h;y+=cell){ g.beginPath(); g.moveTo(0,y); g.lineTo(w,y); g.stroke(); } for(let x=cell;x<w;x+=cell){ g.beginPath(); g.moveTo(x,0); g.lineTo(x,h); g.stroke(); } const t=new THREE.CanvasTexture(c); t.wrapS=t.wrapT=THREE.RepeatWrapping; t.repeat.set(4,2); return t; }
      function meshTex(w=1024,h=1024,cell=20){ const c=document.createElement('canvas'); c.width=w; c.height=h; const g=c.getContext('2d'); g.clearRect(0,0,w,h); g.strokeStyle='rgba(255,255,255,0.9)'; g.lineWidth=2; for(let y=cell;y<h;y+=cell){ g.beginPath(); g.moveTo(0,y); g.lineTo(w,y); g.stroke(); } for(let x=cell;x<w;x+=cell){ g.beginPath(); g.moveTo(x,0); g.lineTo(x,h); g.stroke(); } const t=new THREE.CanvasTexture(c); t.anisotropy=Math.min(8,maxAniso); t.wrapS=t.wrapT=THREE.ClampToEdgeWrapping; return t; }
      function basketballTex(S=1024){ const c=document.createElement('canvas'); c.width=c.height=S; const g=c.getContext('2d'); g.fillStyle='#d6682a'; g.fillRect(0,0,S,S); g.globalAlpha=0.18; g.fillStyle='#f0a06e'; for(let i=0;i<S*S*0.02;i++) g.fillRect(Math.random()*S,Math.random()*S,1,1); g.globalAlpha=1; g.lineWidth=Math.max(10,S*0.03); g.strokeStyle='#1d1d1d'; const draw=()=>{ g.beginPath(); g.moveTo(0,S*0.5); g.bezierCurveTo(S*0.25,S*0.3,S*0.75,S*0.7,S, S*0.5); g.stroke(); g.beginPath(); g.moveTo(0,S*0.5); g.bezierCurveTo(S*0.25,S*0.7,S*0.75,S*0.3,S, S*0.5); g.stroke(); g.beginPath(); g.moveTo(S*0.5,0); g.lineTo(S*0.5,S); g.stroke(); g.beginPath(); g.arc(S*0.5,S*0.5,S*0.48,0,Math.PI*2); g.stroke(); }; draw(); const t=new THREE.CanvasTexture(c); t.anisotropy=Math.min(8,maxAniso); t.colorSpace=THREE.SRGBColorSpace; return t; }

      const matTrack = new THREE.MeshStandardMaterial({ map: trackTex(), roughness: 0.96, metalness: 0.0 });
      const matFence = new THREE.MeshBasicMaterial({ map:fenceTex(), transparent:true, opacity:0.85 });
      const matPost  = new THREE.MeshStandardMaterial({ color:0xb7bcc7, roughness:0.45, metalness:0.35 });
      const matTape  = new THREE.MeshBasicMaterial({ color:0xffffff });

      let PROJ_LIGHT_BUDGET = 8; const projLights=[];
      function addProjector(x,y,z,dir){ const head=new THREE.Mesh(new THREE.BoxGeometry(0.22,0.16,0.28), new THREE.MeshStandardMaterial({ color:0xeeeeee, emissive:0xffffcc, emissiveIntensity:0.9, roughness:0.6, metalness:0.1 })); head.position.set(x,y,z); head.lookAt(x+dir.x, y+dir.y, z+dir.z); city.add(head); if(projLights.length<PROJ_LIGHT_BUDGET){ const sp=new THREE.SpotLight(0xfff2cc, 1.15, 36, Math.PI/5.5, 0.35, 1.8); sp.position.set(x,y,z); sp.target.position.set(x+dir.x*5, y-3, z+dir.z*5); scene.add(sp, sp.target); projLights.push(sp); } }

      function addFenceRect(cx,cz,w,l,h=2.6,doorW=2.4){
        const halfW=w/2, halfL=l/2;
        const makeSide=(len,dx,dz,rot,hasDoor)=>{ const group=new THREE.Group(); const gap=hasDoor?doorW:0; const segLen=(len-gap)/2; const geo=new THREE.PlaneGeometry(segLen,h); const left=new THREE.Mesh(geo, matFence); const right=new THREE.Mesh(geo, matFence); left.position.set(-(gap/2+segLen/2), h/2, 0); right.position.set((gap/2+segLen/2), h/2, 0); left.rotation.y=Math.PI; group.add(left,right); group.position.set(cx+dx, 0, cz+dz); group.rotation.y=rot; city.add(group); const postGeo=new THREE.CylinderGeometry(0.05,0.05,h,10); const p1=new THREE.Mesh(postGeo, matPost), p2=p1.clone(); p1.position.set(cx+dx - (hasDoor?gap/2:0) - segLen, h/2, cz+dz); p1.rotation.y=rot; p2.position.set(cx+dx + (hasDoor?gap/2:0) + segLen, h/2, cz+dz); p2.rotation.y=rot; city.add(p1,p2); };
        makeSide(w, 0,  halfL, 0, true);
        makeSide(w, 0, -halfL, Math.PI, true);
        makeSide(l,  halfW, 0, -Math.PI/2, false);
        makeSide(l, -halfW, 0,  Math.PI/2, false);
      }

      // ===== Courts =====
      const TEN_W=9.2, TEN_L=23.77, TEN_APRON=2.6;

      const basketballs=[]; // {mesh, body}
      function addTennisStadium(cx,cz){
        const courtW=TEN_W, courtL=TEN_L, apron=TEN_APRON; const netH=0.914;
        const track=new THREE.Mesh(new THREE.PlaneGeometry(courtW+apron*2, courtL+apron*2), matTrack); track.rotation.x=-Math.PI/2; track.position.set(cx,0.03,cz); city.add(track);
        const grass=new THREE.Mesh(new THREE.PlaneGeometry(courtW, courtL), grassMatCommon); grass.rotation.x=-Math.PI/2; grass.position.set(cx,0.031,cz); city.add(grass);
        const lines=new THREE.Mesh(new THREE.PlaneGeometry(courtW, courtL), new THREE.MeshBasicMaterial({ map:tennisLinesTex(courtW,courtL), transparent:true, opacity:0.995, polygonOffset:true, polygonOffsetFactor:-2, polygonOffsetUnits:-2, depthWrite:false })); lines.rotation.x=-Math.PI/2; lines.position.set(cx,0.032,cz); city.add(lines);
        const netTex=(function(){ const c=document.createElement('canvas'); c.width=1024; c.height=512; const g=c.getContext('2d'); g.clearRect(0,0,1024,512); g.strokeStyle='rgba(18,18,18,0.96)'; g.lineWidth=2; for(let y=8;y<512;y+=8){ g.beginPath(); g.moveTo(8,y); g.lineTo(1016,y); g.stroke(); } for(let x=8;x<1024;x+=8){ g.beginPath(); g.moveTo(x,8); g.lineTo(x,504); g.stroke(); } return new THREE.CanvasTexture(c); })();
        const net=new THREE.Mesh(new THREE.PlaneGeometry(courtW, netH), new THREE.MeshStandardMaterial({ map:netTex, transparent:true, roughness:0.8, metalness:0.0, color:0xffffff })); net.position.set(cx, netH/2, cz); city.add(net);
        const tapeH=0.09; const top=new THREE.Mesh(new THREE.BoxGeometry(courtW, tapeH, 0.02), matTape); top.position.set(cx, netH - tapeH/2, cz+0.005); const bot=top.clone(); bot.position.set(cx, tapeH/2, cz+0.005); city.add(top,bot);
        const postL=new THREE.Mesh(new THREE.CylinderGeometry(0.06,0.06,1.35,16), matPost); postL.position.set(cx - courtW/2, 0.675, cz); const postR=postL.clone(); postR.position.x = cx + courtW/2; city.add(postL,postR);
        const capL=new THREE.Mesh(new THREE.SphereGeometry(0.07, 16, 12), matPost); capL.position.set(cx - courtW/2, 1.35, cz); const capR=capL.clone(); capR.position.x=cx + courtW/2; city.add(capL,capR);
        addFenceRect(cx,cz,courtW+apron*2, courtL+apron*2, 2.8, 2.4);
        const h=6.8; const posts=[[-1,-1],[1,-1],[-1,1],[1,1]]; posts.forEach(([sx,sz])=>{ const p=new THREE.Mesh(new THREE.CylinderGeometry(0.08,0.08,h,12), matPost); p.position.set(cx+sx*(courtW/2+apron+0.6), h/2, cz+sz*(courtL/2+apron+0.6)); city.add(p); addProjector(p.position.x, h-0.3, p.position.z, new THREE.Vector3(-sx*0.6, -1, -sz*0.6).normalize()); });
      }

      function addBasketballStadium(cx,cz){
        const courtW=TEN_W, courtL=TEN_L, apron=TEN_APRON; // SAME SIZE as tennis
        const surface=new THREE.Mesh(new THREE.PlaneGeometry(courtW, courtL), matTrack); surface.rotation.x=-Math.PI/2; surface.position.set(cx,0.031,cz); city.add(surface);
        const apronMesh=new THREE.Mesh(new THREE.PlaneGeometry(courtW+apron*2, courtL+apron*2), matTrack); apronMesh.rotation.x=-Math.PI/2; apronMesh.position.set(cx,0.03,cz); city.add(apronMesh);
        const lines=new THREE.Mesh(new THREE.PlaneGeometry(courtW, courtL), new THREE.MeshBasicMaterial({ map:basketLinesTex(courtW,courtL), transparent:true, opacity:0.995, depthWrite:false })); lines.rotation.x=-Math.PI/2; lines.position.set(cx,0.032,cz); city.add(lines);
        const sideH=1.6; const sideNetMat=new THREE.MeshStandardMaterial({ map:meshTex(1024,512,20), color:0xffffff, transparent:true, opacity:0.9, roughness:0.9, metalness:0.0 });
        const sideGeo=new THREE.PlaneGeometry(courtL, sideH);
        const s1=new THREE.Mesh(sideGeo, sideNetMat); s1.position.set(cx - courtW/2 + 0.05, sideH/2, cz); s1.rotation.y=Math.PI/2; const s2=s1.clone(); s2.position.x = cx + courtW/2 - 0.05; s2.rotation.y=-Math.PI/2; city.add(s1,s2);
        const hoopMat=new THREE.MeshStandardMaterial({ color:0xffffff, roughness:0.4, metalness:0.1 });
        const boardMat=new THREE.MeshStandardMaterial({ color:0xffffff, transparent:true, opacity:0.08, roughness:0.2, metalness:0.0 });
        const postMat=new THREE.MeshStandardMaterial({ color:0x8a8f99, roughness:0.6, metalness:0.3 });
        const rimMat=new THREE.MeshStandardMaterial({ color:0xff3c3c, roughness:0.5, metalness:0.2 });
        const hoopNetTex=meshTex(1024,1024,22);
        const hoopNetMat=new THREE.MeshStandardMaterial({ map:hoopNetTex, color:0xffffff, transparent:true, opacity:0.95, roughness:0.9, metalness:0.0 });
        function makeHoop(side){ const group=new THREE.Group(); const postH=3.6; const pole=new THREE.Mesh(new THREE.CylinderGeometry(0.08,0.1,postH,14), postMat); pole.position.y=postH/2; group.add(pole); const arm=new THREE.Mesh(new THREE.BoxGeometry(1.0,0.08,0.08), postMat); arm.position.set(0.5,3.05,0); group.add(arm); const board=new THREE.Mesh(new THREE.BoxGeometry(1.8,1.05,0.04), boardMat); board.position.set(1.2,3.05,0); group.add(board); const sq=new THREE.Mesh(new THREE.PlaneGeometry(0.6,0.45), hoopMat); sq.position.set(1.2,3.05,0.021); group.add(sq); const rim=new THREE.Mesh(new THREE.TorusGeometry(0.225,0.03,10,28), rimMat); rim.rotation.x=Math.PI/2; rim.position.set(1.2+0.35,3.05,0); group.add(rim); const net=new THREE.Mesh(new THREE.ConeGeometry(0.24,0.45,18,1,true), hoopNetMat); net.position.set(1.2+0.35,2.85,0); group.add(net); const base=new THREE.Mesh(new THREE.CylinderGeometry(0.18,0.18,0.14,16), postMat); base.position.set(0,0.07,0); group.add(base); group.position.set(cx, 0, cz + side*(courtL/2 - 1.2)); group.rotation.y = side>0 ? Math.PI : 0; city.add(group); }
        makeHoop(-1); makeHoop(1);
        addFenceRect(cx,cz,courtW+apron*2, courtL+apron*2, 2.8, 2.8);
        const h=6.4; const posts=[[-1,-1],[1,-1],[-1,1],[1,1]]; posts.forEach(([sx,sz])=>{ const p=new THREE.Mesh(new THREE.CylinderGeometry(0.08,0.08,h,12), matPost); p.position.set(cx+sx*(courtW/2+apron+0.6), h/2, cz+sz*(courtL/2+apron+0.6)); city.add(p); addProjector(p.position.x, h-0.3, p.position.z, new THREE.Vector3(-sx*0.6, -1, -sz*0.6).normalize()); });
        const ballTex=basketballTex(1024); const ballMat=new THREE.MeshStandardMaterial({ map:ballTex, roughness:0.6, metalness:0.05 }); const r=0.12;
        for(let i=0;i<3;i++){
          const mx=new THREE.Mesh(new THREE.SphereGeometry(r,28,18), ballMat); mx.castShadow=allowShadows; mx.position.set(cx + (Math.random()*2-1)*2.2, 0.12+0.02, cz + (Math.random()*2-1)*3.2); city.add(mx);
          const body=new CANNON.Body({ mass:0.62, material:matBall, shape:new CANNON.Sphere(r), linearDamping:0.12, angularDamping:0.05 }); body.position.set(mx.position.x, mx.position.y, mx.position.z); world.addBody(body);
          basketballs.push({mesh:mx, body});
        }
      }
      // ======== END pro court helpers ========

      // ======== NEW: Fountain area (same footprint as tennis) ========
      const waterNormals = new THREE.TextureLoader().load('https://threejs.org/examples/textures/waternormals.jpg', (t)=>{ t.wrapS=t.wrapT=THREE.RepeatWrapping; });
      function flowerTexture(){ const S=128; const c=document.createElement('canvas'); c.width=c.height=S; const g=c.getContext('2d'); g.clearRect(0,0,S,S); function petal(cx,cy,r,a,col){ g.save(); g.translate(cx,cy); g.rotate(a); const grd=g.createLinearGradient(0,-r,0,r); grd.addColorStop(0,col); grd.addColorStop(1,'rgba(255,255,255,0.85)'); g.fillStyle=grd; g.beginPath(); g.ellipse(0,0,r*0.45,r,0,0,Math.PI*2); g.fill(); g.restore(); }
        const cx=S/2, cy=S/2; const r=40; const cols=['#ff4d6d','#ff7b54','#ffd166','#70e000']; for(let i=0;i<8;i++){ petal(cx,cy,r, i*(Math.PI/4), cols[i%cols.length]); } g.beginPath(); g.arc(cx,cy,14,0,Math.PI*2); g.fillStyle='#ffd400'; g.fill(); const t=new THREE.CanvasTexture(c); t.colorSpace=THREE.SRGBColorSpace; t.anisotropy=4; t.needsUpdate=true; return t; }
      function addFountainArea(cx,cz){
        const areaW=TEN_W, areaL=TEN_L;
        const grass=new THREE.Mesh(new THREE.PlaneGeometry(areaW, areaL), grassMatCommon); grass.rotation.x=-Math.PI/2; grass.position.set(cx,0.031,cz); city.add(grass);
        const borderW=0.8; const stoneMat=new THREE.MeshStandardMaterial({ color:0xa9a29b, roughness:0.95, metalness:0.0 });
        const north=new THREE.Mesh(new THREE.PlaneGeometry(areaW, borderW), stoneMat); north.rotation.x=-Math.PI/2; north.position.set(cx,0.032,cz-areaL/2+borderW/2); const south=north.clone(); south.position.set(cx,0.032,cz+areaL/2-borderW/2);
        const west=new THREE.Mesh(new THREE.PlaneGeometry(borderW, areaL-borderW*2), stoneMat); west.rotation.x=-Math.PI/2; west.position.set(cx-areaW/2+borderW/2,0.032,cz); const east=west.clone(); east.position.set(cx+areaW/2-borderW/2,0.032,cz); city.add(north,south,west,east);
        const R=3.2; const poolRim=new THREE.Mesh(new THREE.TorusGeometry(R+0.22,0.22,12,64), stoneMat); poolRim.rotation.x=Math.PI/2; poolRim.position.set(cx,0.25,cz); city.add(poolRim);
        const water=new Water(new THREE.CircleGeometry(R,64),{ color:0x77aaff, textureWidth:1024, textureHeight:1024, flowDirection:new THREE.Vector2(1,1), scale:1.2, normalMap0:waterNormals, normalMap1:waterNormals }); water.rotation.x=-Math.PI/2; water.position.set(cx,0.24,cz); city.add(water);
        const rockMat=new THREE.MeshStandardMaterial({ color:0x8d8277, roughness:0.98, metalness:0.0 });
        for(let i=0;i<36;i++){ const a=(i/36)*Math.PI*2 + Math.random()*0.1; const rr=R+0.6 + Math.random()*0.7; const w=0.25+Math.random()*0.5, h=0.12+Math.random()*0.24, d=0.2+Math.random()*0.4; const m=new THREE.Mesh(new THREE.DodecahedronGeometry(1,0), rockMat); m.scale.set(w,h,d); m.position.set(cx+Math.cos(a)*rr, 0.06, cz+Math.sin(a)*rr); m.rotation.y=Math.random()*Math.PI*2; city.add(m); }
        const flTex=flowerTexture(); const flMat=new THREE.SpriteMaterial({ map:flTex, depthWrite:false });
        for(let i=0;i<80;i++){ const rx=(Math.random()-0.5)*areaW*0.8, rz=(Math.random()-0.5)*areaL*0.8; if(Math.hypot(rx,rz)<R+0.8) continue; const s=0.3+Math.random()*0.4; const sp=new THREE.Sprite(flMat); sp.scale.set(s,s,1); sp.position.set(cx+rx,0.28,cz+rz); city.add(sp); }
        addFenceRect(cx,cz, areaW, areaL, 1.8, 2.4);
        const h=6.0; const posts=[[-1,-1],[1,-1],[-1,1],[1,1]]; posts.forEach(([sx,sz])=>{ const p=new THREE.Mesh(new THREE.CylinderGeometry(0.08,0.08,h,12), matPost); p.position.set(cx+sx*(areaW/2+0.9), h/2, cz+sz*(areaL/2+0.9)); city.add(p); addProjector(p.position.x, h-0.3, p.position.z, new THREE.Vector3(-sx*0.6, -1, -sz*0.6).normalize()); });
      }
      // ======== END Fountain ========

      // Ladders & buildings
      function addLadder(x,z,y0,y1){ const railMat=new THREE.MeshBasicMaterial({ color:0x9aa3ad }); const stepMat=new THREE.MeshBasicMaterial({ color:0x8a929c }); const g=new THREE.Group(); const railL=new THREE.Mesh(new THREE.BoxGeometry(0.08, y1-y0, 0.08), railMat); const railR=railL.clone(); railL.position.set(-0.25, (y0+y1)/2, 0); railR.position.set(0.25, (y0+y1)/2, 0); g.add(railL,railR); for(let y=y0+0.3;y<y1;y+=0.35){ const s=new THREE.Mesh(new THREE.BoxGeometry(0.6,0.05,0.08), stepMat); s.position.set(0,y,0); g.add(s); } const arrow=new THREE.Mesh(new THREE.ConeGeometry(0.25,0.6,12), new THREE.MeshBasicMaterial({ color:0x1f6feb })); arrow.position.set(0,y1+0.6,0); g.add(arrow); g.position.set(x,0,z); city.add(g); ladders.push({x,z,y0,y1}); }
      function addRoofStair(x,z,y){ const m=new THREE.Mesh(new THREE.BoxGeometry(1.2,0.5,1.2), new THREE.MeshLambertMaterial({ color:0x444b55 })); m.position.set(x,y+0.4,z); city.add(m); return m; }
      function addBuilding(xc,zc){ const floors=6+Math.floor(Math.random()*12); const height=floors*(3.2); const w=30+Math.random()*20, d=30+Math.random()*20; const geom=new THREE.BoxGeometry(w,height,d); const hue=180+Math.floor(Math.random()*60); const mat=new THREE.MeshLambertMaterial({ map:facadeTex(hue) }); const roof=new THREE.MeshLambertMaterial({ color:0x55585c}); const mesh=new THREE.Mesh(geom, [mat,mat,roof,roof,mat,mat]); mesh.castShadow=allowShadows; mesh.receiveShadow=allowShadows; mesh.position.set(xc,height/2,zc); city.add(mesh); const body=new CANNON.Body({mass:0}); body.addShape(new CANNON.Box(new CANNON.Vec3(w/2,height/2,d/2))); body.position.set(xc,height/2,zc); world.addBody(body); addLadder(xc, zc + d/2 + 0.12, 0.3, height+0.6); addRoofStair(xc + (Math.random()*0.6-0.3)*w*0.6, zc + (Math.random()*0.6-0.3)*d*0.6, height); }

      // Civic buildings (police, hospital, school, mall, fire brigade)
      function signTex(text, fg='#ffffff', bg='rgba(17,23,42,0.92)'){ const W=512,H=256; const c=document.createElement('canvas'); c.width=W; c.height=H; const g=c.getContext('2d'); g.fillStyle=bg; g.fillRect(0,0,W,H); g.fillStyle=fg; g.font='bold 116px sans-serif'; g.textAlign='center'; g.textBaseline='middle'; g.fillText(text, W/2, H/2+8); const t=new THREE.CanvasTexture(c); t.anisotropy=4; t.colorSpace=THREE.SRGBColorSpace; return t; }
      const civicMats={ base:new THREE.MeshLambertMaterial({ color:0xd8dde6 }), glass:new THREE.MeshStandardMaterial({ color:0x88aacc, roughness:0.2, metalness:0.0, transparent:true, opacity:0.35 }), red:new THREE.MeshLambertMaterial({ color:0xc73e3e }), yellow:new THREE.MeshLambertMaterial({ color:0xe3b341 }), blue:new THREE.MeshLambertMaterial({ color:0x2a62d6 }) };
      const helisToSpin=[];
      function addHelicopter(x,y,z, color=0xc73e3e){ const g=new THREE.Group(); const body=new THREE.Mesh(new THREE.CapsuleGeometry(0.35,1.2,8,16), new THREE.MeshLambertMaterial({ color })); body.rotation.z=Math.PI/2; g.add(body); const tail=new THREE.Mesh(new THREE.CylinderGeometry(0.05,0.05,1.2,10), new THREE.MeshLambertMaterial({ color })); tail.position.set(-0.9,0.15,0); tail.rotation.z=Math.PI/2; g.add(tail); const rotor=new THREE.Mesh(new THREE.BoxGeometry(2.0,0.03,0.12), new THREE.MeshLambertMaterial({ color:0x222 })); rotor.position.set(0,0.35,0); g.add(rotor); const tailRotor=new THREE.Mesh(new THREE.BoxGeometry(0.6,0.03,0.08), new THREE.MeshLambertMaterial({ color:0x222 })); tailRotor.position.set(-1.4,0.15,0); tailRotor.rotation.y=Math.PI/2; g.add(tailRotor); g.position.set(x,y,z); city.add(g); helisToSpin.push({rotor,tailRotor}); return g; }
      function addCivic(type, x,z, rot=0){ const w=42, d=28, h=18; const base=new THREE.Mesh(new THREE.BoxGeometry(w,h,d), civicMats.base); base.position.set(x,h/2,z); base.rotation.y=rot; base.castShadow=allowShadows; base.receiveShadow=allowShadows; city.add(base); const door=new THREE.Mesh(new THREE.BoxGeometry(6,8,1.2), new THREE.MeshLambertMaterial({ color:0x5a6370 })); door.position.set(x + Math.cos(rot)* (w/2-1), 4, z + Math.sin(rot)*(w/2-1)); door.rotation.y=rot; city.add(door); const canopy=new THREE.Mesh(new THREE.BoxGeometry(10,0.6,4), civicMats.glass); canopy.position.set(door.position.x + Math.cos(rot)*2, 6.6, door.position.z + Math.sin(rot)*2); canopy.rotation.y=rot; city.add(canopy); let signText='CIVIC'; let signCol='#ffffff', bg='rgba(17,23,42,0.92)'; if(type==='POLICE'){ signText='POLICE'; signCol='#e6f0ff'; bg='rgba(18,36,92,0.95)'; }
        if(type==='HOSPITAL'){ signText='HOSPITAL'; signCol='#fff'; bg='rgba(170,20,30,0.95)'; const helipad=new THREE.Mesh(new THREE.CircleGeometry(6,36), new THREE.MeshBasicMaterial({ color:0x333333 })); helipad.rotation.x=-Math.PI/2; helipad.position.set(x, h+0.3, z); city.add(helipad); const Htex=(function(){ const c=document.createElement('canvas'); c.width=c.height=512; const g=c.getContext('2d'); g.fillStyle='rgba(0,0,0,0)'; g.fillRect(0,0,512,512); g.strokeStyle='#ffffff'; g.lineWidth=16; g.beginPath(); g.arc(256,256,180,0,Math.PI*2); g.stroke(); g.fillStyle='#ffffff'; g.fillRect(256-36,256-120,72,240); g.fillRect(256-120,256-36,240,72); const t=new THREE.CanvasTexture(c); t.colorSpace=THREE.SRGBColorSpace; return t; })(); const Hspr=new THREE.Sprite(new THREE.SpriteMaterial({ map:Htex, depthWrite:false })); Hspr.scale.set(10,10,1); Hspr.position.set(x,h+0.31,z); city.add(Hspr); addHelicopter(x+8, h+1.0, z, 0xc72b2b); }
        if(type==='SCHOOL'){ signText='SCHOOL'; signCol='#111'; bg='rgba(255,205,50,0.95)'; }
        if(type==='MALL'){ signText='MALL'; signCol='#fff'; bg='rgba(60,120,220,0.95)'; const glassFront=new THREE.Mesh(new THREE.PlaneGeometry(w*0.7, h*0.6), civicMats.glass); glassFront.position.set(x + Math.cos(rot)* (w/2-0.8), h*0.55, z + Math.sin(rot)*(w/2-0.8)); glassFront.rotation.y=rot+Math.PI/2; city.add(glassFront); }
        if(type==='FIRE'){ signText='FIRE BRIGADE'; signCol='#fff'; bg='rgba(210,40,40,0.95)'; const doorWide=new THREE.Mesh(new THREE.BoxGeometry(10,8,1.2), civicMats.red); doorWide.position.set(x + Math.cos(rot)* (w/2-1), 4, z + Math.sin(rot)*(w/2-1)); doorWide.rotation.y=rot; city.add(doorWide); }
        const sign=new THREE.Mesh(new THREE.PlaneGeometry(18,5), new THREE.MeshBasicMaterial({ map:signTex(signText,signCol,bg), transparent:true })); sign.position.set(x, h-2.2, z + Math.cos(rot)*0); sign.rotation.y=rot; city.add(sign); return {base}; }

      // Playgrounds (kept for variety)
      function addPlayground(cx,cz){ const w=30,h=20; const pad=new THREE.Mesh(new THREE.PlaneGeometry(w,h), new THREE.MeshBasicMaterial({ color:0x6fc1ff })); pad.rotation.x=-Math.PI/2; pad.position.set(cx,0.02,cz); city.add(pad); const sandbox=new THREE.Mesh(new THREE.BoxGeometry(6,0.6,6), new THREE.MeshBasicMaterial({ color:0xe3c07b })); sandbox.position.set(cx-6,0.3,cz); city.add(sandbox); const slide=new THREE.Mesh(new THREE.CylinderGeometry(0.25,0.25,4,12), new THREE.MeshBasicMaterial({ color:0xff4d4f })); slide.rotation.z=-Math.PI/6; slide.position.set(cx+6,1.5,cz-2); city.add(slide); const seesaw=new THREE.Mesh(new THREE.BoxGeometry(6,0.2,0.4), new THREE.MeshBasicMaterial({ color:0xffa142 })); seesaw.position.set(cx,0.6,cz+3); city.add(seesaw); treesOnPerimeter(cx,cz); }

      // ===== Build grid: parks have grass center + trees ring; BIG courts/fountain centered =====
      const ladders=[];
      let proTennisPlaced=0;
      for(let ix=0; ix<BLOCKS_X; ix++){
        for(let iz=0; iz<BLOCKS_Z; iz++){
          const cx=startX+ix*CELL, cz=startZ+iz*CELL;
          const makePark = (ix+iz)%2===0; // alternating blocks
          if(makePark){
            addParkBase(cx,cz);
            const pick = (ix%3===0)?'tennis':(iz%3===0?'basket':'fountain');
            if(pick==='tennis'){
              if(proTennisPlaced<4){ addTennisStadium(cx,cz); proTennisPlaced++; } else { addTennisStadium(cx,cz); }
            } else if(pick==='basket'){
              addBasketballStadium(cx,cz);
            } else { addFountainArea(cx,cz); }
          } else {
            addSidewalk(cx,cz);
            const bCount=2+Math.floor(Math.random()*3); for(let b=0;b<bCount;b++){ addBuilding(cx+(Math.random()-0.5)*PLOT*0.7, cz+(Math.random()-0.5)*PLOT*0.7); }
          }
        }
      }
      city.add(trunks); city.add(crowns);
      // ===== HIGHWAY ring with exits around city =====
      function addRingHighway(){ const ringGroup=new THREE.Group(); const R = Math.max(BLOCKS_X,BLOCKS_Z)*CELL*0.6; const W=18; const N=64; for(let i=0;i<N;i++){ const a0=i*(Math.PI*2/N), a1=(i+1)*(Math.PI*2/N); const L=R*(a1-a0); const geo=new THREE.PlaneGeometry(L, W); const m=new THREE.Mesh(geo, new THREE.MeshLambertMaterial({ map: asphaltTex })); m.rotation.x=-Math.PI/2; const a=(a0+a1)/2; m.position.set(Math.cos(a)*R,0.02,Math.sin(a)*R); m.rotation.z=0; m.rotation.y = -a; ringGroup.add(m); }
        // Exits (ramps) into city
        const exits=10; for(let i=0;i<exits;i++){ const a=i*(Math.PI*2/exits); const len = R - (BLOCKS_X*CELL*0.5); const ramp=new THREE.Mesh(new THREE.PlaneGeometry(len-10, 10), new THREE.MeshLambertMaterial({ map: asphaltTex })); ramp.rotation.x=-Math.PI/2; ramp.position.set(Math.cos(a)*(R-(len/2)),0.02,Math.sin(a)*(R-(len/2))); ramp.rotation.y=-a; ringGroup.add(ramp); }
        ringGroup.position.y=0; city.add(ringGroup); return {R}; }
      const ring = addRingHighway();

      // ===== Airport (at city exit, east) =====
      function runwayTex(W=4096,H=1024){ const c=document.createElement('canvas'); c.width=W; c.height=H; const g=c.getContext('2d'); g.fillStyle='#2b313a'; g.fillRect(0,0,W,H); g.strokeStyle='#eee'; g.setLineDash([60,40]); g.lineWidth=12; g.beginPath(); g.moveTo(0,H/2); g.lineTo(W,H/2); g.stroke(); g.setLineDash([]); g.lineWidth=8; g.strokeRect(20,20,W-40,H-40); const t=new THREE.CanvasTexture(c); t.wrapS=t.wrapT=THREE.ClampToEdgeWrapping; t.anisotropy=8; t.colorSpace=THREE.SRGBColorSpace; return t; }
      function addPlane(x,y,z,rot=0){ const g=new THREE.Group(); const body=new THREE.Mesh(new THREE.CapsuleGeometry(0.35,2.2,8,16), new THREE.MeshLambertMaterial({ color:0xdddddd })); body.rotation.z=Math.PI/2; g.add(body); const wing=new THREE.Mesh(new THREE.BoxGeometry(2.2,0.08,0.4), new THREE.MeshLambertMaterial({ color:0xcccccc })); wing.position.set(0,0,0); g.add(wing); const tail=new THREE.Mesh(new THREE.BoxGeometry(0.5,0.25,0.06), new THREE.MeshLambertMaterial({ color:0xb0b0b0 })); tail.position.set(-1.1,0.25,0); g.add(tail); g.position.set(x,y,z); g.rotation.y=rot; city.add(g); return g; }
      function addAirport(){ const x = (BLOCKS_X*CELL)/2 + 220; const z = 60; const runway=new THREE.Mesh(new THREE.PlaneGeometry(240,32), new THREE.MeshLambertMaterial({ map:runwayTex() })); runway.rotation.x=-Math.PI/2; runway.position.set(x,0.021,z); city.add(runway); const taxi=new THREE.Mesh(new THREE.PlaneGeometry(260,12), new THREE.MeshLambertMaterial({ map:asphaltTex })); taxi.rotation.x=-Math.PI/2; taxi.position.set(x,0.02,z-28); city.add(taxi); const towerBase=new THREE.Mesh(new THREE.CylinderGeometry(3,3,24,18), new THREE.MeshLambertMaterial({ color:0xc7cbd6 })); towerBase.position.set(x+70,12,z-10); const cab=new THREE.Mesh(new THREE.CylinderGeometry(5,4.2,4,24), new THREE.MeshStandardMaterial({ color:0xe6f2ff, roughness:0.15, metalness:0.0, transparent:true, opacity:0.35 })); cab.position.set(x+70,24,z-10); city.add(towerBase,cab); addPlane(x-50,0.12,z-8,Math.PI*0.98); addPlane(x+20,0.12,z-10,Math.PI*1.02); addPlane(x-10,0.12,z-20,Math.PI*1.05); }
      addAirport();

      // ===== Train station (at city exit, south) =====
      function railTex(W=1024,H=1024){ const c=document.createElement('canvas'); c.width=W; c.height=H; const g=c.getContext('2d'); g.fillStyle='#3a3a3a'; g.fillRect(0,0,W,H); g.fillStyle='#8b5a2b'; for(let y=60;y<H;y+=120){ g.fillRect(0,y-8,W,16); } g.fillStyle='#b9b9b9'; g.fillRect(W*0.35,0,20,H); g.fillRect(W*0.65,0,20,H); const t=new THREE.CanvasTexture(c); t.wrapS=t.wrapT=THREE.RepeatWrapping; t.repeat.set(16,4); t.anisotropy=8; t.colorSpace=THREE.SRGBColorSpace; return t; }
      function addTrainStation(){ const x=0, z= (BLOCKS_Z*CELL)/2 + 220; const tracks=new THREE.Mesh(new THREE.PlaneGeometry(320,14), new THREE.MeshLambertMaterial({ map:railTex() })); tracks.rotation.x=-Math.PI/2; tracks.position.set(x,0.02,z); city.add(tracks); const platform=new THREE.Mesh(new THREE.PlaneGeometry(320,8), new THREE.MeshLambertMaterial({ color:0xcfc7b0 })); platform.rotation.x=-Math.PI/2; platform.position.set(x,0.025,z-12); city.add(platform); const station=new THREE.Mesh(new THREE.BoxGeometry(60,14,20), new THREE.MeshLambertMaterial({ color:0xdedede })); station.position.set(x-40,7,z-22); city.add(station); const roof=new THREE.Mesh(new THREE.BoxGeometry(64,1,22), new THREE.MeshLambertMaterial({ color:0x444 })); roof.position.set(x-40,15,z-22); city.add(roof); const sign=new THREE.Mesh(new THREE.PlaneGeometry(20,5), new THREE.MeshBasicMaterial({ map:signTex('STATION','#fff','rgba(32,32,32,0.95)'), transparent:true })); sign.position.set(x-40,13,z-11); city.add(sign); }
      addTrainStation();

      // ===== Bus stops =====
      function addBusStop(x,z,rot=0){ const group=new THREE.Group(); const slab=new THREE.Mesh(new THREE.PlaneGeometry(6,2.6), new THREE.MeshLambertMaterial({ color:0xbdbdbd })); slab.rotation.x=-Math.PI/2; slab.position.set(0,0.021,0); group.add(slab); const roof=new THREE.Mesh(new THREE.BoxGeometry(4.6,0.15,2.2), new THREE.MeshLambertMaterial({ color:0x5a6370 })); roof.position.set(0,2.1,0); group.add(roof); const posts=new THREE.Mesh(new THREE.CylinderGeometry(0.06,0.06,2.2,12), new THREE.MeshLambertMaterial({ color:0x8a929c })); const p1=posts.clone(), p2=posts.clone(); p1.position.set(-2,1.1,1); p2.position.set(2,1.1,1); group.add(p1,p2); const back=new THREE.Mesh(new THREE.PlaneGeometry(4.6,1.6), new THREE.MeshLambertMaterial({ color:0x9fb1c6, transparent:true, opacity:0.45 })); back.position.set(0,1.4,-1); group.add(back); const pole=new THREE.Mesh(new THREE.CylinderGeometry(0.05,0.05,2.6,12), new THREE.MeshLambertMaterial({ color:0x2a62d6 })); pole.position.set(2.8,1.3,0); const plate=new THREE.Mesh(new THREE.PlaneGeometry(1.2,1.2), new THREE.MeshBasicMaterial({ map:signTex('BUS','#fff','rgba(32,64,160,0.95)'), transparent:true })); plate.position.set(2.8,2.2,0); group.add(pole,plate); group.position.set(x,0,z); group.rotation.y=rot; city.add(group); }
      function scatterBusStops(){ const offsets=[-((BLOCKS_Z*CELL)/2)+CELL, ((BLOCKS_Z*CELL)/2)-CELL]; for(const z of offsets){ addBusStop(-CELL*2.2,z,0); addBusStop(CELL*2.2,z,Math.PI); } for(const x of [-CELL*2.5,CELL*2.5]){ addBusStop(x,-CELL*2.2,Math.PI/2); addBusStop(x,CELL*2.2,-Math.PI/2); } }
      scatterBusStops();

      // ===== Place civic buildings =====
      const civicYRot = 0; // face east-west main road
      addCivic('POLICE',   startX + (BLOCKS_X-2)*CELL, startZ + 1*CELL, civicYRot);
      const hosp = addCivic('HOSPITAL', startX + (BLOCKS_X-2)*CELL, startZ + 3*CELL, civicYRot);
      addCivic('SCHOOL',   startX + (BLOCKS_X-4)*CELL, startZ + 2*CELL, civicYRot);
      addCivic('MALL',     startX + (BLOCKS_X-5)*CELL, startZ + 4*CELL, civicYRot);
      addCivic('FIRE',     startX + (BLOCKS_X-3)*CELL, startZ + 0*CELL, civicYRot);

      // -------------- (rest of existing game: audio, weapons, enemies, input, joysticks, BR, etc.) --------------
      // Audio (procedural)
      const audio={ ctx:null, muted:false };
      function ac(){ if(audio.muted) return null; try{ audio.ctx = audio.ctx || new (window.AudioContext||window.webkitAudioContext)(); return audio.ctx; }catch(_){ return null; } }
      function withAC(fn){ const ctx=ac(); if(!ctx) return; fn(ctx); }
      function noiseBuffer(ctx){ const b=ctx.createBuffer(1, ctx.sampleRate*1.0, ctx.sampleRate); const d=b.getChannelData(0); for(let i=0;i<d.length;i++){ d[i]= (Math.random()*2-1) * (1 - i/d.length); } return b; }
      function burstNoise({dur=0.12, freq=1500, type='bandpass', gain=0.12}){ withAC((ctx)=>{ const src=ctx.createBufferSource(); src.buffer=noiseBuffer(ctx); const bp=ctx.createBiquadFilter(); bp.type=type; bp.frequency.value=freq; const g=ctx.createGain(); g.gain.value=gain; src.connect(bp); bp.connect(g); g.connect(ctx.destination); src.start(); src.stop(ctx.currentTime+dur); }); }
      function clickS({freq=800,dur=0.02,gain=0.08}){ withAC((ctx)=>{ const o=ctx.createOscillator(); const g=ctx.createGain(); o.type='square'; o.frequency.value=freq; g.gain.value=gain; o.connect(g); g.connect(ctx.destination); o.start(); o.stop(ctx.currentTime+dur); }); }
      function sfxGun(kind){ switch(kind){ case 'Glock': case 'Pistol': burstNoise({dur:0.09,freq:2200,gain:0.12}); clickS({freq:1800,dur:0.015,gain:0.06}); break; case 'AR': burstNoise({dur:0.08,freq:1900,gain:0.13}); clickS({freq:1600,dur:0.012,gain:0.05}); break; case 'Uzi': burstNoise({dur:0.05,freq:2300,gain:0.12}); clickS({freq:1900,dur:0.01,gain:0.05}); break; case 'AK47': burstNoise({dur:0.1,freq:1400,gain:0.14}); clickS({freq:1200,dur:0.015,gain:0.07}); break; default: burstNoise({dur:0.07,freq:1800,gain:0.12}); } }
      function sfxReload(){ clickS({freq:600,dur:0.05,gain:0.05}); setTimeout(()=>clickS({freq:900,dur:0.04,gain:0.05}),90); }
      $('muteBtn').addEventListener('click',(e)=>{ audio.muted=!audio.muted; e.target.textContent=audio.muted?'ðŸ”‡':'ðŸ”Š'; });

      // Player & Camera
      const playerRadius=0.35; const player=new CANNON.Body({ mass:75, material:matPlayer, shape:new CANNON.Sphere(playerRadius), position:new CANNON.Vec3(0,1.0,10), linearDamping:0.18, angularDamping:0.9 });
      player.fixedRotation=true; player.allowSleep=false; world.addBody(player);
      let yaw=0, pitch=0; function clampPitch(){ pitch=Math.max(-Math.PI/2+0.005, Math.min(Math.PI/2-0.005, pitch)); }
      function camFollow(pos,distMul=1){ const back=new THREE.Vector3(Math.sin(yaw),0,Math.cos(yaw)); const eye=new THREE.Vector3(pos.x - back.x*camDist*distMul, pos.y+2.1, pos.z - back.z*camDist*distMul); camera.position.lerp(eye,0.25); const look=new THREE.Vector3(pos.x + back.x*(camDist+0.2)*distMul, pos.y+1.25 + Math.sin(pitch)*0.8, pos.z + back.z*(camDist+0.2)*distMul); camera.lookAt(look); }
      function grounded(){ return player.position.y < 0.38 && Math.abs(player.velocity.y) < 0.05; }
      function jump(){ if(grounded()){ player.velocity.y = 5.2; } }
      // Aim visuals
      const aimGeo=new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(), new THREE.Vector3(0,0,-50)]);
      const aimMatDark=new THREE.LineBasicMaterial({ color:0x222222, transparent:true, opacity:0.9 });
      const aimLine=new THREE.Line(aimGeo,aimMatDark); aimLine.renderOrder=9; scene.add(aimLine);
      const aimDotTex=(function(){ const c=document.createElement('canvas'); c.width=c.height=64; const x=c.getContext('2d'); x.fillStyle='rgba(255,255,255,0.0)'; x.fillRect(0,0,64,64); x.beginPath(); x.arc(32,32,14,0,Math.PI*2); x.fillStyle='rgba(255,60,60,0.95)'; x.fill(); x.lineWidth=3; x.strokeStyle='rgba(255,255,255,0.9)'; x.stroke(); const t=new THREE.CanvasTexture(c); t.colorSpace=THREE.SRGBColorSpace; return t; })();
      const aimDot=new THREE.Sprite(new THREE.SpriteMaterial({ map:aimDotTex, depthWrite:false, color:0xffffff })); aimDot.scale.set(0.7,0.7,1); scene.add(aimDot);
      const crosshairEl=$('crosshair'); crosshairEl.style.setProperty('--aimColor','#ff3c3c');

      // Armory & weapons
      const BLANK_PNG='data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR4nGNgYAAAAAMAASsJTYQAAAAASUVORK5CYII=';
      const manager=new THREE.LoadingManager(); manager.setURLModifier((url)=>{ if(url?.startsWith('data:')||url?.startsWith('blob:')) return url; if(/(\.(png|jpg|jpeg|webp|ktx2|dds|tga)(\?|#|$))/i.test(url)) return BLANK_PNG; return url; });
      const gltfLoader=new GLTFLoader(manager); const draco=new DRACOLoader(manager); draco.setDecoderPath('https://www.gstatic.com/draco/v1/decoders/'); gltfLoader.setDRACOLoader(draco); gltfLoader.setCrossOrigin('anonymous');
      gltfLoader.register((parser)=>{ const c=document.createElement('canvas'); c.width=c.height=1; const ctx=c.getContext('2d'); ctx.fillStyle='#888'; ctx.fillRect(0,0,1,1); const blank=new THREE.CanvasTexture(c); blank.colorSpace=THREE.SRGBColorSpace; blank.needsUpdate=true; const orig=parser.getDependency.bind(parser); parser.getDependency=function(type,index){ if(type==='texture') return Promise.resolve(blank); return orig(type,index); }; return {name:'NullTextures'}; });
      const ARMORY=[
        { key:'Glock',  name:'Glock', url:'https://cdn.jsdelivr.net/gh/webaverse/pistol@master/glock.glb', s:0.62,  stats:{ rpm:380, dmg:24, spread:0.013, mag:17, reload:1.2 }, auto:false },
        { key:'Pistol', name:'Pistol',url:'https://cdn.jsdelivr.net/gh/webaverse/pistol@master/pistol.glb', s:0.46, stats:{ rpm:320, dmg:22, spread:0.014, mag:15, reload:1.3 }, auto:false },
        { key:'AR',     name:'Assault Rifle', url:'https://cdn.jsdelivr.net/gh/webaverse/pistol@master/military.glb', s:0.70, stats:{ rpm:720, dmg:26, spread:0.012, mag:30, reload:1.9 }, auto:true },
        { key:'Uzi',    name:'Uzi',    url:'https://cdn.jsdelivr.net/gh/webaverse/uzi@main/uzi.glb', s:0.60, stats:{ rpm:900, dmg:18, spread:0.02,  mag:32, reload:1.6 }, auto:true },
        { key:'AK47',   name:'AKâ€‘pattern', url:'https://cdn.jsdelivr.net/gh/LazerMaker/gun-models-ak47-and-supprest-pistol-@master/ak47.glb', s:0.78, stats:{ rpm:600, dmg:30, spread:0.012, mag:30, reload:1.9 }, auto:true },
        { key:'Grenade',name:'Grenade',url:'https://cdn.jsdelivr.net/gh/friuns2/bingextension@main/grenade.glb', s:0.30, stats:{ rpm:60,  dmg:120, spread:0.03,  mag:1,  reload:2.4 }, auto:false }
      ];
      const FIRE_MODES=new Map(); ARMORY.forEach(a=>FIRE_MODES.set(a.key, a.auto?'auto':'single'));

      const weaponRoot=new THREE.Group(); camera.add(weaponRoot);
      const weaponCache=new Map();
      const metalTex=(()=>{ const S=256,c=document.createElement('canvas'); c.width=c.height=S; const x=c.getContext('2d'); const g=x.createLinearGradient(0,0,S,S); g.addColorStop(0,'#2e2e2e'); g.addColorStop(1,'#4a4a4a'); x.fillStyle=g; x.fillRect(0,0,S,S); const t=new THREE.CanvasTexture(c); t.colorSpace=THREE.SRGBColorSpace; t.anisotropy=2; return t; })();
      const matMetal=new THREE.MeshLambertMaterial({ color:'#3b3b3b', map:metalTex });
      const matWood =new THREE.MeshLambertMaterial({ color:'#7b5331' });
      function makeSight(){ const s=new THREE.Group(); const ring=new THREE.Mesh(new THREE.TorusGeometry(0.015,0.004,8,12), new THREE.MeshBasicMaterial({ color:'#222' })); ring.rotation.x=Math.PI/2; ring.position.set(0,0,0.02); const post=new THREE.Mesh(new THREE.BoxGeometry(0.004,0.02,0.004), new THREE.MeshBasicMaterial({ color:'#444' })); post.position.set(0,0,0.03); s.add(ring,post); return s; }
      function makeAK47Mesh(){ const g=new THREE.Group(); const rec=new THREE.Mesh(new THREE.BoxGeometry(0.12,0.11,0.45), matMetal); const hand=new THREE.Mesh(new THREE.BoxGeometry(0.07,0.08,0.28), matWood); hand.position.set(0.07,-0.02,-0.22); const barrel=new THREE.Mesh(new THREE.CylinderGeometry(0.016,0.016,0.38,18), matMetal); barrel.rotation.z=Math.PI/2; barrel.position.set(0.12,-0.02,-0.41); const stock=new THREE.Mesh(new THREE.BoxGeometry(0.08,0.09,0.25), matWood); stock.position.set(-0.06,-0.01,0.16); const mag=new THREE.Mesh(new THREE.CapsuleGeometry(0.04,0.12,8,16), matMetal); mag.rotation.x=Math.PI/2; mag.position.set(0.02,-0.08,0.02); g.add(rec,hand,barrel,stock,mag,makeSight()); return g; }
      function makePistolMesh(){ const g=new THREE.Group(); const slide=new THREE.Mesh(new THREE.BoxGeometry(0.08,0.05,0.18), matMetal); slide.position.set(0.02,0.02,-0.09); const frame=new THREE.Mesh(new THREE.BoxGeometry(0.09,0.07,0.14), new THREE.MeshLambertMaterial({color:'#444'})); const grip=new THREE.Mesh(new THREE.BoxGeometry(0.05,0.1,0.06), new THREE.MeshLambertMaterial({color:'#2b2b2b'})); grip.position.set(-0.02,-0.05,0.02); const barrel=new THREE.Mesh(new THREE.CylinderGeometry(0.008,0.008,0.14,10), matMetal); barrel.rotation.z=Math.PI/2; barrel.position.set(0.07,0.02,-0.18); g.add(frame,slide,grip,barrel,makeSight()); return g; }
      function normalizeAndCenter(root, targetLen=0.6){ const box=new THREE.Box3().setFromObject(root); const size=new THREE.Vector3(); box.getSize(size); const center=new THREE.Vector3(); box.getCenter(center); root.position.sub(center); const maxDim=Math.max(size.x,size.y,size.z)||1; const s=targetLen/maxDim; root.scale.setScalar(s); return root; }
      async function loadWeapon(key){ const entry=ARMORY.find(a=>a.key===key); if(!entry){ return new THREE.Group(); } if(weaponCache.has(key)){ const v=weaponCache.get(key); return (v.clone? v.clone(true) : v); } try{ const gltf=await gltfLoader.loadAsync(entry.url); const base=(gltf.scene||gltf.scenes?.[0]||null); let use = base || makePistolMesh(); normalizeAndCenter(use, entry.s); use.traverse?.(o=>{ if(o.isMesh){ o.castShadow=allowShadows; o.receiveShadow=allowShadows; const m=o.material; o.material = new THREE.MeshLambertMaterial({ color:(m?.color||new THREE.Color('#888')), map:m?.map||null, transparent:!!m?.transparent, opacity:(m?.opacity??1) }); }}); weaponCache.set(key, use); return (use.clone? use.clone(true) : use); }catch(_){ let alt; if(key==='AK47') alt=makeAK47Mesh(); else alt=makePistolMesh(); normalizeAndCenter(alt, key==='AK47'?0.78:0.5); weaponCache.set(key, alt); return (alt.clone? alt.clone(true) : alt); } }

      const armoryDiv=$('armory');
      const thumbCache=new Map();
      function weaponIconURL(key){ const svg=(p)=>'data:image/svg+xml;utf8,'+encodeURIComponent(p); const base=(body)=>`<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 112 68'><rect width='112' height='68' rx='8' ry='8' fill='rgba(0,0,0,0.18)'/><g fill='none' stroke='#e6eefc' stroke-width='4' stroke-linecap='round' stroke-linejoin='round'>${body}</g></svg>`; switch(key){ case 'Glock': return svg(base(`<path d='M14 32h58l8 8H14z'/><path d='M64 32v-8h20l8 10'/>`)); case 'Pistol': return svg(base(`<path d='M12 34h62l10 8H12z'/>`)); case 'AR': return svg(base(`<path d='M8 38h74l8 6H8z'/>`)); case 'Uzi': return svg(base(`<path d='M10 34h52l8 6H10z'/>`)); case 'AK47': return svg(base(`<path d='M10 38h84l10 6H10z'/>`)); case 'Grenade': return svg(base(`<circle cx='42' cy='36' r='12'/>`)); default: return svg(base(`<path d='M16 34h80'/>`)); } }
      function weaponPreviewURL(key){ return thumbCache.get(key) || weaponIconURL(key); }
      async function generateThumb(key){ try{ if(thumbCache.has(key)) return thumbCache.get(key); const size={w:224,h:136}; const rt=new THREE.WebGLRenderTarget(size.w,size.h); const sc=new THREE.Scene(); const cam=new THREE.PerspectiveCamera(40, size.w/size.h, 0.01, 10); const amb=new THREE.AmbientLight(0xffffff,0.9); const dir=new THREE.DirectionalLight(0xffffff,0.9); dir.position.set(2,3,2); sc.add(amb,dir); const model=await loadWeapon(key); const g=new THREE.Group(); if(model) g.add(model); normalizeAndCenter(g,0.9); g.rotation.y=Math.PI*0.85; sc.add(g); const prev=new THREE.Color(); renderer.getClearColor(prev); const prevA=renderer.getClearAlpha(); renderer.setRenderTarget(rt); renderer.setClearColor(0x000000,0); cam.position.set(0.6,0.3,1.2); cam.lookAt(0,0,0); renderer.render(sc,cam); const px=new Uint8Array(size.w*size.h*4); renderer.readRenderTargetPixels(rt,0,0,size.w,size.h,px); const cv=document.createElement('canvas'); cv.width=size.w; cv.height=size.h; const ctx=cv.getContext('2d'); const img=ctx.createImageData(size.w,size.h); for(let y=0;y<size.h;y++){ const sy=size.h-1-y; img.data.set(px.subarray(sy*size.w*4, sy*size.w*4+size.w*4), y*size.w*4);} ctx.putImageData(img,0,0); const url=cv.toDataURL('image/png'); renderer.setRenderTarget(null); renderer.setClearColor(prev,prevA); rt.dispose(); thumbCache.set(key,url); return url; }catch(_){ return weaponIconURL(key); } }
      function buildGallery(){ armoryDiv.innerHTML=''; ARMORY.forEach((a)=>{ const b=document.createElement('button'); b.className='armBtn'; b.id='arm_'+a.key; b.innerHTML = `<img alt="${a.name}" src="${weaponPreviewURL(a.key)}"><span>${a.name}</span>`; b.addEventListener('click',()=>selectWeapon(a.key)); if(a.auto){ const t=document.createElement('button'); t.className='modeToggle'; t.textContent=(FIRE_MODES.get(a.key)==='auto')?'AUTO':'SINGLE'; t.addEventListener('click',(ev)=>{ ev.stopPropagation(); FIRE_MODES.set(a.key, FIRE_MODES.get(a.key)==='auto'?'single':'auto'); t.textContent=(FIRE_MODES.get(a.key)==='auto')?'AUTO':'SINGLE'; }); b.appendChild(t); } armoryDiv.appendChild(b); generateThumb(a.key).then(url=>{ const img=b.querySelector('img'); if(img) img.src=url; }); }); }
      buildGallery();

      let currentKey=ARMORY[0].key, currentStats=ARMORY[0].stats; let weaponModel=null; const ammo=new Map(); ARMORY.forEach(a=>ammo.set(a.key,{mag:a.stats.mag,reserve:a.stats.mag*3}));
      function updateAmmoHUD(){ const a=ammo.get(currentKey); $('ammo').textContent=`${ARMORY.find(x=>x.key===currentKey)?.name||currentKey} â€” ${a.mag}/${a.reserve}`; document.querySelectorAll('.armBtn').forEach(el=>el.classList.remove('active')); const ab=$('arm_'+currentKey); if(ab) ab.classList.add('active'); }
      const MUZZLE_OFF={ Glock:[0.0,-0.02,-0.74], Pistol:[0.0,-0.02,-0.74], AR:[0.0,-0.04,-0.80], Uzi:[0.0,-0.03,-0.78], AK47:[0.0,-0.04,-0.82], Grenade:[0,0,0] };
      const EJECT_OFF={ Glock:[0.06,-0.05,-0.36], Pistol:[0.06,-0.05,-0.36], AR:[0.08,-0.05,-0.42], Uzi:[0.06,-0.04,-0.40], AK47:[0.09,-0.05,-0.44], Grenade:[0,0,0] };

      async function mountPlayerWeapon(key){ if(weaponModel){ weaponRoot.remove(weaponModel); weaponModel.traverse(o=>{ o.geometry?.dispose?.(); if(Array.isArray(o.material)) o.material.forEach(m=>m.dispose?.()); else o.material?.dispose?.(); }); weaponModel=null; }
        const model=await loadWeapon(key); const g=new THREE.Group(); if(model) g.add(model);
        const off={x:0.18,y:-0.10,z:-0.52}; g.position.set(off.x,off.y,off.z); g.rotation.set(-0.03, Math.PI, -0.12);
        weaponModel=g; weaponRoot.add(g);
        const muzzleAnchor=new THREE.Object3D(); const ejectAnchor=new THREE.Object3D(); weaponModel.add(muzzleAnchor); weaponModel.add(ejectAnchor);
        const mo=MUZZLE_OFF[key]||MUZZLE_OFF.Glock; const eo=EJECT_OFF[key]||EJECT_OFF.Glock; muzzleAnchor.position.set(mo[0],mo[1],mo[2]); ejectAnchor.position.set(eo[0],eo[1],eo[2]);
        weaponModel.userData.muzzleAnchor=muzzleAnchor; weaponModel.userData.ejectAnchor=ejectAnchor; }
      async function selectWeapon(key){ currentKey=key; currentStats=ARMORY.find(a=>a.key===key)?.stats||currentStats; updateAmmoHUD(); await mountPlayerWeapon(key); updateZoomUI(); }
      await selectWeapon(currentKey);

      // Enemies + AI
      const CHAR_PRESETS={ Soldier:['https://threejs.org/examples/models/gltf/Soldier.glb'], Xbot:['https://threejs.org/examples/models/gltf/Xbot.glb'] };
      const modelCache=new Map();
      async function robustLoad(urls){ let last=null; for(const u of urls){ try{ return await gltfLoader.loadAsync(u); }catch(e){ last=e; } } throw last||new Error('Load fail'); }
      function normalizeRoot(root){ const box=new THREE.Box3().setFromObject(root); const size=new THREE.Vector3(); box.getSize(size); const scale=1.7/(size.y||1); root.scale.setScalar(scale); return root; }
      function makeCapsulePlaceholder(){ const g=new THREE.Group(); const body=new THREE.Mesh(new THREE.CapsuleGeometry(0.35,1.0,8,16), new THREE.MeshLambertMaterial({ color:0x556b8a })); g.add(body); return g; }
      async function getCharacter(key){ if(modelCache.has(key)) return modelCache.get(key); try{ const gltf=await robustLoad(CHAR_PRESETS[key]||CHAR_PRESETS.Soldier); const baseRoot=(gltf.scene||gltf.scenes?.[0]||null); const root = baseRoot? normalizeRoot(baseRoot) : makeCapsulePlaceholder(); root.traverse?.(o=>{ if(o.isMesh){ o.castShadow=allowShadows; o.receiveShadow=allowShadows; o.material = new THREE.MeshLambertMaterial({ color:0x9fb1c6 }); }}); modelCache.set(key,{root,clips:gltf.animations||[]}); return modelCache.get(key); }catch(_){ const ph=makeCapsulePlaceholder(); modelCache.set(key,{root:ph,clips:[]}); return modelCache.get(key); } }
      const enemies=new Map();
      async function safeCloneSkinned(src){ try{ if(src && SkeletonUtils?.clone){ return SkeletonUtils.clone(src); } if(src?.clone){ return src.clone(true); } }catch(_){ } return makeCapsulePlaceholder(); }
      async function spawnEnemy(x,z,key='Soldier'){ if(enemies.size>=12) return null; const base=await getCharacter(key); const clone=await safeCloneSkinned(base?.root); clone.traverse(o=>{ o.castShadow=allowShadows; }); clone.position.set(x,0,z); clone.userData.enemy=true; scene.add(clone); const r=0.35,h=1.6; const shape=new CANNON.Cylinder(r,r,h,8); const q=new CANNON.Quaternion(); q.setFromEuler(Math.PI/2,0,0); const body=new CANNON.Body({ mass:80, material:matEnemy, linearDamping:0.3, angularDamping:0.9 }); body.fixedRotation=true; body.addShape(shape,new CANNON.Vec3(0,h/2,0),q); body.position.set(x,0.9,z); world.addBody(body); const hpBar=makeBillboardBar(); scene.add(hpBar); enemies.set(clone.uuid,{root:clone, body, hp:120, dead:false, hpBar, cooldown:0}); return clone; }
      function enemyRoots(){ return Array.from(enemies.values()).map(e=>e.root); }
      // Decals & blood
      const decalTex=(function(){ const c=document.createElement('canvas'); c.width=c.height=64; const x=c.getContext('2d'); x.clearRect(0,0,64,64); x.fillStyle='rgba(0,0,0,0.9)'; x.beginPath(); x.arc(32,32,18,0,Math.PI*2); x.fill(); x.fillStyle='rgba(0,0,0,0.4)'; for(let i=0;i<10;i++){ const r=22+Math.random()*6; x.beginPath(); x.arc(32+(Math.random()-0.5)*6,32+(Math.random()-0.5)*6,6+Math.random()*6,0,Math.PI*2); x.fill(); } const t=new THREE.CanvasTexture(c); t.colorSpace=THREE.SRGBColorSpace; t.anisotropy=2; return t; })();
      function addDecal(point, normal){ const s=0.22; const g=new THREE.PlaneGeometry(s,s); const m=new THREE.MeshBasicMaterial({ map:decalTex, transparent:true, depthWrite:false }); const q=new THREE.Quaternion(); q.setFromUnitVectors(new THREE.Vector3(0,0,1), normal.clone().normalize()); const mesh=new THREE.Mesh(g,m); mesh.position.copy(point); mesh.quaternion.copy(q); mesh.renderOrder=10; scene.add(mesh); setTimeout(()=>{ scene.remove(mesh); g.dispose(); m.dispose(); }, 15000); }
      const bloodTex=(function(){ const c=document.createElement('canvas'); c.width=c.height=64; const x=c.getContext('2d'); x.fillStyle='rgba(160,0,0,0.0)'; x.fillRect(0,0,64,64); x.fillStyle='rgba(210,20,20,0.9)'; x.beginPath(); x.arc(32,32,20,0,Math.PI*2); x.fill(); x.fillStyle='rgba(120,0,0,0.9)'; for(let i=0;i<5;i++){ x.beginPath(); x.arc(32+(Math.random()-0.5)*16,32+(Math.random()-0.5)*16,6+Math.random()*6,0,Math.PI*2); x.fill(); } const t=new THREE.CanvasTexture(c); t.colorSpace=THREE.SRGBColorSpace; return t; })();
      function addBlood(point){ const s=0.38; const g=new THREE.PlaneGeometry(s,s); const m=new THREE.MeshBasicMaterial({ map:bloodTex, transparent:true, depthWrite:false }); const mesh=new THREE.Mesh(g,m); mesh.position.copy(point); mesh.lookAt(camera.position); scene.add(mesh); setTimeout(()=>{ scene.remove(mesh); g.dispose(); m.dispose(); }, 12000); }

      function makeBillboardBar(){ const c=document.createElement('canvas'); c.width=128; c.height=16; const t=new THREE.CanvasTexture(c); const m=new THREE.SpriteMaterial({ map:t, depthWrite:false }); const s=new THREE.Sprite(m); s.scale.set(0.9, 0.12, 1); s.userData.canvas=c; s.userData.tex=t; updateBillboardBar(s,1); return s; }
      function updateBillboardBar(s,ratio){ const c=s.userData.canvas; const x=c.getContext('2d'); x.clearRect(0,0,c.width,c.height); x.fillStyle='rgba(0,0,0,0.6)'; x.fillRect(0,0,c.width,c.height); x.fillStyle= ratio>0.6? '#29ff9a' : ratio>0.3? '#ffd966':'#ff4d4f'; x.fillRect(2,2,(c.width-4)*Math.max(0,Math.min(1,ratio)), c.height-4); s.userData.tex.needsUpdate=true; }

      const impactTargets=[]; impactTargets.push(city);
      const raycaster=new THREE.Raycaster(); const tracers=[]; function tracer(from,to,color=0xfff1b1,life=0.12){ const g=new THREE.BufferGeometry().setFromPoints([from,to]); const m=new THREE.LineBasicMaterial({color,transparent:true}); const l=new THREE.Line(g,m); l.userData.life=life; scene.add(l); tracers.push(l);} function updateTracers(dt){ for(let i=0;i<tracers.length;i++){ const l=tracers[i]; l.userData.life-=dt; l.material.opacity=Math.max(0,l.userData.life/0.12); if(l.userData.life<=0){ scene.remove(l); l.geometry.dispose(); l.material.dispose(); tracers.splice(i,1); i--; } } }
      let reloading=false; function reload(){ if(reloading) return; const a=ammo.get(currentKey); const st=currentStats; const need=st.mag-a.mag; if(need<=0||a.reserve<=0) return; const take=Math.min(need,a.reserve); reloading=true; setTimeout(()=>{ a.mag+=take; a.reserve-=take; reloading=false; updateAmmoHUD(); sfxReload(); }, st.reload*1000); }

      function fireRay(off2){ raycaster.setFromCamera(off2||new THREE.Vector2(0,0), camera); const from=camera.position.clone(); const to=raycaster.ray.origin.clone().addScaledVector(raycaster.ray.direction, 8000); const pos = aimGeo.attributes.position; pos.setXYZ(0, from.x, from.y, from.z); pos.setXYZ(1, to.x, to.y, to.z); pos.needsUpdate=true; const plane = new THREE.Plane(new THREE.Vector3(0,1,0), 0); const hit = new THREE.Vector3(); raycaster.ray.intersectPlane(plane, hit); if(hit){ aimDot.position.copy(hit); } else { aimDot.position.copy(to); } return {from,to}; }

      function doShot(){ const st=currentStats; if(!st) return; const a=ammo.get(currentKey); if(a.mag<=0){ return; } muzzleLight.intensity=1.6; setTimeout(()=>muzzleLight.intensity=0,45); sfxGun(currentKey);
        const spread=st.spread; const off=new THREE.Vector2((Math.random()-0.5)*spread*2,(Math.random()-0.5)*spread*2); const {from,to}=fireRay(off);
        tracer(from,to,0xfff1b1);
        const hits = raycaster.intersectObjects(impactTargets, true).filter(h=>h.object!==weaponModel && h.object !== aimLine);
        if(hits.length){ const h=hits[0]; const normal = h.face?.normal?.clone()?.transformDirection(h.object.matrixWorld)||new THREE.Vector3(0,0,1); addDecal(h.point, normal); }
        const hitsEnemy = raycaster.intersectObjects(enemyRoots(), true);
        if(hitsEnemy.length){ const h=hitsEnemy[0]; const root=(function find(o){ let p=o; while(p && !p.userData?.enemy){ p=p.parent; } return p; })(h.object); const e=enemies.get(root.uuid); if(e && !e.dead){ e.hp -= st.dmg; addBlood(h.point); if(e.hp<=0){ e.dead=true; e.body.mass=0; e.body.updateMassProperties(); e.root.visible=false; e.hpBar.visible=false; } else { updateBillboardBar(e.hpBar, e.hp/120); } } }
        a.mag--; updateAmmoHUD(); }

      function enemyTryFire(e, dt){ if(e.dead) return; e.cooldown -= dt; const toP = new THREE.Vector3(player.position.x-e.body.position.x, 0, player.position.z-e.body.position.z); const dist = toP.length(); if(dist>55) return; if(e.cooldown>0) return; const dir = new THREE.Vector3(player.position.x - e.body.position.x, (player.position.y+0.9) - (e.body.position.y+0.9), player.position.z - e.body.position.z).normalize(); dir.x += (Math.random()-0.5)*0.02; dir.y += (Math.random()-0.5)*0.01; dir.z += (Math.random()-0.5)*0.02; dir.normalize(); const origin = new THREE.Vector3(e.body.position.x, e.body.position.y+1.1, e.body.position.z); const to = origin.clone().addScaledVector(dir, 150); tracer(origin,to,0xff8888); e.cooldown = 0.2 + Math.random()*0.6; }

      // Input: keys
      const keys=new Set(); addEventListener('keydown',e=>{ keys.add(e.code); if(e.code==='Space') doShot(); if(e.code==='KeyR') reload(); }); addEventListener('keyup',e=>keys.delete(e.code));
      $('reloadMini').addEventListener('click', reload);
      $('resetBtn').addEventListener('click',()=>{ player.position.set(0,1.0,10); player.velocity.set(0,0,0); yaw=0; pitch=0; hp=100; updateHealth(); });

      // Joystick â€” MOVE
      const joyMove=$('joyMove'), knobMove=joyMove.querySelector('.knob');
      const RJS=150, K=85, DEAD=0.16;
      const mv={active:false,id:null,vx:0,vz:0, tapStart:0, moved:false};
      function centerOf(el){ const r=el.getBoundingClientRect(); return { cx:r.left + r.width/2, cy:r.top + r.height/2 }; }
      function stickTouchStart(el, state, e){ if(state.active) return; const t=e.changedTouches[0]; state.active=true; state.id=t.identifier; state.tapStart=performance.now(); state.moved=false; }
      function stickTouchMove(el, knob, state, e, onMove){ for(const t of e.changedTouches){ if(state.active&&t.identifier===state.id){ const {cx,cy}=centerOf(el); let dx=t.clientX-cx, dy=t.clientY-cy; const len=Math.hypot(dx,dy)||1; const nlen=Math.min(len/RJS,1); state.moved = state.moved || (nlen>DEAD*1.2); const nz=nlen<DEAD?0:(nlen-DEAD)/(1-DEAD); const scale = nz/(nlen||1); dx*=scale; dy*=scale; if(nlen>1){ dx/=nlen; dy/=nlen; } knob.style.transform=`translate(calc(-50% + ${dx}px),calc(-50% + ${dy}px))`; onMove(dx,dy,nz); } } }
      function stickTouchEnd(el, knob, state, onEnd){ return (e)=>{ for(const t of e.changedTouches){ if(state.active&&t.identifier===state.id){ state.active=false; knob.style.transform='translate(-50%,-50%)'; onEnd(state); } } }; }
      joyMove.addEventListener('touchstart',e=>{ e.preventDefault(); stickTouchStart(joyMove,mv,e); },{passive:false});
      joyMove.addEventListener('touchmove', e=>{ e.preventDefault(); stickTouchMove(joyMove,knobMove,mv,e,(dx,dy)=>{ mv.vx = dx/K; mv.vz = -dy/K; }); },{passive:false});
      joyMove.addEventListener('touchend',  e=>{ stickTouchEnd(joyMove,knobMove,mv,(st)=>{ const tap=(performance.now()-st.tapStart)<220 && !st.moved; mv.vx=0; mv.vz=0; if(tap) jump(); })(e); },{passive:false});
      joyMove.addEventListener('touchcancel',()=>{ mv.vx=0; mv.vz=0; knobMove.style.transform='translate(-50%,-50%)'; },{passive:true});
      const mvPE={active:false,id:null,cx:0,cy:0,tapStart:0,moved:false};
      joyMove.addEventListener('pointerdown', (e)=>{ if(mvPE.active) return; mvPE.active=true; mvPE.id=e.pointerId; mvPE.tapStart=performance.now(); mvPE.moved=false; const r=joyMove.getBoundingClientRect(); mvPE.cx=r.left+r.width/2; mvPE.cy=r.top+r.height/2; try{ joyMove.setPointerCapture(e.pointerId); }catch(_){} e.preventDefault(); });
      joyMove.addEventListener('pointermove', (e)=>{ if(!mvPE.active||e.pointerId!==mvPE.id) return; let dx=e.clientX-mvPE.cx, dy=e.clientY-mvPE.cy; const len=Math.hypot(dx,dy)||1; const nlen=Math.min(len/RJS,1); if(!mvPE.moved && nlen>DEAD*1.2) mvPE.moved=true; const nz=nlen<DEAD?0:(nlen-DEAD)/(1-DEAD); const scale=nz/(nlen||1); dx*=scale; dy*=scale; if(nlen>1){ dx/=nlen; dy/=nlen; } knobMove.style.transform=`translate(calc(-50% + ${dx}px),calc(-50% + ${dy}px))`; mv.vx = dx/K; mv.vz = -dy/K; e.preventDefault(); });
      function mvRelease(e){ if(!mvPE.active||e.pointerId!==mvPE.id) return; mvPE.active=false; knobMove.style.transform='translate(-50%,-50%)'; const tap=(performance.now()-mvPE.tapStart)<220 && !mvPE.moved; mv.vx=0; mv.vz=0; if(tap) jump(); try{ joyMove.releasePointerCapture(e.pointerId); }catch(_){} e.preventDefault(); }
      joyMove.addEventListener('pointerup', mvRelease); joyMove.addEventListener('pointercancel', mvRelease);

      // SHOOT / Aim pads
      const shootPad=$('shootPad'); const aimPad=$('aimPad');
      let fireHeld=false;
      function shootDown(){ if(FIRE_MODES.get(currentKey)==='auto'){ fireHeld=true; } else { doShot(); } }
      function shootUp(){ fireHeld=false; }
      shootPad.addEventListener('pointerdown', (e)=>{ if(inputMode!=='A') return; shootDown(); e.preventDefault(); });
      shootPad.addEventListener('pointerup', (e)=>{ if(inputMode!=='A') return; shootUp(); e.preventDefault(); });
      shootPad.addEventListener('pointercancel', (e)=>{ if(inputMode!=='A') return; shootUp(); e.preventDefault(); });
      shootPad.addEventListener('touchstart', (e)=>{ if(inputMode!=='A') return; shootDown(); e.preventDefault(); }, {passive:false});
      shootPad.addEventListener('touchend', (e)=>{ if(inputMode!=='A') return; shootUp(); e.preventDefault(); }, {passive:false});

      const aimPE={active:false,id:null,cx:0,cy:0,tapStart:0,moved:false};
      function aimSet(dx,dy){ yaw -= dx*0.0014; pitch -= dy*0.0012; clampPitch(); }
      aimPad.addEventListener('pointerdown', (e)=>{ if(inputMode!=='B'||aimPE.active) return; aimPE.active=true; aimPE.id=e.pointerId; aimPE.tapStart=performance.now(); aimPE.moved=false; const r=aimPad.getBoundingClientRect(); aimPE.cx=r.left+r.width/2; aimPE.cy=r.top+r.height/2; try{ aimPad.setPointerCapture(e.pointerId); }catch(_){} e.preventDefault(); });
      aimPad.addEventListener('pointermove', (e)=>{ if(inputMode!=='B'||!aimPE.active||e.pointerId!==aimPE.id) return; let dx=e.clientX-aimPE.cx, dy=e.clientY-aimPE.cy; const len=Math.hypot(dx,dy)||1; const nlen=Math.min(len/RJS,1); const nz=nlen<DEAD?0:(nlen-DEAD)/(1-DEAD); const scale=nz/(nlen||1); dx*=scale; dy*=scale; aimSet(dx,dy); e.preventDefault(); });
      function aimRelease(e){ if(inputMode!=='B'||!aimPE.active||e.pointerId!==aimPE.id) return; aimPE.active=false; const tap=(performance.now()-aimPE.tapStart)<220 && !aimPE.moved; if(tap) doShot(); try{ aimPad.releasePointerCapture(e.pointerId); }catch(_){} e.preventDefault(); }
      aimPad.addEventListener('pointerup', aimRelease); aimPad.addEventListener('pointercancel', aimRelease);

      // Drag-to-aim anywhere (Mode A)
      const canvasEl=renderer.domElement; canvasEl.style.touchAction='none';
      const look={active:false,id:null,lastX:0,lastY:0};
      let lookAccumX=0, lookAccumY=0; let aimSmoothX=0, aimSmoothY=0;
      function isUIBlock(el){ return el.closest('#joyMove')||el.closest('#shootPad')||el.closest('#aimPad')||el.closest('#armory')||el.closest('#reloadMini')||el.closest('#climbBtn'); }
      canvasEl.addEventListener('pointerdown',(e)=>{ if(inputMode!=='A') return; if(isUIBlock(e.target)) return; if(look.active) return; look.active=true; look.id=e.pointerId; look.lastX=e.clientX; look.lastY=e.clientY; try{ canvasEl.setPointerCapture(e.pointerId); }catch(_){} e.preventDefault(); });
      canvasEl.addEventListener('pointermove',(e)=>{ if(inputMode!=='A') return; if(!look.active||e.pointerId!==look.id) return; const dx=e.clientX-look.lastX; const dy=e.clientY-look.lastY; look.lastX=e.clientX; look.lastY=e.clientY; lookAccumX += dx; lookAccumY += dy; e.preventDefault(); });
      function lookRelease(e){ if(inputMode!=='A') return; if(!look.active||e.pointerId!==look.id) return; look.active=false; try{ canvasEl.releasePointerCapture(e.pointerId); }catch(_){} e.preventDefault(); }
      canvasEl.addEventListener('pointerup', lookRelease); canvasEl.addEventListener('pointercancel', lookRelease);

      // HUD
      let hp=100; function updateHealth(){ const f=$('healthfill'); f.style.width=Math.max(0,hp)+'%'; f.style.background = hp>60? 'linear-gradient(90deg,#29ff9a,#00c876)': hp>30? 'linear-gradient(90deg,#ffd966,#ff9f1a)' : 'linear-gradient(90deg,#ff6b6b,#ff2e2e)'; }
      updateHealth();

      // Cars (enter/exit)
      const vehicles=[]; function makeCarMesh(color){ const g=new THREE.Group(); const body=new THREE.Mesh(new THREE.BoxGeometry(3.6,1.2,1.6), new THREE.MeshLambertMaterial({ color })); body.position.y=0.6; body.castShadow=allowShadows; body.receiveShadow=allowShadows; g.add(body); return g; }
      function makeDriveableCar(x,z){ const color=new THREE.Color().setHSL(Math.random(),0.5,0.5); const mesh=makeCarMesh(color); mesh.position.set(x,0.05,z); scene.add(mesh); const body=new CANNON.Body({ mass:600, material:matCar, position:new CANNON.Vec3(x,0.4,z), linearDamping:0.3, angularDamping:0.8 }); body.addShape(new CANNON.Box(new CANNON.Vec3(1.8,0.6,0.8)), new CANNON.Vec3(0,0.6,0)); world.addBody(body); const car={mesh, body, yaw:0, speed:0}; vehicles.push(car); return car; }
      const parkedCar = makeDriveableCar(2,8); const useCarBtn=$('useCarBtn'); const exitCarBtn=$('exitCarBtn'); const hornBtn=$('hornBtn'); const brakeBtn=$('brakeBtn'); let inCar=false, currentCar=null, handbrake=false;
      function canEnterCar(){ const p=new THREE.Vector3(player.position.x,0,player.position.z); const c=new THREE.Vector3(parkedCar.body.position.x,0,parkedCar.body.position.z); return p.distanceTo(c) < 3.0 && !inCar; }
      function enterCar(){ if(!canEnterCar()) return; inCar=true; currentCar=parkedCar; camDist=7.0; weaponRoot.visible=false; useCarBtn.style.display='none'; exitCarBtn.style.display='block'; hornBtn.style.display='block'; brakeBtn.style.display='block'; }
      function exitCar(){ if(!inCar) return; inCar=false; player.position.set(currentCar.body.position.x+1.2, 1.0, currentCar.body.position.z); player.velocity.set(0,0,0); camDist=4.2; weaponRoot.visible=true; currentCar.speed=0; exitCarBtn.style.display='none'; hornBtn.style.display='none'; brakeBtn.style.display='none'; handbrake=false; }
      useCarBtn.addEventListener('click', enterCar); exitCarBtn.addEventListener('click', exitCar);

      // Battle Royale auto start
      let brActive=false; let brRadius= (Math.max(BLOCKS_X,BLOCKS_Z)*CELL*0.5)*0.95; const brMat=new THREE.MeshBasicMaterial({color:0x66ccff,transparent:true,opacity:0.12}); const brGeom=new THREE.RingGeometry(brRadius-1.2, brRadius, 64); const brMesh=new THREE.Mesh(brGeom, brMat); brMesh.rotation.x=-Math.PI/2; brMesh.position.y=0.05; scene.add(brMesh);
      function startBR(){ if(brActive) return; brActive=true; $('br').textContent='BR: ON'; for(let i=0;i<8;i++){ const a=(i/8)*Math.PI*2; const r=brRadius*0.6; spawnEnemy(Math.cos(a)*r, Math.sin(a)*r, ['Soldier','Xbot'][i%2]); } }

      // Mode A/B
      let inputMode='A'; const modeA=$('modeA'), modeB=$('modeB');
      function applyMode(){ const isA = inputMode==='A'; shootPad.style.display = isA? 'block':'none'; $('reloadMini').style.display = isA? 'block':'none'; $('aimPad').style.display = isA? 'none':'block'; $('zoomBox').style.display = (currentKey==='AK47' && isA)? 'block':'none'; modeA.classList.toggle('active', isA); modeB.classList.toggle('active', !isA); }
      modeA.addEventListener('click',()=>{ inputMode='A'; applyMode(); }); modeB.addEventListener('click',()=>{ inputMode='B'; applyMode(); }); applyMode();

      // Zoom slider
      const zoomSlider=$('zoomSlider'); function updateZoomUI(){ const box=$('zoomBox'); if(currentKey==='AK47' && inputMode==='A'){ box.style.display='block'; } else { box.style.display='none'; } }
      zoomSlider.addEventListener('input',()=>{ const v=parseFloat(zoomSlider.value||'1'); camera.fov = THREE.MathUtils.clamp(70 / v, 18, 70); camera.updateProjectionMatrix(); });

      // Ladders climb UI
      let climbing=false, ladderIdx=-1; const climbBtn=$('climbBtn');
      function nearestLadder(){ let best=-1, bd=1e9; for(let i=0;i<ladders.length;i++){ const L=ladders[i]; const dx=player.position.x-L.x; const dz=player.position.z-L.z; const d=Math.hypot(dx,dz); if(d<bd){ bd=d; best=i; } } return {idx:best, dist:bd}; }
      function setClimbUI(){ const n=nearestLadder(); if(!climbing && n.dist<1.2){ climbBtn.style.display='block'; climbBtn.textContent='â¬† Climb Ladder'; } else if(climbing){ climbBtn.style.display='block'; climbBtn.textContent='â¬‡ Leave Ladder'; } else { climbBtn.style.display='none'; } }
      climbBtn.addEventListener('click', ()=>{ if(climbing){ climbing=false; return; } const n=nearestLadder(); if(n.dist<1.2){ climbing=true; ladderIdx=n.idx; const L=ladders[ladderIdx]; player.velocity.x=player.velocity.z=0; player.position.x=L.x; player.position.z=L.z; } });
      function doClimb(moveZ,dt){ const L=ladders[ladderIdx]; if(!L){ climbing=false; return; } const speed=2.2; if(moveZ>0.05) player.position.y = Math.min(L.y1+0.5, player.position.y + speed*dt); else if(moveZ<-0.05) player.position.y = Math.max(L.y0+0.4, player.position.y - speed*dt); if(Math.hypot(player.position.x-L.x, player.position.z-L.z)>0.9){ climbing=false; } }

      // Loop
      let last=performance.now(); let frameCount=0,fpsTimer=0; let fireCd=0; const mini=$('mini'); updateAmmoHUD(); startBR();
      const result=$('result');
      function loop(now){ const dt=Math.min((now-last)/1000,0.05); last=now; frameCount++; fpsTimer+=dt; if(fpsTimer>=0.5){ const fps=(frameCount/fpsTimer)|0; mini.textContent='fps: '+fps; if(fps<TARGET_FPS-2 && dprScale>0.6){ dprScale=Math.max(0.6,dprScale-0.06); fit(); } else if(fps>TARGET_FPS+20 && dprScale<1.0){ dprScale=Math.min(1.0,dprScale+0.04); fit(); } frameCount=0; fpsTimer=0; }
        // Spin helicopter rotors
        helisToSpin.forEach(h=>{ h.rotor.rotation.y += dt*6.0; h.tailRotor.rotation.x += dt*8.0; });
        if(inputMode==='A'){ const k = Math.min(1, dt*AIM_SMOOTH_A); const ax = lookAccumX * LOOK_SENS_A; const ay = lookAccumY * LOOK_SENS_A; lookAccumX=0; lookAccumY=0; aimSmoothX += (ax - aimSmoothX)*k; aimSmoothY += (ay - aimSmoothY)*k; yaw   -= aimSmoothX * AIM_RATE_A * dt; pitch -= aimSmoothY * AIM_RATE_A * dt; clampPitch(); }
        const {from,to}=fireRay(new THREE.Vector2(0,0));
        const hitsEnemy = raycaster.intersectObjects(enemyRoots(), true);
        const onEnemy = hitsEnemy.length>0; $('crosshair').style.setProperty('--aimColor', onEnemy? '#2fe56b' : '#ff3c3c');
        const move={x:0,z:0}; if(keys.has('KeyW')) move.z+=1; if(keys.has('KeyS')) move.z-=1; if(keys.has('KeyA')) move.x-=1; if(keys.has('KeyD')) move.x+=1; move.x += mv.vx; move.z += mv.vz; let l=Math.hypot(move.x,move.z); if(l>1){ move.x/=l; move.z/=l; }
        if(inCar){ const car=currentCar; const forward=new CANNON.Vec3(Math.sin(yaw),0,Math.cos(yaw)); car.body.velocity.x = forward.x * (-mv.vz) * 12; car.body.velocity.z = forward.z * (-mv.vz) * 12; const strafe=new CANNON.Vec3(Math.cos(yaw),0,-Math.sin(yaw)); car.body.velocity.x += strafe.x * (mv.vx) * 8; car.body.velocity.z += strafe.z * (mv.vx) * 8; camFollow(car.body.position, 1.2); }
        else {
          if(!climbing){ const forward=new THREE.Vector3(Math.sin(yaw),0,Math.cos(yaw)); const right=new THREE.Vector3(Math.cos(yaw),0,-Math.sin(yaw)); const speed= (l>0.9? 6.8 : 4.8); const vx=forward.x*move.z + right.x*move.x; const vz=forward.z*move.z + right.z*move.x; player.velocity.x=vx*speed; player.velocity.z=vz*speed; player.wakeUp(); camFollow(player.position,1.0); }
          else { player.velocity.x=player.velocity.z=0; doClimb(move.z, dt); camFollow(player.position,1.0); }
        }
        setClimbUI();
        if(fireHeld){ const per=60.0/(currentStats.rpm); fireCd-=dt; while(fireCd<=0){ doShot(); fireCd+=per; } }
        enemies.forEach((e)=>{ if(e.dead) return; const toP = new THREE.Vector3(player.position.x-e.body.position.x, 0, player.position.z-e.body.position.z); const d = toP.length(); if(d>0.01){ toP.normalize(); const sp=d>12?2.4:1.6; e.body.velocity.x = toP.x*sp; e.body.velocity.z = toP.z*sp; } enemyTryFire(e, dt); e.root.position.set(e.body.position.x, 0, e.body.position.z); e.hpBar.position.set(e.body.position.x, 2.2, e.body.position.z); e.hpBar.lookAt(camera.position); });
        let alive=0; enemies.forEach(e=>{ if(!e.dead) alive++; }); if(alive===0){ result.textContent='ðŸ† Winner'; result.style.display='block'; }
        for(const b of basketballs){ b.mesh.position.copy(b.body.position); b.mesh.quaternion.copy(b.body.quaternion); }
        world.step(1/PHYS_HZ, dt, 3);
        updateTracers(dt);
        const canEnter=canEnterCar(); $('useCarBtn').style.display = canEnter? 'block':'none';
        try{ renderer.render(scene,camera); }catch(err){ console.warn('Render error (safe fallback):', err?.message||err); }
        requestAnimationFrame(loop); }

      $('status').textContent='Urban Ops â€¢ BR â€¢ Grass unified + Civics + Airport/Station + Highway + Bus Stops';
      requestAnimationFrame(loop);

      renderer.getContext().canvas.addEventListener('webglcontextlost', (e)=>{ e.preventDefault(); console.warn('WebGL context lost'); });
      renderer.getContext().canvas.addEventListener('webglcontextrestored', ()=>{ console.warn('WebGL context restored'); });

      setTimeout(()=>{
        console.assert(!!document.getElementById('shootPad'), 'shootPad exists');
        console.assert(typeof requestAnimationFrame==='function', 'RAF available');
        console.assert(document.querySelectorAll('#armory .armBtn').length > 0, 'armory buttons');
        console.assert(typeof BLOCKS_X==='number' && typeof BLOCKS_Z==='number', 'grid dims');
        console.assert(!!document.getElementById('crosshair'), 'crosshair visible');
        console.assert((basketballs?.length||0) >= 3, 'basketballs spawned (>=3)');
        let fenceCount=0; scene.traverse(o=>{ if(o.isMesh && o.material===matFence) fenceCount++; });
        console.assert(fenceCount>0, 'perimeter fences present');
        console.assert(projLights.length>0, 'projector lights added');
      }, 800);
    })();
  </script>
</body>
</html>
