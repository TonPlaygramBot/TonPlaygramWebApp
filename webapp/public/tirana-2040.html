<!doctype html>
<html lang="sq">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, viewport-fit=cover, user-scalable=no" />
<title>Tirana 2040 ‚Ä¢ Last Man Standing</title>
<style>
  :root{
    color-scheme: light;
    --hud-gap: clamp(12px, 3vw, 24px);
    --pad-offset: clamp(18px, 12vh, 120px);
    --joy-size: clamp(140px, 34vw, 200px);
    --joy-knob: clamp(80px, 22vw, 140px);
    --hud-blur: 10px;
    --fire-size: clamp(104px, 24vw, 148px);
  }
  html,body{margin:0;height:100%;background:#f5e7cf;overflow:hidden;font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif}
  #wrap{position:fixed;inset:0}
  canvas{display:block;width:100%;height:100%;touch-action:none;user-select:none}
  .hud{position:fixed;inset:0;pointer-events:none}
  .row{position:absolute;left:var(--hud-gap);right:var(--hud-gap);display:flex;gap:10px;align-items:center;z-index:15}
  .top{top:var(--hud-gap);justify-content:space-between}
  .bottom{bottom:var(--hud-gap);justify-content:space-between;align-items:flex-end}
  .chip{background:rgba(0,0,0,.32);color:#fff;border-radius:999px;padding:6px 12px;font-size:clamp(11px,2.9vw,14px);backdrop-filter:blur(var(--hud-blur));pointer-events:auto}
  .btn{background:rgba(0,0,0,.35);color:#fff;border:0;border-radius:14px;padding:8px 14px;font-size:clamp(11px,3vw,14px);cursor:pointer;pointer-events:auto;backdrop-filter:blur(var(--hud-blur));transition:transform .15s ease}
  .btn:active{transform:translateY(1px)}
  .btn[disabled]{opacity:.45;cursor:not-allowed}

  .joy{position:absolute;width:var(--joy-size);height:var(--joy-size);border-radius:50%;background:rgba(0,0,0,.1);border:1px solid rgba(0,0,0,.25);opacity:.95;pointer-events:auto;touch-action:none;display:block;z-index:20;backdrop-filter:blur(var(--hud-blur))}
  .joy .knob{position:absolute;left:50%;top:50%;width:var(--joy-knob);height:var(--joy-knob);transform:translate(-50%,-50%);border-radius:50%;background:rgba(0,0,0,.28);border:1px solid rgba(0,0,0,.35)}
  #joyMove{left:var(--hud-gap);bottom:var(--pad-offset)}
  #joyMove .knob{background:rgba(0,0,0,.32)}
  .padCluster{position:absolute;right:var(--hud-gap);bottom:var(--pad-offset);display:flex;flex-direction:column;align-items:flex-end;gap:clamp(14px,4vw,22px);pointer-events:none}
  .padCluster > *{pointer-events:auto}
  .padActions{display:flex;gap:clamp(18px,4.5vw,28px);align-items:flex-end}
  .fireBtn{width:var(--fire-size);height:var(--fire-size);border-radius:50%;border:1px solid rgba(0,0,0,.36);background:radial-gradient(circle at 50% 50%, rgba(255,68,68,1) 0 35%, rgba(0,0,0,.32) 37%), rgba(0,0,0,.38);color:#fff;font-size:clamp(13px,3.6vw,18px);font-weight:900;letter-spacing:.6px;box-shadow:0 12px 26px rgba(0,0,0,.32);text-transform:uppercase;display:flex;align-items:center;justify-content:center;cursor:pointer;transition:transform .12s ease, box-shadow .12s ease;text-shadow:0 2px 6px rgba(0,0,0,.45)}
  .fireBtn:active{transform:translateY(1px);box-shadow:0 6px 18px rgba(0,0,0,.28)}
  #reloadMini{background:radial-gradient(circle at 50% 50%, rgba(255,132,60,1) 0 35%, rgba(0,0,0,.32) 37%), rgba(0,0,0,.38)}
  #crosshair{position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);width:30px;height:30px;pointer-events:none;z-index:50;display:block}
  #crosshair:before,#crosshair:after{content:"";position:absolute;left:50%;top:50%;background:var(--aimColor,#ff3c3c);box-shadow:0 0 0 2px rgba(255,255,255,0.9) inset, 0 0 6px rgba(0,0,0,.35)}
  #crosshair:before{width:24px;height:3px;transform:translate(-50%,-50%);opacity:.98}
  #crosshair:after{width:3px;height:24px;transform:translate(-50%,-50%);opacity:.98}
  #ammo{color:#fff;font-weight:700;background:rgba(0,0,0,.42);padding:10px 18px;border-radius:14px 14px 4px 4px;pointer-events:auto;font-size:clamp(11px,2.8vw,15px);backdrop-filter:blur(var(--hud-blur));min-width:150px;text-align:center;align-self:flex-end}
  #healthbar{position:absolute;left:50%;top:calc(var(--hud-gap) + 44px);width:clamp(160px,60vw,320px);height:14px;background:rgba(0,0,0,.22);border-radius:999px;overflow:hidden;transform:translateX(-50%)}
  #healthfill{width:100%;height:100%;background:linear-gradient(90deg,#29ff9a,#00c876)}
  .armoryWrap{flex:1;display:flex;justify-content:center;overflow:visible}
  #armory{display:grid;grid-template-columns:repeat(3,minmax(0,1fr));gap:clamp(4px,1.4vw,10px);overflow:visible;padding:8px 10px;border-radius:16px;background:rgba(0,0,0,.28);backdrop-filter:blur(var(--hud-blur));pointer-events:auto;max-width:clamp(240px,60vw,360px);width:100%;box-sizing:border-box;align-items:stretch;justify-items:stretch}
  .armBtn{position:relative;width:100%;padding:6px 4px;border-radius:12px;border:1px solid rgba(255,255,255,.16);background:rgba(0,0,0,.32);color:#e6eefc;font-weight:700;cursor:pointer;display:flex;flex-direction:column;align-items:center;gap:4px;transition:transform .2s ease}
  .armBtn img{width:100%;aspect-ratio:1/1;object-fit:contain;display:block;filter:drop-shadow(0 1px 2px rgba(0,0,0,.35))}
  .armBtn span{font-size:10px;opacity:.95;text-align:center}
  .armBtn.active{outline:2px solid #ffd966;background:rgba(17,23,42,.55);transform:translateY(-4px)}
  .modeToggle{position:absolute;right:6px;top:6px;padding:2px 5px;border-radius:9px;border:1px solid rgba(255,255,255,.25);background:rgba(0,0,0,.45);color:#fff;font-size:9px;cursor:pointer}
  #mini{position:absolute;left:50%;bottom:calc(var(--pad-offset) + var(--joy-size) + clamp(12px,3vh,40px));transform:translateX(-50%);color:#0b1324;background:rgba(255,255,255,.75);padding:4px 10px;border-radius:999px;font-size:11px;pointer-events:auto}
  #climbBtn{position:absolute;left:50%;bottom:calc(var(--pad-offset) + var(--joy-size) + clamp(60px,8vh,120px));transform:translateX(-50%);padding:9px 16px;border-radius:14px;border:1px solid rgba(255,255,255,.25);background:rgba(0,0,0,.7);color:#fff;font-size:clamp(12px,3.1vw,15px);pointer-events:auto;display:none}
  #climbBtn[disabled]{opacity:.55;cursor:not-allowed}
  #zoomBox{position:absolute;left:calc(var(--hud-gap) + var(--joy-size)*0.5);bottom:calc(var(--pad-offset) + var(--joy-size) + clamp(48px,10vh,140px));display:none;pointer-events:auto;transform:translateX(-50%)}
  #zoomSlider{appearance:none;width:clamp(200px,44vh,300px);height:clamp(46px,9vw,62px);transform:rotate(-90deg);transform-origin:50% 50%;background:rgba(0,0,0,.45);border-radius:999px;outline:none;border:1px solid rgba(255,255,255,.22);box-shadow:0 12px 24px rgba(0,0,0,.28);padding:0;touch-action:none}
  #zoomSlider::-webkit-slider-thumb{appearance:none;width:44px;height:44px;border-radius:50%;background:#ffd966;border:1px solid rgba(0,0,0,.4);box-shadow:0 6px 14px rgba(0,0,0,.3)}
  #zoomSlider::-moz-range-thumb{width:44px;height:44px;border-radius:50%;background:#ffd966;border:1px solid rgba(0,0,0,.4);box-shadow:0 6px 14px rgba(0,0,0,.3)}
  #radarBox{position:absolute;left:var(--hud-gap);top:calc(var(--hud-gap) + 82px);width:clamp(160px,36vw,220px);height:clamp(160px,36vw,220px);border-radius:18px;background:rgba(0,0,0,.28);border:1px solid rgba(0,0,0,.35);overflow:hidden;pointer-events:auto;backdrop-filter:blur(var(--hud-blur))}
  #radar{width:100%;height:100%;display:block}
  #mapOverlay{position:fixed;inset:0;background:rgba(0,0,0,.75);display:none;align-items:center;justify-content:center;z-index:200;pointer-events:auto}
  #mapCanvas{width:min(96vw,1200px);height:min(96vh,800px);background:#0b0f1a;border:1px solid #334;box-shadow:0 20px 60px rgba(0,0,0,.4);border-radius:12px}
  #mapClose{position:absolute;top:20px;right:20px;padding:10px 14px;border-radius:10px;border:1px solid rgba(255,255,255,.25);background:#1f2937;color:#fff;font-weight:700;cursor:pointer}
  #legend{position:absolute;left:20px;top:20px;color:#fff;background:rgba(0,0,0,.45);padding:10px 12px;border-radius:10px;font-size:12px}
  #result{display:none !important}
</style>
</head>
<body>
<div id="wrap"></div>

<div class="hud">
  <div class="row top">
    <div style="display:flex;gap:6px;align-items:center">
      <div class="chip" id="status">Tirana 2040 ‚Ä¢ Last Man Standing</div>
      <div id="br" class="chip">Entrants: 10 ‚Ä¢ AI</div>
    </div>
    <div style="display:flex;gap:6px;align-items:center">
      <button id="muteBtn" class="btn">üîä</button>
    </div>
  </div>

  <div id="healthbar"><div id="healthfill"></div></div>
  <div id="crosshair"></div>

  <div id="joyMove" class="joy"><div class="knob"></div></div>
  <div id="zoomBox"><input id="zoomSlider" type="range" min="1" max="3" step="0.01" value="1" /></div>
  <div id="padContainer" class="padCluster">
    <div class="padActions">
      <button id="shootPad" class="fireBtn">SHOOT</button>
      <button id="reloadMini" class="fireBtn">RELOAD</button>
    </div>
    <div id="ammo">‚Äî</div>
  </div>
  <div id="radarBox"><canvas id="radar"></canvas></div>
  <div id="mapOverlay">
    <canvas id="mapCanvas"></canvas>
    <button id="mapClose">Close Map</button>
    <div id="legend">Tap the map for directions &amp; waypoint ‚Ä¢ Icons: üè• Hospital ¬∑ üöì Police ¬∑ üßØ Fire ¬∑ üõç Mall ¬∑ üõ´ Airport ¬∑ üöâ Station ‚Ä¢ Use Exit to close</div>
  </div>

  <button id="climbBtn">‚¨Ü Use/Climb Ladder</button>

  <div id="mini">fps: ‚Äî</div>
  <div id="result"></div>

  <div class="row bottom">
    <div class="armoryWrap">
      <div id="armory"></div>
    </div>
  </div>
</div>

<script type="module">
import * as THREE from 'https://esm.sh/three@0.160.0';
import * as CANNON from 'https://esm.sh/cannon-es@0.20.0';
import { GLTFLoader } from 'https://esm.sh/three@0.160.0/examples/jsm/loaders/GLTFLoader.js';
import { DRACOLoader } from 'https://esm.sh/three@0.160.0/examples/jsm/loaders/DRACOLoader.js';
import * as SkeletonUtils from 'https://esm.sh/three@0.160.0/examples/jsm/utils/SkeletonUtils.js';

document.title = 'Tirana 2040 ‚Ä¢ Last Man Standing';

(async function main(){
  const $ = (id)=>document.getElementById(id);
  const wrap = $('wrap');
  const isTouch = ('ontouchstart' in window) || (navigator.maxTouchPoints>0);
  const isMobile = isTouch || /Android|webOS|iPhone|iPad|iPod|Opera Mini|IEMobile/i.test(navigator.userAgent);

  const params = new URLSearchParams(window.location.search);
  const entrants = parseInt(params.get('players') || '10', 10);
  const stakeToken = params.get('token') || 'TPC';
  const stakeAmount = params.get('amount');
  if(!Number.isNaN(entrants)){
    $('br').textContent = `Entrants: ${entrants} ‚Ä¢ AI`;
  }
  if(stakeAmount){
    $('status').textContent = `Tirana 2040 ‚Ä¢ ${stakeAmount} ${stakeToken}`;
  } else {
    $('status').textContent = 'Tirana 2040 ‚Ä¢ Last Man Standing';
  }

  const renderer = new THREE.WebGLRenderer({ antialias:true, powerPreference:'high-performance', alpha:false, stencil:false, depth:true, precision:'mediump' });
  renderer.outputColorSpace = THREE.SRGBColorSpace;
  renderer.toneMapping = THREE.ACESFilmicToneMapping;
  renderer.toneMappingExposure = 1.85;
  const allowShadows = !isMobile;
  renderer.shadowMap.enabled = allowShadows; renderer.shadowMap.type = THREE.PCFSoftShadowMap;
  wrap.appendChild(renderer.domElement);
  THREE.Cache.enabled = true;

  const scene = new THREE.Scene();
  scene.background = new THREE.Color('#f5e7cf');
  scene.fog = new THREE.Fog('#f5e7cf', 900, 3500);

  const camera = new THREE.PerspectiveCamera(64, (innerWidth||1)/(innerHeight||1), 0.01, 10000);
  camera.position.set(0,1.7,5.6); scene.add(camera);

  let dprBase = Math.min(window.devicePixelRatio||1.2, isMobile ? 2.5 : 2.8);
  let dprScale = 1.0;
  const DPR_MIN = isMobile ? 0.75 : 0.6;
  const DPR_MAX_SCALE = isMobile ? 1.0 : 1.15;
  function fit(){ const w=wrap.clientWidth||innerWidth, h=wrap.clientHeight||innerHeight; const targetDpr=Math.min(dprBase*dprScale, isMobile?2.6:3.0); renderer.setPixelRatio(targetDpr); renderer.setSize(w,h,false); camera.aspect=w/h; camera.updateProjectionMatrix(); }
  addEventListener('resize', fit); fit();

  const hemi = new THREE.HemisphereLight(0xfff3d6, 0x8a7a6a, 0.55);
  const key  = new THREE.DirectionalLight(0xffd6a0, allowShadows?1.25:1.0); key.position.set(220, 350, 180); key.castShadow=allowShadows;
  if(allowShadows){ key.shadow.mapSize.set(isMobile?1024:2048,isMobile?1024:2048); key.shadow.camera.near=1; key.shadow.camera.far=3000; key.shadow.camera.left=-900; key.shadow.camera.right=900; key.shadow.camera.top=900; key.shadow.camera.bottom=-900; }
  const fill = new THREE.DirectionalLight(0xffffff, 0.9); fill.position.set(-320, 140, -260);
  const rim  = new THREE.DirectionalLight(0xffffff, 0.8); rim.position.set(120, 200, -520);
  scene.add(hemi, key, fill, rim);
  const muzzleLight = new THREE.PointLight(0xfff1c6, 0.0, 2.0); scene.add(muzzleLight);

  const world = new CANNON.World({ gravity: new CANNON.Vec3(0,-9.81,0) });
  world.broadphase = new CANNON.SAPBroadphase(world); world.allowSleep = true;
  const matGround=new CANNON.Material('ground'), matPlayer=new CANNON.Material('player'), matEnemy=new CANNON.Material('enemy'), matCar=new CANNON.Material('car'), matGrenade=new CANNON.Material('grenade');
  world.addContactMaterial(new CANNON.ContactMaterial(matGround, matPlayer, { friction:.2, restitution:0 }));
  world.addContactMaterial(new CANNON.ContactMaterial(matGround, matCar, { friction:.9, restitution:0 }));
  world.addContactMaterial(new CANNON.ContactMaterial(matGround, matGrenade, { friction:0.42, restitution:0.36 }));

  const groundBody = new CANNON.Body({ mass:0, material:matGround, shape:new CANNON.Plane() });
  groundBody.quaternion.setFromEuler(-Math.PI/2,0,0); world.addBody(groundBody);

  function makeAsphalt(size=1024){ const c=document.createElement('canvas'); c.width=c.height=size; const x=c.getContext('2d'); x.fillStyle='#2b313a'; x.fillRect(0,0,size,size); for(let i=0;i<3800;i++){ const a=Math.random()*0.12; x.fillStyle=`rgba(255,255,255,${a})`; x.fillRect(Math.random()*size,Math.random()*size,1,1);} const t=new THREE.CanvasTexture(c); t.wrapS=t.wrapT=THREE.RepeatWrapping; t.repeat.set(16,16); t.anisotropy=2; t.colorSpace=THREE.SRGBColorSpace; return t; }
  function makeSidewalk(size=512){ const c=document.createElement('canvas'); c.width=c.height=size; const x=c.getContext('2d'); x.fillStyle='#c9ced6'; x.fillRect(0,0,size,size); x.strokeStyle='#9aa0a8'; x.lineWidth=6; for(let s=0;s<size;s+=64){ x.beginPath(); x.moveTo(s,0); x.lineTo(s,size); x.stroke(); x.beginPath(); x.moveTo(0,s); x.lineTo(size,s); x.stroke(); } const t=new THREE.CanvasTexture(c); t.wrapS=t.wrapT=THREE.RepeatWrapping; t.repeat.set(32,32); t.anisotropy=2; t.colorSpace=THREE.SRGBColorSpace; return t; }
  const maxAniso = renderer.capabilities.getMaxAnisotropy?.() || 4;
  function grassTex(){ const imgURL='https://threejs.org/examples/textures/terrain/grasslight-big.jpg'; const tLoader=new Image(); const p=new Promise(res=>{ tLoader.crossOrigin='anonymous'; tLoader.onload=()=>{ const c=document.createElement('canvas'); c.width=1024; c.height=1024; const g=c.getContext('2d'); g.drawImage(tLoader,0,0,1024,1024); const tex=new THREE.CanvasTexture(c); tex.wrapS=tex.wrapT=THREE.RepeatWrapping; tex.repeat.set(12,26); tex.anisotropy=Math.min(16,maxAniso); tex.colorSpace=THREE.SRGBColorSpace; res(tex); }; tLoader.src=imgURL; }); return p; }
  function trackTex(w=1024,h=1024){ const c=document.createElement('canvas'); c.width=w; c.height=h; const g=c.getContext('2d'); g.fillStyle='#b33a2c'; g.fillRect(0,0,w,h); const dots=Math.floor(w*h*0.004); for(let i=0;i<dots;i++){ const x=Math.random()*w, y=Math.random()*h, r=Math.random()*1.6+0.2; g.fillStyle=Math.random()<0.5?'rgba(255,190,180,0.35)':'rgba(40,12,10,0.35)'; g.beginPath(); g.arc(x,y,r,0,Math.PI*2); g.fill(); } const t=new THREE.CanvasTexture(c); t.anisotropy=Math.min(16,maxAniso); t.wrapS=t.wrapT=THREE.RepeatWrapping; t.colorSpace=THREE.SRGBColorSpace; t.repeat.set(1,1); return t; }

  const asphaltTex = makeAsphalt(), sidewalkTex = makeSidewalk(), redTrackTex = trackTex();
  const tennisGrassTex = await grassTex();

  const city = new THREE.Group(); scene.add(city);
  const BLOCKS_X=6, BLOCKS_Z=6; const CELL=120; const ROAD=22; const PLOT=CELL-ROAD*2; const startX = -(BLOCKS_X*CELL)/2 + CELL/2; const startZ = -(BLOCKS_Z*CELL)/2 + CELL/2;

  const groundGeo = new THREE.PlaneGeometry((CELL)*BLOCKS_X + ROAD*2, (CELL)*BLOCKS_Z + ROAD*2);
  const groundMat = new THREE.MeshLambertMaterial({ color: 0xf0e4cf });
  const gnd = new THREE.Mesh(groundGeo, groundMat); gnd.rotation.x=-Math.PI/2; gnd.receiveShadow=allowShadows; city.add(gnd);

  const roadMat = new THREE.MeshLambertMaterial({ map: asphaltTex });
  for(let ix=0; ix<=BLOCKS_X; ix++){
    const geo=new THREE.PlaneGeometry(ROAD,(CELL)*BLOCKS_Z + ROAD);
    const m=new THREE.Mesh(geo, roadMat);
    m.rotation.x=-Math.PI/2;
    m.position.set(ix*CELL-(BLOCKS_X*CELL)/2, 0.01, ROAD*0.5-(BLOCKS_Z*CELL)/2);
    m.receiveShadow=allowShadows;
    city.add(m);
    const length=(CELL)*BLOCKS_Z + ROAD;
    const zCenter=m.position.z;
    const z0=zCenter-length/2;
    const z1=zCenter+length/2;
    const nameIdx=ix % STREET_NAMES_NS.length;
    const suffix=Math.floor(ix/STREET_NAMES_NS.length);
    const name=suffix>0?`${STREET_NAMES_NS[nameIdx]} ${suffix+1}`:STREET_NAMES_NS[nameIdx];
    ROAD_SEGMENTS.push({name, from:new THREE.Vector3(m.position.x,0,z0), to:new THREE.Vector3(m.position.x,0,z1), width:ROAD, orientation:'NS'});
  }
  for(let iz=0; iz<=BLOCKS_Z; iz++){
    const geo=new THREE.PlaneGeometry((CELL)*BLOCKS_X + ROAD, ROAD);
    const m=new THREE.Mesh(geo, roadMat);
    m.rotation.x=-Math.PI/2;
    m.position.set(ROAD*0.5-(BLOCKS_X*CELL)/2, 0.01, iz*CELL-(BLOCKS_Z*CELL)/2);
    m.receiveShadow=allowShadows;
    city.add(m);
    const length=(CELL)*BLOCKS_X + ROAD;
    const xCenter=m.position.x;
    const x0=xCenter-length/2;
    const x1=xCenter+length/2;
    const nameIdx=iz % STREET_NAMES_EW.length;
    const suffix=Math.floor(iz/STREET_NAMES_EW.length);
    const name=suffix>0?`${STREET_NAMES_EW[nameIdx]} ${suffix+1}`:STREET_NAMES_EW[nameIdx];
    ROAD_SEGMENTS.push({name, from:new THREE.Vector3(x0,0,m.position.z), to:new THREE.Vector3(x1,0,m.position.z), width:ROAD, orientation:'EW'});
  }

  const sidewalkMat = new THREE.MeshLambertMaterial({ map: sidewalkTex });
  function addSidewalk(xc,zc){ const w=CELL-ROAD, h=CELL-ROAD; const geo=new THREE.BoxGeometry(w,2,h); const m=new THREE.Mesh(geo, sidewalkMat); m.castShadow=false; m.receiveShadow=allowShadows; m.position.set(xc,1,zc); city.add(m); }

  function facadeTex(hue=200){ const W=256,H=512; const c=document.createElement('canvas'); c.width=W; c.height=H; const ctx=c.getContext('2d'); ctx.fillStyle=`hsl(${hue},16%,74%)`; ctx.fillRect(0,0,W,H); for(let i=0;i<1800;i++){ const a=Math.random()*0.08; ctx.fillStyle=`rgba(0,0,0,${a})`; ctx.fillRect(Math.random()*W,Math.random()*H,1,1);} const cols=6+Math.floor(Math.random()*4), rows=14+Math.floor(Math.random()*6); const padX=12,padY=16; const cellW=(W-2*padX)/cols, cellH=(H-2*padY)/rows; for(let r=0;r<rows;r++){ for(let cix=0;cix<cols;cix++){ const x=padX+cix*cellW+6, y=padY+r*cellH+6, w=cellW-12, h=cellH-12; const g=ctx.createLinearGradient(0,y,0,y+h); g.addColorStop(0,'rgba(240,245,255,0.95)'); g.addColorStop(0.5,'rgba(150,180,220,0.92)'); g.addColorStop(1,'rgba(60,80,120,0.9)'); ctx.fillStyle=g; ctx.fillRect(x,y,w,h); ctx.strokeStyle='rgba(24,28,38,0.9)'; ctx.lineWidth=2; ctx.strokeRect(x,y,w,h); } } const tex=new THREE.CanvasTexture(c); tex.anisotropy=2; tex.colorSpace=THREE.SRGBColorSpace; return tex; }

  const ladders=[];
  function addLadder(x,z,y0,y1){ const railMat=new THREE.MeshBasicMaterial({ color:0x9aa3ad }); const stepMat=new THREE.MeshBasicMaterial({ color:0x8a929c }); const g=new THREE.Group(); const railL=new THREE.Mesh(new THREE.BoxGeometry(0.08, y1-y0, 0.08), railMat); const railR=railL.clone(); railL.position.set(-0.25, (y0+y1)/2, 0); railR.position.set(0.25, (y0+y1)/2, 0); g.add(railL,railR); for(let y=y0+0.3;y<y1;y+=0.35){ const s=new THREE.Mesh(new THREE.BoxGeometry(0.6,0.05,0.08), stepMat); s.position.set(0,y,0); g.add(s); } const arrow=new THREE.Mesh(new THREE.ConeGeometry(0.25,0.6,12), new THREE.MeshBasicMaterial({ color:0x1f6feb })); arrow.position.set(0,y1+0.6,0); g.add(arrow); g.position.set(x,0,z); city.add(g); ladders.push({x,z,y0,y1}); }

  function addRoofStair(x,z,y){ const m=new THREE.Mesh(new THREE.BoxGeometry(1.2,0.5,1.2), new THREE.MeshLambertMaterial({ color:0x444b55 })); m.position.set(x,y+0.4,z); city.add(m); return m; }

  function addBuilding(xc,zc,opts={}){
    const floors=opts.floors??(6+Math.floor(Math.random()*12)); const height=floors*(3.2); const w=opts.w??(30+Math.random()*20), d=opts.d??(30+Math.random()*20);
    const geom=new THREE.BoxGeometry(w,height,d); const hue=opts.hue??(180+Math.floor(Math.random()*60));
    const mat=new THREE.MeshLambertMaterial({ map:facadeTex(hue) }); const roof=new THREE.MeshLambertMaterial({ color:0x55585c});
    const mesh=new THREE.Mesh(geom, [mat,mat,roof,roof,mat,mat]); mesh.castShadow=allowShadows; mesh.receiveShadow=allowShadows; mesh.position.set(xc,height/2,zc); city.add(mesh);
    const body=new CANNON.Body({mass:0}); body.addShape(new CANNON.Box(new CANNON.Vec3(w/2,height/2,d/2))); body.position.set(xc,height/2,zc); world.addBody(body);
    addLadder(xc, zc + d/2 + 0.12, 0.3, height+0.6);
    addRoofStair(xc + (Math.random()*0.6-0.3)*w*0.6, zc + (Math.random()*0.6-0.3)*d*0.6, height);
    if(opts.sign){ const s=new THREE.Mesh(new THREE.PlaneGeometry(Math.min(18,w*0.8),4), new THREE.MeshBasicMaterial({ color:0xffffff })); s.position.set(xc, Math.min(height*0.65, 14), zc + d/2 + 0.51); city.add(s); const tcv=document.createElement('canvas'); tcv.width=512; tcv.height=128; const gx=tcv.getContext('2d'); gx.fillStyle='#111827'; gx.fillRect(0,0,512,128); gx.fillStyle='#fff'; gx.font='900 62px system-ui,Segoe UI'; gx.textAlign='center'; gx.textBaseline='middle'; gx.fillText(opts.sign, 256, 64); const tex=new THREE.CanvasTexture(tcv); tex.colorSpace=THREE.SRGBColorSpace; s.material.map=tex; s.material.needsUpdate=true; }
    return {mesh, dims:{w,d,h:height}};
  }

  function courtLinesTex(courtW,courtL){ const w=2048, h=4096; const s=h/courtL; const c=document.createElement('canvas'); c.width=w; c.height=h; const g=c.getContext('2d'); g.clearRect(0,0,w,h); const lineW=12; g.strokeStyle='#ffffff'; g.lineWidth=lineW; g.lineJoin='round'; g.lineCap='round'; const halfW=courtW/2, halfL=courtL/2; const X=(x)=>(w/2+x*s), Z=(z)=>(h/2+z*s); const line=(x1,z1,x2,z2)=>{ g.beginPath(); g.moveTo(X(x1),Z(z1)); g.lineTo(X(x2),Z(z2)); g.stroke(); }; const box=(x1,z1,x2,z2)=>{ line(x1,z1,x2,z1); line(x2,z1,x2,z2); line(x2,z2,x1,z2); line(x1,z2,x1,z1); };
    const serviceZ=6.4; box(-halfW,-halfL,halfW,halfL); line(-halfW,-serviceZ,halfW,-serviceZ); line(-halfW,serviceZ,halfW,serviceZ); line(0,-serviceZ,0,serviceZ); const t=new THREE.CanvasTexture(c); t.anisotropy=Math.min(16,maxAniso); t.wrapS=t.wrapT=THREE.ClampToEdgeWrapping; t.needsUpdate=true; return t; }
  function basketLinesTex(wm=28,hm=15){ const w=2048,h=1024; const c=document.createElement('canvas'); c.width=w;c.height=h; const g=c.getContext('2d'); g.clearRect(0,0,w,h); g.strokeStyle='#ffffff'; g.lineWidth=10; g.lineJoin='round'; g.lineCap='round'; const sX=w/wm, sY=h/hm; const R=(x,y)=>[x*sX+w*0.5 - (wm*sX)/2, y*sY+h*0.5 - (hm*sY)/2]; const rect=(x,y,w2,h2)=>{ const [X,Y]=R(x,y); g.strokeRect(X,Y,w2*sX,h2*sY); }; const arc=(cx,cy,r,a0,a1)=>{ const [X,Y]=R(cx,cy); g.beginPath(); g.arc(X+0, Y+0, r*sX, a0, a1); g.stroke(); };
    rect(0,0,wm,hm); rect(0.5,0.5,wm-1,hm-1);
    rect(0.5, hm*0.5-2.4, 4.6, 4.8); rect(wm-0.5-4.6, hm*0.5-2.4, 4.6, 4.8);
    arc(wm*0.5, 0.5, 2.4, 0, Math.PI); arc(wm*0.5, hm-0.5, 2.4, Math.PI, Math.PI*2);
    const t=new THREE.CanvasTexture(c); t.anisotropy=Math.min(16,maxAniso); t.wrapS=t.wrapT=THREE.ClampToEdgeWrapping; t.needsUpdate=true; return t; }

  function fenceMat(){ const c=document.createElement('canvas'); c.width=512;c.height=512; const g=c.getContext('2d'); g.clearRect(0,0,512,512); g.strokeStyle='rgba(18,18,18,0.96)'; g.lineWidth=2; for(let i=16;i<512;i+=16){ g.beginPath(); g.moveTo(i,16); g.lineTo(i,496); g.stroke(); g.beginPath(); g.moveTo(16,i); g.lineTo(496,i); g.stroke(); } const t=new THREE.CanvasTexture(c); t.anisotropy=Math.min(8,maxAniso); t.wrapS=t.wrapT=THREE.RepeatWrapping; t.repeat.set(4,2); return t; }

  function treesPerimeter(cx,cz){ const half=PLOT*0.45; const step=8;
    const trunkGeo=new THREE.CylinderGeometry(0.5,0.8,6,8); const crownGeo=new THREE.IcosahedronGeometry(3.2,1);
    const trunks=new THREE.Group(), crowns=new THREE.Group();
    const trunkMat=new THREE.MeshLambertMaterial({ color:0x6e4f2f }); const crownMat=new THREE.MeshLambertMaterial({ color:0x3a6f42 });
    const place=(x,z)=>{ const t=new THREE.Mesh(trunkGeo,trunkMat); t.position.set(x,3,z); t.castShadow=allowShadows; t.receiveShadow=allowShadows; trunks.add(t); const cr=new THREE.Mesh(crownGeo,crownMat); cr.position.set(x,9,z); cr.castShadow=allowShadows; cr.receiveShadow=allowShadows; crowns.add(cr); };
    for(let x=-half;x<=half;x+=step){ place(cx+x, cz-half); place(cx+x, cz+half); }
    for(let z=-half;z<=half;z+=step){ place(cx-half, cz+z); place(cx+half, cz+z); }
    city.add(trunks,crowns);
  }

  function addParkGrass(cx,cz,scale=1.0){ const g=new THREE.Mesh(new THREE.PlaneGeometry(PLOT*0.9*scale,PLOT*0.9*scale), new THREE.MeshStandardMaterial({ map:tennisGrassTex, roughness:0.94, metalness:0.0 })); g.rotation.x=-Math.PI/2; g.position.set(cx,0.015,cz); g.receiveShadow=allowShadows; city.add(g); }

  function addTennisCourt(cx,cz){
    addParkGrass(cx,cz,1.05);
    const courtW=9.2, courtL=23.77, apron=2.6;
    const track=new THREE.Mesh(new THREE.PlaneGeometry(courtW+apron*2,courtL+apron*2), new THREE.MeshStandardMaterial({ map:redTrackTex, roughness:0.96, metalness:0.0 }));
    track.rotation.x=-Math.PI/2; track.position.set(cx,0.02,cz); city.add(track);
    const grass=new THREE.Mesh(new THREE.PlaneGeometry(courtW,courtL), new THREE.MeshStandardMaterial({ map:tennisGrassTex, roughness:0.94, metalness:0.0 }));
    grass.rotation.x=-Math.PI/2; grass.position.set(cx,0.021,cz); city.add(grass);
    const lines=new THREE.Mesh(new THREE.PlaneGeometry(courtW,courtL), new THREE.MeshBasicMaterial({ map:courtLinesTex(courtW,courtL), transparent:true, opacity:0.995, polygonOffset:true, polygonOffsetFactor:-2, polygonOffsetUnits:-2, depthWrite:false }));
    lines.rotation.x=-Math.PI/2; lines.position.set(cx,0.022,cz); city.add(lines);
    const fenceH=3.2, fenceGap=0.4; const fMat=new THREE.MeshStandardMaterial({ map:fenceMat(), transparent:true, opacity:1.0, roughness:0.9, metalness:0.0, color:0xffffff });
    const fx=courtW/2+apron-fenceGap, fz=courtL/2+apron-fenceGap;
    const totalW=courtW+apron*2, gateW=3.2, segW=(totalW-gateW)/2;
    const addFencePanel=(w,h,rx,rz,rotY=0)=>{ const panel=new THREE.Mesh(new THREE.PlaneGeometry(w,h),fMat); panel.position.set(cx+rx, h/2, cz+rz); panel.rotation.y=rotY; city.add(panel); };
    addFencePanel(segW, fenceH, -(gateW/2 + segW/2), fz);
    addFencePanel(segW, fenceH,  gateW/2 + segW/2, fz);
    addFencePanel(segW, fenceH, -(gateW/2 + segW/2), -fz);
    addFencePanel(segW, fenceH,  gateW/2 + segW/2, -fz);
    const sideLen=courtL+apron*2;
    const sidePanel=new THREE.Mesh(new THREE.PlaneGeometry(sideLen, fenceH), fMat);
    sidePanel.rotation.y=Math.PI/2; sidePanel.position.set(cx-fx, fenceH/2, cz); city.add(sidePanel);
    const sidePanelB=sidePanel.clone(); sidePanelB.position.x=cx+fx; city.add(sidePanelB);
    const gateMat=new THREE.MeshBasicMaterial({ color:0xd1d5db });
    const gatePadW=gateW*0.6, gatePad=new THREE.Mesh(new THREE.PlaneGeometry(gatePadW, 1.2), gateMat);
    gatePad.rotation.x=-Math.PI/2; gatePad.position.set(cx,0.03,cz+fz-0.6); city.add(gatePad);
    const gatePadBack=gatePad.clone(); gatePadBack.position.z=cz-fz+0.6; city.add(gatePadBack);
    treesPerimeter(cx,cz);
    CITY_LABELS.push({name:'Fusha Tenisi', pos:new THREE.Vector3(cx,0,cz)});
  }

  function addBasketCourt(cx,cz){
    addParkGrass(cx,cz,1.05);
    const wm=28, hm=15, apron=2.6;
    const base=new THREE.Mesh(new THREE.PlaneGeometry(wm+apron*2,hm+apron*2), new THREE.MeshStandardMaterial({ map:redTrackTex, roughness:0.96, metalness:0.0 }));
    base.rotation.x=-Math.PI/2; base.position.set(cx,0.02,cz); city.add(base);
    const rubberTex=redTrackTex.clone?.() || redTrackTex; rubberTex.repeat.set(4,3); rubberTex.needsUpdate=true;
    const surface=new THREE.Mesh(new THREE.PlaneGeometry(wm,hm), new THREE.MeshStandardMaterial({ map:rubberTex, roughness:0.96, metalness:0.0 }));
    surface.rotation.x=-Math.PI/2; surface.position.set(cx,0.021,cz); city.add(surface);
    const lines=new THREE.Mesh(new THREE.PlaneGeometry(wm,hm), new THREE.MeshBasicMaterial({ map:basketLinesTex(wm,hm), transparent:true, opacity:0.98 }));
    lines.rotation.x=-Math.PI/2; lines.position.set(cx,0.022,cz); city.add(lines);
    const hoopMat=new THREE.MeshBasicMaterial({ color:0xffffff }); const postMat=new THREE.MeshBasicMaterial({ color:0xff3c3c });
    const makeHoop=(sx)=>{ const g=new THREE.Group(); const board=new THREE.Mesh(new THREE.BoxGeometry(1.8,1.1,0.08), hoopMat); board.position.set(0,2.9,-0.25); const rim=new THREE.Mesh(new THREE.TorusGeometry(0.45,0.06,12,32), postMat); rim.rotation.x=Math.PI/2; rim.position.set(0,2.3,0.42); const post=new THREE.Mesh(new THREE.CylinderGeometry(0.06,0.06,2.6,16), postMat); post.position.y=1.3; const arm=new THREE.Mesh(new THREE.BoxGeometry(0.12,0.12,0.9), postMat); arm.position.set(0,2.5,0.1); const brace=new THREE.Mesh(new THREE.BoxGeometry(0.12,1.0,0.12), postMat); brace.position.set(0,1.9,0.05); g.add(post,board,rim,arm,brace); g.position.set(cx+sx*(wm*0.5-1.2),0,cz); city.add(g); };
    makeHoop(-1); makeHoop(1);
    for(let i=0;i<3;i++){ const ball=new THREE.Mesh(new THREE.SphereGeometry(0.3,20,16), new THREE.MeshStandardMaterial({ color:0xff8a00, roughness:0.65 })); ball.position.set(cx + (Math.random()*2-1)*4, 0.3, cz + (Math.random()*2-1)*3); city.add(ball); }
    const fenceH=3.0; const fMat=new THREE.MeshStandardMaterial({ map:fenceMat(), transparent:true, opacity:1.0, roughness:0.9, metalness:0.0, color:0xffffff });
    const fx=wm/2+apron-0.4, fz=hm/2+apron-0.4;
    const gateW=3.6, fullW=wm+apron*2, segW=(fullW-gateW)/2;
    const addPanel=(w,h,rx,rz,rot=0)=>{ const mesh=new THREE.Mesh(new THREE.PlaneGeometry(w,h), fMat); mesh.position.set(cx+rx, h/2, cz+rz); mesh.rotation.y=rot; city.add(mesh); };
    addPanel(segW, fenceH, -(gateW/2 + segW/2), fz);
    addPanel(segW, fenceH,  gateW/2 + segW/2, fz);
    addPanel(segW, fenceH, -(gateW/2 + segW/2), -fz);
    addPanel(segW, fenceH,  gateW/2 + segW/2, -fz);
    const sideLen=hm+apron*2;
    const sideFence=new THREE.Mesh(new THREE.PlaneGeometry(sideLen, fenceH), fMat); sideFence.rotation.y=Math.PI/2; sideFence.position.set(cx-fx, fenceH/2, cz); city.add(sideFence);
    const sideFenceOpp=sideFence.clone(); sideFenceOpp.position.x=cx+fx; city.add(sideFenceOpp);
    const entryMat=new THREE.MeshBasicMaterial({ color:0xd1d5db });
    const entryPad=new THREE.Mesh(new THREE.PlaneGeometry(gateW*0.6, 1.2), entryMat);
    entryPad.rotation.x=-Math.PI/2; entryPad.position.set(cx,0.031,cz+fz-0.55); city.add(entryPad);
    const entryPadBack=entryPad.clone(); entryPadBack.position.z=cz-fz+0.55; city.add(entryPadBack);
    treesPerimeter(cx,cz);
    CITY_LABELS.push({name:'Fusha Basketbolli', pos:new THREE.Vector3(cx,0,cz)});
  }

  function addFountain(cx,cz){
    addParkGrass(cx,cz,1.2);
    const ringR=12;
    const base=new THREE.Mesh(new THREE.CylinderGeometry(ringR,ringR,0.6,48), new THREE.MeshStandardMaterial({ color:0xaeb8c6, roughness:0.7 })); base.position.set(cx,0.3,cz); base.castShadow=false; base.receiveShadow=true; city.add(base);
    const water=new THREE.Mesh(new THREE.CylinderGeometry(ringR*0.92, ringR*0.92, 0.4, 48), new THREE.MeshStandardMaterial({ color:0x3aa7ff, roughness:0.15, metalness:0.05, transparent:true, opacity:0.75 })); water.position.set(cx,0.5,cz); city.add(water);
    for(let i=0;i<26;i++){ const ang=Math.random()*Math.PI*2, r=ringR*0.95*(0.6+Math.random()*0.35); const s=new THREE.Mesh(new THREE.DodecahedronGeometry(0.6+Math.random()*0.8), new THREE.MeshStandardMaterial({ color:0x9aa0a8, roughness:0.95 })); s.position.set(cx+Math.cos(ang)*r,0.35,cz+Math.sin(ang)*r); city.add(s); }
    for(let i=0;i<80;i++){ const ang=Math.random()*Math.PI*2, r=ringR*(0.2+Math.random()*0.9); const f=new THREE.Mesh(new THREE.ConeGeometry(0.15,0.4,8), new THREE.MeshStandardMaterial({ color: (Math.random()<0.5?0xff4d6d:0xffc300), roughness:0.9 })); f.position.set(cx+Math.cos(ang)*r,0.2,cz+Math.sin(ang)*r); city.add(f); }
    const jets=[]; const jetMat=new THREE.MeshBasicMaterial({ color:0xaee3ff }); for(let i=0;i<8;i++){ const j=new THREE.Mesh(new THREE.CylinderGeometry(0.05,0.05,1.2,8), jetMat); j.position.set(cx+(Math.random()*2-1)*2,1.1,cz+(Math.random()*2-1)*2); city.add(j); jets.push(j); }
    const glow=new THREE.PointLight(0x66d8ff,3.5,45); glow.position.set(cx,6,cz); city.add(glow);
    water.userData.jets=jets;
    CITY_LABELS.push({name:'Shat√´rvani Qendror', pos:new THREE.Vector3(cx,0,cz)});
  }

  const trafficLights=[];
  function addTrafficLight(x,z,dir=0){ const h=5; const pole=new THREE.Mesh(new THREE.CylinderGeometry(0.1,0.1,h,10), new THREE.MeshStandardMaterial({ color:0x666 })); pole.position.set(x,h/2,z); city.add(pole); const box=new THREE.Mesh(new THREE.BoxGeometry(0.4,1,0.3), new THREE.MeshStandardMaterial({ color:0x222 })); box.position.set(x,3.6,z); box.rotation.y=dir; city.add(box);
    const mkLamp=(c,dy)=>{ const m=new THREE.Mesh(new THREE.SphereGeometry(0.14,12,12), new THREE.MeshBasicMaterial({ color:c })); m.position.set(x+Math.sin(dir)*0.15,3.6+dy,z+Math.cos(dir)*0.15); city.add(m); return m; };
    const Lg=mkLamp(0x2ecc71,0.28), Ly=mkLamp(0xf1c40f,0), Lr=mkLamp(0xe74c3c,-0.28);
    trafficLights.push({pos:new THREE.Vector3(x,0,z), dir, state:'green', timer:0, lamps:{Lg,Ly,Lr}});
  }

  function addRingRoad(radius){
    const width=26;
    const ringGeo=new THREE.RingGeometry(radius-width/2, radius+width/2, 160);
    const ring=new THREE.Mesh(ringGeo, new THREE.MeshLambertMaterial({ map: asphaltTex, side:THREE.DoubleSide }));
    ring.rotation.x=-Math.PI/2;
    ring.position.y=0.015;
    ring.receiveShadow=allowShadows;
    city.add(ring);
    const stripe=new THREE.Mesh(new THREE.RingGeometry(radius-4, radius+4, 160), new THREE.MeshBasicMaterial({ color:0xffffff, transparent:true, opacity:0.35, side:THREE.DoubleSide }));
    stripe.rotation.x=-Math.PI/2;
    stripe.position.y=0.016;
    city.add(stripe);
    ringRoadData={radius,width,name:'Unaza e Madhe'};
    const inner=Math.max(BLOCKS_X,BLOCKS_Z)*CELL*0.5 + ROAD*0.5;
    const exits=6;
    for(let i=0;i<exits;i++){
      const ang=(i/exits)*Math.PI*2;
      const start=inner;
      const end=radius-ROAD*0.5;
      if(end<=start) continue;
      const length=end-start;
      const geo=new THREE.PlaneGeometry(ROAD*1.2, length);
      const connector=new THREE.Mesh(geo, roadMat);
      connector.rotation.x=-Math.PI/2;
      connector.rotation.y=ang;
      const mid=start+length/2;
      connector.position.set(Math.cos(ang)*mid,0.012,Math.sin(ang)*mid);
      connector.receiveShadow=allowShadows;
      city.add(connector);
      const from=new THREE.Vector3(Math.cos(ang)*start,0,Math.sin(ang)*start);
      const to=new THREE.Vector3(Math.cos(ang)*end,0,Math.sin(ang)*end);
      ROAD_SEGMENTS.push({name:`Dalja ${i+1}`, from, to, width:ROAD*1.2, orientation:'connector'});
      const sign=makeLabel('Ring Road',0.6);
      sign.position.set(Math.cos(ang)*(end+3),3,Math.sin(ang)*(end+3));
      sign.lookAt(sign.position.clone().add(new THREE.Vector3(0,0,1)));
      city.add(sign);
    }
  }

  const POIS=[];
  const CITY_LABELS=[];
  const ROAD_SEGMENTS=[];
  let ringRoadData=null;
  const STREET_NAMES_NS=['Rr. D√´shmor√´t e Kombit','Rr. Sk√´nderbej','Rr. Ismail Qemali','Rr. Kavaj√´s','Rr. Myslym Shyri','Rr. Kodra e Diellit','Rr. Ali Demi','Rr. Don Bosko'];
  const STREET_NAMES_EW=['Blv. Gjergj Fishta','Blv. Bajram Curri','Rr. e Barrikadave','Blv. Zogu I','Rr. Kongresi i Lushnj√´s','Rr. Pandeli Evangjeli','Blv. Dritan Hoxha','Rr. Teodor Keko'];
  function addInstitution(kind, x, z){
    let sign = kind==='hospital'?'HOSPITAL': kind==='police'?'POLICE': kind==='fire'?'FIRE': kind==='school'?'SCHOOL':'MALL';
    const b=addBuilding(x,z,{floors: (kind==='mall'?6:7), w: (kind==='mall'?70:48), d:(kind==='mall'?60:40), hue: kind==='hospital'?5: (kind==='police'?210: (kind==='fire'?8: (kind==='school'?40:80))), sign});
    if(kind==='hospital'){ const pad=new THREE.Mesh(new THREE.CircleGeometry(8,32), new THREE.MeshBasicMaterial({ color:0xffffff })); pad.rotation.x=-Math.PI/2; pad.position.set(x, b.dims.h+0.2, z- b.dims.d/2 + 10); city.add(pad); const H=new THREE.Mesh(new THREE.TorusGeometry(6,0.6,8,32), new THREE.MeshBasicMaterial({ color:0xff0000 })); H.rotation.x=-Math.PI/2; H.position.copy(pad.position).setY(b.dims.h+0.5); city.add(H); }
    const icon = kind==='hospital'?'üè•': kind==='police'?'üöì': kind==='fire'?'üßØ': kind==='school'?'üè´':'üõç';
    POIS.push({type:kind, pos:new THREE.Vector3(x,0,z), label:icon, dims:b.dims});
    const cityName = kind==='hospital'?'Spitali Qendror': kind==='police'?'Komisariati i Policis√´': kind==='fire'?'Brigada e Zjarrfik√´sve': kind==='school'?'Akademia Metropolitane':'Qendra Tregtare';
    CITY_LABELS.push({name:cityName,pos:new THREE.Vector3(x,0,z)});
  }

  function addAirport(x,z){ const runway=new THREE.Mesh(new THREE.PlaneGeometry(400,26), new THREE.MeshBasicMaterial({ color:0x2f2f2f })); runway.rotation.x=-Math.PI/2; runway.position.set(x,0.02,z); city.add(runway); const stripe=new THREE.Mesh(new THREE.PlaneGeometry(400*0.9,3), new THREE.MeshBasicMaterial({ color:0xffffff, transparent:true, opacity:0.7 })); stripe.rotation.x=-Math.PI/2; stripe.position.set(x,0.03,z); city.add(stripe); const tower=new THREE.Mesh(new THREE.CylinderGeometry(4,4,28,16), new THREE.MeshStandardMaterial({ color:0x9aa0a8 })); tower.position.set(x+40,14,z-20); city.add(tower); const top=new THREE.Mesh(new THREE.SphereGeometry(6,16,12), new THREE.MeshStandardMaterial({ color:0xbfc6cf, metalness:0.2, roughness:0.6 })); top.position.set(x+40,28,z-20); city.add(top); POIS.push({type:'airport', pos:new THREE.Vector3(x,0,z), label:'üõ´'}); CITY_LABELS.push({name:'Aeroporti Tirana 2040', pos:new THREE.Vector3(x,0,z)}); }
  function addTrainStation(x,z){ const plat=new THREE.Mesh(new THREE.PlaneGeometry(160,8), new THREE.MeshBasicMaterial({ color:0x666b73 })); plat.rotation.x=-Math.PI/2; plat.position.set(x,0.02,z); city.add(plat); const rails=new THREE.Group(); for(let i=0;i<4;i++){ const r=new THREE.Mesh(new THREE.PlaneGeometry(160,0.3), new THREE.MeshBasicMaterial({ color:0x444 })); r.rotation.x=-Math.PI/2; r.position.set(x,0.021,z-2+i*1.2); rails.add(r);} city.add(rails); addBuilding(x+30,z-8,{floors:5,w:50,d:16,hue:48,sign:'STATION'}); POIS.push({type:'station', pos:new THREE.Vector3(x,0,z), label:'üöâ'}); CITY_LABELS.push({name:'Stacioni Qendror', pos:new THREE.Vector3(x,0,z)}); }

  const parkKinds=['tennis','basket','fountain'];
  for(let ix=0; ix<BLOCKS_X; ix++){
    for(let iz=0; iz<BLOCKS_Z; iz++){
      const cx=startX+ix*CELL, cz=startZ+iz*CELL; addSidewalk(cx,cz);
      const makePark = ((ix+iz)%2===0);
      if(makePark){
        const pick = parkKinds[(ix+iz)%parkKinds.length];
        if(pick==='tennis') addTennisCourt(cx,cz);
        else if(pick==='basket') addBasketCourt(cx,cz);
        else addFountain(cx,cz);
      } else {
        const bCount=2+Math.floor(Math.random()*3); for(let b=0;b<bCount;b++){ addBuilding(cx+(Math.random()-0.5)*PLOT*0.7, cz+(Math.random()-0.5)*PLOT*0.7); }
      }
    }
  }
  for(let i=-BLOCKS_X;i<=BLOCKS_X;i+=2){ addTrafficLight(i*CELL*0.5, -BLOCKS_Z*CELL*0.5, 0); addTrafficLight(i*CELL*0.5, BLOCKS_Z*CELL*0.5, Math.PI); }

  const ringR = Math.max(BLOCKS_X,BLOCKS_Z)*CELL*0.65;
  addRingRoad(ringR);
  const MAP_EXTENT = ringR*1.25;
  addAirport(ringR*0.9,  -ringR*0.6);
  addTrainStation(-ringR*0.6, ringR*0.85);

  addInstitution('police',   startX+CELL*1.2, startZ+CELL*1.0);
  addInstitution('hospital', startX+CELL*2.6, startZ+CELL*2.0);
  addInstitution('school',   startX+CELL*0.4, startZ+CELL*3.2);
  addInstitution('fire',     startX+CELL*3.5, startZ+CELL*0.6);
  addInstitution('mall',     startX+CELL*4.2, startZ+CELL*2.6);

  const playerRadius=0.35; const player=new CANNON.Body({ mass:75, material:matPlayer, shape:new CANNON.Sphere(playerRadius), position:new CANNON.Vec3(0,1.0,10), linearDamping:0.18, angularDamping:0.9 });
  player.fixedRotation=true; player.allowSleep=false; world.addBody(player);
  let yaw=0, pitch=0; function clampPitch(){ const limit=Math.PI*0.72; pitch=Math.max(-limit, Math.min(limit, pitch)); }
  let camDist=4.2;
  function camFollow(pos,distMul=1){ const back=new THREE.Vector3(Math.sin(yaw),0,Math.cos(yaw)); const eye=new THREE.Vector3(pos.x - back.x*camDist*distMul, pos.y+2.1, pos.z - back.z*camDist*distMul); camera.position.lerp(eye,0.25); const look=new THREE.Vector3(pos.x + back.x*(camDist+0.2)*distMul, pos.y+1.25 + Math.sin(pitch)*0.8, pos.z + back.z*(camDist+0.2)*distMul); camera.lookAt(look); }
  function grounded(){ return player.position.y < 0.38 && Math.abs(player.velocity.y) < 0.05; }
  function jump(){ if(grounded()){ player.velocity.y = 5.2; } }

  const aimGeo=new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(), new THREE.Vector3(0,0,-50)]);
  const aimMatDark=new THREE.LineBasicMaterial({ color:0x222222, transparent:true, opacity:0.9 });
  const aimLine=new THREE.Line(aimGeo,aimMatDark); aimLine.renderOrder=9; scene.add(aimLine);
  const aimDotTex=(function(){ const c=document.createElement('canvas'); c.width=c.height=64; const x=c.getContext('2d'); x.fillStyle='rgba(255,255,255,0.0)'; x.fillRect(0,0,64,64); x.beginPath(); x.arc(32,32,14,0,Math.PI*2); x.fillStyle='rgba(255,60,60,0.95)'; x.fill(); x.lineWidth=3; x.strokeStyle='rgba(255,255,255,0.9)'; x.stroke(); const t=new THREE.CanvasTexture(c); t.colorSpace=THREE.SRGBColorSpace; return t; })();
  const aimDotMat=new THREE.SpriteMaterial({ map:aimDotTex, depthWrite:false, color:0xffffff }); const aimDot=new THREE.Sprite(aimDotMat); aimDot.scale.set(0.7,0.7,1); scene.add(aimDot);
  const crosshairEl=$('crosshair'); crosshairEl.style.setProperty('--aimColor','#ff3c3c');

  const BLANK_PNG='data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR4nGNgYAAAAAMAASsJTYQAAAAASUVORK5CYII=';
  const manager=new THREE.LoadingManager(); manager.setURLModifier((url)=>{ if(url?.startsWith('data:')||url?.startsWith('blob:')) return url; if(/(\.(png|jpg|jpeg|webp|ktx2|dds|tga)(\?|#|$))/i.test(url)) return BLANK_PNG; return url; });
  const gltfLoader=new GLTFLoader(manager); const draco=new DRACOLoader(manager); draco.setDecoderPath('https://www.gstatic.com/draco/v1/decoders/'); gltfLoader.setDRACOLoader(draco); gltfLoader.setCrossOrigin('anonymous');
  gltfLoader.register((parser)=>{ const c=document.createElement('canvas'); c.width=c.height=1; const ctx=c.getContext('2d'); ctx.fillStyle='#888'; ctx.fillRect(0,0,1,1); const blank=new THREE.CanvasTexture(c); blank.colorSpace=THREE.SRGBColorSpace; blank.needsUpdate=true; const orig=parser.getDependency.bind(parser); parser.getDependency=function(type,index){ if(type==='texture') return Promise.resolve(blank); return orig(type,index); }; return {name:'NullTextures'}; });

  const ARMORY=[
    { key:'Glock',  name:'Glock', url:'https://cdn.jsdelivr.net/gh/webaverse/pistol@master/glock.glb', s:0.62,  stats:{ rpm:380, dmg:24, spread:0.013, mag:17, reload:1.2 }, auto:false },
    { key:'Pistol', name:'Pistol',url:'https://cdn.jsdelivr.net/gh/webaverse/pistol@master/pistol.glb', s:0.46, stats:{ rpm:320, dmg:22, spread:0.014, mag:15, reload:1.3 }, auto:false },
    { key:'AR',     name:'Assault Rifle', url:'https://cdn.jsdelivr.net/gh/webaverse/pistol@master/military.glb', s:0.70, stats:{ rpm:720, dmg:26, spread:0.012, mag:30, reload:1.9 }, auto:true },
    { key:'Uzi',    name:'Uzi',    url:'https://cdn.jsdelivr.net/gh/webaverse/uzi@main/uzi.glb', s:0.60, stats:{ rpm:900, dmg:18, spread:0.02,  mag:32, reload:1.6 }, auto:true },
    { key:'AK47',   name:'AK-pattern', url:'https://cdn.jsdelivr.net/gh/LazerMaker/gun-models-ak47-and-supprest-pistol-@master/ak47.glb', s:0.78, stats:{ rpm:600, dmg:30, spread:0.012, mag:30, reload:1.9 }, auto:true },
    { key:'Grenade',name:'Grenade',url:'https://cdn.jsdelivr.net/gh/friuns2/bingextension@main/grenade.glb', s:0.30, stats:{ rpm:60,  dmg:120, spread:0.03,  mag:1,  reload:2.4 }, auto:false }
  ];
  const FIRE_MODES=new Map(); ARMORY.forEach(a=>FIRE_MODES.set(a.key, a.auto?'auto':'single'));
  const GRENADE_STATS=ARMORY.find(a=>a.key==='Grenade')?.stats||{dmg:120, spread:0.03, mag:1, reload:2.4};

  const weaponRoot=new THREE.Group(); camera.add(weaponRoot);
  const weaponCache=new Map();
  const metalTex=(()=>{ const S=256,c=document.createElement('canvas'); c.width=c.height=S; const x=c.getContext('2d'); const g=x.createLinearGradient(0,0,S,S); g.addColorStop(0,'#2e2e2e'); g.addColorStop(1,'#4a4a4a'); x.fillStyle=g; x.fillRect(0,0,S,S); const t=new THREE.CanvasTexture(c); t.colorSpace=THREE.SRGBColorSpace; t.anisotropy=2; return t; })();
  const matMetal=new THREE.MeshLambertMaterial({ color:'#3b3b3b', map:metalTex }), matWood =new THREE.MeshLambertMaterial({ color:'#7b5331' });
  function makeSight(){ const s=new THREE.Group(); const ring=new THREE.Mesh(new THREE.TorusGeometry(0.015,0.004,8,12), new THREE.MeshBasicMaterial({ color:'#222' })); ring.rotation.x=Math.PI/2; ring.position.set(0,0,0.02); const post=new THREE.Mesh(new THREE.BoxGeometry(0.004,0.02,0.004), new THREE.MeshBasicMaterial({ color:'#444' })); post.position.set(0,0,0.03); s.add(ring,post); return s; }
  function makeAK47Mesh(){ const g=new THREE.Group(); const rec=new THREE.Mesh(new THREE.BoxGeometry(0.12,0.11,0.45), matMetal); const hand=new THREE.Mesh(new THREE.BoxGeometry(0.07,0.08,0.28), matWood); hand.position.set(0.07,-0.02,-0.22); const barrel=new THREE.Mesh(new THREE.CylinderGeometry(0.016,0.016,0.38,18), matMetal); barrel.rotation.z=Math.PI/2; barrel.position.set(0.12,-0.02,-0.41); const stock=new THREE.Mesh(new THREE.BoxGeometry(0.08,0.09,0.25), matWood); stock.position.set(-0.06,-0.01,0.16); const mag=new THREE.Mesh(new THREE.CapsuleGeometry(0.04,0.12,8,16), matMetal); mag.rotation.x=Math.PI/2; mag.position.set(0.02,-0.08,0.02); g.add(rec,hand,barrel,stock,mag,makeSight()); return g; }
  function makePistolMesh(){ const g=new THREE.Group(); const slide=new THREE.Mesh(new THREE.BoxGeometry(0.08,0.05,0.18), matMetal); slide.position.set(0.02,0.02,-0.09); const frame=new THREE.Mesh(new THREE.BoxGeometry(0.09,0.07,0.14), new THREE.MeshLambertMaterial({color:'#444'})); const grip=new THREE.Mesh(new THREE.BoxGeometry(0.05,0.1,0.06), new THREE.MeshLambertMaterial({color:'#2b2b2b'})); grip.position.set(-0.02,-0.05,0.02); const barrel=new THREE.Mesh(new THREE.CylinderGeometry(0.008,0.008,0.14,10), matMetal); barrel.rotation.z=Math.PI/2; barrel.position.set(0.07,0.02,-0.18); g.add(frame,slide,grip,barrel,makeSight()); return g; }
  function normalizeAndCenter(root, targetLen=0.6){ const box=new THREE.Box3().setFromObject(root); const size=new THREE.Vector3(); box.getSize(size); const center=new THREE.Vector3(); box.getCenter(center); root.position.sub(center); const maxDim=Math.max(size.x,size.y,size.z)||1; const s=targetLen/maxDim; root.scale.setScalar(s); return root; }
  async function loadWeapon(key){ const entry=ARMORY.find(a=>a.key===key); if(!entry){ return new THREE.Group(); } if(weaponCache.has(key)){ const v=weaponCache.get(key); return (v.clone? v.clone(true) : v); } try{ const gltf=await gltfLoader.loadAsync(entry.url); const base=(gltf.scene||gltf.scenes?.[0]||null); let use = base || makePistolMesh(); normalizeAndCenter(use, entry.s); use.traverse?.(o=>{ if(o.isMesh){ o.castShadow=allowShadows; o.receiveShadow=allowShadows; const m=o.material; o.material = new THREE.MeshLambertMaterial({ color:(m?.color||new THREE.Color('#888')), map:m?.map||null, transparent:!!m?.transparent, opacity:(m?.opacity??1) }); }}); weaponCache.set(key, use); return (use.clone? use.clone(true) : use); }catch(_){ let alt; if(key==='AK47') alt=makeAK47Mesh(); else alt=makePistolMesh(); normalizeAndCenter(alt, key==='AK47'?0.78:0.5); weaponCache.set(key, alt); return (alt.clone? alt.clone(true) : alt); } }

  const armoryDiv=$('armory'); const thumbCache=new Map();
  function weaponIconURL(key){ const svg=(b)=>'data:image/svg+xml;utf8,'+encodeURIComponent(b); const base=(body)=>`<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 112 68'><rect width='112' height='68' rx='8' ry='8' fill='rgba(0,0,0,0.18)'/><g fill='none' stroke='#e6eefc' stroke-width='4' stroke-linecap='round' stroke-linejoin='round'>${body}</g></svg>`; switch(key){ case 'Glock': return svg(base(`<path d='M14 32h58l8 8H14z'/><path d='M64 32v-8h20l8 10'/>`)); case 'Pistol': return svg(base(`<path d='M12 34h62l10 8H12z'/>`)); case 'AR': return svg(base(`<path d='M8 38h74l8 6H8z'/>`)); case 'Uzi': return svg(base(`<path d='M10 34h52l8 6H10z'/>`)); case 'AK47': return svg(base(`<path d='M10 38h84l10 6H10z'/>`)); case 'Grenade': return svg(base(`<circle cx='42' cy='36' r='12'/>`)); default: return svg(base(`<path d='M16 34h80'/>`)); } }
  function weaponPreviewURL(key){ return thumbCache.get(key) || weaponIconURL(key); }
  async function generateThumb(key){ try{ if(thumbCache.has(key)) return thumbCache.get(key); const size={w:224,h:136}; const rt=new THREE.WebGLRenderTarget(size.w,size.h); const sc=new THREE.Scene(); const cam=new THREE.PerspectiveCamera(40, size.w/size.h, 0.01, 10); const amb=new THREE.AmbientLight(0xffffff,0.9); const dir=new THREE.DirectionalLight(0xffffff,0.9); dir.position.set(2,3,2); sc.add(amb,dir); const model=await loadWeapon(key); const g=new THREE.Group(); if(model) g.add(model); normalizeAndCenter(g,0.9); g.rotation.y=Math.PI*0.85; sc.add(g); const prev=new THREE.Color(); renderer.getClearColor(prev); const prevA=renderer.getClearAlpha(); renderer.setRenderTarget(rt); renderer.setClearColor(0x000000,0); cam.position.set(0.6,0.3,1.2); cam.lookAt(0,0,0); renderer.render(sc,cam); const px=new Uint8Array(size.w*size.h*4); renderer.readRenderTargetPixels(rt,0,0,size.w,size.h,px); const cv=document.createElement('canvas'); cv.width=size.w; cv.height=size.h; const ctx=cv.getContext('2d'); const img=ctx.createImageData(size.w,size.h); for(let y=0;y<size.h;y++){ const sy=size.h-1-y; img.data.set(px.subarray(sy*size.w*4, sy*size.w*4+size.w*4), y*size.w*4);} ctx.putImageData(img,0,0); const url=cv.toDataURL('image/png'); renderer.setRenderTarget(null); renderer.setClearColor(prev,prevA); rt.dispose(); thumbCache.set(key,url); return url; }catch(_){ return weaponIconURL(key); } }
  function buildGallery(){ armoryDiv.innerHTML=''; ARMORY.forEach((a)=>{ const b=document.createElement('button'); b.className='armBtn'; b.id='arm_'+a.key; b.innerHTML = `<img alt="${a.name}" src="${weaponPreviewURL(a.key)}"><span>${a.name}</span>`; b.addEventListener('click',()=>selectWeapon(a.key)); if(a.auto){ const t=document.createElement('button'); t.className='modeToggle'; t.textContent=(FIRE_MODES.get(a.key)==='auto')?'AUTO':'SINGLE'; t.addEventListener('click',(ev)=>{ ev.stopPropagation(); FIRE_MODES.set(a.key, FIRE_MODES.get(a.key)==='auto'?'single':'auto'); t.textContent=(FIRE_MODES.get(a.key)==='auto')?'AUTO':'SINGLE'; }); b.appendChild(t); } armoryDiv.appendChild(b); generateThumb(a.key).then(url=>{ const img=b.querySelector('img'); if(img) img.src=url; }); }); }
  buildGallery();

  let currentKey=ARMORY[0].key, currentStats=ARMORY[0].stats; let weaponModel=null; const ammo=new Map(); ARMORY.forEach(a=>ammo.set(a.key,{mag:a.stats.mag,reserve:a.stats.mag*3}));
  function updateAmmoHUD(){ const a=ammo.get(currentKey); $('ammo').textContent=`${ARMORY.find(x=>x.key===currentKey)?.name||currentKey} ‚Äî ${a.mag}/${a.reserve}`; document.querySelectorAll('.armBtn').forEach(el=>el.classList.remove('active')); const ab=$('arm_'+currentKey); if(ab) ab.classList.add('active'); }
  const MUZZLE_OFF={ Glock:[0.0,-0.02,-0.74], Pistol:[0.0,-0.02,-0.74], AR:[0.0,-0.04,-0.80], Uzi:[0.0,-0.03,-0.78], AK47:[0.0,-0.04,-0.82], Grenade:[0,0,0] };
  const EJECT_OFF={ Glock:[0.06,-0.05,-0.36], Pistol:[0.06,-0.05,-0.36], AR:[0.08,-0.05,-0.42], Uzi:[0.06,-0.04,-0.40], AK47:[0.09,-0.05,-0.44], Grenade:[0,0,0] };
  const SHELL_SPECS={
    Glock:{radius:0.006,length:0.14,color:0xd6b064},
    Pistol:{radius:0.006,length:0.14,color:0xd6b064},
    Uzi:{radius:0.0055,length:0.13,color:0xd0a050},
    AR:{radius:0.0064,length:0.20,color:0xcfa443},
    AK47:{radius:0.007,length:0.22,color:0xc58f3d}
  };

  async function mountPlayerWeapon(key){ if(weaponModel){ weaponRoot.remove(weaponModel); weaponModel.traverse(o=>{ o.geometry?.dispose?.(); if(Array.isArray(o.material)) o.material.forEach(m=>m.dispose?.()); else o.material?.dispose?.(); }); weaponModel=null; }
    const model=await loadWeapon(key); const g=new THREE.Group(); if(model) g.add(model);
    const off={x:0.18,y:-0.10,z:-0.52}; g.position.set(off.x,off.y,off.z); g.rotation.set(-0.03, Math.PI, -0.12);
    weaponModel=g; weaponRoot.add(g);
    const muzzleAnchor=new THREE.Object3D(); const ejectAnchor=new THREE.Object3D(); weaponModel.add(muzzleAnchor); weaponModel.add(ejectAnchor);
    const mo=MUZZLE_OFF[key]||MUZZLE_OFF.Glock; const eo=EJECT_OFF[key]||EJECT_OFF.Glock; muzzleAnchor.position.set(mo[0],mo[1],mo[2]); ejectAnchor.position.set(eo[0],eo[1],eo[2]);
    weaponModel.userData.muzzleAnchor=muzzleAnchor; weaponModel.userData.ejectAnchor=ejectAnchor; }
  async function selectWeapon(key){ currentKey=key; currentStats=ARMORY.find(a=>a.key===key)?.stats||currentStats; updateAmmoHUD(); await mountPlayerWeapon(key); updateZoomUI(); }
  await selectWeapon(currentKey);

  const impactTargets=[city];
  const raycaster=new THREE.Raycaster(); const tracers=[]; function tracer(from,to,color=0xfff1b1,life=0.12){ const g=new THREE.BufferGeometry().setFromPoints([from,to]); const m=new THREE.LineBasicMaterial({color,transparent:true}); const l=new THREE.Line(g,m); l.userData.life=life; scene.add(l); tracers.push(l);} function updateTracers(dt){ for(let i=0;i<tracers.length;i++){ const l=tracers[i]; l.userData.life-=dt; l.material.opacity=Math.max(0,l.userData.life/0.12); if(l.userData.life<=0){ scene.remove(l); l.geometry.dispose(); l.material.dispose(); tracers.splice(i,1); i--; } } }
  const decalTex=(function(){ const c=document.createElement('canvas'); c.width=c.height=64; const x=c.getContext('2d'); x.clearRect(0,0,64,64); x.fillStyle='rgba(0,0,0,0.9)'; x.beginPath(); x.arc(32,32,18,0,Math.PI*2); x.fill(); x.fillStyle='rgba(0,0,0,0.4)'; for(let i=0;i<10;i++){ const r=22+Math.random()*6; x.beginPath(); x.arc(32+(Math.random()-0.5)*6,32+(Math.random()-0.5)*6,r,0,Math.PI*2); x.fill(); } const t=new THREE.CanvasTexture(c); t.colorSpace=THREE.SRGBColorSpace; t.anisotropy=2; return t; })();
  function addDecal(point, normal){ const s=0.22; const g=new THREE.PlaneGeometry(s,s); const m=new THREE.MeshBasicMaterial({ map:decalTex, transparent:true, depthWrite:false }); const q=new THREE.Quaternion(); q.setFromUnitVectors(new THREE.Vector3(0,0,1), normal.clone().normalize()); const mesh=new THREE.Mesh(g,m); mesh.position.copy(point); mesh.quaternion.copy(q); mesh.renderOrder=10; scene.add(mesh); setTimeout(()=>{ scene.remove(mesh); g.dispose(); m.dispose(); }, 15000); }
  const bloodTex=(function(){ const c=document.createElement('canvas'); c.width=c.height=64; const x=c.getContext('2d'); x.fillStyle='rgba(160,0,0,0.0)'; x.fillRect(0,0,64,64); x.fillStyle='rgba(210,20,20,0.9)'; x.beginPath(); x.arc(32,32,20,0,Math.PI*2); x.fill(); x.fillStyle='rgba(120,0,0,0.9)'; for(let i=0;i<5;i++){ x.beginPath(); x.arc(32+(Math.random()-0.5)*16,32+(Math.random()-0.5)*16,6+Math.random()*6,0,Math.PI*2); x.fill(); } const t=new THREE.CanvasTexture(c); t.colorSpace=THREE.SRGBColorSpace; return t; })();
  function addBlood(point){ const s=0.38; const g=new THREE.PlaneGeometry(s,s); const m=new THREE.MeshBasicMaterial({ map:bloodTex, transparent:true, depthWrite:false }); const mesh=new THREE.Mesh(g,m); mesh.position.copy(point); mesh.lookAt(camera.position); scene.add(mesh); setTimeout(()=>{ scene.remove(mesh); g.dispose(); m.dispose(); }, 12000); }

  let reloading=false; function reload(){ const a=ammo.get(currentKey); const st=currentStats; if(reloading || !a) return; const need=st.mag-a.mag; if(need<=0||a.reserve<=0) return; const take=Math.min(need,a.reserve); reloading=true; setTimeout(()=>{ a.mag+=take; a.reserve-=take; reloading=false; updateAmmoHUD(); sfxReload(); }, st.reload*1000); }
  $('reloadMini').addEventListener('click', reload);

  function fireRay(off2){ raycaster.setFromCamera(off2||new THREE.Vector2(0,0), camera); const from=camera.position.clone(); const to=raycaster.ray.origin.clone().addScaledVector(raycaster.ray.direction, 8000); const pos = aimGeo.attributes.position; pos.setXYZ(0, from.x, from.y, from.z); pos.setXYZ(1, to.x, to.y, to.z); pos.needsUpdate=true; const plane = new THREE.Plane(new THREE.Vector3(0,1,0), 0); const hit = new THREE.Vector3(); raycaster.ray.intersectPlane(plane, hit); if(hit){ aimDot.position.copy(hit); } else { aimDot.position.copy(to); } return {from,to}; }

  function makeShellInstance(key){
    const spec=SHELL_SPECS[key]||SHELL_SPECS.Glock;
    if(!spec) return null;
    const group=new THREE.Group();
    const materials=new Set();
    const parts=[];
    const brass=new THREE.MeshStandardMaterial({ color:spec.color, metalness:0.65, roughness:0.38 });
    materials.add(brass);
    const bodyLen=spec.length*0.7;
    const neckLen=spec.length*0.2;
    const rimLen=spec.length*0.1;
    const body=new THREE.Mesh(new THREE.CylinderGeometry(spec.radius, spec.radius*0.95, bodyLen, 14), brass);
    body.rotation.z=Math.PI/2;
    parts.push(body);
    const neckMat=brass.clone(); materials.add(neckMat);
    const neck=new THREE.Mesh(new THREE.CylinderGeometry(spec.radius*0.72, spec.radius*0.9, neckLen, 14), neckMat);
    neck.rotation.z=Math.PI/2; neck.position.x=bodyLen*0.5 + neckLen*0.5;
    parts.push(neck);
    const rimMat=brass.clone(); materials.add(rimMat);
    const rim=new THREE.Mesh(new THREE.CylinderGeometry(spec.radius*1.12, spec.radius*1.02, rimLen, 14), rimMat);
    rim.rotation.z=Math.PI/2; rim.position.x=-(bodyLen*0.5 + rimLen*0.5);
    parts.push(rim);
    parts.forEach(p=>group.add(p));
    group.userData.dispose=()=>{
      parts.forEach(p=>p.geometry.dispose());
      materials.forEach(m=>m.dispose?.());
    };
    group.rotation.set(Math.random()*Math.PI, Math.random()*Math.PI, Math.random()*Math.PI);
    return group;
  }
  function ejection(anc,key){
    if(!anc) return;
    const shell=makeShellInstance(key);
    if(!shell) return;
    const wp=new THREE.Vector3(); anc.getWorldPosition(wp);
    shell.position.copy(wp);
    scene.add(shell);
    const power = key==='AK47'?1.25: key==='AR'?1.15:1.0;
    const v=new THREE.Vector3((Math.random()*0.22+0.12)*power, (Math.random()*0.34+0.14), (Math.random()*0.24-0.12));
    const spin=new THREE.Vector3((Math.random()*0.2+0.04)*power, (Math.random()*0.18+0.06), (Math.random()*0.2+0.04));
    const t0=performance.now();
    const id=setInterval(()=>{
      const t=(performance.now()-t0)/1000;
      shell.position.x += v.x;
      shell.position.y += v.y - 9.81*0.5*t*t*0.045;
      shell.position.z += v.z;
      shell.rotation.x += spin.x;
      shell.rotation.y += spin.y;
      shell.rotation.z += spin.z;
      v.y -= 0.018;
      if(t>1.2){
        clearInterval(id);
        scene.remove(shell);
        shell.userData.dispose?.();
      }
    },16);
  }

  async function createGrenade(origin, dir){
    try{
      const base=await loadWeapon('Grenade');
      const grenade=base?.clone? base.clone(true) : base;
      const holder=new THREE.Group();
      if(grenade) holder.add(grenade);
      holder.position.copy(origin);
      scene.add(holder);
      const body=new CANNON.Body({ mass:4.2, material:matGrenade, shape:new CANNON.Sphere(0.22), linearDamping:0.12, angularDamping:0.08 });
      body.position.set(origin.x,origin.y,origin.z);
      body.velocity.set(dir.x*18, dir.y*18 + 6, dir.z*18);
      body.angularVelocity.set((Math.random()-0.5)*4,(Math.random()-0.5)*6,(Math.random()-0.5)*4);
      world.addBody(body);
      grenades.push({mesh:holder, body, fuse:2.4, exploded:false});
    }catch(_){
      const body=new CANNON.Body({ mass:4.2, material:matGrenade, shape:new CANNON.Sphere(0.22) });
      body.position.set(origin.x,origin.y,origin.z);
      body.velocity.set(dir.x*18, dir.y*18 + 6, dir.z*18);
      world.addBody(body);
      const fallback=new THREE.Mesh(new THREE.SphereGeometry(0.22,12,10), new THREE.MeshBasicMaterial({ color:0x999999 }));
      fallback.position.copy(origin);
      scene.add(fallback);
      grenades.push({mesh:fallback, body, fuse:2.4, exploded:false});
    }
  }

  function launchGrenade(){
    const dir=new THREE.Vector3();
    camera.getWorldDirection(dir);
    dir.normalize();
    const origin=camera.position.clone().addScaledVector(dir, 0.9);
    origin.y = Math.max(origin.y, player.position.y + 1.1);
    createGrenade(origin, dir);
  }

  function applyExplosionDamage(pos, baseDamage){
    const radius=10;
    enemies.forEach((e)=>{
      if(e.dead) return;
      const dist=e.body.position.distanceTo(pos);
      if(dist>radius) return;
      const falloff=Math.max(0,1-dist/radius);
      const dmg=baseDamage*falloff;
      e.hp -= dmg;
      if(e.hp<=0){ e.dead=true; e.body.mass=0; e.body.updateMassProperties(); e.root.visible=false; e.hpBar.visible=false; }
      else { updateBillboardBar(e.hpBar, e.hp/120); }
    });
    const playerDist=player.position.distanceTo(pos);
    if(playerDist<=radius){ const falloff=Math.max(0,1-playerDist/radius); const harm=Math.round(45*falloff); if(harm>0){ hp=Math.max(0,hp-harm); updateHealth(); } }
  }

  function createExplosionEffect(pos){
    const sphere=new THREE.Mesh(new THREE.SphereGeometry(0.6,24,18), new THREE.MeshBasicMaterial({ color:0xffa34d, transparent:true, opacity:0.85 }));
    sphere.position.copy(pos);
    scene.add(sphere);
    const flash=new THREE.PointLight(0xffc878, 14, 32);
    flash.position.copy(pos).setY(pos.y+2);
    scene.add(flash);
    explosions.push({mesh:sphere, light:flash, age:0});
  }

  function dispatchEmergency(pos){
    emergencyUnits.forEach((unit)=>{
      unit.dispatch={target:pos.clone(), arrived:false};
      if(unit.mesh?.userData?.siren){ unit.mesh.userData.siren.active=true; }
    });
    setMiniMessage('Emergjencat u nis√´n!',5);
  }

  function explodeGrenade(entry){
    if(entry.exploded) return;
    entry.exploded=true;
    if(entry.body){ world.removeBody(entry.body); entry.body=null; }
    entry.mesh.visible=false;
    const pos=entry.mesh.position.clone();
    createExplosionEffect(pos);
    applyExplosionDamage(pos, GRENADE_STATS.dmg);
    dispatchEmergency(pos);
  }

  function updateGrenades(dt){
    for(let i=grenades.length-1;i>=0;i--){
      const g=grenades[i];
      if(g.body){
        g.mesh.position.set(g.body.position.x,g.body.position.y,g.body.position.z);
        g.mesh.quaternion.set(g.body.quaternion.x,g.body.quaternion.y,g.body.quaternion.z,g.body.quaternion.w);
      }
      g.fuse -= dt;
      if(g.fuse<=0 && !g.exploded){
        explodeGrenade(g);
      }
      if(g.exploded){
        g.fade=(g.fade||0)+dt;
        if(g.fade>2){
          scene.remove(g.mesh);
          g.mesh.traverse?.((o)=>{
            if(o.geometry?.dispose) o.geometry.dispose();
            if(o.material){ if(Array.isArray(o.material)) o.material.forEach(m=>m.dispose?.()); else o.material.dispose?.(); }
          });
          grenades.splice(i,1);
        }
      }
    }
  }

  function updateExplosions(dt){
    for(let i=explosions.length-1;i>=0;i--){
      const ex=explosions[i];
      ex.age+=dt;
      const scale=1+ex.age*9;
      ex.mesh.scale.setScalar(scale);
      ex.mesh.material.opacity=Math.max(0,0.9-ex.age*1.5);
      if(ex.light){ ex.light.intensity=Math.max(0,12-ex.age*20); }
      if(ex.age>1.2){
        if(ex.light){ scene.remove(ex.light); }
        scene.remove(ex.mesh);
        ex.mesh.geometry.dispose();
        ex.mesh.material.dispose();
        explosions.splice(i,1);
      }
    }
  }

  const tempDir=new THREE.Vector3();
  function updateEmergencyUnits(dt){
    emergencyUnits.forEach((unit)=>{
      const siren=unit.mesh.userData?.siren;
      if(unit.dispatch){
        const target=unit.dispatch.target;
        const pos=unit.mesh.position;
        tempDir.set(target.x-pos.x,0,target.z-pos.z);
        const dist=tempDir.length();
        if(dist>1.6){
          tempDir.normalize();
          const speed = unit.type==='fire'?11.5:9.5;
          pos.x += tempDir.x*speed*dt;
          pos.z += tempDir.z*speed*dt;
          setHeading(unit.mesh, Math.atan2(tempDir.z, tempDir.x));
        } else {
          unit.mesh.position.set(target.x, 0, target.z);
          unit.dispatch.arrived=true;
        }
      }
      if(siren){
        const active=!!unit.dispatch;
        siren.phase = (siren.phase||0) + dt*(active?8:2);
        const pulse=Math.sin(siren.phase);
        siren.lamps?.forEach((lamp,idx)=>{ const on = active ? ((idx===0 && pulse>0) || (idx===1 && pulse<0)) : false; lamp.material.opacity=on?0.95:0.18; lamp.material.needsUpdate=true; });
      }
    });
  }

  function doShot(){ const st=currentStats; if(!st) return; const a=ammo.get(currentKey); if(a.mag<=0){ return; } if(currentKey==='Grenade'){ a.mag--; updateAmmoHUD(); sfxGun('Grenade'); launchGrenade(); return; } muzzleLight.intensity=1.6; setTimeout(()=>muzzleLight.intensity=0,45); sfxGun(currentKey);
    const spread=st.spread; const off=new THREE.Vector2((Math.random()-0.5)*spread*2,(Math.random()-0.5)*spread*2); const {from,to}=fireRay(off);
    tracer(from,to,0xfff1b1);
    const hits = raycaster.intersectObjects(impactTargets, true).filter(h=>h.object!==weaponModel && h.object !== aimLine);
    if(hits.length){ const h=hits[0]; const normal = h.face?.normal?.clone()?.transformDirection(h.object.matrixWorld)||new THREE.Vector3(0,0,1); addDecal(h.point, normal); }
    const hitsEnemy = raycaster.intersectObjects(enemyRoots(), true);
    if(hitsEnemy.length){ const h=hitsEnemy[0]; const root=(function find(o){ let p=o; while(p && !p.userData?.enemy){ p=p.parent; } return p; })(h.object); const e=enemies.get(root.uuid); if(e && !e.dead){ e.hp -= st.dmg; addBlood(h.point); if(e.hp<=0){ e.dead=true; e.body.mass=0; e.body.updateMassProperties(); e.root.visible=false; e.hpBar.visible=false; } else { updateBillboardBar(e.hpBar, e.hp/120); } } }
    if(weaponModel?.userData?.ejectAnchor && currentKey!=='Grenade'){ ejection(weaponModel.userData.ejectAnchor, currentKey); }
    a.mag--; updateAmmoHUD();
  }

  const audio={ ctx:null, muted:false };
  function ac(){ if(audio.muted) return null; try{ audio.ctx = audio.ctx || new (window.AudioContext||window.webkitAudioContext)(); return audio.ctx; }catch(_){ return null; } }
  function withAC(fn){ const ctx=ac(); if(!ctx) return; fn(ctx); }
  function noiseBuffer(ctx){ const b=ctx.createBuffer(1, ctx.sampleRate*1.0, ctx.sampleRate); const d=b.getChannelData(0); for(let i=0;i<d.length;i++){ d[i]= (Math.random()*2-1) * (1 - i/d.length); } return b; }
  function burstNoise({dur=0.12, freq=1500, type='bandpass', gain=0.12}){ withAC((ctx)=>{ const src=ctx.createBufferSource(); src.buffer=noiseBuffer(ctx); const bp=ctx.createBiquadFilter(); bp.type=type; bp.frequency.value=freq; const g=ctx.createGain(); g.gain.value=gain; src.connect(bp); bp.connect(g); g.connect(ctx.destination); src.start(); src.stop(ctx.currentTime+dur); }); }
  function click({freq=800,dur=0.02,gain=0.08}){ withAC((ctx)=>{ const o=ctx.createOscillator(); const g=ctx.createGain(); o.type='square'; o.frequency.value=freq; g.gain.value=gain; o.connect(g); g.connect(ctx.destination); o.start(); o.stop(ctx.currentTime+dur); }); }
  function sfxGun(kind){ switch(kind){ case 'Glock': case 'Pistol': burstNoise({dur:0.09,freq:2200,gain:0.12}); click({freq:1800,dur:0.015,gain:0.06}); break; case 'AR': burstNoise({dur:0.08,freq:1900,gain:0.13}); click({freq:1600,dur:0.012,gain:0.05}); break; case 'Uzi': burstNoise({dur:0.05,freq:2300,gain:0.12}); click({freq:1900,dur:0.01,gain:0.05}); break; case 'AK47': burstNoise({dur:0.1,freq:1400,gain:0.14}); click({freq:1200,dur:0.015,gain:0.07}); break; case 'Grenade': burstNoise({dur:0.16,freq:680,gain:0.16}); break; default: burstNoise({dur:0.07,freq:1800,gain:0.12}); } }
  function sfxReload(){ click({freq:600,dur:0.05,gain:0.05}); setTimeout(()=>click({freq:900,dur:0.04,gain:0.05}),90); }
  $('muteBtn').addEventListener('click',(e)=>{ audio.muted=!audio.muted; e.target.textContent=audio.muted?'üîá':'üîä'; });

  const keys=new Set(); addEventListener('keydown',e=>{ keys.add(e.code); if(e.code==='Space') doShot(); if(e.code==='KeyR') reload(); }); addEventListener('keyup',e=>keys.delete(e.code));

  const joyMove=$('joyMove'), knobMove=joyMove.querySelector('.knob');
  const R=150, K=85, DEAD=0.16;
  const mv={active:false,id:null,vx:0,vz:0, tapStart:0, moved:false};
  function centerOf(el){ const r=el.getBoundingClientRect(); return { cx:r.left + r.width/2, cy:r.top + r.height/2 }; }
  joyMove.addEventListener('touchstart',e=>{ if(mv.active) return; const t=e.changedTouches[0]; mv.active=true; mv.id=t.identifier; mv.tapStart=performance.now(); mv.moved=false; e.preventDefault(); },{passive:false});
    joyMove.addEventListener('touchmove', e=>{ for(const t of e.changedTouches){ if(mv.active&&t.identifier===mv.id){ const {cx,cy}=centerOf(joyMove); let dx=t.clientX-cx, dy=t.clientY-cy; const len=Math.hypot(dx,dy)||1; const nlen=Math.min(len/R,1); mv.moved = mv.moved || (nlen>DEAD*1.2); const nz=nlen<DEAD?0:(nlen-DEAD)/(1-DEAD); const scale = nz/(nlen||1); dx*=scale; dy*=scale; if(nlen>1){ dx/=nlen; dy/=nlen; } knobMove.style.transform=`translate(calc(-50% + ${dx}px),calc(-50% + ${dy}px))`; mv.vx = -dx/K; mv.vz = -dy/K; } } e.preventDefault(); },{passive:false});
  function mvEnd(){ knobMove.style.transform='translate(-50%,-50%)'; const tap=(performance.now()-mv.tapStart)<220 && !mv.moved; mv.active=false; mv.vx=0; mv.vz=0; if(tap) jump(); }
  joyMove.addEventListener('touchend', mvEnd, {passive:false}); joyMove.addEventListener('touchcancel', mvEnd, {passive:false});
  joyMove.addEventListener('pointerdown', (e)=>{ if(mv.active) return; mv.active=true; mv.id=e.pointerId; mv.tapStart=performance.now(); mv.moved=false; const r=joyMove.getBoundingClientRect(); mv.cx=r.left+r.width/2; mv.cy=r.top+r.height/2; try{ joyMove.setPointerCapture(e.pointerId); }catch(_){ } e.preventDefault(); });
    joyMove.addEventListener('pointermove', (e)=>{ if(!mv.active||e.pointerId!==mv.id) return; let dx=e.clientX-mv.cx, dy=e.clientY-mv.cy; const len=Math.hypot(dx,dy)||1; const nlen=Math.min(len/R,1); if(!mv.moved && nlen>DEAD*1.2) mv.moved=true; const nz=nlen<DEAD?0:(nlen-DEAD)/(1-DEAD); const scale=nz/(nlen||1); dx*=scale; dy*=scale; if(nlen>1){ dx/=nlen; dy/=nlen; } knobMove.style.transform=`translate(calc(-50% + ${dx}px),calc(-50% + ${dy}px))`; mv.vx = -dx/K; mv.vz = -dy/K; e.preventDefault(); });
  function mvRelease(e){ if(!mv.active||e.pointerId!==mv.id) return; mvEnd(); try{ joyMove.releasePointerCapture(e.pointerId); }catch(_){ } e.preventDefault(); }
  joyMove.addEventListener('pointerup', mvRelease); joyMove.addEventListener('pointercancel', mvRelease);

  const shootPad=$('shootPad');
  let fireHeld=false;
  function shootDown(){ if(FIRE_MODES.get(currentKey)==='auto'){ fireHeld=true; } else { doShot(); } }
  function shootUp(){ fireHeld=false; }
  shootPad.addEventListener('pointerdown', (e)=>{ if(inputMode!=='A') return; shootDown(); e.preventDefault(); });
  shootPad.addEventListener('pointerup', (e)=>{ if(inputMode!=='A') return; shootUp(); e.preventDefault(); });
  shootPad.addEventListener('pointercancel', (e)=>{ if(inputMode!=='A') return; shootUp(); e.preventDefault(); });
  shootPad.addEventListener('touchstart', (e)=>{ if(inputMode!=='A') return; shootDown(); e.preventDefault(); }, {passive:false});
  shootPad.addEventListener('touchend', (e)=>{ if(inputMode!=='A') return; shootUp(); e.preventDefault(); }, {passive:false});


  const canvasEl=renderer.domElement; canvasEl.style.touchAction='none';
  const look={active:false,id:null,lastX:0,lastY:0};
  let lookAccumX=0, lookAccumY=0; let aimSmoothX=0, aimSmoothY=0;
  const LOOK_SENS_A  = isMobile ? 0.24 : 0.16;
  const AIM_RATE_A   = 1.28;
  const AIM_SMOOTH_A = 7.2;
  function isUIBlock(el){ return el.closest('#joyMove')||el.closest('#shootPad')||el.closest('#armory')||el.closest('#reloadMini')||el.closest('#climbBtn')||el.closest('#radarBox')||el.closest('#zoomBox'); }
  canvasEl.addEventListener('pointerdown',(e)=>{ if(inputMode!=='A') return; if(isUIBlock(e.target)) return; if(look.active) return; look.active=true; look.id=e.pointerId; look.lastX=e.clientX; look.lastY=e.clientY; try{ canvasEl.setPointerCapture(e.pointerId); }catch(_){} e.preventDefault(); });
  canvasEl.addEventListener('pointermove',(e)=>{ if(inputMode!=='A') return; if(!look.active||e.pointerId!==look.id) return; const dx=e.clientX-look.lastX; const dy=e.clientY-look.lastY; look.lastX=e.clientX; look.lastY=e.clientY; lookAccumX += dx; lookAccumY += dy; e.preventDefault(); });
  function lookRelease(e){ if(inputMode!=='A') return; if(!look.active||e.pointerId!==look.id) return; look.active=false; try{ canvasEl.releasePointerCapture(e.pointerId); }catch(_){} e.preventDefault(); }
  canvasEl.addEventListener('pointerup', lookRelease); canvasEl.addEventListener('pointercancel', lookRelease);

  let hp=100; function updateHealth(){ const f=$('healthfill'); f.style.width=Math.max(0,hp)+'%'; f.style.background = hp>60? 'linear-gradient(90deg,#29ff9a,#00c876)': hp>30? 'linear-gradient(90deg,#ffd966,#ff9f1a)' : 'linear-gradient(90deg,#ff6b6b,#ff2e2e)'; }
  updateHealth();

  /* Vehicles (GLTF fleet) */
  const URLS = {
    Sedan: [
      'https://assets.babylonjs.com/meshes/car.glb',
      'https://raw.githubusercontent.com/BabylonJS/Assets/master/meshes/car.glb'
    ],
    CarConcept: [
      'https://cdn.jsdelivr.net/gh/KhronosGroup/glTF-Sample-Assets@main/Models/CarConcept/glTF-Binary/CarConcept.glb',
      'https://raw.githubusercontent.com/KhronosGroup/glTF-Sample-Assets/main/Models/CarConcept/glTF-Binary/CarConcept.glb'
    ],
    MilkTruck: [
      'https://cdn.jsdelivr.net/gh/KhronosGroup/glTF-Sample-Models@master/2.0/CesiumMilkTruck/glTF-Binary/CesiumMilkTruck.glb',
      'https://raw.githubusercontent.com/KhronosGroup/glTF-Sample-Models/master/2.0/CesiumMilkTruck/glTF-Binary/CesiumMilkTruck.glb'
    ],
    FireTruck: [
      'https://raw.githubusercontent.com/Kenney-CCO/Kenney-CCO.glb/main/firetruck.glb',
      'https://cdn.jsdelivr.net/gh/Kenney-CCO/Kenney-CCO.glb@main/firetruck.glb',
      'https://raw.githubusercontent.com/MonuYadav05/Astrikos-gc-project/main/public/FireTruck.glb'
    ]
  };

  function makeLabel(text, scale=1){ const cnv=document.createElement('canvas'); const ctx=cnv.getContext('2d'); const pad=28, fs=64, font=`${fs}px system-ui,Arial`; ctx.font=font; const w=Math.ceil(ctx.measureText(text).width); cnv.width=w+pad*2; cnv.height=fs+pad*2; ctx.font=font; ctx.fillStyle='#111827'; ctx.fillRect(0,0,cnv.width,cnv.height); ctx.strokeStyle='#1f2937'; ctx.lineWidth=4; ctx.strokeRect(2,2,cnv.width-4,cnv.height-4); ctx.fillStyle='#e5e7eb'; ctx.textBaseline='top'; ctx.fillText(text,pad,pad); const tex=new THREE.CanvasTexture(cnv); tex.colorSpace=THREE.SRGBColorSpace; const mat=new THREE.MeshBasicMaterial({ map:tex, transparent:true }); return new THREE.Mesh(new THREE.PlaneGeometry(cnv.width/240*scale, cnv.height/240*scale), mat); }
  function centerXZ(root){ const box=new THREE.Box3().setFromObject(root); const c=new THREE.Vector3(); box.getCenter(c); root.position.x -= c.x; root.position.z -= c.z; }
  function placeOnGround(root,y=0){ const box=new THREE.Box3().setFromObject(root); const dy=y - box.min.y; root.position.y += dy; }
  function scaleToLength(root, L){ const box=new THREE.Box3().setFromObject(root); const size=new THREE.Vector3(); box.getSize(size); const len=Math.max(size.x,size.z)||1; const s=L/len; root.scale.multiplyScalar(s); root.updateMatrixWorld(true); }
  function stripGroundMeshes(root){ const rootBox=new THREE.Box3().setFromObject(root); const rootSize=new THREE.Vector3(); rootBox.getSize(rootSize); const rootArea=rootSize.x*rootSize.z; const rm=[]; root.traverse(o=>{ if(!o.isMesh) return; const b=new THREE.Box3().setFromObject(o); const sz=new THREE.Vector3(); b.getSize(sz); const area=sz.x*sz.z; const flat=sz.y/Math.max(0.0001, Math.max(sz.x,sz.z)); const nearBottom=(b.min.y-rootBox.min.y)<=Math.max(0.05, rootSize.y*0.06); const byName=/ground|plane|cloth|board|shadow|table|grid|floor/i.test(o.name||'')||/shadow/i.test(o.material?.name||''); if(nearBottom && area>=rootArea*0.18 && (flat<0.12 || byName)){ rm.push(o); } }); for(const m of rm){ m.parent?.remove(m);} root.updateMatrixWorld(true); }

  const vehicleCache=new Map();
  async function robustLoad(urls){ for(const u of urls){ try{ const gltf=await gltfLoader.loadAsync(u); return gltf; }catch(_){ } } throw new Error('load fail'); }
  async function getVehicle(key){ if(vehicleCache.has(key)) return vehicleCache.get(key); let urls=[]; if(key==='ambulance'||key==='police') urls=URLS.MilkTruck; else if(key==='fire') urls=URLS.FireTruck; else if(key==='sedan') urls=URLS.Sedan; else urls=URLS.CarConcept; try{ const gltf=await robustLoad(urls); const root=(gltf.scene||gltf.scenes?.[0]); stripGroundMeshes(root); vehicleCache.set(key, root); return root; }catch(_){ const g=new THREE.Mesh(new THREE.BoxGeometry(3.6,1.2,1.6), new THREE.MeshLambertMaterial({ color:0x8892a6 })); const group=new THREE.Group(); g.position.y=0.6; group.add(g); vehicleCache.set(key,group); return group; } }

  function tintVehicle(root,hex){ const col=new THREE.Color(hex); root.traverse(o=>{ if(o.isMesh&&o.material&&o.material.color){ o.material.color.lerp(col,0.9); o.material.needsUpdate=true; } }); }
  function addSideLabels(root,text){ const b=new THREE.Box3().setFromObject(root); const s=new THREE.Vector3(); b.getSize(s); const y=b.min.y+s.y*0.6; const midZ=(b.min.z+b.max.z)/2; const L=makeLabel(text,0.9); const R=makeLabel(text,0.9); L.rotation.y=Math.PI/2; R.rotation.y=-Math.PI/2; L.position.set(b.min.x-0.02,y,midZ); R.position.set(b.max.x+0.02,y,midZ); root.add(L,R); }

  function equipSiren(root, colors=['#ff3b30','#3aa7ff']){
    const box=new THREE.Box3().setFromObject(root);
    const width=box.max.x-box.min.x;
    const bar=new THREE.Mesh(new THREE.BoxGeometry(width*0.42,0.18,0.6), new THREE.MeshBasicMaterial({ color:0x111827 }));
    bar.position.set(0, box.max.y+0.32, 0);
    const mkLamp=(color,offset)=>{ const lamp=new THREE.Mesh(new THREE.SphereGeometry(0.22,12,12), new THREE.MeshBasicMaterial({ color, transparent:true, opacity:0.95 })); lamp.position.set(offset, box.max.y+0.42, 0); return lamp; };
    const left=mkLamp(colors[0], -width*0.22);
    const right=mkLamp(colors[1], width*0.22);
    const rig=new THREE.Group(); rig.add(bar,left,right);
    root.add(rig);
    root.userData.siren={lamps:[left,right], colors, phase:0, active:false};
  }

  const parked=[]; const trafficCars=[];
  const emergencyUnits=[];
  const grenades=[];
  const explosions=[];
  async function spawnParkedEmergency(){
    const hosp=POIS.find(p=>p.type==='hospital'); const pol=POIS.find(p=>p.type==='police'); const fire=POIS.find(p=>p.type==='fire');
    if(hosp){ const v=(await getVehicle('ambulance')).clone(true); centerXZ(v); scaleToLength(v,3.8); placeOnGround(v,0); addSideLabels(v,'AMBULANCE'); tintVehicle(v,'#ef4444'); equipSiren(v); v.position.set(hosp.pos.x,0, hosp.pos.z + hosp.dims.d/2 + 6); v.userData.home=v.position.clone(); scene.add(v); parked.push(v); emergencyUnits.push({mesh:v,type:'ambulance',dispatch:null}); }
    if(pol){ const v=(await getVehicle('police')).clone(true); centerXZ(v); scaleToLength(v,3.8); placeOnGround(v,0); addSideLabels(v,'POLICE'); tintVehicle(v,'#1e3a8a'); equipSiren(v,['#1463ff','#f97316']); v.position.set(pol.pos.x-4,0, pol.pos.z + pol.dims.d/2 + 6); v.userData.home=v.position.clone(); scene.add(v); parked.push(v); emergencyUnits.push({mesh:v,type:'police',dispatch:null}); }
    if(fire){ const v=(await getVehicle('fire')).clone(true); centerXZ(v); scaleToLength(v,4.6); placeOnGround(v,0); addSideLabels(v,'FIRE'); tintVehicle(v,'#dc2626'); equipSiren(v,['#ff2d20','#fffb00']); v.position.set(fire.pos.x+4,0, fire.pos.z + fire.dims.d/2 + 6); v.userData.home=v.position.clone(); scene.add(v); parked.push(v); emergencyUnits.push({mesh:v,type:'fire',dispatch:null}); }
  }

  function setHeading(mesh,angle){ mesh.rotation.y = angle + Math.PI/2; }

  async function spawnParkedCommons(){
    const templates=[await getVehicle('sedan'), await getVehicle('car')];
    const palette=['#64748b','#9ca3af','#475569','#7f5539','#ef8354'];
    const spots=[
      {x:startX+CELL*0.9, z:startZ+CELL*1.3, heading:Math.PI*0.18},
      {x:startX+CELL*1.6, z:startZ+CELL*1.1, heading:-Math.PI*0.22},
      {x:startX+CELL*2.3, z:startZ+CELL*1.8, heading:Math.PI*0.36},
      {x:startX+CELL*3.1, z:startZ+CELL*2.2, heading:-Math.PI*0.48},
      {x:startX+CELL*2.4, z:startZ+CELL*3.1, heading:Math.PI*0.52},
      {x:startX+CELL*4.0, z:startZ+CELL*1.6, heading:-Math.PI*0.12}
    ];
    for(let i=0;i<spots.length;i++){
      const base=(templates[i%templates.length]||templates[0]).clone(true);
      centerXZ(base); scaleToLength(base,3.9); placeOnGround(base,0);
      tintVehicle(base,palette[i%palette.length]);
      setHeading(base, spots[i].heading||0);
      base.position.set(spots[i].x, 0, spots[i].z);
      scene.add(base);
      parked.push(base);
    }
  }

  async function spawnTraffic(n=14){ const pool=[await getVehicle('sedan'), await getVehicle('car')?.catch?.(()=>null) || await getVehicle('sedan')]; for(let i=0;i<n;i++){ const base=pool[i%pool.length]; const v=base.clone(true); centerXZ(v); scaleToLength(v,3.8); placeOnGround(v,0); const hue=Math.random(); tintVehicle(v,new THREE.Color().setHSL(hue,0.4,0.5).getHex()); const a=Math.random()*Math.PI*2; const x=Math.cos(a)*ringR, z=Math.sin(a)*ringR; v.position.set(x,0,z); setHeading(v,a); scene.add(v); trafficCars.push({mesh:v, angle:a, speed:0}); } }

  await spawnParkedEmergency();
  await spawnParkedCommons();
  await spawnTraffic(16);

  const ARM_SPEED_BASE = 4.8; const speedRun = 7.2; const trafficTarget = 3 * speedRun; // 3x run speed

  const rayEnemies=new Map();
  const modelCache=new Map();
  const CHAR_PRESETS={ Soldier:['https://threejs.org/examples/models/gltf/Soldier.glb'], Xbot:['https://threejs.org/examples/models/gltf/Xbot.glb'] };
  async function robustLoadChar(urls){ let last=null; for(const u of urls){ try{ return await gltfLoader.loadAsync(u); }catch(e){ last=e; } } throw last||new Error('Load fail'); }
  function normalizeRoot(root){ const box=new THREE.Box3().setFromObject(root); const size=new THREE.Vector3(); box.getSize(size); const scale=1.7/(size.y||1); root.scale.setScalar(scale); return root; }
  function makeCapsulePlaceholder(){ const g=new THREE.Group(); const body=new THREE.Mesh(new THREE.CapsuleGeometry(0.35,1.0,8,16), new THREE.MeshLambertMaterial({ color:0x556b8a })); g.add(body); return g; }
  async function getCharacter(key){ if(modelCache.has(key)) return modelCache.get(key); try{ const gltf=await robustLoadChar(CHAR_PRESETS[key]||CHAR_PRESETS.Soldier); const baseRoot=(gltf.scene||gltf.scenes?.[0]||null); const root = baseRoot? normalizeRoot(baseRoot) : makeCapsulePlaceholder(); root.traverse?.(o=>{ if(o.isMesh){ o.castShadow=allowShadows; o.receiveShadow=allowShadows; o.material = new THREE.MeshLambertMaterial({ color:0x9fb1c6 }); }}); modelCache.set(key,{root,clips:gltf.animations||[]}); return modelCache.get(key); }catch(_){ const ph=makeCapsulePlaceholder(); modelCache.set(key,{root:ph,clips:[]}); return modelCache.get(key); } }
  const enemies=new Map();
  async function safeCloneSkinned(src){ try{ if(src && SkeletonUtils?.clone){ return SkeletonUtils.clone(src); } if(src?.clone){ return src.clone(true); } }catch(_){ } return makeCapsulePlaceholder(); }
  async function spawnEnemy(x,z,key='Soldier'){ if(enemies.size>=12) return null; const base=await getCharacter(key); const clone=await safeCloneSkinned(base?.root); clone.traverse(o=>{ o.castShadow=allowShadows; }); clone.position.set(x,0,z); clone.userData.enemy=true; scene.add(clone); const r=0.35,h=1.6; const shape=new CANNON.Cylinder(r,r,h,8); const q=new CANNON.Quaternion(); q.setFromEuler(Math.PI/2,0,0); const body=new CANNON.Body({ mass:80, material:matEnemy, linearDamping:0.3, angularDamping:0.9 }); body.fixedRotation=true; body.addShape(shape,new CANNON.Vec3(0,h/2,0),q); body.position.set(x,0.9,z); world.addBody(body); const hpBar=makeBillboardBar(); scene.add(hpBar); enemies.set(clone.uuid,{root:clone, body, hp:120, dead:false, hpBar, cooldown:0}); return clone; }
  function enemyRoots(){ return Array.from(enemies.values()).map(e=>e.root); }
  function enemyTryFire(e, dt){ if(e.dead) return; e.cooldown -= dt; const toP = new THREE.Vector3(player.position.x-e.body.position.x, 0, player.position.z-e.body.position.z); const dist = toP.length(); if(dist>55) return; if(e.cooldown>0) return; const dir = new THREE.Vector3(player.position.x - e.body.position.x, (player.position.y+0.9) - (e.body.position.y+0.9), player.position.z - e.body.position.z).normalize(); dir.x += (Math.random()-0.5)*0.02; dir.y += (Math.random()-0.5)*0.01; dir.z += (Math.random()-0.5)*0.02; dir.normalize(); const origin = new THREE.Vector3(e.body.position.x, e.body.position.y+1.1, e.body.position.z); const to = origin.clone().addScaledVector(dir, 150); tracer(origin,to,0xff8888); e.cooldown = 0.2 + Math.random()*0.6; }

  function makeBillboardBar(){ const c=document.createElement('canvas'); c.width=128; c.height=16; const t=new THREE.CanvasTexture(c); const m=new THREE.SpriteMaterial({ map:t, depthWrite:false }); const s=new THREE.Sprite(m); s.scale.set(0.9, 0.12, 1); s.userData.canvas=c; s.userData.tex=t; updateBillboardBar(s,1); return s; }
  function updateBillboardBar(s,ratio){ const c=s.userData.canvas; const x=c.getContext('2d'); x.clearRect(0,0,c.width,c.height); x.fillStyle='rgba(0,0,0,0.6)'; x.fillRect(0,0,c.width,c.height); x.fillStyle= ratio>0.6? '#29ff9a' : ratio>0.3? '#ffd966':'#ff4d4f'; x.fillRect(2,2,(c.width-4)*Math.max(0,Math.min(1,ratio)), c.height-4); s.userData.tex.needsUpdate=true; }

  function startBR(){ for(let i=0;i<8;i++){ const a=(i/8)*Math.PI*2; const r=ringR*0.6; spawnEnemy(Math.cos(a)*r, Math.sin(a)*r, ['Soldier','Xbot'][i%2]); } }
  startBR();

  let inputMode='A';
  function applyMode(){
    shootPad.style.display='block';
    $('reloadMini').style.display='block';
    updateZoomUI();
  }
  applyMode();

  const zoomSlider=$('zoomSlider');
  function updateZoomUI(){ const box=$('zoomBox'); if(currentKey==='AK47' && inputMode==='A'){ box.style.display='block'; } else { box.style.display='none'; } }
  zoomSlider.addEventListener('input',()=>{ const v=parseFloat(zoomSlider.value||'1'); camera.fov = THREE.MathUtils.clamp(70 / v, 18, 70); camera.updateProjectionMatrix(); });

  let climbing=false, ladderIdx=-1; const climbBtn=$('climbBtn');
  function nearestLadder(){ let best=-1, bd=1e9; for(let i=0;i<ladders.length;i++){ const L=ladders[i]; const dx=player.position.x-L.x; const dz=player.position.z-L.z; const d=Math.hypot(dx,dz); if(d<bd){ bd=d; best=i; } } return {idx:best, dist:bd}; }
  function setClimbUI(){ const n=nearestLadder(); climbBtn.style.display='block'; if(climbing){ climbBtn.disabled=false; climbBtn.textContent='‚¨á Zbrit nga shkalla'; } else if(n.dist<1.5){ climbBtn.disabled=false; climbBtn.textContent='‚¨Ü Ngjitu n√´ shkall√´'; } else { climbBtn.disabled=true; climbBtn.textContent='Pozicionohu te shkalla'; } }
  climbBtn.addEventListener('click', ()=>{ if(climbBtn.disabled) return; if(climbing){ climbing=false; return; } const n=nearestLadder(); if(n.dist<1.5){ climbing=true; ladderIdx=n.idx; const L=ladders[ladderIdx]; player.velocity.x=player.velocity.z=0; player.position.x=L.x; player.position.z=L.z; } });
  function doClimb(moveZ,dt){ const L=ladders[ladderIdx]; if(!L){ climbing=false; return; } const speed=2.6; if(moveZ>0.05) player.position.y = Math.min(L.y1+0.5, player.position.y + speed*dt); else if(moveZ<-0.05) player.position.y = Math.max(L.y0+0.4, player.position.y - speed*dt); if(Math.hypot(player.position.x-L.x, player.position.z-L.z)>0.9){ climbing=false; } }

  const radar=$('radar'), rctx=radar.getContext('2d'); function resizeRadar(){ radar.width=radar.clientWidth; radar.height=radar.clientHeight; } resizeRadar(); addEventListener('resize', resizeRadar);
  function drawRadar(){
    const w=radar.width,h=radar.height;
    rctx.clearRect(0,0,w,h);
    rctx.fillStyle='rgba(20,24,38,0.9)';
    rctx.fillRect(0,0,w,h);
    rctx.strokeStyle='rgba(255,255,255,0.2)';
    rctx.strokeRect(0,0,w,h);
    const cx=w/2, cy=h/2; const sc=0.08;
    rctx.lineWidth=2;
    rctx.strokeStyle='rgba(255,255,255,0.28)';
    for(const road of ROAD_SEGMENTS){
      const x0=cx+(road.from.x-player.position.x)*sc;
      const y0=cy+(road.from.z-player.position.z)*sc;
      const x1=cx+(road.to.x-player.position.x)*sc;
      const y1=cy+(road.to.z-player.position.z)*sc;
      if((x0<-20&&x1<-20)||(x0>w+20&&x1>w+20)||(y0<-20&&y1<-20)||(y0>h+20&&y1>h+20)) continue;
      rctx.beginPath();
      rctx.moveTo(x0,y0);
      rctx.lineTo(x1,y1);
      rctx.stroke();
      const mx=(x0+x1)/2, my=(y0+y1)/2;
      if(road.orientation!=='connector' && mx>12&&mx<w-12&&my>12&&my<h-12){
        rctx.save();
        rctx.translate(mx,my);
        const ang=Math.atan2(y1-y0,x1-x0);
        rctx.rotate(ang);
        rctx.fillStyle='rgba(255,255,255,0.85)';
        rctx.font='10px 600 system-ui';
        rctx.textAlign='center';
        rctx.fillText(road.name,0,-4);
        rctx.restore();
      }
    }
    if(ringRoadData){
      rctx.strokeStyle='rgba(255,255,255,0.2)';
      rctx.lineWidth=1.5;
      const rad=ringRoadData.radius*sc;
      rctx.beginPath();
      rctx.arc(cx,cy,rad,0,Math.PI*2);
      rctx.stroke();
    }
    rctx.fillStyle='#7da2ff';
    rctx.beginPath();
    rctx.arc(cx,cy,3,0,Math.PI*2);
    rctx.fill();
    rctx.font='13px system-ui';
    for(const p of POIS){
      const dx=p.pos.x-player.position.x, dz=p.pos.z-player.position.z;
      const x=cx+dx*sc, y=cy+dz*sc;
      if(x<8||y<8||x>w-8||y>h-8) continue;
      rctx.fillText(p.label,x-8,y-6);
    }
    rctx.fillStyle='rgba(255,255,255,0.9)';
    rctx.font='11px 600 system-ui';
    for(const label of CITY_LABELS){
      const dx=label.pos.x-player.position.x, dz=label.pos.z-player.position.z;
      const x=cx+dx*sc, y=cy+dz*sc;
      if(x<10||y<10||x>w-10||y>h-10) continue;
      rctx.textAlign='center';
      rctx.fillText(label.name,x,y+10);
    }
  }
  const mapOverlay=$('mapOverlay'), mapCanvas=$('mapCanvas'), mctx=mapCanvas.getContext('2d'); function resizeMap(){ mapCanvas.width=mapCanvas.clientWidth; mapCanvas.height=mapCanvas.clientHeight; } resizeMap(); addEventListener('resize', resizeMap);
  function drawMap(){
    const w=mapCanvas.width,h=mapCanvas.height;
    const range=MAP_EXTENT*2;
    const project=(x,z)=>[(x+MAP_EXTENT)/range*w,(z+MAP_EXTENT)/range*h];
    mctx.clearRect(0,0,w,h);
    mctx.fillStyle='#0b1120';
    mctx.fillRect(0,0,w,h);
    mctx.strokeStyle='#283347';
    mctx.lineWidth=1.2;
    for(const road of ROAD_SEGMENTS){
      const [x0,y0]=project(road.from.x, road.from.z);
      const [x1,y1]=project(road.to.x, road.to.z);
      mctx.lineWidth=Math.max(1.2, road.width/range*w);
      mctx.beginPath();
      mctx.moveTo(x0,y0);
      mctx.lineTo(x1,y1);
      mctx.stroke();
      if(road.orientation!=='connector'){
        const mx=(x0+x1)/2, my=(y0+y1)/2;
        mctx.save();
        mctx.translate(mx,my);
        const ang=Math.atan2(y1-y0,x1-x0);
        mctx.rotate(ang);
        mctx.fillStyle='rgba(255,255,255,0.7)';
        mctx.font='14px 600 system-ui';
        mctx.textAlign='center';
        mctx.fillText(road.name,0,-6);
        mctx.restore();
      }
    }
    if(ringRoadData){
      const center=project(0,0);
      const radius=ringRoadData.radius/range*w;
      mctx.lineWidth=ringRoadData.width/range*w;
      mctx.strokeStyle='#3d4b5f';
      mctx.beginPath();
      mctx.arc(center[0],center[1],radius,0,Math.PI*2);
      mctx.stroke();
      mctx.lineWidth=1.4;
      mctx.strokeStyle='rgba(255,255,255,0.35)';
      mctx.beginPath();
      mctx.arc(center[0],center[1],radius-ringRoadData.width*0.15/range*w,0,Math.PI*2);
      mctx.stroke();
    }
    mctx.save();
    mctx.fillStyle='rgba(255,255,255,0.08)';
    for(const p of POIS){
      if(!p.dims) continue;
      const halfW=p.dims.w/2, halfD=p.dims.d/2;
      const [x0,y0]=project(p.pos.x-halfW,p.pos.z-halfD);
      const [x1,y1]=project(p.pos.x+halfW,p.pos.z+halfD);
      const wRect=x1-x0, hRect=y1-y0;
      mctx.fillRect(x0,y0,wRect,hRect);
    }
    mctx.restore();
    mctx.font='24px system-ui';
    mctx.textAlign='center';
    mctx.textBaseline='middle';
    mctx.fillStyle='#f4f5f7';
    for(const p of POIS){
      const [x,y]=project(p.pos.x,p.pos.z);
      mctx.fillText(p.label,x-10,y-10);
    }
    mctx.font='16px 600 system-ui';
    mctx.textBaseline='top';
    mctx.fillStyle='#e0e5ef';
    for(const label of CITY_LABELS){
      const [x,y]=project(label.pos.x,label.pos.z);
      mctx.textAlign='center';
      mctx.fillText(label.name,x,y+18);
    }
    const [px,py]=project(player.position.x,player.position.z);
    mctx.fillStyle='#7da2ff';
    mctx.beginPath();
    mctx.arc(px,py,6,0,Math.PI*2);
    mctx.fill();
  }
  $('radarBox').addEventListener('click', ()=>{ mapOverlay.style.display='flex'; requestAnimationFrame(()=>{ resizeMap(); drawMap(); }); });
  $('mapClose').addEventListener('click', ()=>{ mapOverlay.style.display='none'; });

  let waypoint=null;
  mapCanvas.addEventListener('click', (e)=>{ const r=mapCanvas.getBoundingClientRect(); const x=e.clientX-r.left, y=e.clientY-r.top; const ux=x/mapCanvas.width, uz=y/mapCanvas.height; const wx = -MAP_EXTENT + ux*(MAP_EXTENT*2); const wz = -MAP_EXTENT + uz*(MAP_EXTENT*2); waypoint=new THREE.Vector3(wx,0,wz); mapOverlay.style.display='none'; announceNavigation(wx,wz); });

  let last=performance.now(); let frameCount=0,fpsTimer=0; let fireCd=0; const mini=$('mini');
  let miniMsgTimer=0, miniMessage=''; let fpsDisplay='fps: 0';
  function setMiniMessage(msg,duration=4){ miniMessage=msg; miniMsgTimer=duration; }
  function announceNavigation(wx,wz){ const target=new THREE.Vector3(wx,0,wz); let closestRoad=null, roadDist=Infinity; for(const road of ROAD_SEGMENTS){ const mid=new THREE.Vector3((road.from.x+road.to.x)/2,0,(road.from.z+road.to.z)/2); const d=mid.distanceTo(target); if(d<roadDist){ roadDist=d; closestRoad=road; } } let closestLabel=null, labelDist=Infinity; for(const label of CITY_LABELS){ const d=label.pos.distanceTo(target); if(d<labelDist){ labelDist=d; closestLabel=label; } } const roadName=closestRoad?.name||'rruga kryesore'; const msg=closestLabel?`Navigim drejt ${closestLabel.name} ‚Ä¢ ${roadName}`:`Navigim p√´rgjat√´ ${roadName}`; setMiniMessage(msg,6); }
  updateAmmoHUD();
  function loop(now){
    const dt=Math.min((now-last)/1000,0.05); last=now;
    frameCount++; fpsTimer+=dt; if(fpsTimer>=0.5){ const fps=(frameCount/fpsTimer)|0; fpsDisplay='fps: '+fps; if(fps<88 && dprScale>DPR_MIN){ dprScale=Math.max(DPR_MIN,dprScale-0.05); fit(); } else if(fps>120 && dprScale<DPR_MAX_SCALE){ dprScale=Math.min(DPR_MAX_SCALE,dprScale+0.04); fit(); } frameCount=0; fpsTimer=0; }
    if(miniMsgTimer>0){ miniMsgTimer=Math.max(0, miniMsgTimer-dt); mini.textContent=miniMessage; } else { mini.textContent=fpsDisplay; }

    if(inputMode==='A'){ const k = Math.min(1, dt*AIM_SMOOTH_A); const ax = lookAccumX * LOOK_SENS_A; const ay = lookAccumY * LOOK_SENS_A; lookAccumX=0; lookAccumY=0; aimSmoothX += (ax - aimSmoothX)*k; aimSmoothY += (ay - aimSmoothY)*k; yaw   -= aimSmoothX * AIM_RATE_A * dt; pitch -= aimSmoothY * AIM_RATE_A * dt; clampPitch(); }

    const {from,to}=fireRay(new THREE.Vector2(0,0));
    const hitsEnemy = raycaster.intersectObjects(enemyRoots(), true);
    const onEnemy = hitsEnemy.length>0;
    crosshairEl.style.setProperty('--aimColor', onEnemy? '#2fe56b' : '#ff3c3c');
    aimDotMat.color.set(onEnemy? 0x2fe56b : 0xff3c3c);

    const move={x:0,z:0}; if(keys.has('KeyW')) move.z+=1; if(keys.has('KeyS')) move.z-=1; if(keys.has('KeyA')) move.x-=1; if(keys.has('KeyD')) move.x+=1; move.x += mv.vx; move.z += mv.vz; let l=Math.hypot(move.x,move.z); if(l>1){ move.x/=l; move.z/=l; }
    const speedBase = ARM_SPEED_BASE; const speedRun = 7.2;
    if(!climbing){ const forward=new THREE.Vector3(Math.sin(yaw),0,Math.cos(yaw)); const right=new THREE.Vector3(Math.cos(yaw),0,-Math.sin(yaw)); const sprint = (l>0.9 ? speedRun : speedBase); const vx=forward.x*move.z + right.x*move.x; const vz=forward.z*move.z + right.z*move.x; player.velocity.x=vx*sprint; player.velocity.z=vz*sprint; player.wakeUp(); camFollow(player.position,1.0); } else { player.velocity.x=player.velocity.z=0; doClimb(move.z, dt); camFollow(player.position,1.0); }

    setClimbUI();

    if(fireHeld){ const per=60.0/(currentStats.rpm); fireCd-=dt; while(fireCd<=0){ doShot(); fireCd+=per; } }

    enemies.forEach((e)=>{ if(e.dead) return; const toP = new THREE.Vector3(player.position.x-e.body.position.x, 0, player.position.z-e.body.position.z); const d = toP.length(); if(d>0.01){ toP.normalize(); const sp=d>12?2.4:1.6; e.body.velocity.x = toP.x*sp; e.body.velocity.z = toP.z*sp; } enemyTryFire(e, dt); e.root.position.set(e.body.position.x, 0, e.body.position.z); e.hpBar.position.set(e.body.position.x, 2.2, e.body.position.z); e.hpBar.lookAt(camera.position); });

    // traffic move: v = 3x run speed
    for(const c of trafficCars){ if(!c.speed){ c.speed = trafficTarget*(0.8+Math.random()*0.4); } const radPerSec = c.speed / ringR; c.angle = (c.angle + radPerSec*dt)%(Math.PI*2); const nx=Math.cos(c.angle)*ringR, nz=Math.sin(c.angle)*ringR; // obey red
      let blocked=false; for(const tl of trafficLights){ const d=Math.hypot(nx-tl.pos.x, nz-tl.pos.z); if(d<6 && tl.state!=='green'){ blocked=true; break; } }
      if(!blocked){ c.mesh.position.set(nx,0,nz); setHeading(c.mesh, c.angle); }
    }
    trafficLights.forEach(tl=>{ tl.timer+=dt; if(tl.timer>6){ tl.timer=0; tl.state = tl.state==='green'?'yellow': tl.state==='yellow'?'red':'green'; tl.lamps.Lg.material.color.set(tl.state==='green'?0x2ecc71:0x222222); tl.lamps.Ly.material.color.set(tl.state==='yellow'?0xf1c40f:0x222222); tl.lamps.Lr.material.color.set(tl.state==='red'?0xe74c3c:0x222222); } });

    drawRadar();
    if(waypoint){ const guide=new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(player.position.x,0.1,player.position.z), new THREE.Vector3(waypoint.x,0.1,waypoint.z)]); const mat=new THREE.LineDashedMaterial({ color:0x66ccff, dashSize:2, gapSize:1 }); const ln=new THREE.Line(guide,mat); ln.computeLineDistances(); scene.add(ln); setTimeout(()=>{ scene.remove(ln); guide.dispose(); mat.dispose(); }, 120); }

    world.step(1/90, dt, 3);
    updateGrenades(dt);
    updateExplosions(dt);
    updateEmergencyUnits(dt);
    updateTracers(dt);

    try{ renderer.render(scene,camera); }catch(err){ }
  }
  renderer.setAnimationLoop(loop);

  renderer.getContext().canvas.addEventListener('webglcontextlost', (e)=>{ e.preventDefault(); });
  renderer.getContext().canvas.addEventListener('webglcontextrestored', ()=>{ });

  setTimeout(()=>{
    console.assert(!!document.getElementById('shootPad'), 'shootPad exists');
    console.assert(typeof BLOCKS_X==='number' && typeof BLOCKS_Z==='number', 'grid dims defined');
    console.assert(ARMORY.length>=6 && FIRE_MODES.size===ARMORY.length, 'armory + firemodes init');
    console.assert(getComputedStyle(document.getElementById('crosshair')).getPropertyValue('--aimColor').trim()!=='', 'crosshair color var');
    console.assert(typeof GLTFLoader==='function', 'GLTFLoader OK');
  }, 800);
})();
</script>
</body>
</html>
