<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate" />
  <meta http-equiv="Pragma" content="no-cache" />
  <meta http-equiv="Expires" content="0" />
  <title>TonPlaygram – Falling Ball PvP (SFX + Visuals)</title>
  <style>
    :root{ --bg:radial-gradient(1200px 800px at 70% -10%, #1a2450 0%, #0c1020 38%, #0c1020 100%); --panel:#10172a; --ink:#e5e7eb; --muted:#10b981; --accent:#94a3b8; }
    html,body{ height:100%; margin:0; overscroll-behavior:none; }
    body{ background:var(--bg) fixed; background-color:#0c1020; color:var(--ink); font-family:Inter,system-ui,Segoe UI,Roboto,Arial,sans-serif; }
    .app{ position:fixed; inset:0; overflow:hidden; }
    .falling-ball-bg{
      background:
        repeating-linear-gradient(45deg,rgba(255,255,255,0.1)0 2px,transparent 2px 4px),
        radial-gradient(circle at center,#2c3e91 0%,#1e2d64 80%);
      background-size:100px 100px,cover;
      background-position:0 0,center;
      animation:canvasDepthMove 30s linear infinite;
    }
    canvas{ display:block; width:100%; height:100%; position:absolute; top:0; left:0; }
    .hudTop{ position:absolute; inset-inline:0; top:0; padding:4px 10px; display:flex; flex-wrap:wrap; gap:8px; align-items:center; justify-content:space-between; font-size:12px; color:#fff; }
    .row{ display:flex; gap:8px; align-items:center; flex-wrap:wrap; }
    .chip{ padding:6px 10px; border-radius:12px; border:1px solid rgba(255,255,255,.15); color:#fff; background:transparent; cursor:pointer; }
    .chip.active{ border-color:#7dd3fc; }
      .btn{ appearance:none; border:1px solid #00f7ff; background:rgba(0,0,0,.3); color:#00f7ff; padding:10px 14px; border-radius:14px; font-weight:600; font-size:14px; cursor:pointer; }
      .btn.primary{ background:#00f7ff; color:#fff; border:none; box-shadow:0 0 8px rgba(0,247,255,.5); }
      .btn.primary:hover{ background:#66fcff; }
    .btn:disabled{ opacity:.5; }
    #startBtn{ position:relative; z-index:100; }
    .panel{ position:absolute; left:10px; bottom:10px; right:10px; background:linear-gradient(180deg,#0f1530,#0a0f24); border:1px solid #223063; border-radius:16px; padding:10px; z-index:10; }
    .grid{ display:grid; grid-template-columns:repeat(var(--cols,5),minmax(0,1fr)); gap:6px; }
    .slot{ text-align:center; font-size:12px; color:#fff; padding:6px 0; border-radius:10px; border:1px dashed rgba(255,255,255,.12); display:flex; flex-direction:column; align-items:center; gap:4px; background:rgba(16,23,42,0.85); }
    .slot.me{ border-color:#7dd3fc; color:#c7f3ff; }
    .slot img{ width:var(--avatar-size,24px); height:var(--avatar-size,24px); border-radius:50%; }
    .slot.winner img{ outline:2px solid #facc15; box-shadow:0 0 6px #facc15; }
    .coin-confetti{ position:fixed; top:-40px; width:32px; height:32px; pointer-events:none; animation:coin-fall var(--duration,3s) linear forwards; }
    @keyframes coin-fall{ from{ transform:translateY(-10vh) rotate(0deg); opacity:1; } to{ transform:translateY(100vh) rotate(360deg); opacity:0; } }
    .status{ position:absolute; left:10px; top:48px; background:rgba(0,0,0,.35); padding:8px 10px; border-radius:12px; border:1px solid rgba(255,255,255,.08); color:#fff; font-size:12px; max-width:min(92vw,560px); }
    .sep{ opacity:.3; }
      .popup{ position:absolute; inset:0; background:rgba(0,0,0,.7); display:flex; align-items:center; justify-content:center; }
      .popup.hidden{ display:none; }
      .popup .box{ background:linear-gradient(180deg,#0f1530,#0a0f24); background-color:#0b1a2f; border:1px solid #00f7ff; box-shadow:0 0 8px #00f7ff, inset 0 0 10px rgba(0,247,255,.4); padding:20px; border-radius:12px; text-align:center; color:#00f7ff; }
    .countdown{ position:fixed; inset:0; display:flex; align-items:center; justify-content:center; font-size:48px; font-weight:bold; color:#fff; background:rgba(0,0,0,0.5); z-index:50; }
    .countdown.hidden{ display:none; }
  
    @keyframes canvasDepthMove{from{background-position:0 0,center}to{background-position:100px 100px,center}}
  </style>
</head>
<body>
  <div class="app">
    <div class="hudTop">
      <div class="row">
        <span>SFX:</span>
        <button class="chip active" id="sfxToggle">On</button>
      </div>
    </div>

    <button class="btn primary" id="startBtn">START</button>

    <div class="status" id="statusBox">Obstacles regenerate randomly after each game. Density fixed to high. SFX On/Off.</div>

    <div class="panel">
      <div style="display:flex; justify-content:flex-end; align-items:center; gap:8px; margin-bottom:6px; font-size:12px; color:#fff;">
        <div>Winner: <b id="winnerVal">—</b></div>
      </div>
      <div class="grid" id="slots"></div>
      <div style="margin-top:6px; font-size:12px; color:#fff;">Pot: <b id="potVal">0</b> TPC (-10% dev fee at end)</div>
    </div>

    <canvas id="scene" class="falling-ball-bg"></canvas>
    <div id="winnerPopup" class="popup hidden">
      <div class="box">
        <div id="winnerText" style="margin-bottom:10px;"></div>
        <button class="btn primary" id="lobbyBtn">Return Lobby</button>
      </div>
    </div>
    <div id="countdown" class="countdown hidden"></div>
  </div>

  <script src="/flag-emojis.js"></script>
  <script src="/falling-ball-api.js"></script>
  <script>
  // ========================= Canvas & Brand =========================
  const canvas = document.getElementById('scene');
  const ctx = canvas.getContext('2d');
  ctx.imageSmoothingEnabled = true;
  ctx.imageSmoothingQuality = 'high';
  let W=innerWidth, H=innerHeight;
  function resizeCanvas(){
    const panel = document.querySelector('.panel');
    const panelH = panel ? panel.offsetHeight + 20 : 0;
    W = innerWidth;
    H = innerHeight - panelH;
    const dpr = window.devicePixelRatio || 1;
    canvas.style.width = W + 'px';
    canvas.style.height = H + 'px';
    canvas.width = W * dpr;
    canvas.height = H * dpr;
    ctx.setTransform(dpr,0,0,dpr,0,0);
  }
  resizeCanvas();
  addEventListener('resize', ()=>{ resizeCanvas(); genPegField(); carveCorridors(); addStars(); });

  // ========================= Audio (Web Audio, no binaries) =========================
  let audioCtx = null; let sfxOn = true;
  function ensureAudio(){ if(!audioCtx){ try{ audioCtx = new (window.AudioContext||window.webkitAudioContext)(); }catch(e){} } }
  function playTone(f=440, t=0.06, type='sine', gain=0.04){ if(!sfxOn) return; ensureAudio(); if(!audioCtx) return; const o=audioCtx.createOscillator(); const g=audioCtx.createGain(); o.type=type; o.frequency.setValueAtTime(f, audioCtx.currentTime); g.gain.value=gain; o.connect(g).connect(audioCtx.destination); o.start(); o.stop(audioCtx.currentTime+t); }
  const SFX = { bounce(){ playTone(520+Math.random()*120, 0.05, 'triangle', 0.05); }, spinner(){ playTone(740,0.08,'square',0.04); }, win(){ playTone(660,0.12,'sine',0.06); setTimeout(()=>playTone(880,0.18,'sine',0.06), 90); } };

  function coinConfetti(count=50, iconSrc='/assets/icons/ezgif-54c96d8a9b9236.webp'){
    const container=document.createElement('div');
    container.style.position='fixed';
    container.style.top='0';
    container.style.left='0';
    container.style.width='100%';
    container.style.height='0';
    container.style.pointerEvents='none';
    container.style.zIndex='60';
    container.style.overflow='visible';
    document.body.appendChild(container);
    for(let i=0;i<count;i++){
      const img=document.createElement('img');
      img.src=iconSrc;
      img.alt='confetti icon';
      img.className='coin-confetti';
      const left=Math.random()*100;
      const delay=Math.random()*0.2;
      const duration=2+Math.random()*2;
      img.style.left=left+'vw';
      img.style.animationDelay=delay+'s';
      img.style.setProperty('--duration',duration+'s');
      container.appendChild(img);
    }
    setTimeout(()=>container.remove(),5000);
  }

  const sfxToggleBtn = document.getElementById('sfxToggle');
  sfxToggleBtn.onclick = (e)=>{
    sfxOn = !sfxOn;
    e.currentTarget.classList.toggle('active', sfxOn);
    e.currentTarget.textContent = sfxOn ? 'On' : 'Off';
    ensureAudio();
  };

  // ========================= State =========================
  const state={
    mode:'local',
    players:5,
    stake:100,
    pot:0,
    started:false,
    resultSlot:null,
    slots:[],
    obstacles:[], // {x,y,r,type,angle,spin}
    density:'High', // Low|Med|High
    shared:false,
    ballValues:[],
    ballValuesMax:0,
    balls:[],
    ball:{ x:0, y:0, vx:0, vy:0, r:12, value:0, color:'#facc15', stuckCounter:0, stuckBox:null },
    gravity:0.58,
    bounce:0.78,
    fric:0.003,
    time:0,
    elapsed:0,
    maxVy:22,
  };
  const DEFAULT_AVATAR='/assets/icons/9f14924f-e70c-4728-a9e5-ca25ef4138c8.png';

  const params = new URLSearchParams(location.search);
  const p = Number(params.get('players'));
  if (p >= 2 && p <= 10) state.players = p;
  const m = params.get('mode');
  if (m === 'local' || m === 'online') state.mode = m;
  state.shared = params.get('shared') === '1';
  const amt = Number(params.get('amount'));
  if (amt > 0) state.stake = amt;
  let myAccountId = params.get('accountId');
  if (!myAccountId) {
    try { myAccountId = localStorage.getItem('accountId'); } catch {}
  }
  if (!myAccountId) {
    myAccountId = crypto.randomUUID();
    try { localStorage.setItem('accountId', myAccountId); } catch {}
  }
  const devAccountId = params.get('dev');
  const devAccountId1 = params.get('dev1');
  const devAccountId2 = params.get('dev2');
  const initParam = params.get('init');
  if (initParam && !window.Telegram) {
    window.Telegram = { WebApp: { initData: decodeURIComponent(initParam) } };
  }
  const myTelegramId = params.get('tgId') || window?.Telegram?.WebApp?.initDataUnsafe?.user?.id;
  const accountsParam = params.get('accounts');
  const tgIdsParam = params.get('tgIds');

  async function awardDevShare(total){
    const ops=[];
    if(devAccountId1||devAccountId2){
      if(devAccountId) ops.push(fbApi.depositAccount(devAccountId, Math.round(total*0.09), {game:'fallingball-dev'}));
      if(devAccountId1) ops.push(fbApi.depositAccount(devAccountId1, Math.round(total*0.01), {game:'fallingball-dev1'}));
      if(devAccountId2) ops.push(fbApi.depositAccount(devAccountId2, Math.round(total*0.02), {game:'fallingball-dev2'}));
    }else if(devAccountId){
      ops.push(fbApi.depositAccount(devAccountId, Math.round(total*0.1), {game:'fallingball-dev'}));
    }
    if(ops.length){ try{ await Promise.all(ops); }catch{} }
  }

  async function finalizeSharedPayouts(){
    const ops=[];
    for(const s of state.slots){
      const win=s.win||0;
      if(win>0 && s.accountId){
        ops.push(fbApi.depositAccount(s.accountId, win, { game: 'fallingball-win' }));
        if(s.telegramId) ops.push(fbApi.addTransaction(s.telegramId, 0, 'win', { game: 'fallingball', players: state.players, accountId: s.accountId }));
      }
    }
    if(ops.length){ try{ await Promise.all(ops); }catch{} }
  }
  // ========================= HUD =========================
  const startBtn = document.getElementById('startBtn');
  startBtn.onclick = startMatch;
  function setStatus(t){ document.getElementById('statusBox').textContent=t; }
  function showWinnerPopup(name){ document.getElementById('winnerText').textContent = `${name} wins!`; document.getElementById('winnerPopup').classList.remove('hidden'); }
  function showResultsPopup(){
    const lines = state.slots
      .filter(s => (s.win||0) > 0)
      .sort((a,b)=> (b.win||0)-(a.win||0))
      .map(s => `${s.name}: ${s.win||0} TPC`)
      .join('<br/>');
    document.getElementById('winnerText').innerHTML = lines || 'No winnings';
    document.getElementById('winnerPopup').classList.remove('hidden');
  }
  document.getElementById('lobbyBtn').onclick=()=>{ location.href='/games/fallingball/lobby'; };

  function emojiToDataUrl(emoji){ const svg = `<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 120 120'><text y='96' font-size='96'>${emoji}</text></svg>`; return `data:image/svg+xml,${encodeURIComponent(svg)}`; }
  const regionNames = typeof Intl!=='undefined' ? new Intl.DisplayNames(['en'],{type:'region'}) : null;
  function flagName(flag){ try{ const code=[...flag].map(c=>String.fromCharCode(c.codePointAt(0)-127397)).join(''); return regionNames?.of(code)||code; }catch{return 'AI';} }
  function buildPlayers(){
    const list=[]; const avatarsParam=params.get('avatars'); const namesParam=params.get('names');
    const profileAvatar = (()=>{ try{ return localStorage.getItem('profilePhoto'); }catch{return null;} })();
    const accounts = accountsParam ? accountsParam.split(',') : [];
    const tgIds = tgIdsParam ? tgIdsParam.split(',') : [];
    if(state.mode==='online' && avatarsParam && namesParam){
      const names=namesParam.split(',').map(decodeURIComponent);
      const avatars=avatarsParam.split(',').map(decodeURIComponent);
      for(let i=0;i<state.players;i++){ const avatar=(i===0 && profileAvatar)?profileAvatar:(avatars[i]||DEFAULT_AVATAR); const account=accounts[i] || (i===0?myAccountId:null); const tg=tgIds[i] || (i===0?myTelegramId:null); list.push({ name:names[i]||`P${i+1}`, avatar, isMe:i===0, accountId:account, telegramId:tg }); }
    } else {
      const avatarUrl=profileAvatar || params.get('avatar');
      list.push({ name:'You', avatar:avatarUrl||DEFAULT_AVATAR, isMe:true, accountId:myAccountId, telegramId:myTelegramId });
      for(let i=1;i<state.players;i++){ const flag=FLAG_EMOJIS[Math.floor(Math.random()*FLAG_EMOJIS.length)]; const account=accounts[i]; const tg=tgIds[i]; list.push({ name:flagName(flag), avatar:emojiToDataUrl(flag), accountId:account, telegramId:tg }); }
    }
    for(let i=list.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [list[i],list[j]]=[list[j],list[i]]; }
    return list;
  }
  function refreshSlots(){
    const wrap=document.getElementById('slots'); wrap.innerHTML=''; state.slots=[];
    wrap.style.setProperty('--cols', state.players);
    const basePlayers = Math.max(state.players, 5);
    const avatarSize = Math.max(16, Math.floor((W-40)/basePlayers*0.6));
    wrap.style.setProperty('--avatar-size', avatarSize+'px');
    const players=buildPlayers();
    players.forEach((p,i)=>{ const el=document.createElement('div'); el.className='slot'+(p.isMe?' me':''); el.style.fontSize=state.players>5?'10px':'12px'; el.innerHTML=`<img src="${p.avatar}" alt="avatar" onerror="this.onerror=null;this.src='${DEFAULT_AVATAR}'"/><div>${p.name}</div>`; wrap.appendChild(el); state.slots.push({ idx:i, name:p.name, el, left:0, right:0, isMe:p.isMe, accountId:p.accountId, telegramId:p.telegramId }); });
    resizeCanvas();
  }


  state.pot = state.players * state.stake;
  document.getElementById('potVal').textContent = state.shared ? Math.round(state.pot*0.9) : state.pot;

  // ========================= Obstacles =========================
  function randomBetween(a,b){ return a + Math.random()*(b-a); }
  function genPegField(){
    const pegs=[]; const ballDia = state.ball.r*2; const clearance = ballDia*1.5; // ensure gaps exceed ball diameter
    const usableTop = 110, usableBottom = H-80; const pad=30; const margin = state.ball.r;
    const target = Math.round(((state.density==='Low') ? 120 : (state.density==='Med') ? 180 : 240)*1.15);
    const maxAttempts = target*25;
    let attempts=0;
    while (pegs.length<target && attempts++ < maxAttempts){
      const r = randomBetween(6, 8);
      const x = randomBetween(pad+r+margin, W-pad-r-margin);
      const y = randomBetween(usableTop+r+margin, usableBottom-r-margin);
      const cand = { x, y, r, type:'peg' };
      let ok=true;
      for(const p of pegs){ const minCenter = p.r + cand.r + clearance; const dx=cand.x-p.x, dy=cand.y-p.y; if (dx*dx+dy*dy < minCenter*minCenter){ ok=false; break; } }
      if (ok) pegs.push(cand);
    }
    const extra = Math.round(target*0.15); let tries=0;
    while(pegs.length < target+extra && tries++ < extra*25){
      const r = randomBetween(6,8);
      const x = randomBetween(pad+r+margin, W-pad-r-margin);
      const y = randomBetween(usableBottom-120+r+margin, usableBottom-r-margin);
      const cand = { x, y, r, type:'peg' };
      let ok=true;
      for(const p of pegs){ const minCenter = p.r + cand.r + clearance; const dx=cand.x-p.x, dy=cand.y-p.y; if (dx*dx+dy*dy < minCenter*minCenter){ ok=false; break; } }
      if (ok) pegs.push(cand);
    }
    state.obstacles = pegs; // regenerated every game
  }

  function carveCorridors(){
    if (!state.obstacles.length) return;
    const ballDia = state.ball.r*2; const pad=30; const usableW=W-2*pad; const slotW = usableW / state.players;
    const corridorWidth = Math.max(ballDia + 12, slotW*0.4);
    const corridors = []; for(let i=0;i<state.players;i++){ const cx = pad + slotW*(i+0.5); corridors.push({ left: cx - corridorWidth*0.5, right: cx + corridorWidth*0.5 }); }
    const cutY = H*0.75;
    state.obstacles = state.obstacles.filter(o=>{ if (o.y < cutY) return true; for(const c of corridors){ if (o.x>c.left && o.x<c.right) return false; } return true; });
  }

  function addStars(){
    const starCount = Math.min(Math.floor(Math.random()*4)+5, state.obstacles.length); // 5-8 stars
    const indices = [...Array(state.obstacles.length).keys()];
    const colorPairs=[
      ['#fff9c4','#facc15'],
      ['#bfdbfe','#3b82f6'],
      ['#fecdd3','#f43f5e'],
      ['#ddd6fe','#8b5cf6'],
      ['#bbf7d0','#16a34a'],
      ['#fde68a','#f59e0b'],
      ['#fbcfe8','#ec4899'],
      ['#bae6fd','#0ea5e9'],
    ];
    const clearance = state.ball.r*2; // ensure space around stars
    const wallPad = 10 + state.ball.r;
    let attempts = 0; const stars=[];
    while(stars.length < starCount && attempts++ < starCount*20 && indices.length){
      const idx = indices.splice(Math.floor(Math.random()*indices.length),1)[0];
      const base = state.obstacles[idx];
      const sizeMult = randomBetween(1.1,2);
      const drawMult = randomBetween(1.1,1.5);
      const r = state.ball.r*sizeMult;
      if(base.x - r < wallPad || base.x + r > W - wallPad) continue; // too close to side walls
      let ok=true;
      for(const o of state.obstacles){
        if(o===base) continue;
        const minCenter = r + o.r + clearance;
        const dx = base.x - o.x, dy = base.y - o.y;
        if(dx*dx + dy*dy < minCenter*minCenter){ ok=false; break; }
      }
      if(!ok) continue;
      const spin = (Math.random()*0.05+0.03)*(Math.random()<0.5?-1:1);
      const colors = colorPairs[Math.floor(Math.random()*colorPairs.length)];
      state.obstacles[idx] = {
        ...base,
        type:'star',
        r,
        drawR: r*drawMult,
        angle: Math.random()*Math.PI*2,
        spin,
        colors,
      };
      stars.push(idx);
    }
  }

  function resetBall(){ state.ball.x=W*0.5; state.ball.y=60; state.ball.vx=(Math.random()*2-1)*1.8; state.ball.vy=0; state.ball.stuckCounter=0; state.ball.stuckBox={minX:state.ball.x,maxX:state.ball.x,minY:state.ball.y,maxY:state.ball.y}; state.resultSlot=null; state.ball.releaseTime=state.elapsed; }

  function respawnBall(b, now){
    b.x = 20 + Math.random()*(W-40);
    b.y = 60;
    b.vx = (Math.random()*2-1)*1.8;
    b.vy = 0;
    b.stuckCounter = 0;
    b.stuckBox = {minX:b.x,maxX:b.x,minY:b.y,maxY:b.y};
    b.landed = false;
    b.released = true;
    b.releaseTime = now;
    if(!state.shared) state.resultSlot = null;
  }

  const COLORS=['#f87171','#34d399','#60a5fa','#fbbf24','#a78bfa','#f472b6','#38bdf8','#facc15'];
  function generateBallValues(total,count){
    const weights=[]; for(let i=0;i<count;i++) weights.push(Math.random());
    const sum=weights.reduce((a,b)=>a+b,0);
    const values=[];
    let acc=0;
    for(let i=0;i<count;i++){
      const val=Math.round(weights[i]/sum*total);
      values.push(val); acc+=val;
    }
    let diff=total-acc; let idx=0;
    while(diff!==0){
      if(diff>0){ values[idx%count]++; diff--; }
      else if(values[idx%count]>0){ values[idx%count]--; diff++; }
      idx++;
    }
    return values;
  }

  function startMatch(){
    refreshSlots();
    document.getElementById('winnerPopup').classList.add('hidden');
    state.started=true; state.time=0; state.elapsed=0; state.resultSlot=null;
    state.pot=state.players*state.stake;
    document.getElementById('winnerVal').textContent='—';
    if(state.shared){
      state.ballValues=generateBallValues(Math.round(state.pot*0.9),20);
      state.ballValuesMax=Math.max(...state.ballValues);
      state.slots.forEach(s=>s.win=0);
      document.getElementById('potVal').textContent=state.ballValues.reduce((a,b)=>a+b,0);
      const minR=8, maxR=12; const n=state.ballValues.length; state.balls=[];
      for(let i=0;i<n;i++){
        const value=state.ballValues[i];
        const r=minR + (maxR-minR)*(value/state.ballValuesMax);
        const color=COLORS[i % COLORS.length];
        const x=20 + (i/(n-1||1))*(W-40);
        state.balls.push({x,y:60,vx:(Math.random()*2-1)*1.8,vy:0,r,color,value,stuckCounter:0,stuckBox:{minX:x,maxX:x,minY:60,maxY:60},landed:false});
      }
      state.balls.sort((a,b)=>a.value-b.value);
      const batchSize=Math.ceil(state.balls.length/4);
      state.balls.forEach((ball,i)=>{
        const batchIndex=Math.floor(i/batchSize);
        ball.releaseTime=batchIndex*600;
        ball.released=false;
      });
      state.ball.r=Math.max(...state.balls.map(b=>b.r));
    }else{
      document.getElementById('potVal').textContent=state.pot;
      resetBall();
    }
    genPegField(); carveCorridors(); addStars();
    setStatus('Game started! Obstacles regenerate randomly.');
    if(state.mode==='local') startBtn.style.display='none';
  }

  function countdownAndStart(){
    const cd=document.getElementById('countdown');
    let c=3; cd.textContent=c; cd.classList.remove('hidden');
    const timer=setInterval(()=>{
      c--;
      if(c>0){
        cd.textContent=c;
      }else{
        clearInterval(timer);
        cd.classList.add('hidden');
        startMatch();
      }
    },1000);
  }

  // ========================= Physics =========================
  function step(dt){
    if(!state.started) return;
    const groundY = H - 10;
    const balls = state.shared ? state.balls : [state.ball];
    const now = state.elapsed;
    for(const b of balls){
      if(state.shared){
        if(!b.released){
          if(now < b.releaseTime) continue;
          b.released = true;
          b.releaseTime = now;
        }
        if(b.landed) continue;
      }else if(!b.releaseTime){
        b.releaseTime = now;
      }

      if(now - b.releaseTime > 5000 && b.y + b.r < groundY - 5){
        respawnBall(b, now);
      }

      b.vy = Math.min(state.maxVy, b.vy + state.gravity);
      b.vx *= (1 - state.fric);
      b.x += b.vx; b.y += b.vy;

      // walls
      if (b.x - b.r < 10){ b.x = 10 + b.r; b.vx = Math.abs(b.vx)*0.85; SFX.bounce(); }
      if (b.x + b.r > W-10){ b.x = W-10 - b.r; b.vx = -Math.abs(b.vx)*0.85; SFX.bounce(); }
      if (b.y - b.r < 10){ b.y = 10 + b.r; b.vy *= -state.bounce; SFX.bounce(); }

      // obstacles
      for(const o of state.obstacles){
        if(o.type==='star') o.angle += o.spin;
        if (collideCircle(b, o)) {
          SFX.bounce();
        }
      }

      // detect if ball is stuck or jittering in a tiny area
      if (b.y + b.r < groundY - 5){
        if(!b.stuckBox){ b.stuckBox={minX:b.x,maxX:b.x,minY:b.y,maxY:b.y}; }
        b.stuckBox.minX = Math.min(b.stuckBox.minX, b.x);
        b.stuckBox.maxX = Math.max(b.stuckBox.maxX, b.x);
        b.stuckBox.minY = Math.min(b.stuckBox.minY, b.y);
        b.stuckBox.maxY = Math.max(b.stuckBox.maxY, b.y);
        const boxW = b.stuckBox.maxX - b.stuckBox.minX;
        const boxH = b.stuckBox.maxY - b.stuckBox.minY;
        const speed = Math.abs(b.vx)+Math.abs(b.vy);
        const jitter = boxW < 8 && boxH < 8 && speed > 2;
        const frozen = speed < 0.1;
        if(jitter || frozen){
          b.stuckCounter++;
          const limit = jitter ? 120 : 60;
          if(b.stuckCounter > limit){
            respawnBall(b, now);
          }
        }else{
          b.stuckCounter=0;
          b.stuckBox = {minX:b.x,maxX:b.x,minY:b.y,maxY:b.y};
        }
      }else{
        b.stuckCounter=0;
        b.stuckBox = {minX:b.x,maxX:b.x,minY:b.y,maxY:b.y};
      }

      // ground / slots
      if (b.y + b.r >= groundY){
        b.y = groundY - b.r; b.vy *= -state.bounce;
        if (Math.abs(b.vy) < 1.1 && (!state.shared || !b.landed)){
          const idx = pickSlotFromX(b.x);
          if(!state.shared) state.resultSlot = idx;
          const winner = state.slots[idx];
          if(state.shared){
            const winAmt = b.value;
            b.landed = true;
            winner.win = (winner.win||0) + winAmt;
            document.getElementById('winnerVal').textContent = `${winner.name} +${winAmt} TPC`;
            setStatus(`${winner.name} +${winAmt} TPC`);
            SFX.win();
            coinConfetti(20);
            if(state.balls.every(ball=>ball.landed)){
              finalizeSharedPayouts();
              awardDevShare(state.pot);
              setTimeout(()=>showResultsPopup(),2000);
            }
          }else{
            const winAmt = Math.round(state.pot*0.91);
            const fee = state.pot - winAmt;
            document.getElementById('winnerVal').textContent = `${winner.name} +${winAmt} TPC`;
            setStatus(`Winner: ${winner.name}. Payout ${winAmt} TPC (-${fee} dev)`);
            state.slots.forEach(s=>s.el.classList.remove('winner'));
            winner.el.classList.add('winner');
            SFX.win();
            coinConfetti(50);
            if(winner.accountId){
              fbApi.depositAccount(winner.accountId, winAmt, { game: 'fallingball-win' });
              if(winner.telegramId) fbApi.addTransaction(winner.telegramId, 0, 'win', { game: 'fallingball', players: state.players, accountId: winner.accountId });
            }
            awardDevShare(state.pot);
            setTimeout(()=>showWinnerPopup(winner.name),2000);
          }
        }
      }
    }
  }

  function collideCircle(b, o, mult=1){
    const dx=b.x-o.x, dy=b.y-o.y, rr=b.r+(o.r||14);
    if (dx*dx+dy*dy < rr*rr){
      const len=Math.max(0.0001, Math.hypot(dx,dy)); const nx=dx/len, ny=dy/len;
      const overlap = rr - len + 0.2; b.x += nx*overlap; b.y += ny*overlap;
      const vn = b.vx*nx + b.vy*ny; b.vx -= (1+state.bounce*mult)*vn*nx; b.vy -= (1+state.bounce*mult)*vn*ny;
      // very light jitter to avoid sticking (doesn’t close gaps)
      b.vx += (Math.random()*0.3-0.15); b.vy -= (Math.random()*0.2);
      return true;
    }
    return false;
  }

  function segmentCircleHit(x1,y1,x2,y2, cx,cy, r){ const dx=x2-x1, dy=y2-y1; const fx=cx-x1, fy=cy-y1; const t = Math.max(0, Math.min(1, (fx*dx+fy*dy)/(dx*dx+dy*dy||1))); const px=x1+dx*t, py=y1+dy*t; const dd=(cx-px)**2+(cy-py)**2; return dd <= r*r; }
  function pickSlotFromX(x){ const pad=30; const usable=W-2*pad; const w = usable / state.players; const i=Math.max(0, Math.min(state.players-1, Math.floor((x-pad)/w))); return i; }

  // ========================= Render =========================
  function drawObstacles(){
    for(const o of state.obstacles){
      if(o.type==='star'){
        ctx.save();
        ctx.translate(o.x, o.y);
        ctx.rotate(o.angle);
        const grad = ctx.createRadialGradient(0,0,2,0,0,(o.drawR||o.r));
        const c1 = o.colors ? o.colors[0] : '#fff9c4';
        const c2 = o.colors ? o.colors[1] : '#facc15';
        grad.addColorStop(0, c1);
        grad.addColorStop(1, c2);
        ctx.fillStyle = grad;
        ctx.beginPath();
        const r=(o.drawR||o.r), inner=r*0.35;
        for(let i=0;i<4;i++){
          ctx.lineTo(Math.cos(i*Math.PI/2)*r, Math.sin(i*Math.PI/2)*r);
          ctx.lineTo(Math.cos(i*Math.PI/2+Math.PI/4)*inner, Math.sin(i*Math.PI/2+Math.PI/4)*inner);
        }
        ctx.closePath();
        ctx.fill();
        ctx.restore();
      }else{
        const grad = ctx.createRadialGradient(o.x-2,o.y-2,2, o.x,o.y,(o.r||14));
        grad.addColorStop(0,'#ff9999');
        grad.addColorStop(1,'#ff0000');
        ctx.fillStyle = grad;
        ctx.beginPath();
        ctx.arc(o.x, o.y, o.r || 14, 0, Math.PI*2);
        ctx.fill();
      }
    }
  }
  function drawCartoonBubble(ctx,x,y,r,color){
    ctx.beginPath();
    ctx.arc(x,y,r,0,Math.PI*2);
    ctx.fillStyle=color;
    ctx.fill();
    ctx.lineWidth=Math.max(2,r*0.1);
    ctx.strokeStyle='#000';
    ctx.lineJoin='round';
    ctx.lineCap='round';
    ctx.stroke();
    ctx.fillStyle='rgba(255,255,255,0.6)';
    ctx.beginPath();
    ctx.arc(x - r*0.3, y - r*0.3, r*0.25, 0, Math.PI*2);
    ctx.fill();
    ctx.beginPath();
    ctx.arc(x - r*0.45, y - r*0.45, r*0.07, 0, Math.PI*2);
    ctx.fill();
  }
  function drawSlotsGuide(){ const pad=30; const usable=W-2*pad; const w = usable / state.players; const bottom = H-10; const top = bottom-40; for(let i=0;i<state.players;i++){ const x1=pad+i*w; ctx.fillStyle='rgba(0,0,0,0.25)'; ctx.fillRect(x1, top, w-2, bottom-top); if (!state.shared && state.resultSlot===i){ ctx.fillStyle='rgba(250,204,21,0.4)'; ctx.fillRect(x1, top, w-2, bottom-top); ctx.strokeStyle='rgba(250,204,21,0.9)'; ctx.lineWidth=3; ctx.strokeRect(x1+1, top, w-4, bottom-top); } } }
  function drawBalls(){
    const balls = state.shared ? state.balls : [state.ball];
    for(const b of balls){
      if(state.shared && !b.released) continue;
      ctx.fillStyle='rgba(0,0,0,0.28)';
      ctx.beginPath();
      ctx.ellipse(b.x, b.y+b.r+6, b.r*1.2, b.r*0.5, 0,0,Math.PI*2);
      ctx.fill();
      drawCartoonBubble(ctx,b.x,b.y,b.r,b.color);
      if(b.value){
        ctx.fillStyle='#000';
        ctx.font=`${Math.max(8,b.r*0.8)}px sans-serif`;
        ctx.textAlign='center';
        ctx.textBaseline='middle';
        ctx.fillText(b.value, b.x, b.y);
      }
    }
  }

  function frame(ts){ const dt = Math.min(33, ts - state.time); state.time=ts; state.elapsed += dt; step(dt/16.6667); ctx.clearRect(0,0,W,H); drawObstacles(); drawSlotsGuide(); drawBalls(); requestAnimationFrame(frame); }
  requestAnimationFrame(frame);

  // ========================= Init =========================
  function init(){
    refreshSlots();
    genPegField();
    carveCorridors();
    addStars();
    resetBall();
    if(state.mode==='local'){
      startBtn.style.position='fixed';
      startBtn.style.top='75%';
      startBtn.style.left='50%';
      startBtn.style.transform='translate(-50%, -50%)';
    }else if(state.mode==='online'){
      startBtn.style.display='none';
      countdownAndStart();
    }
  }
  init();

  // ========== Smoke Tests ==========
  try{ console.assert(state.players>=2 && state.players<=10, 'players between 2 and 10'); const count = state.obstacles.length; console.assert(count>30, 'obstacles generated'); console.log('%cSFX+Visuals ready','color:#22c55e'); }catch(e){ console.warn('Smoke tests failed', e); }
  </script>
</body>
</html>
