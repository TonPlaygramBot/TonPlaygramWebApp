<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
<meta name="apple-mobile-web-app-capable" content="yes" />
<title>Free Kick Pro ‚Äî Mobile Elite</title>
<style>
  :root{
    --bg:#090f21; --txt:#dbe8ff; --muted:#9fb1df;
    --panel:#0b1225cc; --panel-b:#1c244a; --panel-solid:#0b1225;
    --accent:#2563eb; --accent-2:#22c55e; --warn:#ef4444;
    --turf1:#0c7a23; --turf2:#0a6c1d; --chalk:#ffffff; --goal:#ffffff; --net:#ececec;
    --hole:#e10600; --pts:#ffd400;
  }
  *{box-sizing:border-box}
  html,body{height:100%;margin:0;background:var(--bg);color:var(--txt);
    font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Helvetica,Arial,sans-serif;overflow:hidden}
  #game{position:fixed;inset:0;width:100vw;height:100svh;display:block;touch-action:none;z-index:1;transform:scale(0.95);transform-origin:bottom center}

  /* ===== HUD ===== */
  .hud{position:fixed;left:env(safe-area-inset-left,12px);right:env(safe-area-inset-right,12px);
    z-index:100;display:grid;grid-template-columns:1fr auto 1fr;gap:10px;align-items:center}
  .panel{background:var(--panel);border:1px solid var(--panel-b);backdrop-filter:blur(8px);
    border-radius:14px;padding:8px 12px;display:flex;align-items:center;justify-content:space-between;gap:10px}
  .score{font-weight:900;font-size:20px}
  .meta{font-size:12px;color:var(--muted)}
  .btns{display:flex;gap:8px}
  button{appearance:none;border:0;border-radius:12px;padding:8px 12px;font-weight:800;letter-spacing:.3px;color:#fff;background:var(--accent);
    box-shadow:0 6px 16px rgba(0,0,0,.25)}
  button.ghost{background:#273154}
  button.warn{background:var(--warn)}

  /* ===== Rivals row ===== */
  .previews{position:fixed;left:env(safe-area-inset-left,12px);right:env(safe-area-inset-right,12px);
    top:calc(env(safe-area-inset-top,10px) + 12px);z-index:110;display:grid;grid-template-columns:repeat(3,1fr);gap:8px}
  .pcard{background:var(--panel);border:1px solid var(--panel-b);border-radius:18px;padding:6px;min-height:80px;display:grid;gap:6px}
  .phead{display:flex;align-items:center;justify-content:space-between;font-weight:800;gap:6px}
  .phead .avatar{width:20px;height:14px;border-radius:2px;object-fit:cover}
  .ppts{color:var(--pts);font-weight:900}
  .pcard canvas{display:block;width:100%;height:auto;border-radius:12px}

  /* ===== Player bar ===== */
  .pbar{position:fixed;left:env(safe-area-inset-left,12px);right:env(safe-area-inset-right,12px);
    z-index:95;display:flex;align-items:center;gap:8px;background:var(--panel);
    border:1px solid var(--panel-b);border-radius:16px;padding:10px 12px}
  .avatar{width:28px;height:28px;border-radius:50%;background:linear-gradient(135deg,#22c55e,#2563eb);box-shadow:0 0 0 2px #081027 inset}
  .badge{background:#0f1a3a;border:1px solid var(--panel-b);color:var(--txt);padding:6px 10px;border-radius:12px;font-weight:800;font-size:12px}
  .hearts{color:#ff4d6d;letter-spacing:2px}
  .scoreVal{color:var(--pts);font-size:18px}

  /* ===== Stage label area (visual only) ===== */
  .stage{position:fixed;left:env(safe-area-inset-left,12px);right:env(safe-area-inset-right,12px);
    top:calc(env(safe-area-inset-top,10px) + 70px + 128px + 16px + 56px + 10px);
    bottom:env(safe-area-inset-bottom,72px);z-index:80;pointer-events:none}
  .stage .frame{position:absolute;inset:0;border-radius:18px;border:1px solid var(--panel-b);pointer-events:none}

  /* ===== Bottom ribbon ===== */
  .bottom{position:fixed;left:env(safe-area-inset-left,12px);right:env(safe-area-inset-right,12px);
    bottom:env(safe-area-inset-bottom,10px);z-index:96}
  .ribbon{background:var(--panel);border:1px solid var(--panel-b);border-radius:12px;padding:8px 12px;text-align:center;font-size:14px}

  /* ===== Winner overlay & celebration ===== */
  .winnerOverlay{position:fixed;inset:0;display:flex;align-items:center;justify-content:center;background:rgba(0,0,0,0.6);z-index:200}
  .winnerOverlay.hidden{display:none}
  .winnerOverlay img{width:120px;height:120px;border-radius:50%;display:block;margin:0 auto}
  .winnerOverlay button{margin-top:16px;padding:10px 16px;font-weight:800;border:0;border-radius:12px;background:var(--accent);color:#fff}
  .coin-confetti{position:fixed;top:0;width:48px;height:48px;pointer-events:none;animation:coin-fall var(--duration,3s) linear forwards;z-index:210}
  @keyframes coin-fall{from{transform:translateY(-10vh) rotate(0deg);opacity:1}to{transform:translateY(100vh) rotate(360deg);opacity:0}}

  .bomb-explosion{position:fixed;transform:translate(-50%,-50%) scale(1);font-size:64px;pointer-events:none;z-index:200;animation:bomb-pop 1s forwards}
  @keyframes bomb-pop{to{transform:translate(-50%,-50%) scale(3);opacity:0}}

  /* tests */

  @media (max-width: 420px){
    .hud{grid-template-columns:1fr}
  }
</style>
</head>
<body>
  <div class="previews" id="previews">
    <div class="pcard" id="pv0">
      <div class="phead">
        <div style="display:flex;align-items:center;gap:4px">
          <img id="pv0avatar" class="avatar" alt="" />
          <span id="pv0name"></span>
        </div>
        <div class="ppts" id="pv0pts">0</div>
      </div>
      <canvas width="240" height="120"></canvas>
    </div>
    <div class="pcard" id="pv1">
      <div class="phead">
        <div style="display:flex;align-items:center;gap:4px">
          <img id="pv1avatar" class="avatar" alt="" />
          <span id="pv1name"></span>
        </div>
        <div class="ppts" id="pv1pts">0</div>
      </div>
      <canvas width="240" height="120"></canvas>
    </div>
    <div class="pcard" id="pv2">
      <div class="phead">
        <div style="display:flex;align-items:center;gap:4px">
          <img id="pv2avatar" class="avatar" alt="" />
          <span id="pv2name"></span>
        </div>
        <div class="ppts" id="pv2pts">0</div>
      </div>
      <canvas width="240" height="120"></canvas>
    </div>
  </div>

  <div class="pbar" id="pbar">
    <div style="display:flex;align-items:center;gap:10px"><img class="avatar" id="userAvatar" alt="" /><div id="username">You</div></div>
    <div class="badge hearts">‚ù§‚ù§‚ù§</div>
      <div class="badge">Time <span id="timeShort">17</span>s</div>
    <div class="badge">Score <span id="playerScore" class="scoreVal">0</span></div>
  </div>

  <div class="stage"><div class="frame"></div></div>

  <canvas id="game" aria-label="Free kick field"></canvas>

  <div id="winnerOverlay" class="winnerOverlay hidden">
    <div style="text-align:center">
      <img id="winnerAvatar" alt="winner" />
      <button id="lobbyBtn">Return Home</button>
    </div>
  </div>

<script src="/free-kick-api.js"></script>
<script src="/flag-emojis.js"></script>
<script>
(()=> {
  // ===== Canvas =====
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d', { alpha:true });
  let DPR=1, W=0, H=0;
  const STRIPE = 44;
  function resize(){
    DPR = Math.max(1, Math.min(2.5, window.devicePixelRatio||1));
    W = Math.floor(window.innerWidth); H = Math.floor(window.innerHeight);
    canvas.width = Math.floor(W*DPR); canvas.height = Math.floor(H*DPR);
    ctx.setTransform(DPR,0,0,DPR,0,0);
    positionLayout();
    layout();
    generateMiniHoles();
    initBanners();
    initCameras();
    drawStaticOnce();
  }
  addEventListener('resize', resize);

  // ===== UI refs =====
  const timeShort = document.getElementById('timeShort');
  const playerScoreEl = document.getElementById('playerScore');
  const previewsEl= document.getElementById('previews');
  const userAvatarEl = document.getElementById('userAvatar');
  const usernameEl = document.getElementById('username');
  const pvAvatars = [document.getElementById('pv0avatar'), document.getElementById('pv1avatar'), document.getElementById('pv2avatar')];
  const pvNames   = [document.getElementById('pv0name'), document.getElementById('pv1name'), document.getElementById('pv2name')];

  function positionLayout(){
    const pr = previewsEl.getBoundingClientRect();
    const pbar = document.getElementById('pbar');
    pbar.style.top = (pr.bottom + 8) + 'px';
    document.querySelector('.stage').style.top = (pbar.getBoundingClientRect().bottom + 16) + 'px';
  }

  const params = new URLSearchParams(location.search);
  const tgKey = params.get("tgId") || "anon";
  const STATE_KEY = `freeKickTournamentState_${tgKey}`;
  const OPP_KEY = `freeKickTournamentOpponent_${tgKey}`;
  const stake = Number(params.get("amount") || "0");
  const accountId = params.get("accountId");
  const tgId = params.get("tgId");
  const devAccount = params.get("dev");
  const devAccount1 = params.get("dev1");
  const devAccount2 = params.get("dev2");
  const playType = params.get('type') || 'regular';
  window.tournamentMode = playType === 'tournament';
  window.tournamentPlayers = window.tournamentMode
    ? parseInt(params.get('players') || '0', 10)
    : 0;
  const avatarParam = params.get('avatar') || '';
  let userName = params.get('name') || params.get('username') || '';
  const durationParam = parseInt(params.get('duration')) || 60;
  timeShort.textContent = durationParam;

  let currentRound = 0;
  if(window.tournamentMode){
    try{ const st = JSON.parse(localStorage.getItem(STATE_KEY) || '{}'); currentRound = st.currentRound || 0; }catch{}
  }

  function emojiToDataUri(flag){
    return `data:image/svg+xml,${encodeURIComponent(`<svg xmlns='http://www.w3.org/2000/svg' width='64' height='64'><text x='50%' y='50%' font-size='48' text-anchor='middle' dominant-baseline='central'>${flag}</text></svg>`)}`;
  }
  const regionNames = new Intl.DisplayNames(['en'], { type: 'region' });
  function flagName(flag){
    const pts = [...flag].map(c=>c.codePointAt(0)-127397);
    const code = String.fromCharCode(...pts);
    return regionNames.of(code) || flag;
  }

  if(!userName){
    const userData = window?.Telegram?.WebApp?.initDataUnsafe?.user;
    userName = userData?.username || [userData?.first_name, userData?.last_name].filter(Boolean).join(' ') || 'Player';
  }
  usernameEl.textContent = userName;
  const hudNameEl = document.querySelector('#hud .panel .meta');
  if(hudNameEl) hudNameEl.textContent = userName;

  let userAvatar = avatarParam;
  const initUser = window?.Telegram?.WebApp?.initDataUnsafe?.user;
  if(!userAvatar && initUser?.photo_url){ userAvatar = initUser.photo_url; }
  if(!userAvatar){ userAvatar = 'assets/icons/profile.svg'; }
  else if(!(userAvatar.startsWith('http')||userAvatar.startsWith('/')||userAvatar.startsWith('data:'))){
    userAvatar = emojiToDataUri(userAvatar);
  }
  userAvatarEl.src = userAvatar;

  function shuffle(arr){ for(let i=arr.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [arr[i],arr[j]]=[arr[j],arr[i]]; } }
  const flags = [...(window.FLAG_EMOJIS || [])];
  shuffle(flags);
  if(window.tournamentMode){
    try{
      const opp = JSON.parse(localStorage.getItem(OPP_KEY) || '{}');
      if(pvAvatars[0] && opp.flag) pvAvatars[0].src = emojiToDataUri(opp.flag);
      if(pvNames[0]) pvNames[0].textContent = opp.name || flagName(opp.flag);
    }catch{}
    for(let i=1;i<3;i++){
      const flag = flags[i];
      if(pvAvatars[i]) pvAvatars[i].src = emojiToDataUri(flag);
      if(pvNames[i]) pvNames[i].textContent = flagName(flag);
    }
  } else {
    for(let i=0;i<3;i++){
      const flag = flags[i];
      if(pvAvatars[i]) pvAvatars[i].src = emojiToDataUri(flag);
      if(pvNames[i]) pvNames[i].textContent = flagName(flag);
    }
  }
  positionLayout();

  // ===== Geometry =====
  const geom = { goal:{x:0,y:0,w:0,h:0,post:12}, spot:{x:0,y:0}, penaltySpot:{x:0,y:0}, scale:1, paDepth:0 };
  function layout(){
    const goalScale = 0.85;
    const goalW = Math.min(W*0.92, 950) * 0.97 * goalScale;
    const goalH = Math.min(H*0.28, 260) * 0.92 * goalScale;
    const pbarBottom = document.getElementById('pbar').getBoundingClientRect().bottom;
    geom.goal = { x:(W-goalW)/2, y:pbarBottom + 10, w:goalW, h:goalH, post:12 };
    geom.scale = goalW / 860;
    geom.paDepth = Math.min(320*geom.scale, H*0.34) * goalScale;
    geom.penaltySpot = { x:W/2, y: geom.goal.y + geom.goal.h + geom.paDepth * (11/16.5) + STRIPE*3 };
    // position the ball a bit higher near the bottom edge and move it one stripe up
    geom.spot = { x: W/2, y: H - BALL_R*geom.scale*1.8 - STRIPE };
    keeper.w = 40*geom.scale*4*0.85;
    keeper.h = 100*geom.scale*4*0.85;
    keeper.x = geom.goal.x + (geom.goal.w-keeper.w)/2;
    keeper.y = geom.goal.y + geom.goal.h - keeper.h + geom.goal.h*0.05;
    keeper.baseY = keeper.y;
    keeper.baseX = keeper.x;
    keeper.targetX = keeper.x;
    keeper.targetY = keeper.y;
    defenders.w = keeper.w * 2.8;
    defenders.h = keeper.h * 1.5;
    defenders.x = (W - defenders.w)/2;
    defenders.y = geom.penaltySpot.y + STRIPE/2 - STRIPE*5;
    defenders.baseY = defenders.y;
  }

  // ===== Game state =====
  const ROUND_TIME = durationParam * 1000;
  let roundStart = 0; let timeLeft = ROUND_TIME; let running=false; let paused=false; let ended=false;
  let myScore = 0;

  const BALL_R = 28;
  // slightly faster initial shot for a snappier feel
  const SHOT_SPEED = 24; // previously 22
  const MIN_GOAL_POINTS = 5;
  const ball = {
    x: 0,
    y: 0,
    r: BALL_R,
    vx: 0,
    vy: 0,
    moving: false,
    trail: [],
    spin: 0,
    angle: 0,
    netSounded: false,
    goalSounded: false,
    trailStopped: false,
    target: null,
    prevDist: null,
    points: 0,
    path: null,
    pathIndex: 0,
    pathSpeed: 0,
    exploded: false
  };
  const ballImg = new Image();
  ballImg.src = '/assets/icons/file_0000000061d4620aaf506adfa605e1f3.webp';

  let holes=[]; let banners=[]; let cameras=[]; let looseBalls=[]; let punchEffects=[];
  let prizePieces=[]; let ballPieces=[]; let smokePuffs=[];
  let netHit={x:0,y:0,t:0,shake:0};
  let goalFlash=0;
  let missFlash=0;
  const NET_DECAY = 0.94; // decay factor for net pullback and shake
  const SHOT_RESET_DELAY = 300; // delay before resetting after a shot (ms)
  const keeper={x:0,y:0,w:40,h:100,vx:0,vy:0,a:0,baseY:0,baseX:0,dive:0,jumping:false,dir:1,targetX:0,targetY:0};
  const keeperImg = new Image();
  keeperImg.src = '/assets/icons/file_00000000945461f8bb9a2974fb9ee402.webp';
  const defenders={x:0,y:0,w:40,h:100,baseY:0,vy:0,jumping:false};
  const defendersImg = new Image();
  defendersImg.src = '/assets/icons/file_0000000091b0624395c9e8d8acf66e69.webp';
  const aimOn = true;

  const rivals=[
    {
      i:0,
      wrap:document.querySelector('#pv0'),
      ptsEl:document.querySelector('#pv0pts'),
      cvs:null,
      ctx:null,
      score:0,
      next:0,
      acc:0.68,
      rate:[800,1650],
      shots:[],
      kx:0,
      kw:0,
      kh:0,
      g:null,
      avatar:'',
      flash:0,
      result:'',
      defX:0,
      defY:0,
      defBaseY:0,
      defVy:0,
      defJump:false,
      defW:0,
      scale:1
    },
    {
      i:1,
      wrap:document.querySelector('#pv1'),
      ptsEl:document.querySelector('#pv1pts'),
      cvs:null,
      ctx:null,
      score:0,
      next:0,
      acc:0.62,
      rate:[885,1805],
      shots:[],
      kx:0,
      kw:0,
      kh:0,
      g:null,
      avatar:'',
      flash:0,
      result:'',
      defX:0,
      defY:0,
      defBaseY:0,
      defVy:0,
      defJump:false,
      defW:0,
      scale:1
    },
    {
      i:2,
      wrap:document.querySelector('#pv2'),
      ptsEl:document.querySelector('#pv2pts'),
      cvs:null,
      ctx:null,
      score:0,
      next:0,
      acc:0.58,
      rate:[950,1935],
      shots:[],
      kx:0,
      kw:0,
      kh:0,
      g:null,
      avatar:'',
      flash:0,
      result:'',
      defX:0,
      defY:0,
      defBaseY:0,
      defVy:0,
      defJump:false,
      defW:0,
      scale:1
    },
  ];
  for(let i=0;i<rivals.length;i++){ rivals[i].cvs = rivals[i].wrap.querySelector('canvas'); rivals[i].ctx = rivals[i].cvs.getContext('2d'); rivals[i].avatar = pvAvatars[i]?.src || ''; }
  if(window.tournamentMode && currentRound){
    for(const r of rivals){ r.rate = r.rate.map(t=>Math.max(300, t - currentRound*50)); }
  }
  const miniHolesCache=[[],[],[]];
  const MINI_GOAL_PAD = 8;
  function miniGoalRect(cv){
    const field={x:12,y:12,w:cv.width-24,h:cv.height-32};
    return {x:field.x+MINI_GOAL_PAD,y:field.y+MINI_GOAL_PAD,w:field.w-2*MINI_GOAL_PAD,h:field.h-2*MINI_GOAL_PAD};
  }

  function createTimerHole(goal, scale, existing=[]){
    const minR=Math.max(ball.r*1.05*scale,22*geom.scale*scale);
    const maxR=Math.max(minR+12*scale,60*geom.scale*scale);
    const pad=18*scale; let tries=0;
    while(tries<600){
      tries++;
      const r=rnd(minR,maxR);
      let x;
      // bias timers toward goal sides
      if(Math.random()<0.8){
        const side=Math.random()<0.5?'l':'r';
        const range=goal.w*0.25;
        if(side==='l') x=rnd(goal.x+pad+r,goal.x+pad+range);
        else x=rnd(goal.x+goal.w-pad-range,goal.x+goal.w-pad-r);
      }else{
        x=rnd(goal.x+pad+r,goal.x+goal.w-pad-r);
      }
      const y=rnd(goal.y+pad+r,goal.y+goal.h-pad-r);
      if(existing.every(h=>Math.hypot(h.x-x,h.y-y)>h.r+r+12*scale)){
        const values=[10,15,20];
        const tVal=values[Math.floor(Math.random()*values.length)];
        return {x,y,r,points:0,timer:tVal};
      }
    }
    return null;
  }
  function createBombHole(goal, scale, existing=[]){
    const minR=Math.max(ball.r*1.05*scale,22*geom.scale*scale);
    const maxR=Math.max(minR+12*scale,60*geom.scale*scale);
    const pad=18*scale; let tries=0;
    const keeperCenter=keeper.x+keeper.w/2;
    const goalMid=goal.x+goal.w/2;
    const preferSide=keeperCenter<goalMid?'r':'l';
    while(tries<600){
      tries++;
      const r=rnd(minR,maxR);
      let x;
      // place bombs near sides, mostly opposite goalkeeper
      if(Math.random()<0.9){
        const range=goal.w*0.25;
        if(preferSide==='l') x=rnd(goal.x+pad+r,goal.x+pad+range);
        else x=rnd(goal.x+goal.w-pad-range,goal.x+goal.w-pad-r);
      }else{
        x=rnd(goal.x+pad+r,goal.x+goal.w-pad-r);
      }
      const y=rnd(goal.y+pad+r,goal.y+goal.h-pad-r);
      if(existing.every(h=>Math.hypot(h.x-x,h.y-y)>h.r+r+12*scale)){
        return {x,y,r:r*1.2,points:-50,bomb:true};
      }
    }
    return null;
  }
  function createHoleSet(goal, scale){
    const list=[]; const cnt=6+Math.floor(Math.random()*7);
    const minR=Math.max(ball.r*1.05*scale,22*geom.scale*scale);
    const maxR=Math.max(minR+12*scale,60*geom.scale*scale);
    const pad=18*scale; let tries=0;
    while(list.length<cnt && tries<1600){
      tries++;
      const r=rnd(minR,maxR);
      let x;
      if(Math.random() < 0.6){
        const side = Math.random() < 0.5 ? 'l' : 'r';
        const range = goal.w * 0.2;
        if(side === 'l') x = rnd(goal.x+pad+r, goal.x+pad+range);
        else x = rnd(goal.x+goal.w-pad-range, goal.x+goal.w-pad-r);
      } else {
        x = rnd(goal.x+pad+r,goal.x+goal.w-pad-r);
      }
      const y=rnd(goal.y+pad+r,goal.y+goal.h-pad-r);
      if(list.every(h=>Math.hypot(h.x-x,h.y-y)>h.r+r+12*scale)){
        const points=Math.max(10,Math.round(((maxR/r)*70)/5)*5);
        list.push({x,y,r,points});
      }
    }
    for(let i=0;i<18;i++){ const timer=createTimerHole(goal,scale,list); if(timer) list.push(timer); }
    for(let i=0;i<18;i++){ const bomb=createBombHole(goal,scale,list); if(bomb) list.push(bomb); }
    return list;
  }
  function generateMiniHoles(){
    for(let i=0;i<rivals.length;i++){
      const cv=rivals[i].cvs;
      const goal=miniGoalRect(cv);
      const scale=goal.w/geom.goal.w;
      const set=createHoleSet(goal,scale);
      miniHolesCache[i]=set.map(h=>({x:h.x,y:h.y,r:h.r,p:h.points,t:h.timer||0,b:h.bomb?1:0}));
    }
  }

  // ===== Helpers =====
  const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));
  const rnd=(a,b)=>a+Math.random()*(b-a);
  function roundedRect(x,y,w,h,r){ ctx.beginPath(); ctx.moveTo(x+r,y); ctx.arcTo(x+w,y,x+w,y+h,r); ctx.arcTo(x+w,y+h,x,y+h,r); ctx.arcTo(x,y+h,x,y,r); ctx.arcTo(x,y,x+w,y,r); ctx.closePath(); }

  function coinConfetti(count=50, iconSrc='/assets/icons/ezgif-54c96d8a9b9236.webp'){
    for(let i=0;i<count;i++){
      const img=document.createElement('img');
      img.src=iconSrc;
      img.className='coin-confetti';
      img.style.left=Math.random()*100+'vw';
      img.style.setProperty('--duration',(2+Math.random()*2)+'s');
      document.body.appendChild(img);
      setTimeout(()=>img.remove(),3000);
    }
  }

  function popupText(text,x,y,targetEl,color){
    if(!targetEl) return;
    const rect=canvas.getBoundingClientRect();
    const startX=rect.left + (x/W)*rect.width;
    const startY=rect.top + (y/H)*rect.height;
    const tRect=targetEl.getBoundingClientRect();
    const el=document.createElement('div');
    el.textContent=text;
    el.style.position='fixed';
    el.style.left=startX+'px';
    el.style.top=startY+'px';
    el.style.fontSize='32px';
    el.style.fontWeight='900';
    el.style.color=color;
    el.style.webkitTextStroke='2px #fff';
    el.style.pointerEvents='none';
    el.style.transition='transform 0.8s ease, opacity 0.8s ease';
    el.style.zIndex=150;
    document.body.appendChild(el);
    requestAnimationFrame(()=>{
      const dx=tRect.left + tRect.width/2 - startX;
      const dy=tRect.top + tRect.height/2 - startY;
      el.style.transform=`translate(${dx}px,${dy}px) scale(0.5)`;
      el.style.opacity='0';
    });
    setTimeout(()=>{ el.remove(); },800);
  }

  function reflectBall(nx,ny,damp=0.8){
    const dot = ball.vx*nx + ball.vy*ny;
    ball.vx -= 2*dot*nx;
    ball.vy -= 2*dot*ny;
    ball.vx *= damp;
    ball.vy *= damp;
  }
  function ballHitsKeeper(){
    const k=keeper;
    const left=k.x, right=k.x+k.w;
    const top=k.y + k.dive, bottom=k.y + k.h + k.dive;
    if(ball.x+ball.r<left || ball.x-ball.r>right || ball.y+ball.r<top || ball.y-ball.r>bottom) return null;
    const centerX = k.x + k.w/2;
    const center = Math.abs(ball.x-centerX) < k.w*0.2;
    const nx = ball.x < centerX ? -0.6 : 0.6;
    return {center, nx};
  }
  function ballHitsDefenders(){
    const d = defenders;
    const left = d.x, right = d.x + d.w;
    const top = d.y, bottom = d.y + d.h;
    if(ball.x + ball.r < left || ball.x - ball.r > right || ball.y + ball.r < top || ball.y - ball.r > bottom) return null;
    const centerX = d.x + d.w / 2;
    const nx = ball.x < centerX ? -0.6 : 0.6;
    let ny = 0;
    if(ball.y - ball.r < top + d.h * 0.25) ny = -1;
    return { nx, ny };
  }
  function ballScale(y){
    const g=geom.goal;
    const goalBottom=g.y+g.h;
    const progress=clamp((goalBottom - y)/g.h,0,1);
    return 1 - 0.25*progress;
  }

  // ===== Ads & Cameras =====
  function initBanners(){
    banners=[]; const g=geom.goal; const trackH=58; const trackY=g.y+g.h-trackH-8;
    const texts=['SPONSOR','ULTRA BOOTS','MEGA SPORTS','FAIR PLAY','STADIO TECH','HYDRATE','CLEAN PLAY'];
    let x=-W*0.5;
    for(let i=0;i<10;i++){ const w=rnd(240,320); banners.push({x,y:trackY,w,h:trackH,speed:rnd(0.6,1.1),hue:Math.floor(rnd(200,320)),text:texts[i%texts.length]}); x+=w+rnd(80,140); }
  }
  function initCameras(){ const g=geom.goal,cw=36,ch=24; cameras=[{x:g.x-cw-12,y:g.y+g.h-ch-6,w:cw,h:ch},{x:g.x+g.w+12,y:g.y+g.h-ch-6,w:cw,h:ch}]; }

  // ===== Targets =====
  function generateHoles(){
    holes = createHoleSet(geom.goal,1);
    generateMiniHoles();
  }
  function replaceHole(old){
    const idx=holes.indexOf(old);
    if(idx===-1) return;
    if(old.timer){
      holes.splice(idx,1);
      const t=createTimerHole(geom.goal,1,holes);
      if(t) holes.push(t);
      generateMiniHoles();
      return;
    }
    const g=geom.goal;
    const minR=Math.max(ball.r*1.05,22*geom.scale); const maxR=Math.max(minR+6,50*geom.scale);
    const pad=18; let tries=0;
    while(tries<600){
      tries++;
      const r=rnd(minR,maxR);
      let x;
      if(Math.random() < 0.6){
        const side = Math.random() < 0.5 ? 'l' : 'r';
        const range = g.w * 0.2;
        if(side === 'l') x = rnd(g.x+pad+r, g.x+pad+range);
        else x = rnd(g.x+g.w-pad-range, g.x+g.w-pad-r);
      } else {
        x = rnd(g.x+pad+r,g.x+g.w-pad-r);
      }
      const y=rnd(g.y+pad+r,g.y+g.h-pad-r);
      if(holes.every(h=>h===old||Math.hypot(h.x-x,h.y-y)>h.r+r+12)){
        const points=Math.max(10,Math.round(((maxR/r)*70)/5)*5);
        holes[idx]={x,y,r,points};
        break;
      }
    }
    generateMiniHoles();
  }

  function explodeBall(){
    const rect=canvas.getBoundingClientRect();
    const x=rect.left + (ball.x/W)*rect.width;
    const y=rect.top + (ball.y/H)*rect.height;
    const el=document.createElement('div');
    el.textContent='üí®';
    el.className='bomb-explosion';
    el.style.left=x+'px';
    el.style.top=y+'px';
    document.body.appendChild(el);
    setTimeout(()=>el.remove(),1000);
    for(let i=0;i<10;i++){ ballPieces.push({x:ball.x,y:ball.y,vx:rnd(-3,3),vy:rnd(-3,3),life:1}); }
    for(let i=0;i<12;i++){ smokePuffs.push({x:ball.x,y:ball.y,r:rnd(6,10),vx:rnd(-0.4,0.4),vy:rnd(-1.2,-0.6),life:1}); }
    ball.exploded = true;
    ball.moving = false;
    ball.path = null;
    ball.pathIndex = 0;
    ball.pathSpeed = 0;
    ball.trail = [];
  }

  // ===== Drawing: Field & lines =====
  function drawField(){
    for(let y=0;y<H;y+=STRIPE){
      ctx.fillStyle=(Math.floor(y/STRIPE)%2?getComputedStyle(document.documentElement).getPropertyValue('--turf2')||'#0a6c1d':'#0c7a23'); ctx.fillRect(0,y,W,STRIPE);
    }
    const vg=ctx.createRadialGradient(W/2,H,10,W/2,H,H/1.12); vg.addColorStop(0,'rgba(0,0,0,0)'); vg.addColorStop(1,'rgba(0,0,0,0.26)'); ctx.fillStyle=vg; ctx.fillRect(0,0,W,H);

    const kickerLineY = H - STRIPE*3;
    ctx.strokeStyle = '#fff';
    ctx.lineWidth = 4;
    ctx.beginPath();
    ctx.lineJoin='round'; ctx.lineCap='round';
    ctx.moveTo(0, kickerLineY);
    ctx.lineTo(W, kickerLineY);
    ctx.stroke();
    ctx.beginPath();
    ctx.arc(W/2, kickerLineY, 180*geom.scale, 0, Math.PI);
    ctx.stroke();

    const g=geom.goal; ctx.strokeStyle='#fff'; ctx.lineJoin='round';
    const gl=g.y+g.h+2;
    // Removed middle lane in front of the goal
    // ctx.lineWidth=2; ctx.beginPath(); ctx.moveTo(0,gl); ctx.lineTo(W,gl); ctx.stroke();
    ctx.lineWidth=4;

    const paDepth=geom.paDepth, pad=Math.max(120*geom.scale,(W-g.w)/4);
    ctx.strokeRect(g.x-pad,gl,g.w+pad*2,paDepth);
    const sixDepth=Math.min(120*geom.scale,paDepth*0.45), sixPad=Math.max(140*geom.scale,pad*0.7);
    // Removed goal-area line close to the net
    // ctx.strokeRect(g.x-sixPad,gl,g.w+sixPad*2,sixDepth);
    ctx.fillStyle = '#fff';
    ctx.beginPath();
    ctx.arc(geom.penaltySpot.x, geom.penaltySpot.y, ctx.lineWidth, 0, Math.PI*2);
    ctx.fill();

    // Free-kick arc omitted for simplified field
  }

  function drawMiniGoal(c,g,netOverride){
    const innerW=g.w*0.8, innerH=g.h*0.8;
    const ix=g.x+(g.w-innerW)/2, iy=g.y+(g.h-innerH)/2;
    const scale=g.w/geom.goal.w;
    const netColor=netOverride||getComputedStyle(document.documentElement).getPropertyValue('--net')||'#e6e6e6';
    const size=18*scale; const h=size*Math.sqrt(3)/2;
    c.save();
    c.beginPath();
    c.rect(ix,iy,innerW,innerH);
    c.clip();
    c.strokeStyle=netColor; c.lineWidth=Math.max(0.5,1.2*scale);
    for(let y=g.y-h; y<g.y+g.h+h; y+=h){
      for(let x=g.x-size; x<g.x+g.w+size; x+=size*1.5){
        const off=((Math.round((y-g.y)/h))%2)*size*0.75;
        let cx=x+off, cy=y;
        c.beginPath();
        for(let i=0;i<6;i++){
          const a=Math.PI/3*i;
          const px=cx+size*Math.cos(a);
          const py=cy+size*Math.sin(a);
          if(i===0) c.moveTo(px,py); else c.lineTo(px,py);
        }
        c.closePath();
        c.stroke();
      }
    }
    c.restore();
    c.strokeStyle='#fff';
    c.lineWidth=2*scale;
    c.beginPath();
    c.moveTo(g.x,g.y); c.lineTo(ix,iy);
    c.moveTo(g.x+g.w,g.y); c.lineTo(ix+innerW,iy);
    c.moveTo(g.x,g.y+g.h); c.lineTo(ix,iy+innerH);
    c.moveTo(g.x+g.w,g.y+g.h); c.lineTo(ix+innerW,iy+innerH);
    c.stroke();
    c.strokeStyle='#fff';
    c.lineWidth=4*scale;
    c.beginPath();
    c.moveTo(g.x,g.y+g.h); c.lineTo(ix,iy+innerH);
    c.moveTo(g.x+g.w,g.y+g.h); c.lineTo(ix+innerW,iy+innerH);
    c.moveTo(ix,iy+innerH); c.lineTo(ix+innerW,iy+innerH);
    c.moveTo(ix,iy+innerH); c.lineTo(ix,iy); c.lineTo(ix+innerW,iy); c.lineTo(ix+innerW,iy+innerH);
    c.stroke();
    c.strokeStyle='#fff';
    c.lineWidth=12*scale;
    c.beginPath();
    c.moveTo(g.x,g.y+g.h);
    c.lineTo(g.x,g.y);
    c.lineTo(g.x+g.w,g.y);
    c.lineTo(g.x+g.w,g.y+g.h);
    c.stroke();
  }

  // ===== Ads behind goal =====
  function drawAds(){
    const g=geom.goal, trackH=58, trackY=g.y+g.h-trackH-18;
    ctx.fillStyle='#0e1430'; ctx.fillRect(g.x-60,trackY,g.w+120,trackH);
    ctx.save(); ctx.beginPath(); ctx.rect(g.x-60,trackY,g.w+120,trackH); ctx.clip();
    for(const b of banners){
      b.x+=b.speed; if(b.x>g.x+g.w+160) b.x=g.x-220-b.w;
      ctx.fillStyle=`hsl(${b.hue} 70% 50%)`; ctx.fillRect(b.x,trackY+4,b.w,trackH-8);
      ctx.fillStyle='#fff'; ctx.font='700 14px system-ui'; ctx.textAlign='center'; ctx.textBaseline='middle';
      ctx.fillText(b.text,b.x+b.w/2,trackY+trackH/2);
    }
    ctx.restore();
  }

  // ===== Goal, net, cameras, targets =====
  function drawGoal(){
    const g=geom.goal;
    const innerW=g.w*0.8, innerH=g.h*0.8;
    const ix=g.x+(g.w-innerW)/2, iy=g.y+(g.h-innerH)/2;
    const netColor=(goalFlash>0||missFlash>0)?'#ffd400':(getComputedStyle(document.documentElement).getPropertyValue('--net')||'#e6e6e6');
    const size=18; const h=size*Math.sqrt(3)/2;
    function drawNetMesh(){
      ctx.strokeStyle=netColor; ctx.lineWidth=1.2;
      for(let y=g.y-h; y<g.y+g.h+h; y+=h){
        for(let x=g.x-size; x<g.x+g.w+size; x+=size*1.5){
          const off = ((Math.round((y-g.y)/h))%2)*size*0.75;
          let cx=x+off, cy=y;
          // skip drawing net near the ground behind the keeper's feet
          if(cy > g.y + g.h - 8) continue;
          ctx.beginPath();
          for(let i=0;i<6;i++){
            const a=Math.PI/3*i; let px=cx+size*Math.cos(a); let py=cy+size*Math.sin(a);
            const dx=netHit.x-px, dy=netHit.y-py; const dist=Math.hypot(dx,dy);
            if(netHit.t>0 && dist>0){
              const impact=Math.exp(-dist/40)*12*netHit.t;
              const ripple=0.3*netHit.t;
              const pull=impact+ripple;
              px+=dx/dist*pull; py+=dy/dist*pull;
            }
            if(netHit.shake>0){ py+=Math.sin((px+py+i)*0.3+performance.now()*0.02)*netHit.shake*3; }
            if(i===0) ctx.moveTo(px,py); else ctx.lineTo(px,py);
          }
          ctx.closePath(); ctx.stroke();
        }
      }
    }
    function drawNetPanel(pathFn){
      ctx.save();
      ctx.beginPath();
      pathFn();
      ctx.clip();
      drawNetMesh();
      ctx.restore();
    }
    // back panel
    drawNetPanel(() => { ctx.rect(ix, iy, innerW, innerH); });
    // left side
    drawNetPanel(() => {
      ctx.moveTo(g.x, g.y);
      ctx.lineTo(ix, iy);
      ctx.lineTo(ix, iy + innerH);
      ctx.lineTo(g.x, g.y + g.h);
      ctx.closePath();
    });
    // right side
    drawNetPanel(() => {
      ctx.moveTo(g.x + g.w, g.y);
      ctx.lineTo(ix + innerW, iy);
      ctx.lineTo(ix + innerW, iy + innerH);
      ctx.lineTo(g.x + g.w, g.y + g.h);
      ctx.closePath();
    });
    // top
    drawNetPanel(() => {
      ctx.moveTo(g.x, g.y);
      ctx.lineTo(g.x + g.w, g.y);
      ctx.lineTo(ix + innerW, iy);
      ctx.lineTo(ix, iy);
      ctx.closePath();
    });
    ctx.strokeStyle='#fff'; ctx.lineWidth=2;
    ctx.beginPath();
    ctx.moveTo(g.x, g.y);
    ctx.lineTo(ix, iy);
    ctx.moveTo(g.x+g.w, g.y);
    ctx.lineTo(ix+innerW, iy);
    ctx.moveTo(g.x, g.y+g.h);
    ctx.lineTo(ix, iy+innerH);
    ctx.moveTo(g.x+g.w, g.y+g.h);
    ctx.lineTo(ix+innerW, iy+innerH);
    ctx.stroke();
    ctx.strokeStyle='#fff'; ctx.lineWidth=4;
    ctx.beginPath();
    ctx.moveTo(g.x, g.y+g.h);
    ctx.lineTo(ix, iy+innerH);
    ctx.moveTo(g.x+g.w, g.y+g.h);
    ctx.lineTo(ix+innerW, iy+innerH);
    ctx.moveTo(ix, iy+innerH);
    ctx.lineTo(ix+innerW, iy+innerH);
    ctx.moveTo(ix, iy+innerH);
    ctx.lineTo(ix, iy);
    ctx.lineTo(ix+innerW, iy);
    ctx.lineTo(ix+innerW, iy+innerH);
    ctx.stroke();
    ctx.strokeStyle='#fff'; ctx.lineWidth=12;
    ctx.beginPath();
    ctx.moveTo(g.x, g.y+g.h);
    ctx.lineTo(g.x, g.y);
    ctx.lineTo(g.x+g.w, g.y);
    ctx.lineTo(g.x+g.w, g.y+g.h);
    ctx.stroke();
    if(goalFlash>0){
      ctx.save();
      ctx.globalAlpha=goalFlash;
      ctx.font=`900 ${Math.min(innerH*0.8,120)}px system-ui`;
      ctx.textAlign='center';
      ctx.textBaseline='middle';
      ctx.lineWidth=8;
      ctx.strokeStyle='#000';
      ctx.fillStyle='#fff';
      ctx.strokeText('GOAL',ix+innerW/2,iy+innerH/2);
      ctx.fillText('GOAL',ix+innerW/2,iy+innerH/2);
      ctx.restore();
    }
    if(missFlash>0){
      ctx.save();
      ctx.globalAlpha=missFlash;
      ctx.font=`900 ${Math.min(innerH*0.8,120)}px system-ui`;
      ctx.textAlign='center';
      ctx.textBaseline='middle';
      ctx.lineWidth=8;
      ctx.strokeStyle='#000';
      ctx.fillStyle='#ef4444';
      ctx.strokeText('MISSED',ix+innerW/2,iy+innerH/2);
      ctx.fillText('MISSED',ix+innerW/2,iy+innerH/2);
      ctx.restore();
    }
    for(const c of cameras){ ctx.fillStyle='#111'; ctx.fillRect(c.x,c.y,c.w,c.h); ctx.fillStyle='#e10600'; ctx.beginPath(); ctx.arc(c.x+8,c.y+6,3,0,Math.PI*2); ctx.fill(); }
    for(const h of holes){ if(h.hit) continue; ctx.fillStyle='rgba(225,6,0,.9)'; ctx.beginPath(); ctx.arc(h.x,h.y,h.r,0,Math.PI*2); ctx.fill();
      ctx.fillStyle='#ffd400'; ctx.font=`800 ${Math.max(12,h.r*0.9)}px system-ui`; ctx.textAlign='center'; ctx.textBaseline='middle';
      if(h.timer) ctx.fillText(`‚è≥Ô∏è +${h.timer}`, h.x, h.y);
      else if(h.bomb) ctx.fillText('üí£ ' + (h.points * 3), h.x, h.y);
      else ctx.fillText(h.points, h.x, h.y);
    }
    drawKeeper();
  }

  function drawKeeper(){
    const k=keeper;
    ctx.save();
    ctx.translate(k.x + k.w/2, k.y + k.h);
    ctx.rotate(k.a||0);
    ctx.translate(-k.w/2, -k.h + k.dive);
    ctx.drawImage(keeperImg, 0, 0, k.w, k.h);
    ctx.restore();
  }

  function drawDefenders(){
    const d=defenders;
    ctx.drawImage(defendersImg, d.x, d.y, d.w, d.h);
  }

  // ===== Ball & physics =====
  function drawBall(){
    const baseR=Math.max(BALL_R*geom.scale,22);
    ball.r=baseR;
    const drawR = baseR * ballScale(ball.y);
    // draw any loose balls continuing to fall
    for(const b of looseBalls){
      ctx.save();
      ctx.translate(b.x,b.y);
      ctx.rotate(b.angle||0);
      const sizeL = baseR*2*ballScale(b.y);
      ctx.drawImage(ballImg, -sizeL/2, -sizeL/2, sizeL, sizeL);
      ctx.restore();
    }
    if(ball.exploded) return;
    ctx.save();
    for(let i=0;i<ball.trail.length;i++){
      const t=ball.trail[i];
      const a=(i+1)/ball.trail.length*0.4;
      ctx.globalAlpha=a;
      ctx.beginPath();
      ctx.arc(t.x,t.y,drawR,0,Math.PI*2);
      ctx.fillStyle='#fff';
      ctx.fill();
    }
    ctx.restore();
    ctx.save();
    ctx.translate(ball.x,ball.y);
    ctx.rotate(ball.angle);
    const size = drawR*2;
    ctx.drawImage(ballImg, -size/2, -size/2, size, size);
    ctx.restore();
  }

  function drawPrizePieces(){
    ctx.fillStyle='#e10600';
    for(const p of prizePieces){
      ctx.globalAlpha=p.life;
      ctx.beginPath();
      ctx.arc(p.x,p.y,2,0,Math.PI*2);
      ctx.fill();
      p.x+=p.vx; p.y+=p.vy; p.vy+=0.1; p.life-=0.02;
    }
    ctx.globalAlpha=1;
    prizePieces=prizePieces.filter(p=>p.life>0);
  }

  function drawBallPieces(){
    ctx.fillStyle='#fff';
    for(const b of ballPieces){
      ctx.globalAlpha=b.life;
      ctx.beginPath();
      ctx.arc(b.x,b.y,2,0,Math.PI*2);
      ctx.fill();
      b.x+=b.vx; b.y+=b.vy; b.vy+=0.2; b.life-=0.02;
    }
    ctx.globalAlpha=1;
    ballPieces=ballPieces.filter(b=>b.life>0);
  }

  function drawSmoke(){
    for(const s of smokePuffs){
      ctx.globalAlpha=s.life*0.5;
      ctx.fillStyle='#bbb';
      ctx.beginPath();
      ctx.arc(s.x,s.y,s.r,0,Math.PI*2);
      ctx.fill();
      s.x+=s.vx; s.y+=s.vy; s.r+=0.3; s.life-=0.02;
    }
    ctx.globalAlpha=1;
    smokePuffs=smokePuffs.filter(s=>s.life>0);
  }

  function drawPunchEffects(){
    for(const p of punchEffects){
      ctx.globalAlpha=p.life;
      ctx.font=`${42*geom.scale}px system-ui`;
      ctx.textAlign='center';
      ctx.textBaseline='middle';
      ctx.fillText('ü•ä',p.x,p.y);
      p.life-=0.01;
    }
    ctx.globalAlpha=1;
    punchEffects=punchEffects.filter(p=>p.life>0);
  }
  const FRICTION=0.995, AIR_DRAG=0.0006, GRAVITY=0.20; // reduce drag for smoother motion
  function stepBall(){
    if(!ball.moving) return;
    if(!ball.trailStopped){
      ball.trail.push({x:ball.x,y:ball.y});
      if(ball.trail.length>20) ball.trail.shift();
    } else if(ball.trail.length>0){
      ball.trail.shift();
    }
    const g=geom.goal;
    const postR = g.post;
    let nextX, nextY, soundX, soundY;
    if(ball.path){
      const targetPoint = ball.path[ball.pathIndex] || ball.target;
      const dxp = targetPoint.x - ball.x;
      const dyp = targetPoint.y - ball.y;
      const dist = Math.hypot(dxp, dyp);
      const step = Math.min(ball.pathSpeed, dist);
      const t = dist === 0 ? 0 : step / dist;
      nextX = ball.x + dxp * t;
      nextY = ball.y + dyp * t;
      ball.vx = nextX - ball.x;
      ball.vy = nextY - ball.y;
      soundX = nextX;
      soundY = nextY;
      if(dist <= step && ball.pathIndex < ball.path.length-1){
        ball.pathIndex++;
      }
    } else {
      const speed=Math.hypot(ball.vx,ball.vy); const drag = 1 - AIR_DRAG*speed; const curve = ball.spin*0.5;
      const knuckle = 0;
      ball.vx = (ball.vx + curve + knuckle)*FRICTION*drag; ball.vy = (ball.vy + GRAVITY)*FRICTION*drag;
      nextX = ball.x + ball.vx;
      nextY = ball.y + ball.vy;
      const soundLead = 0.7; // trigger post sounds when ~70% of the way to impact
      soundX = ball.x + ball.vx * soundLead;
      soundY = ball.y + ball.vy * soundLead;
    }

    // Predict collisions with goal posts or crossbar slightly early so the sound lines up.
    if(soundX - ball.r <= g.x && soundY > g.y - postR && soundY < g.y + g.h + postR && ball.vx < 0){
      triggerNetHit(nextX, nextY);
      sfxPost();
      reflectBall(1,0,0.85);
      if(nextY - ball.r <= g.y && ball.vy < 0){
        ball.vy *= -1;
        ball.y = g.y + ball.r + 1;
      } else {
        ball.y = nextY;
      }
      ball.spin *= -0.3;
      ball.x = g.x + ball.r + 1;
      ball.path = null;
      ball.pathIndex = 0;
      ball.pathSpeed = 0;
      return;
    }
    if(soundX + ball.r >= g.x + g.w && soundY > g.y - postR && soundY < g.y + g.h + postR && ball.vx > 0){
      triggerNetHit(nextX, nextY);
      sfxPost();
      reflectBall(-1,0,0.85);
      if(nextY - ball.r <= g.y && ball.vy < 0){
        ball.vy *= -1;
        ball.y = g.y + ball.r + 1;
      } else {
        ball.y = nextY;
      }
      ball.spin *= -0.3;
      ball.x = g.x + g.w - ball.r - 1;
      ball.path = null;
      ball.pathIndex = 0;
      ball.pathSpeed = 0;
      return;
    }
    if(soundY - ball.r <= g.y && soundX > g.x - postR && soundX < g.x + g.w + postR && ball.vy < 0){
      triggerNetHit(nextX, nextY);
      sfxPost();
      if(!ball.goalSounded){ playGoalSound(); ball.goalSounded = true; }
      reflectBall(0,1,0.85);
      if(nextX - ball.r <= g.x && ball.vx < 0){
        ball.vx *= -1;
        ball.x = g.x + ball.r + 1;
      } else if(nextX + ball.r >= g.x + g.w && ball.vx > 0){
        ball.vx *= -1;
        ball.x = g.x + g.w - ball.r - 1;
      } else {
        ball.x = nextX;
      }
      ball.spin *= 0.3;
      ball.y = g.y + ball.r + 1;
      ball.path = null;
      ball.pathIndex = 0;
      ball.pathSpeed = 0;
      return;
    }

    ball.x = nextX; ball.y = nextY; ball.angle += ball.spin*0.15; ball.spin *= 0.98;

    // prevent the ball from getting stuck in the top corners
    const cornerTol = 2;
    if (ball.y - ball.r <= g.y + cornerTol) {
      if (ball.x - ball.r <= g.x + cornerTol) {
        ball.vx = Math.max(ball.vx, 2);
        ball.x = g.x + ball.r + 1;
      } else if (ball.x + ball.r >= g.x + g.w - cornerTol) {
        ball.vx = Math.min(ball.vx, -2);
        ball.x = g.x + g.w - ball.r - 1;
      }
      ball.vy = Math.max(ball.vy, 2);
      ball.y = g.y + ball.r + 1;
    }

    const dHit = ballHitsDefenders();
    if(dHit){
      ball.trailStopped = true;
      reflectBall(dHit.nx, dHit.ny, 0.85);
      if(dHit.ny < 0){
        ball.y = defenders.y - ball.r;
      } else {
        ball.x = dHit.nx < 0 ? defenders.x - ball.r : defenders.x + defenders.w + ball.r;
      }
      ball.path = null;
      ball.pathIndex = 0;
      ball.pathSpeed = 0;
      return;
    }

    // Trigger net animation once the ball crosses inside the goal area.
    // Sound playback occurs later when the goal is confirmed.
    if(!ball.netSounded && ball.x>g.x && ball.x<g.x+g.w && ball.y>g.y && ball.y<g.y+g.h){
      triggerNetHit(ball.x, ball.y);
      ball.netSounded = true;
      ball.path = null;
      ball.pathIndex = 0;
      ball.pathSpeed = 0;
      ball.vx *= 0.6;
      ball.vy *= 0.6;
    }

    if(ball.x>g.x && ball.x<g.x+g.w && ball.y>g.y && ball.y<g.y+g.h){
      for(const h of holes){
        if(h.hit) continue;
        // break a prize once the ball overlaps roughly 30% of its radius
        if(Math.hypot(h.x-ball.x,h.y-ball.y) <= Math.max(2, h.r + ball.r * 0.3)){
          h.hit=true;
          if(h.timer){
            const extra=h.timer*1000;
            roundStart -= extra;
            timeLeft += extra;
            updateHUD();
            popupText(`+${h.timer}s`,h.x,h.y,timeShort,'#22c55e');
            sfxTimer();
            for(let i=0;i<8;i++){ prizePieces.push({x:h.x,y:h.y,vx:rnd(-2,2),vy:rnd(-2,2),life:1}); }
          } else if(h.bomb){
            roundStart += 15000;
            timeLeft = Math.max(0,timeLeft-15000);
            myScore = Math.max(0,myScore-50);
            updateHUD();
            popupText('-15',h.x,h.y,timeShort,'#ef4444');
            popupText('-50',h.x,h.y,playerScoreEl,'#ef4444');
            sfxExplosion();
            explodeBall();
            setTimeout(()=>{ resetBall(); generateHoles(); }, 700);
          } else {
            ball.points += h.points;
            sfxPrize();
            for(let i=0;i<8;i++){ prizePieces.push({x:h.x,y:h.y,vx:rnd(-2,2),vy:rnd(-2,2),life:1}); }
          }
          ball.spin *= 0.6;
          break;
        }
      }
    }
    if(ball.exploded) return;
    const kHit = ballHitsKeeper();
    if(kHit){
      ball.trailStopped = true;
      punchEffects.push({x:ball.x,y:ball.y,life:1});
      playKeeperSaveSound();
      reflectBall(kHit.nx,1,0.6);
      ball.spin *= 0.5;
      ball.y = keeper.y + keeper.h + ball.r;
      missFlash=1;
      endShot(false,0,SHOT_RESET_DELAY);
      return;
    }
    if(ball.target){
      const dx=ball.target.x-ball.x, dy=ball.target.y-ball.y;
      const dist=Math.hypot(dx,dy);
      if(dist < ball.r*0.15 || (ball.prevDist && dist>ball.prevDist)){
        ball.x = ball.target.x;
        ball.y = ball.target.y;
        // keep velocity so loose ball keeps moving after scoring
        endShot(true, ball.points);
        ball.target = null;
        ball.prevDist = null;
        return;
      }
      ball.prevDist=dist;
    }
    if(ball.y < -80 || ball.x < -80 || ball.x > W+80 || ball.y > H+80 || Math.hypot(ball.vx,ball.vy)<0.3){
      ball.trailStopped = true;
      const insideGoal = ball.x > g.x && ball.x < g.x + g.w && ball.y > g.y && ball.y < g.y + g.h;
      endShot(insideGoal, insideGoal ? Math.max(ball.points, MIN_GOAL_POINTS) : 0);
    }
  }

  function stepLooseBalls(){
    const r = Math.max(BALL_R*geom.scale*1.08,22);
    const fieldGround = geom.spot.y;
    const goalGround = geom.goal.y + geom.goal.h;
    const g = geom.goal;
    const postR = g.post;
    const now = performance.now();
    for(const b of looseBalls){
      b.vy += GRAVITY;
      b.vx *= 0.98;
      b.spin *= 0.98;
      let nextX = b.x + b.vx;
      let nextY = b.y + b.vy;
      if(b.insideGoal){
        const innerW = g.w * 0.8;
        const innerH = g.h * 0.8;
        const ix = g.x + (g.w - innerW) / 2;
        const iy = g.y + (g.h - innerH) / 2;
        if(nextX - r <= g.x && nextY > g.y - postR && nextY < g.y + g.h + postR && b.vx < 0){
          sfxPost();
          b.vx *= -0.6;
          nextX = g.x + r + 1;
        } else if(nextX + r >= g.x + g.w && nextY > g.y - postR && nextY < g.y + g.h + postR && b.vx > 0){
          sfxPost();
          b.vx *= -0.6;
          nextX = g.x + g.w - r - 1;
        } else if(nextX - r <= ix && nextY > iy && nextY < iy + innerH && b.vx < 0){
          sfxPost();
          b.vx *= -0.6;
          nextX = ix + r + 1;
        } else if(nextX + r >= ix + innerW && nextY > iy && nextY < iy + innerH && b.vx > 0){
          sfxPost();
          b.vx *= -0.6;
          nextX = ix + innerW - r - 1;
        }
        if(nextY - r <= g.y && nextX > g.x - postR && nextX < g.x + g.w + postR && b.vy < 0){
          sfxPost();
          b.vy *= -0.6;
          nextY = g.y + r + 1;
        } else if(nextY - r <= iy && nextX > ix && nextX < ix + innerW && b.vy < 0){
          sfxPost();
          b.vy *= -0.6;
          nextY = iy + r + 1;
        }
      }
      b.x = nextX;
      b.y = nextY;
      b.angle += b.spin;
      const ground = b.insideGoal ? goalGround : fieldGround;
      if(b.y + r > ground){
        b.y = ground - r;
        if(b.insideGoal){
          if(!b.bounced){
            b.vy *= -0.25;
            b.spin *= 0.5;
            b.bounced = true;
          } else {
            b.vy = 0;
            b.vx *= 0.92;
            b.spin *= 0.8;
          }
        } else if(!b.bounced){
          b.vy *= -0.25;
          b.spin *= 0.5;
          b.bounced = true;
        } else {
          b.vy = 0;
          b.vx *= 0.92;
          b.spin *= 0.8;
        }
      }
      if(now - b.landedAt > 1500){
        b.remove = true;
      }
    }
    looseBalls = looseBalls.filter(b => !b.remove);
  }


  function stepDefenders(){
    if(!defenders.jumping) return;
    defenders.vy += GRAVITY*0.5;
    defenders.y += defenders.vy;
    if(defenders.y >= defenders.baseY){
      defenders.y = defenders.baseY;
      defenders.vy = 0;
      defenders.jumping = false;
    }
  }

  function stepKeeper(){
    // Smoothly move keeper toward target position
    keeper.x += (keeper.targetX - keeper.x) * 0.05;
    keeper.y += (keeper.targetY - keeper.y) * 0.05;
  }

  // ===== Aim guide =====
  // aiming controls removed
  function drawSwipePath(path){
    if(!aimOn || path.length < 2) return;
    ctx.beginPath();
    ctx.moveTo(path[0].x, path[0].y);
    for(let i=1;i<path.length;i++){
      ctx.lineTo(path[i].x, path[i].y);
    }
    ctx.strokeStyle='rgba(125,211,252,.9)';
    ctx.lineWidth=2;
    ctx.setLineDash([6,8]);
    ctx.stroke();
    ctx.setLineDash([]);
  }

  // ===== Round / scoring =====
function endShot(hit,pts,delay=SHOT_RESET_DELAY){
  // keep current ball falling while spawning the next one
  looseBalls.push({x:ball.x,y:ball.y,vx:ball.vx,vy:ball.vy,angle:ball.angle,spin:ball.spin,bounced:false,insideGoal:hit,landedAt:performance.now()});
  ball.moving=false;
  ball.trailStopped = true;
  ball.path = null;
  ball.pathIndex = 0;
  ball.pathSpeed = 0;
  if(hit){
    showGoal(ball.x, ball.y);
    ball.netSounded=true;
    const score=Math.max(pts,MIN_GOAL_POINTS);
    myScore += score;
    status('GOAL! +' + score);
    vibrate(25);
  } else {
    status('Missed.');
    vibrate(12);
  }
  updateHUD();
  if(delay>0){
    setTimeout(()=>{ resetBall(); generateHoles(); }, delay);
  } else {
    resetBall();
    generateHoles();
  }
}
  function updateHUD(){
    if(playerScoreEl) playerScoreEl.textContent = myScore;
    timeShort.textContent = Math.ceil(timeLeft/1000);
  }
  function fmtTime(ms){ const s=Math.max(0, Math.ceil(ms/1000)); const m=Math.floor(s/60); const ss=String(s%60).padStart(2,'0'); return `${m}:${ss}`; }
  function finish(){
    if(!running) return;
    running=false; ended=true;
    crowdSound.pause(); crowdSound.currentTime=0;
    playWhistle();
    const scores=[{score:myScore,avatar:userAvatar}];
    for(const r of rivals){ scores.push({score:r.score,avatar:r.avatar}); }
    const max=Math.max(...scores.map(s=>s.score));
    const winner=scores.find(s=>s.score===max);
    const winIdx = scores.indexOf(winner) === 0 ? 1 : 2;
    if(window.tournamentMode && typeof window.handleTournamentResult === 'function'){
      try{localStorage.setItem(`freeKickLastResult_${tgKey}`, JSON.stringify({p1: myScore, p2: rivals[0]?.score || 0}));}catch{}
      window.handleTournamentResult(winIdx);
      return;
    }
    const overlay=document.getElementById('winnerOverlay');
    const img=document.getElementById('winnerAvatar');
    if(img) img.src=winner.avatar || userAvatar;
    const container=overlay.firstElementChild;
    if(container){
      const scoreEl=document.createElement('div');
      scoreEl.style.marginTop='8px';scoreEl.style.color='#fff';
      scoreEl.textContent=`${myScore}-${rivals[0]?.score||0}`;
      container.insertBefore(scoreEl, container.lastElementChild);
    }
    overlay.classList.remove('hidden');
    coinConfetti(50);
    cheerSound.currentTime=0; cheerSound.play().catch(()=>{});
  }
  function status(msg){ /* no-op */ }

  // ===== Input (swipe/flick + spin) =====
  let pointer={id:null,path:[],active:false,armed:false,t0:0,t1:0};
  function pos(e){ const r=canvas.getBoundingClientRect(); return {x:(e.clientX-r.left)*(W/r.width), y:(e.clientY-r.top)*(H/r.height)}; }
  function onDown(e){ if(!running||ended||paused) return; if(pointer.active) return; pointer.active=true; pointer.id=e.pointerId; const p=pos(e); pointer.path=[p]; pointer.t0=performance.now(); pointer.t1=pointer.t0; pointer.armed = Math.hypot(p.x-ball.x,p.y-ball.y) <= ball.r*2.4 && !ball.moving; if(pointer.armed){ status('Swipe upward. Curve for spin.'); } }
  function onMove(e){
    if(!pointer.active || e.pointerId !== pointer.id) return;
    pointer.path.push(pos(e));
    pointer.t1 = performance.now();
    if(pointer.armed && aimOn && pointer.path.length > 1){
      drawSwipePath(pointer.path);
    }
  }
function onUp(e){
  if(!pointer.active || e.pointerId !== pointer.id) return;
  pointer.active = false;
  if(!pointer.armed || ball.moving || !running || paused){ pointer.path = []; return; }
  const path = pointer.path;
  pointer.path = [];
  if(path.length < 3){ status('Swipe longer/faster.'); return; }
  path[0] = { x: ball.x, y: ball.y };
  const totalDist = path.reduce((sum, p, i) => i ? sum + Math.hypot(p.x - path[i-1].x, p.y - path[i-1].y) : 0, 0);
  const power = clamp(totalDist / 150, 0.4, 5.0);
  ball.path = path.slice(1);
  ball.pathIndex = 0;
  ball.pathSpeed = SHOT_SPEED * power;
  ball.vx = 0; ball.vy = 0; ball.spin = 0;
  ball.moving = true;
  // when shot starts, move keeper toward the center of the goal smoothly
  const centerX = geom.goal.x + (geom.goal.w - keeper.w) / 2;
  keeper.targetX = centerX;
  keeper.targetY = keeper.baseY + geom.goal.h * 0.02;
  if(!defenders.jumping){
    defenders.vy = -3*geom.scale;
    defenders.jumping = true;
  }
  playBallKickSound();
  ball.target = path[path.length-1];
  ball.prevDist = Infinity;
}
  canvas.addEventListener('pointerdown', onDown, {passive:true});
  canvas.addEventListener('pointermove', onMove, {passive:true});
  addEventListener('pointerup', onUp, {passive:true}); addEventListener('pointercancel', onUp, {passive:true});

  // ===== Rivals (mini boards + scoring) =====
  function drawMiniBoards(init=false){
    for(let i=0;i<rivals.length;i++){
      const r=rivals[i], c=r.ctx, cv=r.cvs;
      const field={x:12,y:12,w:cv.width-24,h:cv.height-32};
      c.clearRect(0,0,cv.width,cv.height);

      // turf background replicating main field
      const goal = miniGoalRect(cv);
      const scale = goal.w/geom.goal.w;
      const stripe = STRIPE*scale;
      c.save();
      c.beginPath();
      c.rect(field.x,field.y,field.w,field.h);
      c.clip();
      for(let y=field.y;y<field.y+field.h;y+=stripe){
        c.fillStyle=(Math.floor((y-field.y)/stripe)%2?
          getComputedStyle(document.documentElement).getPropertyValue('--turf2')||'#0a6c1d':
          getComputedStyle(document.documentElement).getPropertyValue('--turf1')||'#0c7a23');
        c.fillRect(field.x,y,field.w,stripe);
      }
      const vg=c.createRadialGradient(field.x+field.w/2,field.y+field.h,10,field.x+field.w/2,field.y+field.h,field.h/1.12);
      vg.addColorStop(0,'rgba(0,0,0,0)');
      vg.addColorStop(1,'rgba(0,0,0,0.26)');
      c.fillStyle=vg;
      c.fillRect(field.x,field.y,field.w,field.h);
      c.restore();

      // goal and prize holes
      drawMiniGoal(c,goal,r.flash>0?'#ffd400':undefined);
      // goal line across mini field
      c.strokeStyle='#fff';
      c.lineWidth=2*scale;
      c.beginPath();
      c.moveTo(field.x,goal.y+goal.h);
      c.lineTo(field.x+field.w,goal.y+goal.h);
      c.stroke();

      const DEFENDER_PREVIEW_SCALE=0.7;
      const dw=defenders.w*scale*DEFENDER_PREVIEW_SCALE;
      const dh=(defenders.h*scale*DEFENDER_PREVIEW_SCALE)/2;
      if(init){
        r.defW = dw;
        r.defX = goal.x + Math.random()*(goal.w - dw);
        r.defBaseY = goal.y+goal.h-dh+8*scale;
        r.defY = r.defBaseY;
        r.defVy = 0;
        r.defJump = false;
        r.scale = scale;
      }
      const dx=r.defX;
      const dy=r.defY;
      const dRect={x:dx,y:dy,w:dw,h:dh};

      const list = Array.isArray(miniHolesCache[i]) ? miniHolesCache[i] : [];
      for(const h of list){
        c.fillStyle='rgba(225,6,0,.9)';
        c.beginPath();
        c.arc(h.x,h.y,h.r,0,Math.PI*2);
        c.fill();
        c.fillStyle='#ffd400';
        c.font='bold 12px system-ui';
        c.textAlign='center';
        c.textBaseline='middle';
        if(h.t) c.fillText(`‚è≥Ô∏è +${h.t}`,h.x,h.y);
        else if(h.b) c.fillText('üí£',h.x,h.y);
        else c.fillText(h.p,h.x,h.y);
      }

      // keeper setup
      const kw = keeper.w*scale, kh = keeper.h*scale;
      const centerX = goal.x + (goal.w - kw) / 2;
      const ky = goal.y + goal.h - kh + goal.h*0.07;
      if(init){
        r.kx = centerX;
        r.kw = kw; r.kh = kh; r.g = goal;
      }
      const active = r.shots[0];
      const targetX = active ? clamp(active.x - kw/2, goal.x, goal.x + goal.w - kw) : centerX;
      r.kx += (targetX - r.kx) * 0.1;

      // rival shots
      for(const s of r.shots){
        s.x+=s.vx; s.y+=s.vy; s.vy+=0.25; s.life-=0.02;
        if(!s.saved && s.x>=dRect.x && s.x<=dRect.x+dRect.w && s.y>=dRect.y && s.y<=dRect.y+dRect.h){
          s.saved = true;
          s.life = 0;
        }
        if(s.saved && s.y <= ky + kh * 0.2){ s.life = 0; }
        if(s.life<=0){
          if(!s.done){ r.result = s.saved ? 'MISSED' : 'GOAL'; r.flash = 1; s.done = true; }
          continue;
        }
        c.fillStyle='#fff';
        c.beginPath();
        c.arc(s.x,s.y,4,0,Math.PI*2);
        c.fill();
        if(s.life<0.6 && !s.fragments){
          s.fragments=[];
          for(let k=0;k<5;k++){
            s.fragments.push({x:s.x,y:s.y,vx:rnd(-2,2),vy:rnd(-2,2),life:0.4});
          }
        }
        if(s.fragments){
          for(const f of s.fragments){ f.x+=f.vx; f.y+=f.vy; f.life-=0.03; c.fillRect(f.x,f.y,2,2); }
        }
      }

      // keeper behind defenders
      c.drawImage(keeperImg, r.kx, ky, kw, kh);

      // defenders in front
      c.save();
      c.beginPath();
      c.rect(field.x,field.y,field.w,field.h);
      c.clip();
      c.drawImage(defendersImg,0,0,defendersImg.width,defendersImg.height/2,dx,dy,dw,dh);
      c.restore();
      if(r.flash>0){
        c.save();
        c.globalAlpha=r.flash;
        const txt=r.result;
        c.font=`900 ${Math.min(goal.h*0.5,40)}px system-ui`;
        c.textAlign='center';
        c.textBaseline='middle';
        c.lineWidth=4;
        c.strokeStyle='#000';
        c.fillStyle=txt==='GOAL'?'#fff':'#ef4444';
        c.strokeText(txt,goal.x+goal.w/2,goal.y+goal.h/2);
        c.fillText(txt,goal.x+goal.w/2,goal.y+goal.h/2);
        c.restore();
        r.flash*=0.92;
      }
      r.shots = r.shots.filter(s=>s.life>0);
      r.ptsEl.textContent = r.score;
    }
  }
  function roundRect(c,x,y,w,h,r,fill,stroke,fillColor){ c.beginPath(); c.moveTo(x+r,y); c.arcTo(x+w,y,x+w,y+h,r); c.arcTo(x+w,y+h,x,y+h,r); c.arcTo(x,y+h,x,y,r); c.arcTo(x,y,x+w,y,r); if(fill){ if(fillColor){ const old=c.fillStyle; c.fillStyle=fillColor; c.fill(); c.fillStyle=old; } else c.fill(); } if(stroke) c.stroke(); }
  function stepRivals(now){
    if(!running||paused) return;
    const t = 1 - (timeLeft/ROUND_TIME);
    for(let i=0;i<rivals.length;i++){
      const r=rivals[i];
      if(r.defJump){
        r.defVy += GRAVITY*0.5*r.scale;
        r.defY += r.defVy;
        if(r.defY >= r.defBaseY){
          r.defY = r.defBaseY;
          r.defVy = 0;
          r.defJump = false;
        }
      }
      if(now>r.next){
        r.next = now + rnd(r.rate[0], r.rate[1]) * (1 - 0.45*t) * 0.95;
        const g = r.g;
        const list = Array.isArray(miniHolesCache[i]) ? miniHolesCache[i] : [];
        if(list.length===0){ generateMiniHoles(); continue; }
        let target;
        const rand = Math.random();
        if(rand < 0.3){
          target = list.slice().sort((a,b)=>a.r-b.r)[0];
        } else if(rand < 0.6){
          target = list[Math.floor(Math.random()*list.length)];
        } else {
          target = { x: rnd(g.x, g.x + g.w), y: rnd(g.y, g.y + g.h), r: 40*r.scale, p: 0, t: 0 };
        }
        const acc = clamp(r.acc * (0.9 + 0.5*t),0, 0.98);
        const chance = acc * (22/Math.max(10,target.r)) * 0.8;
        if(Math.random() < chance){
          const saved = Math.random() < 0.5;
          if(!saved){
            if(target.t){
              const extra=target.t*1000;
              roundStart -= extra;
              timeLeft += extra;
              updateHUD();
              sfxTimer();
            } else if(target.b){
              roundStart += 15000;
              timeLeft = Math.max(0,timeLeft-15000);
              r.score = Math.max(0,r.score-50);
              updateHUD();
              sfxExplosion();
            } else if(target.p){
              r.score += Math.max(5, Math.round(target.p));
            }
          }
          const startX = rnd(g.x, g.x + g.w);
          r.defX = clamp(startX - r.defW/2, g.x, g.x + g.w - r.defW);
          if(!r.defJump){ r.defVy = -2*r.scale; r.defJump = true; }
          const vx = (target.x - startX) / 15;
          const vy = (target.y - (g.y + g.h)) / 15;
          r.shots.push({x:startX,y:g.y+g.h,vx,vy,life:1,saved});
        }
      }
      r.ptsEl.textContent = r.score;
    }
  }

  // ===== Timer + loop =====
  function tick(now){ if(!running||paused) return; if(!roundStart) roundStart=now; timeLeft = Math.max(0, ROUND_TIME - (now - roundStart)); timeShort.textContent = Math.ceil(timeLeft/1000); if(timeLeft<=0){ finish(); } }
  function loop(now){ requestAnimationFrame(loop); drawField(); drawAds(); drawGoal(); drawBall(); drawPrizePieces(); drawBallPieces(); drawSmoke(); drawDefenders(); drawPunchEffects(); stepBall(); stepLooseBalls(); stepDefenders(); stepKeeper(); drawMiniBoards(); tick(now||performance.now()); stepRivals(now||performance.now()); updateHUD(); netHit.t*=NET_DECAY; netHit.shake*=NET_DECAY; goalFlash*=0.92; missFlash*=0.92; }

  // ===== Controls =====
  // controls removed

  function resetBall(){
    const margin = BALL_R*geom.scale*2;
    const minX = margin + defenders.w/2;
    const maxX = W - margin - defenders.w/2;
    ball.x = minX + Math.random() * (maxX - minX);
    ball.y = geom.spot.y;
    ball.vx = ball.vy = ball.spin = 0;
    ball.angle = 0;
    ball.moving = false;
    ball.netSounded = false;
    ball.goalSounded = false;
    ball.trail = [];
    ball.trailStopped = false;
    ball.target = null;
    ball.prevDist = null;
    ball.points = 0;
    ball.path = null;
    ball.pathIndex = 0;
    ball.pathSpeed = 0;
    ball.exploded = false;
    defenders.x = clamp(ball.x - defenders.w/2, 0, W - defenders.w);
    defenders.y = defenders.baseY;
    defenders.vy = 0;
    defenders.jumping = false;
    keeper.vx = 0;
    keeper.vy = 0;
    keeper.a = 0;
    keeper.dive = 0;
    keeper.jumping = false;
    keeper.dir = 1;

    // Position keeper on the side opposite the wall
    const goal = geom.goal;
    const wallCenter = defenders.x + defenders.w / 2;
    const goalCenter = goal.x + goal.w / 2;
    const gap = goal.w * 0.02;
    if (wallCenter < goalCenter - goal.w * 0.1) {
      // Wall on left, keeper covers right
      keeper.x = goal.x + goal.w - keeper.w - gap;
    } else if (wallCenter > goalCenter + goal.w * 0.1) {
      // Wall on right, keeper covers left
      keeper.x = goal.x + gap;
    } else {
      // Wall centered, choose a side near the post with a small gap
      keeper.x = Math.random() < 0.5 ? goal.x + gap : goal.x + goal.w - keeper.w - gap;
    }
    keeper.y = keeper.baseY;
    keeper.baseX = keeper.x;
    keeper.targetX = keeper.x;
    keeper.targetY = keeper.y;
  }
  function startGame(){
    playWhistle();
    running=true;
    paused=false;
    ended=false;
    roundStart=performance.now();
    timeLeft=ROUND_TIME;
    myScore=0;
    looseBalls=[];
    for(const r of rivals){ r.score=0; r.next=0; r.shots=[]; }
    resetBall();
    generateHoles();
    drawMiniBoards(true);
    updateHUD();
    ensureAudio();
    crowdSound.play().catch(()=>{});
    status('Go! Score as many as you can.');
  }

  // ===== WebAudio SFX =====
  let audioCtx=null, masterGain=null; function ensureAudio(){ try{ if(!audioCtx){ const AC = window.AudioContext || window.webkitAudioContext; audioCtx = new AC(); masterGain = audioCtx.createGain(); masterGain.gain.value = 0.18; masterGain.connect(audioCtx.destination); } if(audioCtx.state==='suspended') audioCtx.resume(); }catch{} }
  const crowdSound = new Audio('/assets/sounds/football-crowd-3-69245.mp3');
  crowdSound.loop = true;
  crowdSound.volume = 0.5;
  const whistleSound = new Audio('/assets/sounds/metal-whistle-6121.mp3');
  const cheerSound = new Audio('/assets/sounds/man-cheering-in-victory-epic-stock-media-1-00-01.mp3');
  function playWhistle(){
    ensureAudio();
    whistleSound.currentTime = 0;
    whistleSound.play().catch(()=>{});
    setTimeout(()=>{ whistleSound.pause(); whistleSound.currentTime = 0; },2000);
  }
  // Prize break sound
  let prizeSoundBuf=null;
  async function loadPrizeSound(){
    try{
      const res=await fetch('/assets/sounds/glass-bottle-breaking-351297.mp3');
      const arr=await res.arrayBuffer();
      ensureAudio(); if(!audioCtx) return;
      prizeSoundBuf = await audioCtx.decodeAudioData(arr);
    }catch{}
  }
  loadPrizeSound();
  function playPrizeSound(){
    ensureAudio();
    if(!audioCtx || !prizeSoundBuf) return;
    const src=audioCtx.createBufferSource();
    src.buffer=prizeSoundBuf;
    const gain=audioCtx.createGain();
    gain.gain.value=1.0; // boosted volume for point prize sound
    src.connect(gain).connect(masterGain);
    src.start(0);
  }
  const sfxPrize = playPrizeSound;
  let postHitSoundBuf=null;
  async function loadPostHitSound(){
    try{
      // Uses frying-pan-over-the-head-89303.mp3 from webapp/public/assets/sounds
      const res=await fetch('/assets/sounds/frying-pan-over-the-head-89303.mp3');
      const arr=await res.arrayBuffer();
      ensureAudio(); if(!audioCtx) return;
      postHitSoundBuf=await audioCtx.decodeAudioData(arr);
    }catch{}
  }
  loadPostHitSound();
  function playPostHitSound(){
    ensureAudio();
    if(!audioCtx || !postHitSoundBuf) return;
    const src=audioCtx.createBufferSource();
    src.buffer=postHitSoundBuf;
    const gain=audioCtx.createGain();
    gain.gain.value=0.35; // further reduce volume on post/crossbar hits
    src.connect(gain).connect(masterGain);
    // Skip ~0.4s of initial silence so the clang matches contact
    src.start(0, 0.4);
  }
  const sfxPost = playPostHitSound;
  let bombSoundBuf=null;
  async function loadBombSound(){
    try{
      const res=await fetch('/assets/sounds/a-bomb-139689.mp3');
      const arr=await res.arrayBuffer();
      ensureAudio(); if(!audioCtx) return;
      bombSoundBuf = await audioCtx.decodeAudioData(arr);
    }catch{}
  }
  loadBombSound();
  function playBombSound(){
    ensureAudio();
    if(!audioCtx || !bombSoundBuf) return;
    const src=audioCtx.createBufferSource();
    src.buffer=bombSoundBuf;
    const gain=audioCtx.createGain();
    gain.gain.value=1.2;
    src.connect(gain).connect(masterGain);
    src.start(0);
  }
  const sfxExplosion = playBombSound;
  let timerSoundBuf=null;
  async function loadTimerSound(){
    try{
      const res=await fetch('/assets/sounds/clock-ticking-60-second-countdown-118231.mp3');
      const arr=await res.arrayBuffer();
      ensureAudio(); if(!audioCtx) return;
      timerSoundBuf = await audioCtx.decodeAudioData(arr);
    }catch{}
  }
  loadTimerSound();
  function playTimerSound(){
    ensureAudio();
    if(!audioCtx || !timerSoundBuf) return;
    const src=audioCtx.createBufferSource();
    src.buffer=timerSoundBuf;
    const gain=audioCtx.createGain();
    gain.gain.value=1.4;
    src.connect(gain).connect(masterGain);
    src.start(0);
  }
  const sfxTimer = playTimerSound;
  // Ball kick sound
  const BALL_KICK_SOUND = encodeURI('/assets/sounds/ball kick .mp3');
  let ballKickSoundBuf = null;
  async function loadBallKickSound(){
    try{
      const res = await fetch(BALL_KICK_SOUND);
      const arr = await res.arrayBuffer();
      ensureAudio(); if(!audioCtx) return;
      ballKickSoundBuf = await audioCtx.decodeAudioData(arr);
    }catch{}
  }
  loadBallKickSound();
  function playBallKickSound(){
    ensureAudio();
    if(!audioCtx || !ballKickSoundBuf) return;
    const src = audioCtx.createBufferSource();
    src.buffer = ballKickSoundBuf;
    const gain = audioCtx.createGain();
    gain.gain.value = 1.6; // boost volume 60% on kick
    src.connect(gain).connect(masterGain);
    // Play only the first 0.03 seconds of the sound
    src.start(0, 0, 0.03);
  }
  const sfxKick = playBallKickSound;
  let keeperSaveSoundBuf=null;
  async function loadKeeperSaveSound(){
      try{
        const res=await fetch('/assets/sounds/punch-03-352040.mp3');
        const arr=await res.arrayBuffer();
        ensureAudio(); if(!audioCtx) return;
        keeperSaveSoundBuf = await audioCtx.decodeAudioData(arr);
      }catch{}
    }
    loadKeeperSaveSound();
    function playKeeperSaveSound(){
      ensureAudio();
      if(!audioCtx || !keeperSaveSoundBuf) return;
      const src=audioCtx.createBufferSource();
      src.buffer=keeperSaveSoundBuf;
      const gain=audioCtx.createGain();
      gain.gain.value=0.3; // lower volume for keeper saves
      src.connect(gain).connect(masterGain);
      src.start(0);
    }
    // Sound effect for the ball hitting the net when a goal is scored.
    // Uses the "goal net origjinal (2).mp3" asset in webapp/public/assets/sounds.
    const GOAL_SOUND = encodeURI('/assets/sounds/goal net origjinal (2).mp3');
    let goalSoundBuf = null;

  async function loadGoalSound(){
    try {
      const res = await fetch(GOAL_SOUND);
      const arr = await res.arrayBuffer();
      ensureAudio(); if(!audioCtx) return;
      goalSoundBuf = await audioCtx.decodeAudioData(arr);
    } catch {}
  }
  loadGoalSound();

  async function playGoalSound(){
    ensureAudio();
    if(!audioCtx) return;
    if(!goalSoundBuf){
      await loadGoalSound();
      if(!goalSoundBuf) return;
    }
    const src = audioCtx.createBufferSource();
    src.buffer = goalSoundBuf;
    const gain = audioCtx.createGain();
    gain.gain.value = 5.0; // goal sound volume boosted further
    src.connect(gain).connect(masterGain);
    // Play the goal sound from the start of the clip so the net swoosh is always heard
    // regardless of the file's duration. Starting mid‚Äëclip occasionally skipped the
    // audible portion, resulting in no sound on successful goals.
    src.start(0);
  }

  function triggerNetHit(x, y){
    // Pull the net back and add a brief shake on impact.
    netHit.x = x; netHit.y = y;
    netHit.t = Math.max(netHit.t, 1);
    netHit.shake = Math.max(netHit.shake, 1.2);
    ball.trailStopped = true;
  }
  function celebrateGoal(x, y){
    triggerNetHit(x, y);
    if(!ball.goalSounded){ playGoalSound(); ball.goalSounded = true; }
  }
  function showGoal(x, y){
    goalFlash = 1;
    const gx = x ?? geom.goal.x + geom.goal.w / 2;
    const gy = y ?? geom.goal.y + geom.goal.h / 2;
    celebrateGoal(gx, gy);
  }
  window.celebrateGoal = celebrateGoal;
  window.showGoal = showGoal;
  function vibrate(ms){ if(navigator.vibrate) try{ navigator.vibrate(ms); }catch{} }

  // ===== Static draw & tests =====
function drawStaticOnce(){ drawField(); drawAds(); drawGoal(); resetBall(); drawBall(); drawDefenders(); drawMiniBoards(true); }

  // ===== Boot =====
  function startCountdown(n){
    const el=document.createElement('div');
    el.style.position='fixed';
    el.style.inset='0';
    el.style.display='flex';
    el.style.alignItems='center';
    el.style.justifyContent='center';
    el.style.fontSize='72px';
    el.style.fontWeight='800';
    el.style.background='rgba(0,0,0,0.4)';
    el.style.color='#fff';
    document.body.appendChild(el);
    const tick=()=>{
      if(n>0){
        el.textContent=n;
        setTimeout(()=>{ n--; tick(); },1000);
      } else {
        document.body.removeChild(el);
        startGame();
      }
    };
    tick();
  }

  function boot(){
    resize();
    requestAnimationFrame(loop);
    canvas.addEventListener('pointerdown', ()=>{ if(!running||ended) startCountdown(3); ensureAudio(); crowdSound.play().catch(()=>{}); }, {once:false});
    startCountdown(3);
  }

  if (params.get('type') === 'tournament') {
    window.handleTournamentResult = async function (winner) {
      try {
        var st = JSON.parse(localStorage.getItem(STATE_KEY) || '{}');
        if (!st.pendingMatch) {
          window.location.href = '/free-kick-bracket.html?' + window.location.search.slice(1);
          return;
        }
        var r = st.pendingMatch.round;
        var m = st.pendingMatch.match;
        var oppSeed = st.pendingMatch.pair[0] === st.userSeed ? st.pendingMatch.pair[1] : st.pendingMatch.pair[0];
        var winnerSeed = winner === 1 ? st.userSeed : oppSeed;
        var next = st.rounds[r + 1];
        if (next) {
          next[Math.floor(m / 2)][m % 2] = winnerSeed;
        } else {
          st.championSeed = winnerSeed;
          st.complete = true;
        }
        if (winnerSeed !== st.userSeed) {
          simulateRemaining(st, r);
        } else {
          simulateRoundAI(st, r);
          if (next && st.rounds[r].every(function(p, idx){ return next[Math.floor(idx/2)][idx%2]; })) {
            st.currentRound++;
          }
        }
        if (st.complete && winnerSeed === st.userSeed && stake > 0 && accountId) {
        const total = stake * window.tournamentPlayers;
        const prize = Math.round(total * 0.91);
        try {
          await fkApi.depositAccount(accountId, prize, { game: 'freekick-win' });
          if (tgId) await fkApi.addTransaction(tgId, 0, 'win', { game: 'freekick', players: window.tournamentPlayers, accountId });
          const ops = [];
          if (devAccount1 || devAccount2) {
            if (devAccount) ops.push(fkApi.depositAccount(devAccount, Math.round(total*0.09), { game: 'freekick-dev' }));
            if (devAccount1) ops.push(fkApi.depositAccount(devAccount1, Math.round(total*0.01), { game: 'freekick-dev1' }));
            if (devAccount2) ops.push(fkApi.depositAccount(devAccount2, Math.round(total*0.02), { game: 'freekick-dev2' }));
          } else if (devAccount) {
            ops.push(fkApi.depositAccount(devAccount, Math.round(total*0.1), { game: 'freekick-dev' }));
          }
          if (ops.length) await Promise.all(ops);
        } catch {}
        }
        delete st.pendingMatch;
        localStorage.setItem(STATE_KEY, JSON.stringify(st));
        localStorage.removeItem(OPP_KEY);
      } catch (err) {
        console.error(err);
      }
      window.location.href = '/free-kick-bracket.html?' + window.location.search.slice(1);
    };

    function simulateRoundAI(st, round){
      var next = st.rounds[round + 1];
      var userSeed = st.userSeed;
      st.rounds[round].forEach(function(pair, idx){
        if(pair.includes(userSeed)) return;
        if(next && next[Math.floor(idx/2)][idx%2]) return;
        var s1 = pair[0];
        var s2 = pair[1];
        var p1 = st.seedToPlayer[s1];
        var p2 = st.seedToPlayer[s2];
        var w;
        if(p1 && p1.name === 'BYE') w = s2;
        else if(p2 && p2.name === 'BYE') w = s1;
        else w = Math.random() < 0.5 ? s1 : s2;
        if(next){
          next[Math.floor(idx/2)][idx%2] = w;
        } else {
          st.championSeed = w;
          st.complete = true;
        }
      });
    }

    function simulateRemaining(st, startRound){
      for(var r = startRound; r < st.rounds.length; r++){
        simulateRoundAI(st, r);
        if(st.complete) break;
      }
      st.currentRound = st.rounds.length - 1;
      st.complete = true;
    }
  }

  boot();
  document.getElementById('lobbyBtn').addEventListener('click', ()=>{ location.href='/games/freekick/lobby'; });
})();
</script>
<script>
if(window.tournamentMode){
  const tg = window.Telegram?.WebApp;
  function showExitPopup(){
    if(document.getElementById('tournExit')) return;
    const overlay=document.createElement('div');
    overlay.id='tournExit';
    overlay.style.position='fixed';overlay.style.inset='0';
    overlay.style.background='rgba(0,0,0,0.6)';
    overlay.style.display='flex';overlay.style.flexDirection='column';
    overlay.style.alignItems='center';overlay.style.justifyContent='center';
    const box=document.createElement('div');
    box.style.background='#11172a';box.style.padding='20px';box.style.borderRadius='8px';box.style.textAlign='center';box.style.maxWidth='90%';box.style.color='#dbe7ff';
    box.innerHTML='<p style="margin-bottom:12px;">If you quit the tournament, your funds will be lost and you will be placed last.</p>';
    const quit=document.createElement('button');
    quit.textContent='Quit Tournament';
    quit.style.margin='4px';quit.style.padding='8px 12px';
    quit.style.background='#f97316';quit.style.border='none';
    quit.style.borderRadius='4px';quit.style.color='#fff';
    const ret=document.createElement('button');
    ret.textContent='Return to Lobby';
    ret.style.margin='4px';ret.style.padding='8px 12px';
    ret.style.background='#2563eb';ret.style.border='none';
    ret.style.borderRadius='4px';ret.style.color='#fff';
    box.appendChild(quit);box.appendChild(ret);overlay.appendChild(box);document.body.appendChild(overlay);
    quit.onclick=()=>{localStorage.removeItem(STATE_KEY);localStorage.removeItem(OPP_KEY);if(tg) tg.BackButton.hide();window.location.href='/games/freekick/lobby';};
    ret.onclick=()=>{if(tg) tg.BackButton.show();window.location.href='/free-kick-bracket.html'+window.location.search;};
  }
  if(tg){ tg.BackButton.show(); tg.onEvent('backButtonClicked', showExitPopup); tg.onEvent('close', showExitPopup); }
  history.pushState(null,'',location.href);
  window.addEventListener('popstate',(e)=>{ e.preventDefault(); showExitPopup(); history.pushState(null,'',location.href); });
}
</script>
</body>
</html>
