<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, viewport-fit=cover" />
  <title>Goal Rush</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Luckiest+Guy&display=swap" rel="stylesheet">
  <style>
    :root{
      --bg:#050812;
      --field:#228B22;
      --line:#ffffff;
      --goal:#fff;
      --p1:#22c55e;
      --p2:#f59e0b;
      --puck:#e5e7eb;
    }
    *{box-sizing:border-box; -webkit-tap-highlight-color: transparent;}
    html,body{height:100vh;height:100dvh;overscroll-behavior:none;}
    body{margin:0;background:var(--bg);color:#e5e7eb;font-family:'Luckiest Guy','Comic Sans MS',cursive;overflow:hidden}
    .ui{position:fixed;inset:0;}
    .scoreboard{position:absolute;top:0;left:0;right:0;height:48px;display:flex;align-items:center;justify-content:center;pointer-events:none;}
    .score{font-variant-numeric:tabular-nums;background:#0b1220;border:1px solid #233050;border-radius:12px;padding:6px 10px;display:flex;align-items:center;gap:8px;-webkit-text-stroke:0.3px #000;text-shadow:0 0 4px #000;color:#fff}
    .score span{-webkit-text-stroke:0.3px #000;text-shadow:0 0 4px #000;color:#fff}
    .score-player{display:flex;align-items:center;gap:6px;min-width:0;}
    .score-avatar{width:32px;height:32px;border-radius:999px;background:#111;border:1px solid #233050;display:grid;place-items:center;font-size:18px;overflow:hidden;color:#fff;flex-shrink:0;}
    .score-avatar.img{background-size:cover;background-position:center;text-indent:-9999px;}
    .badge{padding:2px 8px;border-radius:999px;font-weight:800;color:#fff;-webkit-text-stroke:0.3px #000;text-shadow:0 0 4px #000;white-space:nowrap;}
    .p1{background:var(--p1)}
    .p2{background:var(--p2)}

    .canvasWrap{
      position:absolute;
      top:48px;
      bottom:0;
      left:0;
      right:0;
      display:flex;
      align-items:center;
      justify-content:center;
    }
    canvas{
      display:block;
      touch-action:none;
      width:100%;
      height:auto;
      max-height:100%;
      aspect-ratio:720/1280;
      transform-origin:center;
      transform:scale(0);
      transition:transform .5s ease,width .3s ease,height .3s ease;
    }

    body.loaded canvas{transform:scale(1)}


    .hint{position:fixed;inset:0;display:none;align-items:center;justify-content:center;margin:auto;max-width:680px;background:rgba(10,16,34,.6);backdrop-filter:blur(6px);border:1px solid #1f2944;border-radius:12px;padding:8px 12px;text-align:center;font-size:.9rem}

    #quickActions{position:fixed;left:calc(0.75rem + env(safe-area-inset-left,0px));bottom:calc(env(safe-area-inset-bottom,0px) + 1rem);display:flex;flex-direction:column;gap:.6rem;z-index:6;pointer-events:auto;}
    #quickActions .quick-action{width:3.15rem;height:3.15rem;border-radius:14px;background:rgba(0,0,0,.6);border:1px solid rgba(255,255,255,.18);color:#fff;display:flex;flex-direction:column;align-items:center;justify-content:center;gap:.25rem;box-shadow:0 8px 18px rgba(0,0,0,.35);backdrop-filter:blur(8px);padding:0;}
    #quickActions .quick-action span{font-size:.6rem;font-weight:800;letter-spacing:.08em;text-transform:uppercase;}
    #quickActions .quick-action .icon{font-size:1.1rem;line-height:1;}
    .modal-overlay{position:fixed;inset:0;background:rgba(0,0,0,.7);display:none;align-items:center;justify-content:center;z-index:7;}
    .modal-overlay.active{display:flex;}
    .modal-card{width:min(340px, 88vw);background:#0b1220;border:1px solid #233050;border-radius:16px;padding:1rem;color:#e5e7eb;box-shadow:0 18px 40px rgba(0,0,0,.5);display:flex;flex-direction:column;gap:.75rem;}
    .modal-header{display:flex;align-items:center;justify-content:space-between;gap:.5rem;}
    .modal-header h3{margin:0;font-size:1rem;letter-spacing:.04em;}
    .modal-close{background:rgba(255,255,255,.1);border:1px solid rgba(255,255,255,.15);border-radius:999px;width:2rem;height:2rem;display:grid;place-items:center;color:#fff;padding:0;}
    .quick-messages{display:grid;grid-template-columns:repeat(2,minmax(0,1fr));gap:.45rem;max-height:12rem;overflow:auto;}
    .quick-messages button{font-size:.7rem;padding:.4rem;border-radius:10px;border:1px solid rgba(255,255,255,.12);background:rgba(15,23,42,.55);color:#e2e8f0;font-weight:700;}
    .quick-messages button.active{border-color:rgba(34,197,94,.8);background:rgba(34,197,94,.2);color:#eafff0;}
    .modal-primary{width:100%;padding:.6rem 1rem;border-radius:12px;background:linear-gradient(135deg, rgba(34,197,94,.95), rgba(16,185,129,.85));color:#04210f;font-weight:800;border:1px solid rgba(34,197,94,.6);}
    .gift-players{display:flex;flex-direction:column;gap:.4rem;max-height:8.5rem;overflow:auto;}
    .gift-players button{display:flex;align-items:center;gap:.5rem;border-radius:10px;border:1px solid rgba(255,255,255,.12);background:rgba(15,23,42,.55);color:#e2e8f0;padding:.35rem .5rem;font-size:.72rem;font-weight:700;}
    .gift-players button.active{border-color:rgba(34,197,94,.8);background:rgba(34,197,94,.2);}
    .gift-players img{width:1.25rem;height:1.25rem;border-radius:999px;object-fit:cover;}
    .gift-tier{display:flex;flex-direction:column;gap:.35rem;}
    .gift-tier h4{margin:0;font-size:.7rem;letter-spacing:.18em;text-transform:uppercase;color:rgba(226,232,240,.7);}
    .gift-grid{display:grid;grid-template-columns:repeat(2,minmax(0,1fr));gap:.4rem;}
    .gift-button{display:flex;align-items:center;justify-content:space-between;gap:.3rem;border-radius:10px;border:1px solid rgba(255,255,255,.12);background:rgba(15,23,42,.55);color:#e2e8f0;padding:.35rem .5rem;font-size:.7rem;font-weight:700;}
    .gift-button.active{border-color:rgba(245,158,11,.75);background:rgba(245,158,11,.15);}
    .gift-button img{width:1rem;height:1rem;}
    .gift-cost{display:flex;align-items:center;justify-content:center;gap:.35rem;font-size:.7rem;color:rgba(226,232,240,.9);}
    .gift-cost img{width:.9rem;height:.9rem;}
    .gift-note{font-size:.6rem;line-height:1.4;text-align:center;color:rgba(226,232,240,.7);}
    .commentary-options{display:grid;grid-template-columns:repeat(1,minmax(0,1fr));gap:.4rem;max-height:12rem;overflow:auto;}
    .commentary-options button{font-size:.7rem;padding:.45rem;border-radius:12px;border:1px solid rgba(255,255,255,.12);background:rgba(15,23,42,.55);color:#e2e8f0;font-weight:700;text-align:left;}
    .commentary-options button.active{border-color:rgba(34,197,94,.8);background:rgba(34,197,94,.2);color:#eafff0;}
    .commentary-toggle{display:flex;align-items:center;justify-content:space-between;gap:.5rem;border-radius:999px;border:1px solid rgba(255,255,255,.12);background:rgba(15,23,42,.55);color:#e2e8f0;font-size:.7rem;font-weight:700;padding:.5rem .75rem;}
    .commentary-toggle.active{border-color:rgba(34,197,94,.8);background:rgba(34,197,94,.2);color:#eafff0;}
    .chat-bubble{position:fixed;display:flex;align-items:center;gap:.35rem;padding:.35rem .6rem;border-radius:999px;background:rgba(8,13,26,.88);border:1px solid rgba(255,255,255,.12);color:#f8fafc;font-size:.7rem;font-weight:700;box-shadow:0 10px 24px rgba(0,0,0,.45);z-index:7;pointer-events:none;white-space:nowrap;}
    .chat-bubble img,.chat-bubble .avatar{width:1.2rem;height:1.2rem;border-radius:999px;display:grid;place-items:center;background:rgba(255,255,255,.2);font-size:.75rem;}
    .toast{position:fixed;left:50%;bottom:calc(env(safe-area-inset-bottom,0px) + 4.5rem);transform:translateX(-50%);padding:.4rem .75rem;border-radius:999px;background:rgba(15,23,42,.8);border:1px solid rgba(255,255,255,.18);color:#f8fafc;font-size:.72rem;font-weight:700;z-index:7;box-shadow:0 10px 24px rgba(0,0,0,.45);pointer-events:none;}
    #rules{position:fixed;top:0;left:0;right:0;bottom:0;display:none;align-items:center;justify-content:center;background:rgba(5,8,18,.75);z-index:6;backdrop-filter:blur(2px);}
    #rules .card{max-width:720px;background:#0b1220;color:#e5e7eb;border-radius:16px;box-shadow:0 18px 38px rgba(0,0,0,.45);padding:16px 18px;border:1px solid #233050;}
    #rules h2{margin:0 0 6px 0;font-size:18px;letter-spacing:0.35px;}
    #rules ol{margin:6px 0 0 18px;color:#94a3b8;}
    #rules .row{display:flex;gap:8px;justify-content:flex-end;margin-top:12px}

    .coin-confetti{position:fixed;top:-40px;width:32px;height:32px;pointer-events:none;animation:coin-fall var(--duration,3s) linear forwards}
    @keyframes coin-fall{from{transform:translateY(-10vh) rotate(0deg);opacity:1}to{transform:translateY(100vh) rotate(360deg);opacity:0}}

      .goal-text{position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);font-size:48px;font-weight:800;color:var(--goal);text-align:center;display:none;pointer-events:none;line-height:1.1;-webkit-text-stroke:2px #000;text-shadow:-2px -2px 0 #000,2px -2px 0 #000,-2px 2px 0 #000,2px 2px 0 #000}
      .goal-text.own-goal{color:#ff0000;-webkit-text-stroke:2px #fff;text-shadow:-2px -2px 0 #fff,2px -2px 0 #fff,-2px 2px 0 #fff,2px 2px 0 #fff}
      .goal-text .score-line{display:block;font-size:32px;font-weight:600}
      .post-text{position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);font-size:48px;font-weight:800;color:#facc15;text-align:center;display:none;pointer-events:none;line-height:1.1;-webkit-text-stroke:2px #000;text-shadow:-2px -2px 0 #000,2px -2px 0 #000,-2px 2px 0 #000,2px 2px 0 #000}
      .lobby-btn{padding:8px;background:#00f7ff;color:#fff;border:none;border-radius:8px;font-size:14px;font-weight:600;-webkit-text-stroke:0.5px #000;text-shadow:-1px -1px 0 #000,1px -1px 0 #000,-1px 1px 0 #000,1px 1px 0 #000;cursor:pointer}
      .lobby-btn:hover{background:#66fcff}

    @media (orientation:landscape){
      .landscape-block{position:fixed;inset:0;display:flex;align-items:center;justify-content:center;background:#0008;z-index:20;color:#fff;text-align:center;padding:24px}
    }
  </style>
</head>
<body>
  <div class="ui">
    <div class="scoreboard">
      <div class="score" aria-live="polite">
        <div class="score-player">
          <span id="p1AvatarTop" class="score-avatar" aria-hidden="true"></span>
          <span id="p1Name" class="badge p1">P1</span>
        </div>
        <span id="s1">0</span>
        <span>‚Äî</span>
        <span id="s2">0</span>
        <div class="score-player">
          <span id="p2Name" class="badge p2">P2</span>
          <span id="p2AvatarTop" class="score-avatar" aria-hidden="true"></span>
        </div>
      </div>
    </div>
    <div id="quickActions" aria-label="Quick actions">
      <button class="quick-action" type="button" data-action="chat">
        <span class="icon" aria-hidden="true">üí¨</span>
        <span>Chat</span>
      </button>
      <button class="quick-action" type="button" data-action="gift">
        <span class="icon" aria-hidden="true">üéÅ</span>
        <span>Gift</span>
      </button>
      <button class="quick-action" type="button" data-action="info">
        <span class="icon" aria-hidden="true">‚ÑπÔ∏è</span>
        <span>Info</span>
      </button>
      <button class="quick-action" type="button" data-action="commentary">
        <span class="icon" aria-hidden="true">üéôÔ∏è</span>
        <span>Audio</span>
      </button>
      <button class="quick-action" type="button" data-action="mute">
        <span class="icon" id="muteIcon" aria-hidden="true">üîä</span>
        <span id="muteLabel">Mute</span>
      </button>
    </div>
    <div class="canvasWrap">
      <canvas id="game" width="720" height="1280" aria-label="Goal Rush Field"></canvas>
    </div>
      <div id="goalText" class="goal-text"></div>
      <div id="postText" class="post-text"></div>
  </div>
  <div id="rules">
    <div class="card">
      <h2>Goal Rush ‚Äî How to Play</h2>
      <ol>
        <li><b>Objective:</b> Score by hitting the puck into the opponent goal first.</li>
        <li><b>Control:</b> Drag your paddle in your half; aim shots by building momentum.</li>
        <li><b>Kickoff:</b> The puck drops center after every goal.</li>
        <li><b>Defend:</b> Keep your paddle between the puck and your goal to block.</li>
      </ol>
      <div class="row">
        <button id="closeRules" type="button">Close</button>
      </div>
    </div>
  </div>
  <div id="chatModal" class="modal-overlay" aria-hidden="true">
    <div class="modal-card" role="dialog" aria-modal="true" aria-labelledby="chatTitle">
      <div class="modal-header">
        <h3 id="chatTitle">Quick Chat</h3>
        <button class="modal-close" id="chatClose" type="button" aria-label="Close chat">‚úï</button>
      </div>
      <div class="quick-messages" id="chatMessages"></div>
      <button class="modal-primary" id="chatSend" type="button">Send</button>
    </div>
  </div>
  <div id="giftModal" class="modal-overlay" aria-hidden="true">
    <div class="modal-card" role="dialog" aria-modal="true" aria-labelledby="giftTitle">
      <div class="modal-header">
        <h3 id="giftTitle">Send Gift</h3>
        <button class="modal-close" id="giftClose" type="button" aria-label="Close gifts">‚úï</button>
      </div>
      <div class="gift-players" id="giftPlayers"></div>
      <div id="giftTiers"></div>
      <div class="gift-cost">
        <span>Cost:</span>
        <span id="giftCost">0</span>
        <img src="/assets/icons/ezgif-54c96d8a9b9236.webp" alt="TPC" />
      </div>
      <button class="modal-primary" id="giftSend" type="button">Send Gift</button>
      <p class="gift-note">10% charge and the amount of the gift will be deducted from your balance.</p>
    </div>
  </div>
  <div id="commentaryModal" class="modal-overlay" aria-hidden="true">
    <div class="modal-card" role="dialog" aria-modal="true" aria-labelledby="commentaryTitle">
      <div class="modal-header">
        <h3 id="commentaryTitle">Commentary</h3>
        <button class="modal-close" id="commentaryClose" type="button" aria-label="Close commentary">‚úï</button>
      </div>
      <button class="commentary-toggle" id="commentaryMute" type="button">
        <span>Mute commentary</span>
        <span id="commentaryMuteState">Off</span>
      </button>
      <p class="gift-note" id="commentarySupportNote" style="display:none;">Voice commentary needs Web Speech support.</p>
    </div>
  </div>
  <div class="hint" id="startHint"></div>
  <div class="landscape-block" style="display:none">Please hold your phone in <b>portrait</b> for the best experience.</div>


<script src="/goal-rush-api.js"></script>
<script src="/flag-emojis.js"></script>
<script>
(async () => {
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  const s1El = document.getElementById('s1');
  const s2El = document.getElementById('s2');
  const p1NameEl = document.getElementById('p1Name');
  const p2NameEl = document.getElementById('p2Name');
  const p1AvatarTop = document.getElementById('p1AvatarTop');
  const p2AvatarTop = document.getElementById('p2AvatarTop');
  const startHint = document.getElementById('startHint');
  const landscapeBlock = document.querySelector('.landscape-block');
  const goalText = document.getElementById('goalText');
  const postText = document.getElementById('postText');
  const quickActions = document.getElementById('quickActions');
  const chatModal = document.getElementById('chatModal');
  const chatMessagesEl = document.getElementById('chatMessages');
  const chatSend = document.getElementById('chatSend');
  const chatClose = document.getElementById('chatClose');
  const giftModal = document.getElementById('giftModal');
  const giftPlayersEl = document.getElementById('giftPlayers');
  const giftTiersEl = document.getElementById('giftTiers');
  const giftSend = document.getElementById('giftSend');
  const giftClose = document.getElementById('giftClose');
  const commentaryModal = document.getElementById('commentaryModal');
  const commentaryOptionsEl = document.getElementById('commentaryOptions');
  const commentaryClose = document.getElementById('commentaryClose');
  const commentaryMuteButton = document.getElementById('commentaryMute');
  const commentaryMuteState = document.getElementById('commentaryMuteState');
  const commentarySupportNote = document.getElementById('commentarySupportNote');
  const muteIcon = document.getElementById('muteIcon');
  const muteLabel = document.getElementById('muteLabel');
  const panelRules = document.getElementById('rules');
  const closeRules = document.getElementById('closeRules');
  const TOP_BAR = 40; // height of scoreboard bar
  const BOTTOM_GAP = 0; // gap below rink
  const GOAL_PAUSE = 1500; // pause after a goal
  let fieldScaleActual = 1;

  const puckImg = new Image();
  puckImg.src = '/assets/icons/file_0000000061d4620aaf506adfa605e1f3.webp';
  let puckImgLoaded = false;
  puckImg.onload = () => { puckImgLoaded = true; };
  puckImg.onerror = () => { puckImgLoaded = false; };

  const params = new URLSearchParams(location.search);
  const tgKey = params.get("tgId") || "anon";
  const TOURN_STATE_KEY = `goalRushTournamentState_${tgKey}`;
  const TOURN_OPP_KEY = `goalRushTournamentOpponent_${tgKey}`;
  const playType = params.get('type') || 'regular';
  window.tournamentMode = playType === 'tournament';
  window.tournamentPlayers = window.tournamentMode
    ? parseInt(params.get('players') || '0', 10)
    : 0;
  const stake = Number(params.get('amount')) || 0;
  let myAccountId = params.get('accountId');
  if (!myAccountId) {
    try { myAccountId = localStorage.getItem('accountId'); } catch {}
  }
  if (!myAccountId) {
    myAccountId = crypto.randomUUID();
    try { localStorage.setItem('accountId', myAccountId); } catch {}
  }
  const devAccount = params.get('dev');
  const devAccount1 = params.get('dev1');
  const devAccount2 = params.get('dev2');
  const tgId = params.get('tgId');
  const initParam = params.get('init');
  if (initParam && !window.Telegram) {
    window.Telegram = { WebApp: { initData: decodeURIComponent(initParam) } };
  }
  const oppAccountId = params.get('oppAcc') || params.get('oppId') || params.get('p2AccountId');
  const oppTgId = params.get('oppTg') || params.get('p2TgId');
  const mode = params.get('mode') || 'ai';
  const difficulty = 'normal';
  const target = Number(params.get('target')) || 3;
  const avatarParam = params.get('avatar') || '';
  const oppParam = params.get('p2Avatar') || '';
  const playerFlagParam = params.get('flag') || '';
  const aiFlagParam = params.get('aiFlag') || '';
  let p1Name = params.get('name') || 'P1';
  let p2Name = params.get('p2Name') || 'P2';
    let fieldScaleX = 1,
      fieldScaleY = 1,
      puckScale = 1.1,
      goalWidthPct = 0.36,
      goalOffsetXPct = 0,
      goalOffsetYPct = 0,
      paddleScale = 0.9,
      speedMul = 0.95;

  async function loadCalibration() {
    try {
      const res = await fetch('/goal-rush-calibration.json');
      const cfg = await res.json();
      fieldScaleX = cfg.fieldScaleX ?? fieldScaleX;
      fieldScaleY = cfg.fieldScaleY ?? fieldScaleY;
      puckScale = cfg.puckScale ?? puckScale;
      goalWidthPct = cfg.goalWidthPct ?? goalWidthPct;
      goalOffsetXPct = cfg.goalOffsetXPct ?? goalOffsetXPct;
      goalOffsetYPct = cfg.goalOffsetYPct ?? goalOffsetYPct;
      paddleScale = cfg.paddleScale ?? paddleScale;
      speedMul = cfg.speedMul ?? speedMul;
    } catch {}
  }

  await loadCalibration();

  let currentRound = 0;
  if(window.tournamentMode){
    try{
      const st = JSON.parse(localStorage.getItem(TOURN_STATE_KEY) || '{}');
      currentRound = st.currentRound || 0;
    }catch{}
    speedMul += currentRound * 0.05;
  }

  const regionNames = new Intl.DisplayNames(['en'], { type: 'region' });
  function flagToName(flag){
    try{
      const codes = Array.from(flag).map(c => c.codePointAt(0) - 0x1F1E6 + 65);
      return regionNames.of(String.fromCharCode(...codes)) || 'CPU';
    }catch{
      return 'CPU';
    }
  }
  const FLAG_DATA = (window.FLAG_EMOJIS || []).map(f => ({
    emoji: f,
    name: flagToName(f)
  }));

  let p1AvatarImg=null, p1AvatarEmoji=null;
  if(avatarParam){
    if(avatarParam.startsWith('http') || avatarParam.startsWith('/')){ p1AvatarImg = new Image(); p1AvatarImg.src = avatarParam; }
    else { p1AvatarEmoji = avatarParam; }
  }
  if(!p1AvatarImg && !p1AvatarEmoji && playerFlagParam){
    p1AvatarEmoji = playerFlagParam;
  }
  let p2AvatarImg=null, p2AvatarEmoji='ü§ñ';
  if(oppParam){
    if(oppParam.startsWith('http') || oppParam.startsWith('/')){ p2AvatarImg = new Image(); p2AvatarImg.src = oppParam; p2AvatarEmoji=null; }
    else { p2AvatarEmoji = oppParam; }
  }
  if(window.tournamentMode){
    try{
      const opp = JSON.parse(localStorage.getItem(TOURN_OPP_KEY) || '{}');
      if(opp.flag) p2AvatarEmoji = opp.flag;
      if(opp.name) p2Name = opp.name;
    }catch{}
  }

  if(mode==='ai'){
    const chosenAi = aiFlagParam
      ? { emoji: aiFlagParam, name: flagToName(aiFlagParam) }
      : FLAG_DATA[Math.floor(Math.random()*FLAG_DATA.length)] || { emoji: 'ü§ñ', name: 'CPU' };
    p2AvatarImg = null;
    p2AvatarEmoji = chosenAi.emoji;
    p2Name = chosenAi.name;
  }
  p1NameEl.textContent = p1Name;
  p2NameEl.textContent = p2Name;
  function renderTopAvatar(el,img,emoji,colorVar){
    if(!el) return;
    el.classList.remove('img');
    el.style.backgroundImage='';
    el.textContent='';
    const bg = colorVar ? getCSS(colorVar) || '#111' : '#111';
    el.style.backgroundColor = bg;
    if(img && img.complete && img.naturalWidth>0){
      el.classList.add('img');
      el.style.backgroundImage=`url(${img.src})`;
      return;
    }
    if(emoji){
      el.textContent = emoji;
    }
  }
  function updateTopAvatars(){
    renderTopAvatar(p1AvatarTop, p1AvatarImg, p1AvatarEmoji, '--p1');
    renderTopAvatar(p2AvatarTop, p2AvatarImg, p2AvatarEmoji, '--p2');
  }
  if(p1AvatarImg){ p1AvatarImg.onload = updateTopAvatars; }
  if(p2AvatarImg){ p2AvatarImg.onload = updateTopAvatars; }
  updateTopAvatars();

  async function awardTpc(accountId, amount){
    try{
      await grApi.depositAccount(accountId, amount, { game: 'goalrush-win' });
    }catch(err){ console.warn('Failed to award TPC',err); }
  }
  async function recordWin(tgId, accountId){
    if(!tgId) return;
    try{
      await grApi.addTransaction(tgId, 0, 'win', { game:'goalrush', players:2, accountId });
    }catch{}
  }
  async function awardDevShare(total){
    const ops=[];
    if(devAccount1||devAccount2){
      if(devAccount) ops.push(grApi.depositAccount(devAccount, Math.round(total*0.09), {game:'goalrush-dev'}));
      if(devAccount1) ops.push(grApi.depositAccount(devAccount1, Math.round(total*0.01), {game:'goalrush-dev1'}));
      if(devAccount2) ops.push(grApi.depositAccount(devAccount2, Math.round(total*0.02), {game:'goalrush-dev2'}));
    }else if(devAccount){
      ops.push(grApi.depositAccount(devAccount, Math.round(total*0.1), {game:'goalrush-dev'}));
    }
    if(ops.length){ try{ await Promise.all(ops); }catch{} }
  }

  function coinConfetti(count=50,iconSrc='/assets/icons/ezgif-54c96d8a9b9236.webp'){
    const container=document.createElement('div');
    container.style.position='fixed';container.style.top='0';container.style.left='0';
    container.style.width='100%';container.style.height='0';container.style.pointerEvents='none';
    container.style.zIndex='60';container.style.overflow='visible';
    document.body.appendChild(container);
    for(let i=0;i<count;i++){
      const img=document.createElement('img');
      img.src=iconSrc;img.alt='confetti icon';img.className='coin-confetti';
      const left=Math.random()*100;const delay=Math.random()*0.2;const duration=2+Math.random()*2;
      img.style.left=left+'vw';img.style.animationDelay=delay+'s';img.style.setProperty('--duration',duration+'s');
      container.appendChild(img);
    }
    setTimeout(()=>container.remove(),5000);
  }

  async function chargeStake(){
    if(!tgId || stake<=0) return;
    try{
      await grApi.addTransaction(tgId, -stake, 'stake', { game:'goalrush', players:2, accountId: myAccountId });
    }catch{}
  }

  function celebrate(winner,avatarImg,avatarEmoji){
    coinConfetti();
    let audio;
    try{
      audio=new Audio('/assets/sounds/11l-victory_sound_with_t-1749487412779-357604.mp3');
      if(audioEnabled) audio.play().catch(()=>{});
    }catch{}
    const overlay=document.createElement('div');
    overlay.style.position='fixed';overlay.style.inset='0';overlay.style.display='flex';overlay.style.flexDirection='column';
    overlay.style.alignItems='center';overlay.style.justifyContent='center';overlay.style.background='rgba(0,0,0,0.7)';overlay.style.zIndex='40';
    const av=document.createElement('div');
    av.style.fontSize='64px';av.style.width='80px';av.style.height='80px';av.style.display='flex';
    av.style.alignItems='center';av.style.justifyContent='center';av.style.borderRadius='50%';av.style.background='#fff';
    if(avatarImg && avatarImg.complete){av.style.backgroundImage=`url(${avatarImg.src})`;av.style.backgroundSize='cover';av.textContent='';}
    else{av.textContent=avatarEmoji||'';}
    const scoreLine=document.createElement('div');
    scoreLine.textContent=`${score.p1}-${score.p2}`;scoreLine.style.color='#fff';scoreLine.style.marginTop='12px';scoreLine.style.fontSize='1.5rem';
    const txt=document.createElement('div');
    txt.textContent=`${winner} Wins!`;txt.style.color='#fff';txt.style.fontSize='2rem';txt.style.marginTop='8px';txt.style.fontWeight='bold';
    overlay.appendChild(av);overlay.appendChild(scoreLine);overlay.appendChild(txt);document.body.appendChild(overlay);
    setTimeout(()=>{overlay.remove();showEndPopup();if(audio) audio.pause();},2500);
  }

  function showEndPopup(){
    const pop=document.createElement('div');
    pop.style.position='fixed';pop.style.inset='0';pop.style.display='flex';pop.style.alignItems='center';pop.style.justifyContent='center';pop.style.background='rgba(0,0,0,0.7)';pop.style.zIndex='50';
    const box=document.createElement('div');
    box.style.background='#0b1220';box.style.padding='16px';box.style.borderRadius='12px';box.style.display='flex';box.style.flexDirection='column';box.style.gap='8px';box.style.minWidth='200px';
    const btnLobby=document.createElement('button');btnLobby.textContent='Return to Lobby';btnLobby.className='lobby-btn';btnLobby.onclick=()=>{location.href='/games/goalrush/lobby';};
    box.appendChild(btnLobby);pop.appendChild(box);document.body.appendChild(pop);
  }

  let W = 720, H = 1280, goalCenterX = 0, goalTopY = 0, goalBottomY = 0;
  function fit(){
    const ratio = 1280 / 720;
    const maxWidth = window.innerWidth;
    const maxHeight = window.innerHeight - TOP_BAR - BOTTOM_GAP;
    let width = maxWidth;
    let height = width * ratio;
    if (height > maxHeight) {
      height = maxHeight;
      width = height / ratio;
    }
    W = canvas.width = Math.floor(width * devicePixelRatio);
    H = canvas.height = Math.floor(height * devicePixelRatio);
    canvas.style.width = width + 'px';
    canvas.style.height = height + 'px';
    // expand field by reducing canvas margins ~5% on each side
    const baseW = W * 0.98;
    const baseH = H * 0.98;
    const maxFieldScaleX = W/baseW;
    const maxFieldScaleY = H/baseH;
    const fsx = Math.min(fieldScaleX, maxFieldScaleX);
    const fsy = Math.min(fieldScaleY, maxFieldScaleY);
    fieldScaleActual = Math.min(fsx, fsy);
    rink.w = Math.round(baseW * fsx);
    rink.h = Math.round(baseH * fsy);
    rink.x = Math.round((W - rink.w) / 2);
    rink.y = Math.round((H - rink.h) / 2);
    centerX = W/2; centerY = H/2;
    goalCenterX = centerX + rink.w * goalOffsetXPct;
    goalTopY = rink.y + rink.h * goalOffsetYPct;
    goalBottomY = goalTopY + rink.h;
    try{
      localStorage.setItem('goalTopY', goalTopY);
      localStorage.setItem('goalBottomY', goalBottomY);
    }catch{}
    goalWidth = Math.round(W*goalWidthPct*fsx);
    const base = Math.max(24, Math.round(Math.min(W,H)*0.035*fieldScaleActual));
    paddleRadius = base*3.4*paddleScale;
    puck.r = Math.max(24, Math.round(base*1.3*puckScale));
    p1.r = paddleRadius; p2.r = paddleRadius;
  }
  window.addEventListener('resize', fit);

  const rink = { x:0,y:0,w:0,h:0,r:24 };
  let centerX = 0, centerY = 0;
  let goalWidth = 260;
  let goalDepth = 24;
  let paddleRadius = 34;

  const puck = { x:0, y:0, r:26, vx:0, vy:0, max: 32, angle: 0, spin: 0 };
  const p1 = { x:0, y:0, r:34, vx:0, vy:0, max: 17, lastX:0, lastY:0 };
  const p2 = { x:0, y:0, r:34, vx:0, vy:0, max: 17, lastX:0, lastY:0 };
  const score = { p1:0, p2:0, target };
  let running = true; let last = 0;
  let lastTouch = null;
  let cornerEscapeFrames = 0;
  const difficultySpeeds = { easy:11, normal:14, hard:20 };
  p2.max = (difficultySpeeds[difficulty] || 15) + currentRound * 2;

  let audioEnabled = true;
  let audioStarted = false;
  const crowdSound = new Audio('/assets/sounds/football-crowd-3-69245.mp3');
  crowdSound.loop = true;
  const whistleSound = new Audio('/assets/sounds/metal-whistle-6121.mp3');
  const goalNetSound = new Audio('/assets/sounds/a-football-hits-the-net-goal-313216.mp3');
  const postHitSound = new Audio('/assets/sounds/frying-pan-over-the-head-89303.mp3');
  postHitSound.volume = 0.7; // 30% lower volume on post/crossbar hits
  const crowdBaseVolume = 0.5;
  crowdSound.volume = crowdBaseVolume;
  let pendingWhistle = false;

  function playWhistle(){
    if(!audioEnabled || !audioStarted){ pendingWhistle = true; return; }
    pendingWhistle = false;
    whistleSound.currentTime = 0;
    whistleSound.play().catch(()=>{});
    setTimeout(()=>{ whistleSound.pause(); whistleSound.currentTime = 0; },2000);
  }

  function initAudio(){
    if(audioStarted || !audioEnabled) return;
    audioStarted = true;
    crowdSound.play().catch(()=>{});
    unlockCommentary();
    if(pendingWhistle) playWhistle();
  }

  function setAudioEnabled(nextEnabled) {
    audioEnabled = nextEnabled;
    updateQuickActionMute();
    if(audioEnabled){
      if(!audioStarted) initAudio();
      else crowdSound.play().catch(()=>{});
    }else{
      crowdSound.pause();
      whistleSound.pause();
    }
  }


  const sfx = {
    hit(){
      if(!audioEnabled) return;
      const snd = new Audio('/assets/sounds/football-game-sound-effects-359284.mp3');
      snd.play().catch(()=>{});
      setTimeout(()=>{ snd.pause(); },700);
    },
    wall(){},
    post(){
      if(!audioEnabled) return;
      // Skip ~0.15s of initial silence so the clang matches contact
      postHitSound.currentTime = 0.15;
      postHitSound.play().catch(()=>{});
      setTimeout(()=>{
        postHitSound.pause();
        postHitSound.currentTime = 0.15;
      },1000);
    },
    goal(){
      if(!audioEnabled) return;
      goalNetSound.currentTime = 0;
      goalNetSound.play().catch(()=>{});
      setTimeout(()=>{
        goalNetSound.pause();
        goalNetSound.currentTime = 0;
      },2000);
      playWhistle();
    }
  };

  /* ---------- Commentary (multi-language, professional) ---------- */
  const GOAL_RUSH_SPEAKERS = Object.freeze({
    lead: 'Kai',
    analyst: 'Sofia'
  });

  const COMMENTARY_EVENTS = Object.freeze({
    intro: 'intro',
    introReply: 'introReply',
    kickoff: 'kickoff',
    goal: 'goal',
    ownGoal: 'ownGoal',
    post: 'post',
    save: 'save',
    counter: 'counter',
    pressure: 'pressure',
    leadChange: 'leadChange',
    equalizer: 'equalizer',
    matchPoint: 'matchPoint',
    matchWin: 'matchWin',
    outro: 'outro'
  });

  const DEFAULT_COMMENTARY_CONTEXT = Object.freeze({
    player: 'Player A',
    opponent: 'Player B',
    playerScore: 0,
    opponentScore: 0,
    scoreline: '0-0',
    arena: 'Goal Rush arena',
    targetScore: 3
  });

  const ENGLISH_COMMENTARY = Object.freeze({
    common: {
      intro: [
        'Welcome to {arena}. {speaker} here with you. {player} faces {opponent}‚Äî{scoreline}.',
        'Match time at {arena}. {speaker} on the mic. {player} versus {opponent}, score {scoreline}.'
      ],
      introReply: [
        'Thanks {speaker}. It is all about quick reads, clean touches, and smart angles.',
        'Great to be here, {speaker}. Pace and positioning will decide this one.'
      ],
      kickoff: [
        'Kickoff underway. First touch matters in Goal Rush.',
        'Puck drops center‚Äîearly control is everything.'
      ],
      goal: [
        'Goal for {player}! That was laser-accurate finishing.',
        '{player} scores! Clean strike, no doubt about it.',
        '{player} finds the net. Clinical execution.'
      ],
      ownGoal: [
        'Own goal. A brutal deflection against {player}.',
        'Unfortunate own goal‚Äî{player} will want that back.'
      ],
      post: [
        'Off the post! Inches away from a highlight.',
        'Rattled the post‚Äîno goal this time.'
      ],
      save: [
        'Big save by {opponent}. Brilliant reaction.',
        '{opponent} shuts the door with a strong stop.'
      ],
      counter: [
        'Quick counter‚Äî{player} is flying into space.',
        'Transition chance for {player}; this is dangerous.'
      ],
      pressure: [
        'High-pressure moment for {player}; they need precision here.',
        '{player} under pressure‚Äîtouch and timing are key.'
      ],
      leadChange: [
        '{player} takes the lead. Momentum swings fast in Goal Rush.',
        'Lead change! {player} moves in front.'
      ],
      equalizer: [
        'Equalizer! {player} drags it level.',
        'We are level again‚Äî{player} answers back.'
      ],
      matchPoint: [
        '{player} is on match point. One more goal seals it.',
        'Match point for {player}. The finish line is in sight.'
      ],
      matchWin: [
        'Full time. {player} wins it {scoreline}.',
        '{player} takes the match with a {scoreline} victory.'
      ],
      outro: [
        'That is it from {arena}. Thanks for watching Goal Rush.',
        'From {arena}, we are done. What a contest.'
      ]
    }
  });

  const GOAL_RUSH_TEMPLATES = Object.freeze({
    en: ENGLISH_COMMENTARY
  });

  const GOAL_RUSH_COMMENTARY_PRESETS = Object.freeze([
    {
      id: 'english',
      label: 'English',
      description: 'Mixed voices, classic English',
      language: 'en',
      voiceHints: {
        Kai: ['en-US', 'English', 'male', 'David', 'Guy', 'Daniel', 'Alex'],
        Sofia: ['en-GB', 'English', 'female', 'Sonia', 'Hazel', 'Kate', 'Emma']
      },
      speakerSettings: {
        Kai: { rate: 1, pitch: 0.96, volume: 1 },
        Sofia: { rate: 1.04, pitch: 1.06, volume: 1 }
      }
    },
    {
      id: 'saffron-table',
      label: 'Indian Table',
      description: 'Hindi commentary with lively pacing',
      language: 'hi',
      voiceHints: {
        Kai: ['hi-IN', 'hi', 'Hindi', 'male', 'Raj', 'Amit', 'Arjun'],
        Sofia: ['hi-IN', 'hi', 'Hindi', 'female', 'Asha', 'Priya', 'Neha']
      },
      speakerSettings: {
        Kai: { rate: 1.06, pitch: 1.02, volume: 1 },
        Sofia: { rate: 1.08, pitch: 1.08, volume: 1 }
      }
    },
    {
      id: 'moscow-mics',
      label: 'Russian Booth',
      description: 'Russian commentary with steady cadence',
      language: 'ru',
      voiceHints: {
        Kai: ['ru-RU', 'ru', 'Russian', 'male', 'Dmitri', 'Ivan', 'Sergey', 'Alexey'],
        Sofia: ['ru-RU', 'ru', 'Russian', 'female', 'Anna', 'Svetlana', 'Irina', 'Olga']
      },
      speakerSettings: {
        Kai: { rate: 1, pitch: 0.95, volume: 1 },
        Sofia: { rate: 1.03, pitch: 1.02, volume: 1 }
      }
    },
    {
      id: 'latin-pulse',
      label: 'Latin Pulse',
      description: 'Spanish play-by-play with lively color',
      language: 'es',
      voiceHints: {
        Kai: ['es-ES', 'es-MX', 'Spanish', 'male', 'Jorge', 'Carlos', 'Miguel'],
        Sofia: ['es-ES', 'es-MX', 'Spanish', 'female', 'Isabella', 'Lucia', 'Camila']
      },
      speakerSettings: {
        Kai: { rate: 1.05, pitch: 1, volume: 1 },
        Sofia: { rate: 1.08, pitch: 1.1, volume: 1 }
      }
    },
    {
      id: 'francophone-booth',
      label: 'Francophone Booth',
      description: 'French broadcast pairing',
      language: 'fr',
      voiceHints: {
        Kai: ['fr-FR', 'French', 'male', 'Henri', 'Louis', 'Paul'],
        Sofia: ['fr-FR', 'French', 'female', 'Amelie', 'Marie', 'Charlotte']
      },
      speakerSettings: {
        Kai: { rate: 0.98, pitch: 0.96, volume: 1 },
        Sofia: { rate: 1.04, pitch: 1.06, volume: 1 }
      }
    }
  ]);

  const COMMENTARY_PRESET_STORAGE_KEY = 'goalRushCommentaryPreset';
  const COMMENTARY_MUTE_STORAGE_KEY = 'goalRushCommentaryMute';
  const COMMENTARY_QUEUE_LIMIT = 4;
  const COMMENTARY_MIN_INTERVAL_MS = 1200;

  const resolveLanguageKey = (language = 'en') => {
    const normalized = String(language || '').toLowerCase();
    if (normalized.startsWith('hi')) return 'hi';
    if (normalized.startsWith('ru')) return 'ru';
    if (normalized.startsWith('es')) return 'es';
    if (normalized.startsWith('fr')) return 'fr';
    if (normalized.startsWith('en')) return 'en';
    return normalized || 'en';
  };

  const pickRandom = (pool) => pool[Math.floor(Math.random() * pool.length)];
  const applyTemplate = (template, context) =>
    template.replace(/\{(\w+)\}/g, (_, key) => String(context[key] ?? `{${key}}`));

  const buildGoalRushCommentaryLine = ({ event, speaker, language = 'en', context = {} }) => {
    const templates = GOAL_RUSH_TEMPLATES[resolveLanguageKey(language)] || ENGLISH_COMMENTARY;
    const pool = templates.common[event] || ENGLISH_COMMENTARY.common[event] || ENGLISH_COMMENTARY.common.goal;
    const mergedContext = { ...DEFAULT_COMMENTARY_CONTEXT, ...context, speaker };
    return applyTemplate(pickRandom(pool), mergedContext);
  };

  const getSpeechSynthesis = () =>
    typeof window !== 'undefined' && 'speechSynthesis' in window ? window.speechSynthesis : null;

  const loadVoices = (synth, timeoutMs = 2500) =>
    new Promise((resolve) => {
      if (!synth) {
        resolve([]);
        return;
      }
      const existing = synth.getVoices();
      if (existing.length) {
        resolve(existing);
        return;
      }
      let settled = false;
      const finalize = (voices) => {
        if (settled) return;
        settled = true;
        resolve(voices);
      };
      const handleVoices = () => {
        const next = synth.getVoices();
        if (next.length) finalize(next);
      };
      if (typeof synth.addEventListener === 'function') {
        synth.addEventListener('voiceschanged', handleVoices, { once: true });
      } else {
        synth.onvoiceschanged = handleVoices;
      }
      setTimeout(() => finalize(synth.getVoices()), timeoutMs);
    });

  const findDistinctVoice = (voices, hints = [], usedVoices = new Set()) => {
    if (!voices.length) return null;
    const normalizedHints = hints.map((hint) => hint.toLowerCase());
    const matchesByName = voices.filter((voice) =>
      normalizedHints.some((hint) => voice.name.toLowerCase().includes(hint))
    );
    const matchesByLang = voices.filter((voice) =>
      normalizedHints.some((hint) => voice.lang.toLowerCase().includes(hint))
    );
    const candidateLists = [matchesByName, matchesByLang, voices];
    for (const candidates of candidateLists) {
      const match = candidates.find((voice) => !usedVoices.has(voice));
      if (match) return match;
    }
    return voices[0] || null;
  };

  const speakCommentaryLines = async (lines, {
    speakerSettings = {},
    voiceHints = {}
  } = {}) => {
    const synth = getSpeechSynthesis();
    if (!synth || !Array.isArray(lines) || lines.length === 0) return;

    const voices = await loadVoices(synth);
    const uniqueSpeakers = [...new Set(lines.map((line) => line.speaker || GOAL_RUSH_SPEAKERS.lead))];
    const usedVoices = new Set();
    const speakerVoices = uniqueSpeakers.reduce((acc, speaker) => {
      const voice = findDistinctVoice(voices, voiceHints[speaker] || [], usedVoices);
      if (voice) {
        usedVoices.add(voice);
        acc[speaker] = voice;
      }
      return acc;
    }, {});

    if (typeof synth.resume === 'function') {
      try { synth.resume(); } catch {}
    }

    for (const line of lines) {
      const speaker = line.speaker || GOAL_RUSH_SPEAKERS.lead;
      const settings = speakerSettings[speaker] || { rate: 1, pitch: 1, volume: 1 };
      const utterance = new SpeechSynthesisUtterance(line.text);
      const voice = speakerVoices[speaker] || findDistinctVoice(voices, voiceHints[speaker] || []);
      if (voice) {
        utterance.voice = voice;
        if (voice.lang) utterance.lang = voice.lang;
      }
      utterance.rate = settings.rate;
      utterance.pitch = settings.pitch;
      utterance.volume = settings.volume;
      await new Promise((resolve) => {
        utterance.onend = resolve;
        utterance.onerror = resolve;
        synth.speak(utterance);
      });
    }
  };

  const commentarySupported = Boolean(getSpeechSynthesis());
  let commentaryPresetId = GOAL_RUSH_COMMENTARY_PRESETS[0]?.id || 'english';
  try {
    const stored = localStorage.getItem(COMMENTARY_PRESET_STORAGE_KEY);
    if (stored && GOAL_RUSH_COMMENTARY_PRESETS.some((preset) => preset.id === stored)) {
      commentaryPresetId = stored;
    }
  } catch {}

  let commentaryMuted = false;
  try {
    const storedMuted = localStorage.getItem(COMMENTARY_MUTE_STORAGE_KEY);
    commentaryMuted = storedMuted === '1';
  } catch {}

  let commentaryReady = false;
  let commentaryQueue = [];
  let commentarySpeaking = false;
  let commentaryLastEventAt = 0;
  let commentaryGreetingPlayed = false;
  let commentaryOutroPlayed = false;
  let commentarySpeakerIndex = 0;
  let pendingCommentary = null;

  const activeCommentaryPreset = () =>
    GOAL_RUSH_COMMENTARY_PRESETS.find((preset) => preset.id === commentaryPresetId) ||
    GOAL_RUSH_COMMENTARY_PRESETS[0];

  const pickCommentarySpeaker = (preferred) => {
    if (preferred) return preferred;
    const speakers = [GOAL_RUSH_SPEAKERS.lead, GOAL_RUSH_SPEAKERS.analyst];
    const selected = speakers[commentarySpeakerIndex % speakers.length] || GOAL_RUSH_SPEAKERS.lead;
    commentarySpeakerIndex += 1;
    return selected;
  };

  const getBaseCommentaryContext = () => ({
    player: p1Name,
    opponent: p2Name,
    playerScore: score.p1,
    opponentScore: score.p2,
    scoreline: `${score.p1}-${score.p2}`,
    arena: 'Goal Rush arena',
    targetScore: score.target
  });

  const getContextForScorer = (scorerKey) => {
    const base = getBaseCommentaryContext();
    if (scorerKey === 'p2') {
      return {
        ...base,
        player: p2Name,
        opponent: p1Name,
        playerScore: score.p2,
        opponentScore: score.p1
      };
    }
    return base;
  };

  const buildCommentaryLine = (event, context = {}, options = {}) => {
    const preset = activeCommentaryPreset();
    const speaker = pickCommentarySpeaker(options.speaker);
    return {
      speaker,
      text: buildGoalRushCommentaryLine({
        event,
        speaker,
        language: options.language ?? preset?.language ?? 'en',
        context
      })
    };
  };

  const playNextCommentary = async () => {
    if (commentarySpeaking) return;
    const next = commentaryQueue.shift();
    if (!next) return;
    commentarySpeaking = true;
    await speakCommentaryLines(next.lines, {
      speakerSettings: next.preset?.speakerSettings || {},
      voiceHints: next.preset?.voiceHints || {}
    });
    commentarySpeaking = false;
    if (commentaryQueue.length) {
      playNextCommentary();
    }
  };

  const enqueueCommentaryLines = (lines, { priority = false, preset = activeCommentaryPreset() } = {}) => {
    if (!commentarySupported || commentaryMuted) return;
    if (!commentaryReady) {
      pendingCommentary = { lines, priority, preset };
      return;
    }
    const now = performance.now();
    if (!priority && now - commentaryLastEventAt < COMMENTARY_MIN_INTERVAL_MS) return;
    if (!priority && commentaryQueue.length >= COMMENTARY_QUEUE_LIMIT) return;
    commentaryQueue.push({ lines, preset });
    if (!commentarySpeaking) {
      playNextCommentary();
    }
    commentaryLastEventAt = now;
  };

  const enqueueCommentaryEvent = (event, context = {}, options = {}) => {
    const line = buildCommentaryLine(event, context, options);
    enqueueCommentaryLines([line], options);
  };

  const queueIntroIfNeeded = () => {
    if (commentaryGreetingPlayed || !commentarySupported || commentaryMuted) return;
    const baseContext = getBaseCommentaryContext();
    const lines = [
      buildCommentaryLine(COMMENTARY_EVENTS.intro, baseContext, { speaker: GOAL_RUSH_SPEAKERS.lead }),
      buildCommentaryLine(COMMENTARY_EVENTS.introReply, baseContext, { speaker: GOAL_RUSH_SPEAKERS.analyst }),
      buildCommentaryLine(COMMENTARY_EVENTS.kickoff, baseContext, { speaker: GOAL_RUSH_SPEAKERS.lead })
    ];
    enqueueCommentaryLines(lines, { priority: true });
    commentaryGreetingPlayed = true;
  };

  const unlockCommentary = () => {
    if (commentaryReady) return;
    commentaryReady = true;
    if (pendingCommentary) {
      const pending = pendingCommentary;
      pendingCommentary = null;
      enqueueCommentaryLines(pending.lines, pending);
    }
    queueIntroIfNeeded();
  };

  const updateCommentaryMuteState = () => {
    if (!commentaryMuteState || !commentaryMuteButton) return;
    commentaryMuteState.textContent = commentaryMuted ? 'On' : 'Off';
    commentaryMuteButton.classList.toggle('active', commentaryMuted);
  };

  const updateCommentarySupport = () => {
    if (!commentarySupportNote) return;
    commentarySupportNote.style.display = commentarySupported ? 'none' : 'block';
    if (commentaryMuteButton) {
      commentaryMuteButton.disabled = !commentarySupported;
    }
  };

  const populateCommentaryOptions = () => {
    if (!commentaryOptionsEl) return;
    commentaryOptionsEl.replaceChildren();
    GOAL_RUSH_COMMENTARY_PRESETS.forEach((preset) => {
      const button = document.createElement('button');
      button.type = 'button';
      button.textContent = `${preset.label} ‚Äî ${preset.description}`;
      if (preset.id === commentaryPresetId) {
        button.classList.add('active');
      }
      button.disabled = !commentarySupported;
      button.addEventListener('click', () => {
        if (!commentarySupported) return;
        commentaryPresetId = preset.id;
        try { localStorage.setItem(COMMENTARY_PRESET_STORAGE_KEY, preset.id); } catch {}
        populateCommentaryOptions();
        if (!commentaryMuted) {
          const context = getBaseCommentaryContext();
          enqueueCommentaryLines([
            buildCommentaryLine(COMMENTARY_EVENTS.intro, context, { speaker: GOAL_RUSH_SPEAKERS.lead }),
            buildCommentaryLine(COMMENTARY_EVENTS.introReply, context, { speaker: GOAL_RUSH_SPEAKERS.analyst })
          ], { priority: true });
        }
      });
      commentaryOptionsEl.appendChild(button);
    });
  };

  /* ---------- Quick actions: chat, gift, info, mute ---------- */
  const QUICK_MESSAGES = [
    'Nice goal ‚öΩ',
    'Well played üëè',
    "You're fast ‚ö°",
    'No way üò≤',
    'Oops üò¨',
    'Close one ü•Ö',
    'Good save üß§',
    'Great shot üéØ',
    'Amazing! ü§©',
    'So close üòñ',
    'Lucky bounce üçÄ',
    'This is fun ü§©',
    "I'm ready üí™",
    'GG! üèÜ',
  ];
  const NFT_GIFTS = [
    { id: 'fireworks',    name: 'Fireworks',    icon: 'üéÜ', price: 200,  tier: 1 },
    { id: 'laugh_bomb',   name: 'Laugh Bomb',   icon: 'üòÇ', price: 300,  tier: 1 },
    { id: 'pizza_slice',  name: 'Pizza Slice',  icon: 'üçï', price: 500,  tier: 1 },
    { id: 'coffee_boost', name: 'Coffee Boost', icon: '‚òï', price: 750,  tier: 1 },
    { id: 'baby_chick',   name: 'Baby Chick',   icon: 'üê£', price: 1000, tier: 1 },
    { id: 'poop',         name: 'Poop',         icon: 'üí©', price: 1200, tier: 2 },
    { id: 'speed_racer',  name: 'Speed Racer',  icon: '/assets/icons/futuristic_racing_car.webp', price: 1800,  tier: 2 },
    { id: 'bullseye',     name: 'Bullseye',     icon: 'üéØ', price: 3000,  tier: 2 },
    { id: 'magic_trick',  name: 'Magic Trick',  icon: 'üé©', price: 5000,  tier: 2 },
    { id: 'surprise_box', name: 'Surprise Box', icon: 'üéÅ', price: 8000,  tier: 2 },
    { id: 'dragon_burst', name: 'Dragon Burst', icon: 'üêâ', price: 20000,  tier: 3 },
    { id: 'rocket_blast', name: 'Rocket Blast', icon: 'üöÄ', price: 35000,  tier: 3 },
    { id: 'royal_crown',  name: 'Royal Crown',  icon: 'üëë', price: 90000,  tier: 3 },
    { id: 'alien_visit',  name: 'Alien Visit',  icon: 'üõ∏', price: 150000, tier: 3 },
  ];
  const GIFT_SOUNDS = {
    fireworks: "/assets/sounds/fireworks-29629.mp3",
    laugh_bomb: "/assets/sounds/080998_bullet-hit-39870.mp3",
    pizza_slice: "/assets/sounds/life_is_beautiful_italiano-108264.mp3",
    coffee_boost: "/assets/sounds/drinking-coffee-214463.mp3",
    baby_chick: "/assets/sounds/bebek-220068.mp3",
    speed_racer: "/assets/sounds/race-care-151963.mp3",
    bullseye: "/assets/sounds/080998_bullet-hit-39870.mp3",
    magic_trick: "/assets/sounds/ah-good-morning-sir-would-you-like-a-cup-of-tea-26151.mp3",
    surprise_box: "/assets/sounds/082229_pinkie-pie-39surprise39wav-86428.mp3",
    poop: "/assets/sounds/fart-5-228245.mp3",
    dragon_burst: "/assets/sounds/snake-hissing-high-quality-240154.mp3",
    rocket_blast: "/assets/sounds/launch-85216.mp3",
    royal_crown: "/assets/sounds/king-conversation-48272.mp3",
    alien_visit: "/assets/sounds/ufo-sound-effect-240256.mp3",
  };
  const CHAT_BEEP_URL = "/assets/sounds/080998_bullet-hit-39870.mp3";
  let activeChatMessage = QUICK_MESSAGES[0];
  let selectedGift = NFT_GIFTS[0];
  let selectedGiftTarget = 1;

  function toggleModal(modal, open = true) {
    if (!modal) return;
    modal.classList.toggle('active', open);
    modal.setAttribute('aria-hidden', String(!open));
  }

  function updateQuickActionMute() {
    if (!muteLabel || !muteIcon) return;
    const muted = !audioEnabled;
    muteIcon.textContent = muted ? 'üîá' : 'üîä';
    muteLabel.textContent = muted ? 'Unmute' : 'Mute';
  }

  function showToast(message) {
    const toast = document.createElement('div');
    toast.className = 'toast';
    toast.textContent = message;
    document.body.appendChild(toast);
    setTimeout(() => toast.remove(), 2800);
  }

  function playEffectSound(url, { delay = 0, maxDuration } = {}) {
    if (!audioEnabled || !url) return;
    const audio = new Audio(url);
    audio.volume = 0.7;
    const play = () => audio.play().catch(() => {});
    if (delay) {
      setTimeout(play, delay);
    } else {
      play();
    }
    if (maxDuration) {
      setTimeout(() => audio.pause(), maxDuration);
    }
  }

  function createAvatarNode(source) {
    if (typeof source === 'string' && (source.startsWith('/') || source.startsWith('http') || source.startsWith('data:'))) {
      const img = document.createElement('img');
      img.src = source;
      img.alt = '';
      img.className = 'avatar';
      return img;
    }
    const span = document.createElement('span');
    span.className = 'avatar';
    span.textContent = source || '‚öΩ';
    return span;
  }

  function getAvatarSources() {
    return [
      p1AvatarImg?.src || p1AvatarEmoji || '‚öΩ',
      p2AvatarImg?.src || p2AvatarEmoji || 'ü§ñ',
    ];
  }

  function getPlayerNames() {
    return [p1Name, p2Name];
  }

  function showChatBubble(text, playerIndex = 0) {
    const bubble = document.createElement('div');
    bubble.className = 'chat-bubble';
    const avatars = getAvatarSources();
    bubble.appendChild(createAvatarNode(avatars[playerIndex]));
    const label = document.createElement('span');
    label.textContent = text;
    bubble.appendChild(label);
    document.body.appendChild(bubble);
    const targets = [p1AvatarTop, p2AvatarTop];
    const badge = targets[playerIndex];
    if (badge) {
      const rect = badge.getBoundingClientRect();
      bubble.style.left = `${rect.left + rect.width / 2}px`;
      bubble.style.top = `${rect.top - 12}px`;
      bubble.style.transform = 'translate(-50%, -100%)';
    } else {
      bubble.style.left = '1rem';
      bubble.style.bottom = '5.5rem';
    }
    setTimeout(() => bubble.remove(), 3000);
  }

  function animateGift(fromIndex, toIndex, gift) {
    const icon = typeof gift.icon === 'string' && gift.icon.match(/\.(png|jpg|jpeg|webp|svg)$/)
      ? Object.assign(document.createElement('img'), { src: gift.icon })
      : Object.assign(document.createElement('div'), { textContent: gift.icon });
    icon.style.position = 'fixed';
    icon.style.left = '0';
    icon.style.top = '0';
    icon.style.pointerEvents = 'none';
    icon.style.width = '24px';
    icon.style.height = '24px';
    icon.style.fontSize = '24px';
    icon.style.zIndex = '9999';
    document.body.appendChild(icon);
    const targets = [p1AvatarTop, p2AvatarTop];
    const start = targets[fromIndex]?.getBoundingClientRect();
    const end = targets[toIndex]?.getBoundingClientRect();
    const cx = window.innerWidth / 2;
    const cy = window.innerHeight / 2;
    const startX = start ? start.left + start.width / 2 : 24;
    const startY = start ? start.top + start.height / 2 : window.innerHeight - 80;
    const endX = end ? end.left + end.width / 2 : window.innerWidth - 24;
    const endY = end ? end.top + end.height / 2 : window.innerHeight / 2;
    const animation = icon.animate(
      [
        { transform: `translate(${startX}px, ${startY}px) scale(1)` },
        { transform: `translate(${cx}px, ${cy}px) scale(3)`, offset: 0.5 },
        { transform: `translate(${endX}px, ${endY}px) scale(1)` },
      ],
      { duration: 3500, easing: 'linear' },
    );
    animation.onfinish = () => icon.remove();
  }

  function populateChatMessages() {
    if (!chatMessagesEl) return;
    chatMessagesEl.replaceChildren();
    QUICK_MESSAGES.forEach((message) => {
      const button = document.createElement('button');
      button.type = 'button';
      button.textContent = message;
      if (message === activeChatMessage) {
        button.classList.add('active');
      }
      button.addEventListener('click', () => {
        activeChatMessage = message;
        populateChatMessages();
      });
      chatMessagesEl.appendChild(button);
    });
  }

  function populateGiftPlayers() {
    if (!giftPlayersEl) return;
    giftPlayersEl.replaceChildren();
    const avatars = getAvatarSources();
    const names = getPlayerNames();
    avatars.forEach((avatar, idx) => {
      const button = document.createElement('button');
      button.type = 'button';
      if (idx === selectedGiftTarget) {
        button.classList.add('active');
      }
      button.appendChild(createAvatarNode(avatar));
      const label = document.createElement('span');
      label.textContent = names[idx] || `Player ${idx + 1}`;
      button.appendChild(label);
      button.addEventListener('click', () => {
        selectedGiftTarget = idx;
        populateGiftPlayers();
      });
      giftPlayersEl.appendChild(button);
    });
  }

  function populateGiftTiers() {
    if (!giftTiersEl) return;
    giftTiersEl.replaceChildren();
    [1, 2, 3].forEach((tier) => {
      const tierWrap = document.createElement('div');
      tierWrap.className = 'gift-tier';
      const heading = document.createElement('h4');
      heading.textContent = `Tier ${tier}`;
      tierWrap.appendChild(heading);
      const grid = document.createElement('div');
      grid.className = 'gift-grid';
      NFT_GIFTS.filter((gift) => gift.tier === tier).forEach((gift) => {
        const button = document.createElement('button');
        button.type = 'button';
        button.className = 'gift-button';
        if (gift.id === selectedGift.id) {
          button.classList.add('active');
        }
        const icon = createAvatarNode(gift.icon);
        icon.classList.add('gift-icon');
        icon.style.width = '1rem';
        icon.style.height = '1rem';
        button.appendChild(icon);
        const label = document.createElement('span');
        label.textContent = gift.price;
        button.appendChild(label);
        button.addEventListener('click', () => {
          selectedGift = gift;
          updateGiftCost();
          populateGiftTiers();
        });
        grid.appendChild(button);
      });
      tierWrap.appendChild(grid);
      giftTiersEl.appendChild(tierWrap);
    });
  }

  function updateGiftCost() {
    const costEl = document.getElementById('giftCost');
    if (costEl) {
      costEl.textContent = selectedGift?.price ?? 0;
    }
  }

  function openChatModal() {
    populateChatMessages();
    toggleModal(chatModal, true);
  }

  function openGiftModal() {
    populateGiftPlayers();
    populateGiftTiers();
    updateGiftCost();
    toggleModal(giftModal, true);
  }

  function openCommentaryModal() {
    populateCommentaryOptions();
    updateCommentaryMuteState();
    updateCommentarySupport();
    toggleModal(commentaryModal, true);
  }

  updateQuickActionMute();
  updateCommentaryMuteState();
  updateCommentarySupport();

  if (panelRules && closeRules) {
    closeRules.addEventListener('click', () => { panelRules.style.display = 'none'; });
    panelRules.addEventListener('click', (event) => {
      if (event.target === panelRules) panelRules.style.display = 'none';
    });
  }
  if (quickActions) {
    quickActions.addEventListener('click', (event) => {
      const button = event.target.closest('button[data-action]');
      if (!button) return;
      const action = button.dataset.action;
      if (action === 'chat') {
        openChatModal();
      } else if (action === 'gift') {
        openGiftModal();
      } else if (action === 'info' && panelRules) {
        panelRules.style.display = 'flex';
      } else if (action === 'commentary') {
        openCommentaryModal();
      } else if (action === 'mute') {
        setAudioEnabled(!audioEnabled);
      }
    });
  }
  if (chatModal) {
    chatModal.addEventListener('click', (event) => {
      if (event.target === chatModal) toggleModal(chatModal, false);
    });
  }
  if (chatClose) {
    chatClose.addEventListener('click', () => toggleModal(chatModal, false));
  }
  if (chatSend) {
    chatSend.addEventListener('click', () => {
      toggleModal(chatModal, false);
      showChatBubble(activeChatMessage, 0);
      playEffectSound(CHAT_BEEP_URL, { maxDuration: 1200 });
    });
  }
  if (giftModal) {
    giftModal.addEventListener('click', (event) => {
      if (event.target === giftModal) toggleModal(giftModal, false);
    });
  }
  if (giftClose) {
    giftClose.addEventListener('click', () => toggleModal(giftModal, false));
  }
  if (giftSend) {
    giftSend.addEventListener('click', () => {
      const recipient = selectedGiftTarget;
      toggleModal(giftModal, false);
      animateGift(0, recipient, selectedGift);
      playEffectSound(GIFT_SOUNDS[selectedGift.id], { delay: selectedGift.id === 'bullseye' ? 2500 : 0 });
      showToast(`Sent ${selectedGift.name} to ${getPlayerNames()[recipient] || `Player ${recipient + 1}`}`);
    });
  }
  if (commentaryModal) {
    commentaryModal.addEventListener('click', (event) => {
      if (event.target === commentaryModal) toggleModal(commentaryModal, false);
    });
  }
  if (commentaryClose) {
    commentaryClose.addEventListener('click', () => toggleModal(commentaryModal, false));
  }
  if (commentaryMuteButton) {
    commentaryMuteButton.addEventListener('click', () => {
      commentaryMuted = !commentaryMuted;
      updateCommentaryMuteState();
      try { localStorage.setItem(COMMENTARY_MUTE_STORAGE_KEY, commentaryMuted ? '1' : '0'); } catch {}
      if (commentaryMuted) {
        commentaryQueue = [];
        pendingCommentary = null;
        commentarySpeaking = false;
        const synth = getSpeechSynthesis();
        if (synth && typeof synth.cancel === 'function') {
          try { synth.cancel(); } catch {}
        }
      } else {
        queueIntroIfNeeded();
      }
    });
  }

  const keys = new Set();
  const touches = new Map();

  function clamp(v,a,b){ return Math.max(a, Math.min(b,v)); }
  function dist(x1,y1,x2,y2){ const dx=x2-x1, dy=y2-y1; return Math.hypot(dx,dy); }

  function resetPositions(kickoff=0){
    p1.x = centerX; p1.y = Math.min(rink.y+rink.h- rink.h*0.12, H*0.85);
    p2.x = centerX; p2.y = Math.max(rink.y + rink.h*0.12, H*0.15);
    puck.x = centerX;
    puck.y = centerY;
    if(kickoff===1){
      puck.y = centerY + rink.h/4;
    } else if(kickoff===2){
      puck.y = centerY - rink.h/4;
    }
    puck.vx = 0; puck.vy = 0; puck.spin = 0;
    [p1,p2].forEach(p=>{p.vx=0;p.vy=0;p.lastX=p.x;p.lastY=p.y;});
    lastTouch = null;
  }

  function showGoalMessage(ownGoal=false){
    if(ownGoal){
      goalText.innerHTML = `OWN GOAL<span class="score-line">${score.p1} - ${score.p2}</span>`;
      goalText.classList.add('own-goal');
    } else {
      goalText.innerHTML = `GOAL!<span class="score-line">${score.p1} - ${score.p2}</span>`;
      goalText.classList.remove('own-goal');
    }
    goalText.style.display = 'block';
    setTimeout(()=>{ goalText.style.display='none'; }, GOAL_PAUSE);
  }

  function showPostMessage(){
    sfx.post();
    postText.textContent = 'HIT THE POST';
    postText.style.display = 'block';
    setTimeout(()=>{ postText.style.display='none'; }, 1000);
    enqueueCommentaryEvent(COMMENTARY_EVENTS.post, getBaseCommentaryContext());
  }

  function handleGoalCommentary({ scorerKey, ownGoal, prevP1, prevP2 }){
    const context = getContextForScorer(scorerKey);
    if (ownGoal) {
      enqueueCommentaryEvent(COMMENTARY_EVENTS.ownGoal, context);
    } else {
      enqueueCommentaryEvent(COMMENTARY_EVENTS.goal, context);
    }
    const prevLeader = prevP1 === prevP2 ? null : prevP1 > prevP2 ? 'p1' : 'p2';
    const newLeader = score.p1 === score.p2 ? null : score.p1 > score.p2 ? 'p1' : 'p2';
    if (newLeader && newLeader !== prevLeader) {
      enqueueCommentaryEvent(COMMENTARY_EVENTS.leadChange, context);
    }
    if (!newLeader && prevLeader) {
      enqueueCommentaryEvent(COMMENTARY_EVENTS.equalizer, context);
    }
    const scorerScore = scorerKey === 'p1' ? score.p1 : score.p2;
    if (scorerScore === score.target - 1) {
      enqueueCommentaryEvent(COMMENTARY_EVENTS.matchPoint, context);
    }
  }

  function rr(x,y,w,h,r){
    const rr = Math.min(r,w/2,h/2);
    ctx.beginPath();
    ctx.moveTo(x+rr,y);
    ctx.arcTo(x+w,y,x+w,y+h,rr);
    ctx.arcTo(x+w,y+h,x,y+h,rr);
    ctx.arcTo(x,y+h,x,y,rr);
    ctx.arcTo(x,y,x+w,y,rr);
    ctx.closePath();
  }
  function drawRink(){
    // base field
    rr(rink.x, rink.y, rink.w, rink.h, rink.r);
    ctx.fillStyle = getCSS('--field');
    ctx.fill();

    // vertical shadow stripes
    ctx.save();
    rr(rink.x, rink.y, rink.w, rink.h, rink.r);
    ctx.clip();
    const stripeW = rink.w / 10;
    ctx.fillStyle = 'rgba(255,255,255,0.05)';
    for (let i = 1; i < 10; i += 2) {
      ctx.fillRect(rink.x + i * stripeW, rink.y, stripeW, rink.h);
    }
    ctx.restore();

    // thick white markings
    ctx.lineWidth = Math.max(4, W * 0.006);
    ctx.strokeStyle = getCSS('--line');
    ctx.lineJoin = 'round';
    ctx.lineCap = 'round';

    // outer boundary
    rr(rink.x, rink.y, rink.w, rink.h, rink.r);
    ctx.stroke();

    // center line
    ctx.beginPath();
    ctx.moveTo(rink.x, centerY);
    ctx.lineTo(rink.x + rink.w, centerY);
    ctx.stroke();

    // center circle
    ctx.beginPath();
    ctx.arc(centerX, centerY, Math.min(W, H) * 0.13, 0, Math.PI * 2);
    ctx.stroke();

    // penalty areas
    const penW = rink.w * 0.58;
    const penH = rink.h * 0.18;
    ctx.beginPath();
    ctx.rect(centerX - penW / 2, rink.y, penW, penH);
    ctx.rect(centerX - penW / 2, rink.y + rink.h - penH, penW, penH);
    ctx.stroke();

    // goal areas (6-yard boxes)
    const goalAreaW = goalWidth * 1.1;
    const goalAreaH = rink.h * 0.06;
    ctx.beginPath();
    ctx.rect(centerX - goalAreaW / 2, rink.y, goalAreaW, goalAreaH);
    ctx.rect(centerX - goalAreaW / 2, rink.y + rink.h - goalAreaH, goalAreaW, goalAreaH);
    ctx.stroke();

    // penalty arcs
    const arcR = penW * 0.32;
    const arcD = penH * 0.3;
    const arcAngle = Math.asin(arcD / arcR);

    // top penalty arc
    ctx.beginPath();
    ctx.arc(centerX, rink.y + penH * 0.7, arcR, arcAngle, Math.PI - arcAngle);
    ctx.stroke();

    // bottom penalty arc
    ctx.beginPath();
    ctx.arc(centerX, rink.y + rink.h - penH * 0.7, arcR, Math.PI + arcAngle, Math.PI * 2 - arcAngle);
    ctx.stroke();

    // penalty spots
    const spotR = Math.min(W, H) * 0.01;
    ctx.fillStyle = getCSS('--line');
    ctx.beginPath();
    ctx.arc(centerX, rink.y + penH * 0.7, spotR, 0, Math.PI * 2);
    ctx.arc(centerX, rink.y + rink.h - penH * 0.7, spotR, 0, Math.PI * 2);
    ctx.fill();

    // corner arcs
    const cornerR = puck.r * 1.2;
    ctx.beginPath();
    ctx.arc(rink.x, rink.y, cornerR, 0, Math.PI / 2);
    ctx.stroke();
    ctx.beginPath();
    ctx.arc(rink.x + rink.w, rink.y, cornerR, Math.PI / 2, Math.PI);
    ctx.stroke();
    ctx.beginPath();
    ctx.arc(rink.x, rink.y + rink.h, cornerR, (3 * Math.PI) / 2, Math.PI * 2);
    ctx.stroke();
    ctx.beginPath();
    ctx.arc(rink.x + rink.w, rink.y + rink.h, cornerR, Math.PI, (3 * Math.PI) / 2);
    ctx.stroke();

    // corner flags
    const flagSize = Math.max(16, cornerR * 1.2);
    ctx.font = `${flagSize}px serif`;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'top';
    ctx.fillText('üèÅ', rink.x, rink.y);
    ctx.fillText('üèÅ', rink.x + rink.w, rink.y);
    ctx.textBaseline = 'bottom';
    ctx.fillText('üèÅ', rink.x, rink.y + rink.h);
    ctx.fillText('üèÅ', rink.x + rink.w, rink.y + rink.h);

    // advertising billboards behind goals
    const billboardH = goalDepth * 1.2;
    drawBillboard(goalCenterX, goalTopY - goalDepth - billboardH, goalWidth, billboardH);
    drawBillboard(goalCenterX, goalBottomY + goalDepth, goalWidth, billboardH);

    drawGoal(goalCenterX, goalTopY, goalWidth, goalDepth, -1);
    drawGoal(goalCenterX, goalBottomY, goalWidth, goalDepth, 1);
  }
  function drawBillboard(cx, y, w, h){
    ctx.save();
    ctx.translate(cx, y);
    ctx.fillStyle = '#222';
    ctx.fillRect(-w/2, 0, w, h);
    ctx.fillStyle = '#fff';
    ctx.font = `${h*0.6}px sans-serif`;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText('AD', 0, h/2);
    ctx.restore();
  }
  function drawGoal(cx, y, w, d, dir){
    ctx.save();
    ctx.translate(cx, y);
    ctx.scale(1, dir);
    const lw = Math.max(3, W*0.004);
    ctx.lineWidth = lw;
    ctx.strokeStyle = '#fff';
    ctx.beginPath();
    ctx.moveTo(-w/2, 0); ctx.lineTo(w/2, 0);
    ctx.moveTo(-w/2, d); ctx.lineTo(w/2, d);
    ctx.moveTo(-w/2, 0); ctx.lineTo(-w/2, d);
    ctx.moveTo(w/2, 0); ctx.lineTo(w/2, d);
    ctx.stroke();
    // draw hexagonal net
    const size = Math.max(6, w/15);
    const hexH = Math.sqrt(3) * size;
    ctx.strokeStyle = 'rgba(255,255,255,0.6)';
    ctx.lineWidth = Math.max(1, w*0.005);
    for(let row = 0; row < d/(hexH/2); row++){
      const yOff = row * (hexH/2);
      for(let col = -w/2; col < w/2 + size; col += 1.5*size){
        const xOff = col + (row % 2 ? 0.75*size : 0);
        ctx.beginPath();
        ctx.moveTo(xOff, yOff - hexH/2);
        ctx.lineTo(xOff + size/2, yOff - hexH/4);
        ctx.lineTo(xOff + size/2, yOff + hexH/4);
        ctx.lineTo(xOff, yOff + hexH/2);
        ctx.lineTo(xOff - size/2, yOff + hexH/4);
        ctx.lineTo(xOff - size/2, yOff - hexH/4);
        ctx.closePath();
        ctx.stroke();
      }
    }
    // camera lenses on posts
    const camR = lw * 1.5;
    ctx.fillStyle = '#000';
    ctx.beginPath();
    ctx.arc(-w/2, 0, camR, 0, Math.PI*2);
    ctx.arc(w/2, 0, camR, 0, Math.PI*2);
    ctx.fill();
    ctx.restore();
  }
  function drawPaddle(p, color, img, emoji){
    const g = ctx.createRadialGradient(p.x-6, p.y-6, 6, p.x, p.y, p.r);
    g.addColorStop(0, '#fff'); g.addColorStop(0.2, color); g.addColorStop(1, '#0d0f14');
    ctx.beginPath(); ctx.arc(p.x,p.y,p.r,0,Math.PI*2); ctx.fillStyle = g; ctx.fill();
    ctx.save();
    ctx.beginPath(); ctx.arc(p.x,p.y,p.r*0.8,0,Math.PI*2); ctx.clip();
    if(img && img.complete){
      ctx.drawImage(img, p.x-p.r*0.8, p.y-p.r*0.8, p.r*1.6, p.r*1.6);
    } else if(emoji){
      ctx.fillStyle = '#fff';
      ctx.font = `${p.r*0.8}px sans-serif`;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(emoji, p.x, p.y+1);
    }
    ctx.restore();
  }
  function drawPuck(){
    const r = puck.r;
    ctx.save();
    ctx.translate(puck.x, puck.y);
    ctx.rotate(puck.angle);
    if (puckImgLoaded && puckImg.complete && puckImg.naturalWidth > 0) {
      ctx.drawImage(puckImg, -r, -r, r * 2, r * 2);
      ctx.restore();
      return;
    }
    ctx.fillStyle = '#fff';
    ctx.beginPath(); ctx.arc(0,0,r,0,Math.PI*2); ctx.fill();
    ctx.fillStyle = '#000';
    const pentR = r*0.4;
    ctx.beginPath();
    for(let i=0;i<5;i++){ const a=-Math.PI/2+i*2*Math.PI/5; ctx.lineTo(pentR*Math.cos(a), pentR*Math.sin(a)); }
    ctx.closePath(); ctx.fill();
    for(let i=0;i<5;i++){
      const a=-Math.PI/2+i*2*Math.PI/5;
      const bx=r*0.9*Math.cos(a), by=r*0.9*Math.sin(a);
      ctx.beginPath();
      for(let j=0;j<5;j++){ const ang=a+Math.PI/5+j*2*Math.PI/5; ctx.lineTo(bx+pentR*0.6*Math.cos(ang), by+pentR*0.6*Math.sin(ang)); }
      ctx.closePath(); ctx.fill();
    }
    ctx.globalAlpha = .18; ctx.fillStyle = '#000';
    ctx.beginPath(); ctx.arc(5,5,r,0,Math.PI*2); ctx.fill(); ctx.globalAlpha = 1;
    ctx.restore();
  }
  function getCSS(v){ return getComputedStyle(document.documentElement).getPropertyValue(v).trim(); }

  const friction = 0.996;
  const wallBounce = 1.12;
  const minWallSpeed = 5;
  function constrainPaddle(p, bottom){
    const margin=12;
    const minX = rink.x + margin + p.r;
    const maxX = rink.x + rink.w - margin - p.r;
    const minY = rink.y + margin + p.r;
    const maxY = rink.y + rink.h - margin - p.r;
    if (bottom){
      p.y = clamp(p.y, centerY + p.r, maxY);
    } else {
      p.y = clamp(p.y, minY, centerY - p.r);
    }
    p.x = clamp(p.x, minX, maxX);
  }

  function paddleFollowTouch(p, bottom){
    let best = null; let bestD = 1e9;
    touches.forEach(t=>{
      if (bottom && t.y > centerY) {
        const d = dist(p.x,p.y,t.x,t.y); if (d<bestD){bestD=d; best=t;}
      }
      if (!bottom && t.y < centerY) {
        const d = dist(p.x,p.y,t.x,t.y); if (d<bestD){bestD=d; best=t;}
      }
    });
    if (best){
      const ease = 0.95;
      const tx = best.x, ty = best.y;
      const nx = p.x + (tx - p.x) * ease;
      let ny = p.y + (ty - p.y) * ease;
      ny -= p.r * 0.5;
      p.vx = nx - p.lastX;
      p.vy = ny - p.lastY;
      p.x = nx; p.y = ny;
    } else {
      p.vx *= 0.8; p.vy *= 0.8;
    }
  }

  function aiUpdate(){
    const baseReaction = { easy: 0.05, normal: 0.085, hard: 0.16 }[difficulty] || 0.075;
    let reaction = baseReaction;
    const margin = p2.r + 12;
    const minX = rink.x + margin;
    const maxX = rink.x + rink.w - margin;
    const minY = rink.y + margin;
    const maxY = centerY - p2.r - 8;
    const defendY = minY + (maxY - minY) * 0.25;
    let tx = clamp(puck.x, minX, maxX);
    let ty = defendY;
    if (puck.y < centerY) {
      // attack: chase puck when it's on AI side
      ty = clamp(puck.y, minY, maxY);
    } else {
      // defend: react a bit slower to make AI less perfect
      reaction *= 0.85;
    }
    if (cornerEscapeFrames > 0) {
      cornerEscapeFrames--;
      reaction *= 2;
      tx = centerX;
      ty = rink.y + rink.h * 0.3;
    } else {
      // Pull the AI away from corners when the puck is far away
      if (puck.y >= centerY && (p2.x <= minX + 1 || p2.x >= maxX - 1 || p2.y <= minY + 1)) {
        tx = centerX;
        ty = defendY;
      }
      // If puck and AI are stuck in a corner on the AI side, nudge the puck out
      const cornerZone = 40; // expanded area from walls to consider a corner
      const puckSpeed = Math.hypot(puck.vx, puck.vy);
      const puckInCorner = puck.y < minY + cornerZone && (puck.x < minX + cornerZone || puck.x > maxX - cornerZone);
      if (puck.y < centerY && puckInCorner && puckSpeed < 8) {
        const dir = puck.x < centerX ? 1 : -1;
        const angle = 0.3 + Math.random() * 1.0; // kick downward toward center
        const power = 10 + Math.random() * 6;
        puck.vx = Math.cos(angle) * dir * power;
        puck.vy = Math.sin(angle) * power;
        tx = centerX;
        ty = rink.y + rink.h * 0.3;
        cornerEscapeFrames = 25;
      }
    }
    p2.x += (tx - p2.x) * reaction;
    p2.y += (ty - p2.y) * reaction;
    const maxStep = p2.max * speedMul;
    const vx = p2.x - p2.lastX;
    const vy = p2.y - p2.lastY;
    const v = Math.hypot(vx, vy);
    if (v > maxStep) { const s = maxStep / v; p2.x = p2.lastX + vx * s; p2.y = p2.lastY + vy * s; }
    p2.vx = p2.x - p2.lastX; p2.vy = p2.y - p2.lastY;
  }

  function handleCollisions(){
    [p1,p2].forEach(p => {
      const d = dist(p.x,p.y,puck.x,puck.y);
      const minD = p.r + puck.r;
      if (d < minD){
        const nx = (puck.x - p.x) / (d||1);
        const ny = (puck.y - p.y) / (d||1);
        const overlap = minD - d + 0.5;
        puck.x += nx * overlap; puck.y += ny * overlap;
        p.x -= nx * overlap; p.y -= ny * overlap;
        constrainPaddle(p, p === p1);
        p.vx = p.x - p.lastX; p.vy = p.y - p.lastY;
        const relVX = puck.vx - p.vx;
        const relVY = puck.vy - p.vy;
        const relAlongNormal = relVX*nx + relVY*ny;
        const tangential = relVX*(-ny) + relVY*nx;
        puck.spin += tangential * 0.012;
        if (relAlongNormal <= 0){
          const restitution = 1.15;
          const impulse = -(1+restitution) * relAlongNormal;
          puck.vx += impulse * nx;
          puck.vy += impulse * ny;
          puck.vx += p.vx*0.2; puck.vy += p.vy*0.2;
        } else {
          const speed = Math.hypot(puck.vx, puck.vy);
          const minSpeed = 2;
          if (speed < minSpeed) {
            const boost = minSpeed - speed;
            puck.vx += nx * boost;
            puck.vy += ny * boost;
          }
        }
        const v = Math.hypot(puck.vx,puck.vy); const maxV = puck.max*speedMul*1.25;
        if (v>maxV){ const s=maxV/v; puck.vx*=s; puck.vy*=s; }
        lastTouch = (p === p1) ? 'p1' : 'p2';
        if (p === p2) {
          const aimX = centerX;
          const aimY = goalBottomY - 20;
          const dx = aimX - puck.x;
          const dy = aimY - puck.y;
          const len = Math.hypot(dx, dy) || 1;
          const shotSpeed = Math.max(Math.hypot(puck.vx, puck.vy), 10);
          puck.vx = (dx / len) * shotSpeed;
          puck.vy = (dy / len) * shotSpeed;
        }
        if (p === p1 || mode !== 'ai') sfx.hit();
      }
    });

    const left = rink.x + 6 + puck.r;
    const right = rink.x + rink.w - 6 - puck.r;
    const top = goalTopY + 6 + puck.r;
    const bottom = goalBottomY - 6 - puck.r;

    if (puck.x < left){
      puck.x = left;
      const speed = Math.max(Math.abs(puck.vx), minWallSpeed);
      puck.vx = speed * wallBounce;
      if (Math.abs(puck.vy) < minWallSpeed / 2) {
        puck.vy = (Math.sign(puck.vy) || 1) * (minWallSpeed / 2);
      }
      sfx.wall();
    }
    if (puck.x > right){
      puck.x = right;
      const speed = Math.max(Math.abs(puck.vx), minWallSpeed);
      puck.vx = -speed * wallBounce;
      if (Math.abs(puck.vy) < minWallSpeed / 2) {
        puck.vy = (Math.sign(puck.vy) || 1) * (minWallSpeed / 2);
      }
      sfx.wall();
    }

    const goalLeft = goalCenterX - goalWidth/2 + puck.r;
    const goalRight = goalCenterX + goalWidth/2 - puck.r;

    if (puck.y < top){
      if (puck.x > goalLeft && puck.x < goalRight){
        const prevP1 = score.p1;
        const prevP2 = score.p2;
        score.p1++; updateScore(); sfx.goal();
        const goalLine = goalTopY + 6;
        puck.y = goalLine - 0.6 * puck.r;
        puck.vx = 0; puck.vy = 0;
        const ownGoal = lastTouch === 'p2';
        handleGoalCommentary({ scorerKey: 'p1', ownGoal, prevP1, prevP2 });
        running = false;
        showGoalMessage(ownGoal);
        checkWin();
        if (score.p1 < score.target && score.p2 < score.target){
          setTimeout(()=>{ resetPositions(2); running = true; }, GOAL_PAUSE);
        }
        return;
      } else {
        puck.y = top;
        const speed = Math.max(Math.abs(puck.vy), minWallSpeed);
        puck.vy = speed * wallBounce;
        if (Math.abs(puck.vx) < minWallSpeed / 2) {
          puck.vx = (Math.sign(puck.vx) || 1) * (minWallSpeed / 2);
        }
        if (Math.abs(puck.x - goalLeft) < puck.r || Math.abs(puck.x - goalRight) < puck.r) {
          showPostMessage();
        }
        sfx.wall();
      }
    }
    if (puck.y > bottom){
      if (puck.x > goalLeft && puck.x < goalRight){
        const prevP1 = score.p1;
        const prevP2 = score.p2;
        score.p2++; updateScore(); sfx.goal();
        const goalLine = goalBottomY - 6;
        puck.y = goalLine + 0.6 * puck.r;
        puck.vx = 0; puck.vy = 0;
        const ownGoal = lastTouch === 'p1';
        handleGoalCommentary({ scorerKey: 'p2', ownGoal, prevP1, prevP2 });
        running = false;
        showGoalMessage(ownGoal);
        checkWin();
        if (score.p1 < score.target && score.p2 < score.target){
          setTimeout(()=>{ resetPositions(1); running = true; }, GOAL_PAUSE);
        }
        return;
      } else {
        puck.y = bottom;
        const speed = Math.max(Math.abs(puck.vy), minWallSpeed);
        puck.vy = -speed * wallBounce;
        if (Math.abs(puck.vx) < minWallSpeed / 2) {
          puck.vx = (Math.sign(puck.vx) || 1) * (minWallSpeed / 2);
        }
        if (Math.abs(puck.x - goalLeft) < puck.r || Math.abs(puck.x - goalRight) < puck.r) {
          showPostMessage();
        }
        sfx.wall();
      }
    }
  }

  function update(dt){
    paddleFollowTouch(p1, true);
    if (mode==='ai') {
      aiUpdate();
    } else {
      paddleFollowTouch(p2, false);
    }

    constrainPaddle(p1, true);
    constrainPaddle(p2, false);

    puck.x += puck.vx * dt * 60;
    puck.y += puck.vy * dt * 60;
    const mag = puck.spin * dt * 0.6;
    const magVx = -puck.vy * mag;
    const magVy = puck.vx * mag;
    puck.vx += magVx;
    puck.vy += magVy;
    puck.vx *= Math.pow(friction, dt*60);
    puck.vy *= Math.pow(friction, dt*60);
    puck.angle += Math.hypot(puck.vx, puck.vy) * dt * 0.1;
    puck.angle += puck.spin * dt * 13;
    puck.spin *= Math.pow(0.991, dt*60);

    handleCollisions();

    [p1,p2].forEach(p=>{p.lastX=p.x; p.lastY=p.y;});
  }

  function render(){
    ctx.clearRect(0,0,W,H);
    drawRink();
    drawPaddle(p2, getCSS('--p2'), p2AvatarImg, p2AvatarEmoji);
    drawPaddle(p1, getCSS('--p1'), p1AvatarImg, p1AvatarEmoji);
      drawPuck();
  }

  function loop(ts){
    if (!running){ last = ts; render(); return requestAnimationFrame(loop); }
    const dt = Math.min(0.033, (ts - last)/1000 || 0.016);
    last = ts;
    update(dt);
    render();
    requestAnimationFrame(loop);
  }

  function updateScore(){ s1El.textContent = score.p1; s2El.textContent = score.p2; }
  function checkWin(){
    if (score.p1>=score.target){
      running=false;
      if (!commentaryOutroPlayed) {
        const context = getContextForScorer('p1');
        enqueueCommentaryEvent(COMMENTARY_EVENTS.matchWin, context, {
          priority: true,
          speaker: GOAL_RUSH_SPEAKERS.lead
        });
        enqueueCommentaryEvent(COMMENTARY_EVENTS.outro, context, {
          priority: true,
          speaker: GOAL_RUSH_SPEAKERS.analyst
        });
        commentaryOutroPlayed = true;
      }
      const pot = stake*2;
      if(!window.tournamentMode){
        if (stake>0 && myAccountId){
          const prize = Math.round(pot*0.91);
          awardTpc(myAccountId, prize);
          recordWin(tgId, myAccountId);
        }
        if(stake>0) awardDevShare(pot);
      }

      if(window.tournamentMode && typeof window.handleTournamentResult === 'function'){
        try{localStorage.setItem(`goalRushLastResult_${tgKey}`, JSON.stringify({p1: score.p1, p2: score.p2}));}catch{}
        window.handleTournamentResult(1);
        return;
      }
      celebrate(p1Name, p1AvatarImg, p1AvatarEmoji);
    }
    if (score.p2>=score.target){
      running=false;
      if (!commentaryOutroPlayed) {
        const context = getContextForScorer('p2');
        enqueueCommentaryEvent(COMMENTARY_EVENTS.matchWin, context, {
          priority: true,
          speaker: GOAL_RUSH_SPEAKERS.lead
        });
        enqueueCommentaryEvent(COMMENTARY_EVENTS.outro, context, {
          priority: true,
          speaker: GOAL_RUSH_SPEAKERS.analyst
        });
        commentaryOutroPlayed = true;
      }
      const pot = stake*2;
      if(!window.tournamentMode){
        if(stake>0 && oppAccountId){
          const prize = Math.round(pot*0.91);
          awardTpc(oppAccountId, prize);
          recordWin(oppTgId, oppAccountId);
        }
        if(stake>0) awardDevShare(pot);
      }

      if(window.tournamentMode && typeof window.handleTournamentResult === 'function'){
        try{localStorage.setItem(`goalRushLastResult_${tgKey}`, JSON.stringify({p1: score.p1, p2: score.p2}));}catch{}
        window.handleTournamentResult(2);
        return;
      }
      celebrate(p2Name, p2AvatarImg, p2AvatarEmoji);
    }
  }
  function toast(msg){
    const old = startHint.textContent;
    startHint.textContent = msg;
    startHint.style.display = 'flex';
    setTimeout(()=>{ startHint.textContent = old; startHint.style.display = 'none'; }, 1400);
  }

  window.addEventListener('keydown', e=>keys.add(e.key));
  window.addEventListener('keyup', e=>keys.delete(e.key));

  function posFromEvent(e){
    const rect = canvas.getBoundingClientRect();
    const scaleX = canvas.width / rect.width; const scaleY = canvas.height / rect.height;
    return { x: (e.clientX-rect.left)*scaleX, y: (e.clientY-rect.top)*scaleY };
  }
  canvas.addEventListener('pointerdown', e=>{
    const p = posFromEvent(e);
    canvas.setPointerCapture(e.pointerId);
    const t = performance.now();
    touches.set(e.pointerId, {x:p.x, y:p.y, vx:0, vy:0, t});
    unlockCommentary();
    initAudio();
  });
  canvas.addEventListener('pointermove', e=>{
    const p = posFromEvent(e);
    if (!touches.has(e.pointerId)) return;
    const now = performance.now();
    const last = touches.get(e.pointerId);
    const dt = Math.max(1, now - last.t);
    const vx = (p.x - last.x) / dt * 16.67;
    const vy = (p.y - last.y) / dt * 16.67;
    touches.set(e.pointerId, {x:p.x, y:p.y, vx, vy, t:now});
    const d1 = dist(p1.x,p1.y,p.x,p.y); const d2 = dist(p2.x,p2.y,p.x,p.y);
    if (p.y > centerY && d1 < d2) { p1.vx = vx; p1.vy = vy; }
    else if (p.y < centerY && d2 <= d1) { p2.vx = vx; p2.vy = vy; }
  });
  function clearTouch(id){ touches.delete(id); }
  canvas.addEventListener('pointerup', e=>{
    clearTouch(e.pointerId);
  });
  canvas.addEventListener('pointercancel', e=>{
    clearTouch(e.pointerId);
  });

  if (!window.PointerEvent) {
    canvas.addEventListener('touchstart', e => {
      e.preventDefault();
      const now = performance.now();
      for (const t of e.changedTouches) {
        const p = posFromEvent(t);
        touches.set(t.identifier, { x: p.x, y: p.y, vx: 0, vy: 0, t: now });
      }
      unlockCommentary();
      initAudio();
    }, { passive: false });

    canvas.addEventListener('touchmove', e => {
      e.preventDefault();
      const now = performance.now();
      for (const t of e.changedTouches) {
        if (!touches.has(t.identifier)) continue;
        const p = posFromEvent(t);
        const last = touches.get(t.identifier);
        const dt = Math.max(1, now - last.t);
        const vx = (p.x - last.x) / dt * 16.67;
        const vy = (p.y - last.y) / dt * 16.67;
        touches.set(t.identifier, { x: p.x, y: p.y, vx, vy, t: now });
        const d1 = dist(p1.x, p1.y, p.x, p.y);
        const d2 = dist(p2.x, p2.y, p.x, p.y);
        if (p.y > centerY && d1 < d2) { p1.vx = vx; p1.vy = vy; }
        else if (p.y < centerY && d2 <= d1) { p2.vx = vx; p2.vy = vy; }
      }
    }, { passive: false });

    const removeTouches = e => {
      for (const t of e.changedTouches) clearTouch(t.identifier);
    };
    canvas.addEventListener('touchend', removeTouches);
    canvas.addEventListener('touchcancel', removeTouches);
  }

  function checkOrientation(){ landscapeBlock.style.display = (window.matchMedia('(orientation: landscape)').matches ? 'flex' : 'none'); }
  window.addEventListener('orientationchange', checkOrientation);

  if (params.get('type') === 'tournament') {
    window.handleTournamentResult = async function (winner) {
      try {
        var st = JSON.parse(localStorage.getItem(TOURN_STATE_KEY) || '{}');
        if (!st.pendingMatch) {
          window.location.href = '/goal-rush-bracket.html?' + window.location.search.slice(1);
          return;
        }
        var r = st.pendingMatch.round;
        var m = st.pendingMatch.match;
        var oppSeed = st.pendingMatch.pair[0] === st.userSeed ? st.pendingMatch.pair[1] : st.pendingMatch.pair[0];
        var winnerSeed = winner === 1 ? st.userSeed : oppSeed;
        var next = st.rounds[r + 1];
        if (next) {
          next[Math.floor(m / 2)][m % 2] = winnerSeed;
        } else {
          st.championSeed = winnerSeed;
          st.complete = true;
        }
        if (winnerSeed !== st.userSeed) {
          simulateRemaining(st, r);
        } else {
          simulateRoundAI(st, r);
          if (next && st.rounds[r].every(function (p, idx) { return next[Math.floor(idx / 2)][idx % 2]; })) {
            st.currentRound++;
          }
        }
        if (st.complete && winnerSeed === st.userSeed && stake > 0 && myAccountId) {
          const total = stake * window.tournamentPlayers;
          const prize = Math.round(total * 0.91);
          try {
            await awardTpc(myAccountId, prize);
            if (tgId) await recordWin(tgId, myAccountId);
            await awardDevShare(total);
          } catch {}
        }
        delete st.pendingMatch;
        localStorage.setItem(TOURN_STATE_KEY, JSON.stringify(st));
        localStorage.removeItem(TOURN_OPP_KEY);
      } catch (err) {
        console.error(err);
      }
      window.location.href = '/goal-rush-bracket.html?' + window.location.search.slice(1);
    };

    function simulateRoundAI(st, round) {
      var next = st.rounds[round + 1];
      var userSeed = st.userSeed;
      st.rounds[round].forEach(function (pair, idx) {
        if (pair.includes(userSeed)) return;
        if (next && next[Math.floor(idx / 2)][idx % 2]) return;
        var s1 = pair[0];
        var s2 = pair[1];
        var p1 = st.seedToPlayer[s1];
        var p2 = st.seedToPlayer[s2];
        var w;
        if (p1 && p1.name === 'BYE') w = s2;
        else if (p2 && p2.name === 'BYE') w = s1;
        else w = Math.random() < 0.5 ? s1 : s2;
        if (next) {
          next[Math.floor(idx / 2)][idx % 2] = w;
        } else {
          st.championSeed = w;
          st.complete = true;
        }
      });
    }

    function simulateRemaining(st, startRound) {
      for (var r = startRound; r < st.rounds.length; r++) {
        simulateRoundAI(st, r);
        if (st.complete) break;
      }
      st.currentRound = st.rounds.length - 1;
      st.complete = true;
    }
  }

  fit(); checkOrientation(); resetPositions(); updateScore(); playWhistle();
  document.body.classList.add('loaded');
  requestAnimationFrame(loop);
  })();
</script>
<script>
if(window.tournamentMode){
  const tg = window.Telegram?.WebApp;
  function showExitPopup(){
    if(document.getElementById('tournExit')) return;
    const overlay=document.createElement('div');
    overlay.id='tournExit';
    overlay.style.position='fixed';overlay.style.inset='0';
    overlay.style.background='rgba(0,0,0,0.6)';
    overlay.style.display='flex';overlay.style.flexDirection='column';
    overlay.style.alignItems='center';overlay.style.justifyContent='center';
    const box=document.createElement('div');
    box.style.background='#11172a';box.style.padding='20px';box.style.borderRadius='8px';box.style.textAlign='center';box.style.maxWidth='90%';box.style.color='#dbe7ff';
    box.innerHTML='<p style="margin-bottom:12px;">If you quit the tournament, your funds will be lost and you will be placed last.</p>';
    const quit=document.createElement('button');
    quit.textContent='Quit Tournament';
    quit.style.margin='4px';quit.style.padding='8px 12px';
    quit.style.background='#f97316';quit.style.border='none';
    quit.style.borderRadius='4px';quit.style.color='#fff';
    const ret=document.createElement('button');
    ret.textContent='Return to Lobby';
    ret.style.margin='4px';ret.style.padding='8px 12px';
    ret.style.background='#2563eb';ret.style.border='none';
    ret.style.borderRadius='4px';ret.style.color='#fff';
    box.appendChild(quit);box.appendChild(ret);overlay.appendChild(box);document.body.appendChild(overlay);
    quit.onclick=()=>{localStorage.removeItem(TOURN_STATE_KEY);localStorage.removeItem(TOURN_OPP_KEY);if(tg) tg.BackButton.hide();window.location.href='/games/goalrush/lobby';};
    ret.onclick=()=>{if(tg) tg.BackButton.show();window.location.href='/goal-rush-bracket.html'+window.location.search;};
  }
  if(tg){ tg.BackButton.show(); tg.onEvent('backButtonClicked', showExitPopup); tg.onEvent('close', showExitPopup); }
  history.pushState(null,'',location.href);
  window.addEventListener('popstate',(e)=>{ e.preventDefault(); showExitPopup(); history.pushState(null,'',location.href); });
}
</script>
</body>
</html>
