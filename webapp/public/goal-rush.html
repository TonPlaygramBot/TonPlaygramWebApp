<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
  <title>Goal Rush</title>
  <style>
    :root{
      --bg:#050812;
      --ice:#0f1730;
      --line:#67a6ff;
      --goal:#fff;
      --p1:#22c55e;
      --p2:#f59e0b;
      --puck:#e5e7eb;
    }
    *{box-sizing:border-box; -webkit-tap-highlight-color: transparent;}
    html,body{height:100%;}
    body{margin:0;background:var(--bg);color:#e5e7eb;font-family:system-ui,Segoe UI,Roboto,Helvetica,Arial;overflow:hidden}
    .ui{position:fixed;inset:0;}
    .scoreboard{position:absolute;top:0;left:0;right:0;height:40px;display:flex;align-items:center;justify-content:center;pointer-events:none;}
    .score{font-variant-numeric:tabular-nums;background:#0b1220;border:1px solid #233050;border-radius:12px;padding:6px 10px;display:flex;align-items:center;gap:8px}
    .badge{padding:2px 8px;border-radius:999px;font-weight:800}
    .p1{background:var(--p1);color:#052e12}
    .p2{background:var(--p2);color:#3a2600}

    .canvasWrap{position:absolute;top:40px;bottom:20px;left:0;right:0;}
    canvas{position:absolute;inset:0;width:100%;height:100%;display:block;touch-action:none}


    .hint{position:fixed;inset:0;display:none;align-items:center;justify-content:center;margin:auto;max-width:680px;background:rgba(10,16,34,.6);backdrop-filter:blur(6px);border:1px solid #1f2944;border-radius:12px;padding:8px 12px;text-align:center;font-size:.9rem}

    .mute-btn{position:absolute;top:6px;right:6px;z-index:5;background:#0b1220;border:1px solid #233050;color:#e5e7eb;border-radius:8px;padding:4px 8px;font-size:14px}
    .mute-btn.muted::after{content:'';position:absolute;top:50%;left:20%;width:60%;height:2px;background:#ff3b3b;transform:rotate(-45deg)}

    .coin-confetti{position:fixed;top:-40px;width:32px;height:32px;pointer-events:none;animation:coin-fall var(--duration,3s) linear forwards}
    @keyframes coin-fall{from{transform:translateY(-10vh) rotate(0deg);opacity:1}to{transform:translateY(100vh) rotate(360deg);opacity:0}}

    .goal-text{position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);font-size:48px;font-weight:800;color:var(--goal);text-align:center;display:none;pointer-events:none;text-shadow:2px 2px 0 #000;line-height:1.1}
    .goal-text .score-line{display:block;font-size:32px;font-weight:600}

    @media (orientation:landscape){
      .landscape-block{position:fixed;inset:0;display:flex;align-items:center;justify-content:center;background:#0008;z-index:20;color:#fff;text-align:center;padding:24px}
    }
  </style>
</head>
<body>
  <div class="ui">
    <div class="scoreboard">
      <div class="score" aria-live="polite">
        <span id="p1Name" class="badge p1">P1</span><span id="s1">0</span>
        <span>â€”</span>
        <span id="s2">0</span><span id="p2Name" class="badge p2">P2</span>
      </div>
    </div>
    <button id="muteBtn" class="mute-btn" aria-label="Toggle sound">ðŸ”Š</button>
    <div class="canvasWrap">
      <canvas id="game" width="720" height="1280" aria-label="Goal Rush Field"></canvas>
    </div>
    <div id="goalText" class="goal-text"></div>
  </div>
  <div class="hint" id="startHint"></div>
  <div class="landscape-block" style="display:none">Please hold your phone in <b>portrait</b> for the best experience.</div>


<script src="/falling-ball-api.js"></script>
<script>
(() => {
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  const s1El = document.getElementById('s1');
  const s2El = document.getElementById('s2');
  const p1NameEl = document.getElementById('p1Name');
  const p2NameEl = document.getElementById('p2Name');
  const startHint = document.getElementById('startHint');
  const landscapeBlock = document.querySelector('.landscape-block');
  const muteBtn = document.getElementById('muteBtn');
  const goalText = document.getElementById('goalText');
  const TOP_BAR = 40; // height of scoreboard bar
  const BOTTOM_GAP = 20; // gap below rink
  const GOAL_PAUSE = 1500; // pause after a goal
  let fieldScaleActual = 1;

  const fieldImg = new Image();
  fieldImg.src = '/assets/icons/file_00000000becc620a8755badc01cfefca.webp';
  const puckImg = new Image();
  puckImg.src = '/assets/icons/file_0000000061d4620aaf506adfa605e1f3.webp';

  const params = new URLSearchParams(location.search);
  const stake = Number(params.get('amount')) || 0;
  let myAccountId = params.get('accountId');
  if (!myAccountId) {
    try { myAccountId = localStorage.getItem('accountId'); } catch {}
  }
  if (!myAccountId) {
    myAccountId = crypto.randomUUID();
    try { localStorage.setItem('accountId', myAccountId); } catch {}
  }
  const devAccount = params.get('dev');
  const devAccount1 = params.get('dev1');
  const devAccount2 = params.get('dev2');
  const tgId = params.get('tgId');
  const initParam = params.get('init');
  if (initParam && !window.Telegram) {
    window.Telegram = { WebApp: { initData: decodeURIComponent(initParam) } };
  }
  const oppAccountId = params.get('oppAcc') || params.get('oppId') || params.get('p2AccountId');
  const oppTgId = params.get('oppTg') || params.get('p2TgId');
  const mode = params.get('mode') || 'ai';
  const difficulty = 'normal';
  const target = Number(params.get('target')) || 3;
  const avatarParam = params.get('avatar') || '';
  const oppParam = params.get('p2Avatar') || '';
  let p1Name = params.get('name') || 'P1';
  let p2Name = params.get('p2Name') || 'P2';
  let fieldScaleX = 1, fieldScaleY = 1, fieldImgScaleX = 1, fieldImgScaleY = 1, puckScale = 0.9, goalWidthPct = 0.36, goalOffsetXPct = 0, goalOffsetYPct = 0, paddleScale = 0.95, speedMul = 1;
  try {
    const oldFieldScale = parseFloat(localStorage.getItem('fieldScale')) || 1;
    fieldScaleX = parseFloat(localStorage.getItem('fieldScaleX')) || oldFieldScale;
    fieldScaleY = parseFloat(localStorage.getItem('fieldScaleY')) || oldFieldScale;
    const oldImgScale = parseFloat(localStorage.getItem('fieldImgScale')) || 1;
    fieldImgScaleX = parseFloat(localStorage.getItem('fieldImgScaleX')) || oldImgScale;
    fieldImgScaleY = parseFloat(localStorage.getItem('fieldImgScaleY')) || oldImgScale;
    puckScale = parseFloat(localStorage.getItem('puckScale')) || 0.9;
    goalWidthPct = parseFloat(localStorage.getItem('goalWidthPct')) || 0.36;
    goalOffsetXPct = parseFloat(localStorage.getItem('goalOffsetXPct')) || 0;
    goalOffsetYPct = parseFloat(localStorage.getItem('goalOffsetYPct')) || 0;
    paddleScale = parseFloat(localStorage.getItem('paddleScale')) || 0.95;
    speedMul = parseFloat(localStorage.getItem('speedMul')) || 1;
  } catch {}
  const FLAG_DATA = [
    { emoji:'ðŸ‡ºðŸ‡¸', name:'USA' },
    { emoji:'ðŸ‡¬ðŸ‡§', name:'UK' },
    { emoji:'ðŸ‡«ðŸ‡·', name:'France' },
    { emoji:'ðŸ‡©ðŸ‡ª', name:'Germany' },
    { emoji:'ðŸ‡¨ðŸ‡¦', name:'Canada' },
    { emoji:'ðŸ‡¯ðŸ‡µ', name:'Japan' },
    { emoji:'ðŸ‡®ðŸ‡³', name:'India' },
    { emoji:'ðŸ‡°ðŸ‡·', name:'South Korea' },
    { emoji:'ðŸ‡§ðŸ‡·', name:'Brazil' },
    { emoji:'ðŸ‡²ðŸ‡½', name:'Mexico' },
    { emoji:'ðŸ‡¨ðŸ‡³', name:'China' },
    { emoji:'ðŸ‡¦ðŸ‡º', name:'Australia' },
    { emoji:'ðŸ‡®ðŸ‡¹', name:'Italy' },
    { emoji:'ðŸ‡ªðŸ‡¸', name:'Spain' },
    { emoji:'ðŸ‡·ðŸ‡º', name:'Russia' }
  ];

  let p1AvatarImg=null, p1AvatarEmoji=null;
  if(avatarParam){
    if(avatarParam.startsWith('http') || avatarParam.startsWith('/')){ p1AvatarImg = new Image(); p1AvatarImg.src = avatarParam; }
    else { p1AvatarEmoji = avatarParam; }
  }
  let p2AvatarImg=null, p2AvatarEmoji='ðŸ¤–';
  if(oppParam){
    if(oppParam.startsWith('http') || oppParam.startsWith('/')){ p2AvatarImg = new Image(); p2AvatarImg.src = oppParam; p2AvatarEmoji=null; }
    else { p2AvatarEmoji = oppParam; }
  }

  if(mode==='ai'){
    const ai = FLAG_DATA[Math.floor(Math.random()*FLAG_DATA.length)];
    p2AvatarImg = null;
    p2AvatarEmoji = ai.emoji;
    p2Name = ai.name;
  }
    p1NameEl.textContent = p1Name;
    p2NameEl.textContent = p2Name;

  async function awardTpc(accountId, amount){
    try{
      await fbApi.depositAccount(accountId, amount, { game: 'goalrush-win' });
    }catch(err){ console.warn('Failed to award TPC',err); }
  }
  async function recordWin(tgId, accountId){
    if(!tgId) return;
    try{
      await fbApi.addTransaction(tgId, 0, 'win', { game:'goalrush', players:2, accountId });
    }catch{}
  }
  async function awardDevShare(total){
    const ops=[];
    if(devAccount1||devAccount2){
      if(devAccount) ops.push(fbApi.depositAccount(devAccount, Math.round(total*0.09), {game:'goalrush-dev'}));
      if(devAccount1) ops.push(fbApi.depositAccount(devAccount1, Math.round(total*0.01), {game:'goalrush-dev1'}));
      if(devAccount2) ops.push(fbApi.depositAccount(devAccount2, Math.round(total*0.02), {game:'goalrush-dev2'}));
    }else if(devAccount){
      ops.push(fbApi.depositAccount(devAccount, Math.round(total*0.1), {game:'goalrush-dev'}));
    }
    if(ops.length){ try{ await Promise.all(ops); }catch{} }
  }

  function coinConfetti(count=50,iconSrc='/assets/icons/ezgif-54c96d8a9b9236.webp'){
    const container=document.createElement('div');
    container.style.position='fixed';container.style.top='0';container.style.left='0';
    container.style.width='100%';container.style.height='0';container.style.pointerEvents='none';
    container.style.zIndex='60';container.style.overflow='visible';
    document.body.appendChild(container);
    for(let i=0;i<count;i++){
      const img=document.createElement('img');
      img.src=iconSrc;img.alt='confetti icon';img.className='coin-confetti';
      const left=Math.random()*100;const delay=Math.random()*0.2;const duration=2+Math.random()*2;
      img.style.left=left+'vw';img.style.animationDelay=delay+'s';img.style.setProperty('--duration',duration+'s');
      container.appendChild(img);
    }
    setTimeout(()=>container.remove(),5000);
  }

  async function chargeStake(){
    if(!tgId || stake<=0) return;
    try{
      await fbApi.addTransaction(tgId, -stake, 'stake', { game:'goalrush', players:2, accountId: myAccountId });
    }catch{}
  }

  function celebrate(winner,avatarImg,avatarEmoji){
    coinConfetti();
    let audio;
    try{
      audio=new Audio('/assets/sounds/11l-victory_sound_with_t-1749487412779-357604.mp3');
      if(audioEnabled) audio.play().catch(()=>{});
    }catch{}
    const overlay=document.createElement('div');
    overlay.style.position='fixed';overlay.style.inset='0';overlay.style.display='flex';overlay.style.flexDirection='column';
    overlay.style.alignItems='center';overlay.style.justifyContent='center';overlay.style.background='rgba(0,0,0,0.7)';overlay.style.zIndex='40';
    const av=document.createElement('div');
    av.style.fontSize='64px';av.style.width='80px';av.style.height='80px';av.style.display='flex';
    av.style.alignItems='center';av.style.justifyContent='center';av.style.borderRadius='50%';av.style.background='#fff';
    if(avatarImg && avatarImg.complete){av.style.backgroundImage=`url(${avatarImg.src})`;av.style.backgroundSize='cover';av.textContent='';}
    else{av.textContent=avatarEmoji||'';}
    const txt=document.createElement('div');
    txt.textContent=`${winner} Wins!`;txt.style.color='#fff';txt.style.fontSize='2rem';txt.style.marginTop='16px';txt.style.fontWeight='bold';
    overlay.appendChild(av);overlay.appendChild(txt);document.body.appendChild(overlay);
    setTimeout(()=>{overlay.remove();showEndPopup();if(audio) audio.pause();},2500);
  }

  function showEndPopup(){
    const pop=document.createElement('div');
    pop.style.position='fixed';pop.style.inset='0';pop.style.display='flex';pop.style.alignItems='center';pop.style.justifyContent='center';pop.style.background='rgba(0,0,0,0.7)';pop.style.zIndex='50';
    const box=document.createElement('div');
    box.style.background='#0b1220';box.style.padding='16px';box.style.borderRadius='12px';box.style.display='flex';box.style.flexDirection='column';box.style.gap='8px';box.style.minWidth='200px';
    const btnLobby=document.createElement('button');btnLobby.textContent='Return to Lobby';btnLobby.style.padding='8px';btnLobby.onclick=()=>{location.href='/games/goalrush/lobby';};
    const btnAgain=document.createElement('button');btnAgain.textContent='Play Again';btnAgain.style.padding='8px';
    btnAgain.onclick=async()=>{
      if(mode==='ai'){
        await chargeStake();
        score.p1=0;score.p2=0;updateScore();resetPositions();running=true;pop.remove();
      }else{
        btnAgain.disabled=true;
        const wait=document.createElement('div');wait.textContent='Waiting for opponent...';wait.style.color='#fff';wait.style.marginTop='8px';box.appendChild(wait);
        try{await fetch('/api/goalrush/rematch',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({accountId:myAccountId})});}catch{}
      }
    };
    box.appendChild(btnLobby);box.appendChild(btnAgain);pop.appendChild(box);document.body.appendChild(pop);
  }

  let W = 720, H = 1280, goalCenterX = 0, goalTopY = 0, goalBottomY = 0;
  function fit(){
    W = canvas.width = Math.floor(window.innerWidth * devicePixelRatio);
    const usableHeight = window.innerHeight - TOP_BAR - BOTTOM_GAP;
    H = canvas.height = Math.floor(usableHeight * devicePixelRatio);
    canvas.style.width = window.innerWidth + 'px';
    canvas.style.height = usableHeight + 'px';
    const baseW = W*0.88;
    const baseH = H*0.92;
    const maxFieldScaleX = W/baseW;
    const maxFieldScaleY = H/baseH;
    const fsx = Math.min(fieldScaleX, maxFieldScaleX);
    const fsy = Math.min(fieldScaleY, maxFieldScaleY);
    fieldScaleActual = Math.min(fsx, fsy);
    rink.w = Math.round(baseW * fsx);
    rink.h = Math.round(baseH * fsy);
    rink.x = Math.round((W - rink.w) / 2);
    rink.y = Math.round((H - rink.h) / 2);
    centerX = W/2; centerY = H/2;
    goalCenterX = centerX + rink.w * goalOffsetXPct;
    goalTopY = rink.y + rink.h * goalOffsetYPct;
    goalBottomY = goalTopY + rink.h;
    try{
      localStorage.setItem('goalTopY', goalTopY);
      localStorage.setItem('goalBottomY', goalBottomY);
    }catch{}
    goalWidth = Math.round(W*goalWidthPct*fsx);
    const base = Math.max(24, Math.round(Math.min(W,H)*0.035*fieldScaleActual));
    paddleRadius = base*3.4*paddleScale;
    puck.r = Math.max(20, Math.round(base*1.0*puckScale));
    p1.r = paddleRadius; p2.r = paddleRadius;
  }
  window.addEventListener('resize', fit);

  const rink = { x:0,y:0,w:0,h:0,r:24 };
  let centerX = 0, centerY = 0;
  let goalWidth = 260;
  let goalDepth = 24;
  let paddleRadius = 34;

  const puck = { x:0, y:0, r:20, vx:0, vy:0, max: 29, angle: 0, spin: 0 };
  const p1 = { x:0, y:0, r:34, vx:0, vy:0, max: 18, lastX:0, lastY:0 };
  const p2 = { x:0, y:0, r:34, vx:0, vy:0, max: 18, lastX:0, lastY:0 };
  const score = { p1:0, p2:0, target }; 
  let running = true; let last = 0;
  const difficultySpeeds = { easy:14, normal:18, hard:24 };
  p2.max = difficultySpeeds[difficulty] || 18;

  let audioEnabled = true;
  let audioStarted = false;
  const crowdSound = new Audio('/assets/sounds/football-crowd-3-69245.mp3');
  crowdSound.loop = true;
  const whistleSound = new Audio('/assets/sounds/metal-whistle-6121.mp3');
  const crowdBaseVolume = 0.5;
  crowdSound.volume = crowdBaseVolume;
  let pendingWhistle = false;

  function playWhistle(){
    if(!audioEnabled || !audioStarted){ pendingWhistle = true; return; }
    pendingWhistle = false;
    whistleSound.currentTime = 0;
    whistleSound.play().catch(()=>{});
    setTimeout(()=>{ whistleSound.pause(); whistleSound.currentTime = 0; },2000);
  }

  function initAudio(){
    if(audioStarted || !audioEnabled) return;
    audioStarted = true;
    crowdSound.play().catch(()=>{});
    if(pendingWhistle) playWhistle();
  }

  muteBtn.classList.toggle('muted', !audioEnabled);
  muteBtn.addEventListener('click', () => {
    audioEnabled = !audioEnabled;
    muteBtn.classList.toggle('muted', !audioEnabled);
    if(audioEnabled){
      if(!audioStarted) initAudio();
      else crowdSound.play().catch(()=>{});
    }else{
      crowdSound.pause();
      whistleSound.pause();
    }
  });


  const sfx = {
    hit(){
      if(!audioEnabled) return;
      const snd = new Audio('/assets/sounds/football-game-sound-effects-359284.mp3');
      snd.play().catch(()=>{});
      setTimeout(()=>{ snd.pause(); },700);
    },
    wall(){},
    goal(){
      if(!audioEnabled) return;
      playWhistle();
    }
  };

  const keys = new Set();
  const touches = new Map();

  function clamp(v,a,b){ return Math.max(a, Math.min(b,v)); }
  function dist(x1,y1,x2,y2){ const dx=x2-x1, dy=y2-y1; return Math.hypot(dx,dy); }

  function resetPositions(kickoff=0){
    p1.x = centerX; p1.y = Math.min(rink.y+rink.h- rink.h*0.12, H*0.85);
    p2.x = centerX; p2.y = Math.max(rink.y + rink.h*0.12, H*0.15);
    puck.x = centerX;
    puck.y = centerY;
    if(kickoff===1){
      puck.y = centerY + rink.h/4;
    } else if(kickoff===2){
      puck.y = centerY - rink.h/4;
    }
    puck.vx = 0; puck.vy = 0; puck.spin = 0;
    [p1,p2].forEach(p=>{p.vx=0;p.vy=0;p.lastX=p.x;p.lastY=p.y;});
  }

  function showGoalMessage(){
    goalText.innerHTML = `GOAL!<span class="score-line">${score.p1} - ${score.p2}</span>`;
    goalText.style.display = 'block';
    setTimeout(()=>{ goalText.style.display='none'; }, GOAL_PAUSE);
  }

  function rr(x,y,w,h,r){
    const rr = Math.min(r,w/2,h/2);
    ctx.beginPath();
    ctx.moveTo(x+rr,y);
    ctx.arcTo(x+w,y,x+w,y+h,rr);
    ctx.arcTo(x+w,y+h,x,y+h,rr);
    ctx.arcTo(x,y+h,x,y,rr);
    ctx.arcTo(x,y,x+w,y,rr);
    ctx.closePath();
  }
  function drawRink(){
    if (fieldImg.complete) {
      const imgW = rink.w * fieldImgScaleX;
      const imgH = rink.h * fieldImgScaleY;
      const imgX = rink.x + (rink.w - imgW)/2;
      const imgY = rink.y + (rink.h - imgH)/2;
      ctx.drawImage(fieldImg, imgX, imgY, imgW, imgH);
    } else {
      rr(rink.x, rink.y, rink.w, rink.h, rink.r);
      ctx.fillStyle = getCSS('--ice'); ctx.fill();
      ctx.lineWidth = Math.max(2, W*0.003);
      ctx.strokeStyle = getCSS('--line');
      ctx.beginPath(); ctx.moveTo(rink.x+10, centerY); ctx.lineTo(rink.x+rink.w-10, centerY); ctx.stroke();
      ctx.beginPath(); ctx.arc(centerX, centerY, Math.min(W,H)*0.11, 0, Math.PI*2); ctx.stroke();
      ctx.beginPath();
      ctx.arc(centerX, H*0.25, Math.min(W,H)*0.09, 0, Math.PI*2);
      ctx.moveTo(centerX + Math.min(W,H)*0.09, H*0.75);
      ctx.arc(centerX, H*0.75, Math.min(W,H)*0.09, 0, Math.PI*2);
      ctx.stroke();
      drawGoal(goalCenterX, goalTopY, goalWidth, goalDepth, -1);
      drawGoal(goalCenterX, goalBottomY, goalWidth, goalDepth, 1);
    }
  }
  function drawGoal(cx, y, w, d, dir){
    ctx.save();
    ctx.translate(cx, y);
    ctx.scale(1, dir);
    const lw = Math.max(3, W*0.004);
    ctx.lineWidth = lw;
    ctx.strokeStyle = '#fff';
    ctx.beginPath();
    ctx.moveTo(-w/2, 0); ctx.lineTo(w/2, 0);
    ctx.moveTo(-w/2, d); ctx.lineTo(w/2, d);
    ctx.moveTo(-w/2, 0); ctx.lineTo(-w/2, d);
    ctx.moveTo(w/2, 0); ctx.lineTo(w/2, d);
    ctx.stroke();
    const spacing = Math.max(8, w/10);
    ctx.beginPath();
    for(let i=-w/2+spacing;i<w/2;i+=spacing){
      ctx.moveTo(i,0); ctx.lineTo(i,d);
    }
    for(let j=spacing;j<d;j+=spacing){
      ctx.moveTo(-w/2,j); ctx.lineTo(w/2,j);
    }
    ctx.strokeStyle = 'rgba(255,255,255,0.4)';
    ctx.stroke();
    ctx.restore();
  }
  function drawPaddle(p, color, img, emoji){
    const g = ctx.createRadialGradient(p.x-6, p.y-6, 6, p.x, p.y, p.r);
    g.addColorStop(0, '#fff'); g.addColorStop(0.2, color); g.addColorStop(1, '#0d0f14');
    ctx.beginPath(); ctx.arc(p.x,p.y,p.r,0,Math.PI*2); ctx.fillStyle = g; ctx.fill();
    ctx.save();
    ctx.beginPath(); ctx.arc(p.x,p.y,p.r*0.8,0,Math.PI*2); ctx.clip();
    if(img && img.complete){
      ctx.drawImage(img, p.x-p.r*0.8, p.y-p.r*0.8, p.r*1.6, p.r*1.6);
    } else if(emoji){
      ctx.fillStyle = '#fff';
      ctx.font = `${p.r*0.8}px sans-serif`;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(emoji, p.x, p.y+1);
    }
    ctx.restore();
  }
  function drawPuck(){
    const r = puck.r;
    ctx.save();
    ctx.translate(puck.x, puck.y);
    ctx.rotate(puck.angle);
    if (puckImg.complete) {
      ctx.drawImage(puckImg, -r, -r, r * 2, r * 2);
      ctx.restore();
      return;
    }
    ctx.fillStyle = '#fff';
    ctx.beginPath(); ctx.arc(0,0,r,0,Math.PI*2); ctx.fill();
    ctx.fillStyle = '#000';
    const pentR = r*0.4;
    ctx.beginPath();
    for(let i=0;i<5;i++){ const a=-Math.PI/2+i*2*Math.PI/5; ctx.lineTo(pentR*Math.cos(a), pentR*Math.sin(a)); }
    ctx.closePath(); ctx.fill();
    for(let i=0;i<5;i++){
      const a=-Math.PI/2+i*2*Math.PI/5;
      const bx=r*0.9*Math.cos(a), by=r*0.9*Math.sin(a);
      ctx.beginPath();
      for(let j=0;j<5;j++){ const ang=a+Math.PI/5+j*2*Math.PI/5; ctx.lineTo(bx+pentR*0.6*Math.cos(ang), by+pentR*0.6*Math.sin(ang)); }
      ctx.closePath(); ctx.fill();
    }
    ctx.globalAlpha = .18; ctx.fillStyle = '#000';
    ctx.beginPath(); ctx.arc(5,5,r,0,Math.PI*2); ctx.fill(); ctx.globalAlpha = 1;
    ctx.restore();
  }
  function getCSS(v){ return getComputedStyle(document.documentElement).getPropertyValue(v).trim(); }

  const friction = 0.996;
  const wallBounce = 1.05;
  const minWallSpeed = 4;
  function constrainPaddle(p, bottom){
    const margin=12;
    const minX = rink.x + margin + p.r;
    const maxX = rink.x + rink.w - margin - p.r;
    const minY = rink.y + margin + p.r;
    const maxY = rink.y + rink.h - margin - p.r;
    if (bottom){
      p.y = clamp(p.y, centerY + p.r, maxY);
    } else {
      p.y = clamp(p.y, minY, centerY - p.r);
    }
    p.x = clamp(p.x, minX, maxX);
  }

  function paddleFollowTouch(p, bottom){
    let best = null; let bestD = 1e9;
    touches.forEach(t=>{
      if (bottom && t.y > centerY) {
        const d = dist(p.x,p.y,t.x,t.y); if (d<bestD){bestD=d; best=t;}
      }
      if (!bottom && t.y < centerY) {
        const d = dist(p.x,p.y,t.x,t.y); if (d<bestD){bestD=d; best=t;}
      }
    });
    if (best){
      const ease = 1;
      const tx = best.x, ty = best.y;
      const nx = p.x + (tx - p.x) * ease;
      let ny = p.y + (ty - p.y) * ease;
      ny -= p.r * 0.5;
      p.vx = nx - p.lastX;
      p.vy = ny - p.lastY;
      p.x = nx; p.y = ny;
    } else {
      p.vx *= 0.8; p.vy *= 0.8;
    }
  }

  function aiUpdate(){
    const reaction = {easy:0.05, normal:0.1, hard:0.18}[difficulty] || 0.1;
    let tx = centerX;
    let ty = rink.y + rink.h*0.15;
    if(puck.y < centerY){
      tx = clamp(puck.x, rink.x + p2.r + 8, rink.x + rink.w - p2.r - 8);
      ty = clamp(puck.y, rink.y + p2.r + 8, centerY - p2.r - 8);
    }
    p2.x += (tx - p2.x) * reaction;
    p2.y += (ty - p2.y) * reaction;
    const maxStep = p2.max * speedMul;
    const vx = p2.x - p2.lastX;
    const vy = p2.y - p2.lastY;
    const v = Math.hypot(vx,vy);
    if(v > maxStep){ const s = maxStep / v; p2.x = p2.lastX + vx*s; p2.y = p2.lastY + vy*s; }
    p2.vx = p2.x - p2.lastX; p2.vy = p2.y - p2.lastY;
  }

  function handleCollisions(){
    [p1,p2].forEach(p => {
      const d = dist(p.x,p.y,puck.x,puck.y);
      const minD = p.r + puck.r;
      if (d < minD){
        const nx = (puck.x - p.x) / (d||1);
        const ny = (puck.y - p.y) / (d||1);
        const overlap = minD - d + 0.5;
        puck.x += nx * overlap; puck.y += ny * overlap;
        p.x -= nx * overlap; p.y -= ny * overlap;
        constrainPaddle(p, p === p1);
        p.vx = p.x - p.lastX; p.vy = p.y - p.lastY;
        const relVX = puck.vx - p.vx;
        const relVY = puck.vy - p.vy;
        const relAlongNormal = relVX*nx + relVY*ny;
        const tangential = relVX*(-ny) + relVY*nx;
        puck.spin += tangential * 0.01;
        if (relAlongNormal <= 0){
          const restitution = 1.06;
          const impulse = -(1+restitution) * relAlongNormal;
          puck.vx += impulse * nx;
          puck.vy += impulse * ny;
          puck.vx += p.vx*0.2; puck.vy += p.vy*0.2;
        } else {
          const speed = Math.hypot(puck.vx, puck.vy);
          const minSpeed = 2;
          if (speed < minSpeed) {
            const boost = minSpeed - speed;
            puck.vx += nx * boost;
            puck.vy += ny * boost;
          }
        }
        const v = Math.hypot(puck.vx,puck.vy); const maxV = puck.max*speedMul*1.25;
        if (v>maxV){ const s=maxV/v; puck.vx*=s; puck.vy*=s; }
        sfx.hit();
      }
    });

    const left = rink.x + 6 + puck.r;
    const right = rink.x + rink.w - 6 - puck.r;
    const top = goalTopY + 6 + puck.r;
    const bottom = goalBottomY - 6 - puck.r;

    if (puck.x < left){
      puck.x = left;
      const speed = Math.max(Math.abs(puck.vx), minWallSpeed);
      puck.vx = speed * wallBounce;
      if (Math.abs(puck.vy) < minWallSpeed / 2) {
        puck.vy = (Math.sign(puck.vy) || 1) * (minWallSpeed / 2);
      }
      sfx.wall();
    }
    if (puck.x > right){
      puck.x = right;
      const speed = Math.max(Math.abs(puck.vx), minWallSpeed);
      puck.vx = -speed * wallBounce;
      if (Math.abs(puck.vy) < minWallSpeed / 2) {
        puck.vy = (Math.sign(puck.vy) || 1) * (minWallSpeed / 2);
      }
      sfx.wall();
    }

    const goalLeft = goalCenterX - goalWidth/2 + puck.r;
    const goalRight = goalCenterX + goalWidth/2 - puck.r;

    if (puck.y < top){
      if (puck.x > goalLeft && puck.x < goalRight){
        score.p1++; updateScore(); sfx.goal();
        const goalLine = goalTopY + 6;
        puck.y = goalLine - 0.6 * puck.r;
        puck.vx = 0; puck.vy = 0;
        running = false;
        showGoalMessage();
        checkWin();
        if (score.p1 < score.target && score.p2 < score.target){
          setTimeout(()=>{ resetPositions(2); running = true; }, GOAL_PAUSE);
        }
        return;
      } else {
        puck.y = top;
        const speed = Math.max(Math.abs(puck.vy), minWallSpeed);
        puck.vy = speed * wallBounce;
        if (Math.abs(puck.vx) < minWallSpeed / 2) {
          puck.vx = (Math.sign(puck.vx) || 1) * (minWallSpeed / 2);
        }
        sfx.wall();
      }
    }
    if (puck.y > bottom){
      if (puck.x > goalLeft && puck.x < goalRight){
        score.p2++; updateScore(); sfx.goal();
        const goalLine = goalBottomY - 6;
        puck.y = goalLine + 0.6 * puck.r;
        puck.vx = 0; puck.vy = 0;
        running = false;
        showGoalMessage();
        checkWin();
        if (score.p1 < score.target && score.p2 < score.target){
          setTimeout(()=>{ resetPositions(1); running = true; }, GOAL_PAUSE);
        }
        return;
      } else {
        puck.y = bottom;
        const speed = Math.max(Math.abs(puck.vy), minWallSpeed);
        puck.vy = -speed * wallBounce;
        if (Math.abs(puck.vx) < minWallSpeed / 2) {
          puck.vx = (Math.sign(puck.vx) || 1) * (minWallSpeed / 2);
        }
        sfx.wall();
      }
    }
  }

  function update(dt){
    paddleFollowTouch(p1, true);
    if (mode==='ai') {
      aiUpdate();
    } else {
      paddleFollowTouch(p2, false);
    }

    constrainPaddle(p1, true);
    constrainPaddle(p2, false);

    puck.x += puck.vx * dt * 60;
    puck.y += puck.vy * dt * 60;
    const mag = puck.spin * dt;
    const magVx = -puck.vy * mag;
    const magVy = puck.vx * mag;
    puck.vx += magVx;
    puck.vy += magVy;
    puck.vx *= Math.pow(friction, dt*60);
    puck.vy *= Math.pow(friction, dt*60);
    puck.angle += Math.hypot(puck.vx, puck.vy) * dt * 0.1;
    puck.angle += puck.spin * dt * 30;
    puck.spin *= Math.pow(0.99, dt*60);

    handleCollisions();

    [p1,p2].forEach(p=>{p.lastX=p.x; p.lastY=p.y;});
  }

  function render(){
    ctx.clearRect(0,0,W,H);
    drawRink();
    drawPaddle(p2, getCSS('--p2'), p2AvatarImg, p2AvatarEmoji);
    drawPaddle(p1, getCSS('--p1'), p1AvatarImg, p1AvatarEmoji);
      drawPuck();
  }

  function loop(ts){
    if (!running){ last = ts; render(); return requestAnimationFrame(loop); }
    const dt = Math.min(0.033, (ts - last)/1000 || 0.016);
    last = ts;
    update(dt);
    render();
    requestAnimationFrame(loop);
  }

  function updateScore(){ s1El.textContent = score.p1; s2El.textContent = score.p2; }
  function checkWin(){
    if (score.p1>=score.target){
      running=false;
      const pot = stake*2;
      if (stake>0 && myAccountId){
        const prize = Math.round(pot*0.91);
        awardTpc(myAccountId, prize);
        recordWin(tgId, myAccountId);
      }
      if(stake>0) awardDevShare(pot);
      celebrate(p1Name, p1AvatarImg, p1AvatarEmoji);
    }
    if (score.p2>=score.target){
      running=false;
      const pot = stake*2;
      if(stake>0 && oppAccountId){
        const prize = Math.round(pot*0.91);
        awardTpc(oppAccountId, prize);
        recordWin(oppTgId, oppAccountId);
      }
      if(stake>0) awardDevShare(pot);
      celebrate(p2Name, p2AvatarImg, p2AvatarEmoji);
    }
  }
  function toast(msg){
    const old = startHint.textContent;
    startHint.textContent = msg;
    startHint.style.display = 'flex';
    setTimeout(()=>{ startHint.textContent = old; startHint.style.display = 'none'; }, 1400);
  }

  window.addEventListener('keydown', e=>keys.add(e.key));
  window.addEventListener('keyup', e=>keys.delete(e.key));

  function posFromEvent(e){
    const rect = canvas.getBoundingClientRect();
    const scaleX = canvas.width / rect.width; const scaleY = canvas.height / rect.height;
    return { x: (e.clientX-rect.left)*scaleX, y: (e.clientY-rect.top)*scaleY };
  }
  canvas.addEventListener('pointerdown', e=>{
    const p = posFromEvent(e);
    canvas.setPointerCapture(e.pointerId);
    const t = performance.now();
    touches.set(e.pointerId, {x:p.x, y:p.y, vx:0, vy:0, t});
    initAudio();
  });
  canvas.addEventListener('pointermove', e=>{
    const p = posFromEvent(e);
    if (!touches.has(e.pointerId)) return;
    const now = performance.now();
    const last = touches.get(e.pointerId);
    const dt = Math.max(1, now - last.t);
    const vx = (p.x - last.x) / dt * 16.67;
    const vy = (p.y - last.y) / dt * 16.67;
    touches.set(e.pointerId, {x:p.x, y:p.y, vx, vy, t:now});
    const d1 = dist(p1.x,p1.y,p.x,p.y); const d2 = dist(p2.x,p2.y,p.x,p.y);
    if (p.y > centerY && d1 < d2) { p1.vx = vx; p1.vy = vy; }
    else if (p.y < centerY && d2 <= d1) { p2.vx = vx; p2.vy = vy; }
  });
  function clearTouch(id){ touches.delete(id); }
  canvas.addEventListener('pointerup', e=>{
    clearTouch(e.pointerId);
  });
  canvas.addEventListener('pointercancel', e=>{
    clearTouch(e.pointerId);
  });

  function checkOrientation(){ landscapeBlock.style.display = (window.matchMedia('(orientation: landscape)').matches ? 'flex' : 'none'); }
  window.addEventListener('orientationchange', checkOrientation);

  fit(); checkOrientation(); resetPositions(); updateScore(); playWhistle(); requestAnimationFrame(loop);
  })();
</script>
</body>
</html>
