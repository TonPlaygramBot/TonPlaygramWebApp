<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
<title>Bubble Smash Royale â€” Touch & Human Bots</title>
<style>
  :root{ --bg:#0c1020; --panel:#11172a; --primary:#2563eb; --gold:#d4af37; --text:#e7eefc; --muted:#8fa1d2; }
  *{box-sizing:border-box;font-family:Inter,system-ui,Segoe UI,Roboto,Helvetica,Arial,sans-serif}
  html,body{height:100vh;overscroll-behavior:none}
  body{margin:0;background:radial-gradient(1200px 800px at 70% -10%, #1a2450 0%, #0c1020 38%, #0c1020 100%) fixed;color:var(--text);overflow:hidden}
  .app{height:100vh;display:flex;flex-direction:column;padding:12px;gap:10px;max-width:1100px;margin:0 auto}
  .tetris-grid-bg{background: repeating-linear-gradient(45deg,rgba(255,255,255,0.05)0 2px,transparent 2px 4px), radial-gradient(circle at center,#243375 0%,#18234d 80%); background-size:100px 100px,cover; background-position:0 0,center; animation:canvasDepthMove 30s linear infinite}

  .hud{display:flex;gap:8px}
  .hud .panel{flex:1}
.panel{border:1px solid #223063;background:linear-gradient(180deg,#0f1530,#0a0f24);border-radius:12px;padding:10px;display:flex;flex-direction:column;align-items:center;justify-content:center;text-align:center;gap:4px}
  .score{color:var(--gold);font-weight:800}
  .timer{font-variant-numeric:tabular-nums;font-weight:800}

  .layout{display:grid;grid-template-rows:25vh 1fr;gap:10px;flex:1;min-height:0}
  .top{display:grid;grid-template-columns:repeat(3,1fr);gap:10px;min-height:0}
  .mini{position:relative;border:1px solid #223063;background:linear-gradient(180deg,#0f1530,#0a0f24);border-radius:12px;padding:8px;display:flex;flex-direction:column;min-height:0}
  .mini h3{margin:0;font-size:12px;color:var(--muted);display:flex;align-items:center;gap:4px}
  .mini .aiScore{font-size:12px;color:var(--muted);margin:2px 0 6px}
  .flagInline{width:16px;height:16px;border-radius:2px}
  .mini canvas{flex:1;width:100%;height:100%;border-radius:8px;image-rendering:pixelated}

  .userWrap{position:relative;border:1px solid #223063;background:linear-gradient(180deg,#0f1530,#0a0f24);border-radius:14px;padding:10px;display:flex;flex-direction:column;min-height:0}
  .userHeader{display:flex;align-items:center;gap:8px;margin-bottom:8px}
  .avatar{width:32px;height:32px;border-radius:50%}
  .userWrap h3{margin:0;font-size:13px;color:var(--muted)}
  #user{flex:1;width:100%;height:100%;border-radius:10px;touch-action:none;image-rendering:pixelated}
  .overlayButtons{position:absolute;left:10px;bottom:10px;display:flex;gap:8px}
  .small{padding:8px 10px;border-radius:10px;border:1px solid #223063;background:#15204a;color:#e7eefc;font-size:12px;cursor:pointer}

  .toast{position:fixed;left:50%;transform:translateX(-50%);bottom:16px;background:#0d1536;border:1px solid #223063;border-radius:10px;padding:8px 12px;font-size:13px;opacity:0;transition:opacity .2s}
  .toast.show{opacity:1}

  dialog{border:none;border-radius:16px;background:#0d1330;color:#e7eefc;max-width:520px;width:calc(100% - 24px)}
  .modal{padding:16px;border:1px solid #223063;border-radius:16px;background:linear-gradient(180deg,#0f1736,#0b1126)}
  .grid{display:grid;gap:10px}
  .grid.two{grid-template-columns:1fr 1fr}
.kpi{background:linear-gradient(180deg,#0f1530,#0a0f24);border:1px solid #223063;border-radius:12px;padding:10px;text-align:center}
  .kpi .v{font-size:22px;font-weight:800}

  @keyframes canvasDepthMove{from{background-position:0 0,center}to{background-position:100px 100px,center}}
</style>
</head>
<body>
<div class="app">
  <div class="layout">
    <div class="top">
      <div class="mini">
        <h3><img id="avatar1" src="assets/icons/profile.svg" alt="" class="flagInline"/><span id="name1">P1</span></h3>
        <div id="score1" class="aiScore">0</div>
        <canvas id="opp1" class="tetris-grid-bg"></canvas>
      </div>
      <div class="mini">
        <h3><img id="avatar2" src="assets/icons/profile.svg" alt="" class="flagInline"/><span id="name2">P2</span></h3>
        <div id="score2" class="aiScore">0</div>
        <canvas id="opp2" class="tetris-grid-bg"></canvas>
      </div>
      <div class="mini">
        <h3><img id="avatar3" src="assets/icons/profile.svg" alt="" class="flagInline"/><span id="name3">P3</span></h3>
        <div id="score3" class="aiScore">0</div>
        <canvas id="opp3" class="tetris-grid-bg"></canvas>
      </div>
    </div>
    <div class="userWrap">
      <div class="userHeader">
        <img id="avatarUser" src="assets/icons/profile.svg" alt="" class="avatar"/>
        <h3 id="playerName">USER</h3>
        <div class="hud">
          <div class="panel">
            <strong>Time</strong>
            <span id="time" class="timer">03:00</span>
          </div>
          <div class="panel">
            <strong>Your score</strong>
            <span id="myscore" class="score">0</span>
          </div>
        </div>
      </div>
      <canvas id="user" class="tetris-grid-bg"></canvas>
      <div class="overlayButtons">
        <button id="soundBtn" class="small">ðŸ”Š</button>
      </div>
    </div>
  </div>
</div>
<div id="toast" class="toast"></div>

<dialog id="results">
  <div class="modal">
    <h2>Round results</h2>
    <div class="grid two">
      <div class="kpi"><div class="v" id="winner">-</div><div>Winner</div></div>
      <div class="kpi"><div class="v" id="payout">0</div><div>Payout TPC</div></div>
    </div>
    <div class="grid" style="margin-top:10px">
      <div class="kpi"><div class="v" id="fee">0</div><div>Fee 10%</div></div>
      <div class="kpi"><div class="v" id="potFinal">0</div><div>Final Pot</div></div>
    </div>
    <div class="grid" id="scoreList" style="margin-top:10px"></div>
    <div style="display:flex;gap:8px;flex-wrap:wrap;margin-top:8px">
      <button class="btn" id="rematch">Play Again</button>
      <button class="btn" id="change">Return to Lobby</button>
    </div>
  </div>
</dialog>

<script>
(function(){
  // ===== Core config =====
  const COLS=8, ROWS=8;
  const COLORS=['#00bfff','#ff7f00','#ff1493','#ffd700','#32cd32','#8a2be2','#ff69b4'];
  const SCORE_BASE=60, SCORE_EXTRA=30;

  // ===== Helpers =====
  const $=s=>document.querySelector(s);
  const fmt=s=>{const m=String((s/60)|0).padStart(2,'0');const ss=String(Math.max(0,s%60)).padStart(2,'0');return `${m}:${ss}`;};
  function fitCanvas(c){
    const r = c.getBoundingClientRect();
    const dprBase = window.devicePixelRatio || 1;
    const dpr = dprBase * 2;
    c.style.width = r.width + 'px';
    c.style.height = r.height + 'px';
    c.width = Math.round(r.width * dpr);
    c.height = Math.round(r.height * dpr);
    const ctx = c.getContext('2d');
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    c.dpr = dpr;
  }

  // Audio
  let audioCtx=null, muted=false;
  function ensureAudio(){ if(!audioCtx){ audioCtx=new (window.AudioContext||window.webkitAudioContext)(); } }
  function pop(freq=900, dur=0.08, vol=0.22){
    if(!audioCtx||muted) return;
    const t=audioCtx.currentTime, o=audioCtx.createOscillator(), g=audioCtx.createGain();
    o.type='triangle'; o.frequency.value=freq;
    g.gain.setValueAtTime(0, t);
    g.gain.linearRampToValueAtTime(vol, t+0.01);
    g.gain.exponentialRampToValueAtTime(0.0001, t+dur);
    o.connect(g); g.connect(audioCtx.destination);
    o.start(t); o.stop(t+dur+0.02);
  }

  function matchSound(size){
    if(!audioCtx||muted) return;
    const t=audioCtx.currentTime, o=audioCtx.createOscillator(), g=audioCtx.createGain();
    o.type='square';
    o.frequency.value = size>=5 ? 1100 : 850;
    g.gain.setValueAtTime(0, t);
    g.gain.linearRampToValueAtTime(0.25, t+0.01);
    g.gain.exponentialRampToValueAtTime(0.0001, t+0.3);
    o.connect(g); g.connect(audioCtx.destination);
    o.start(t); o.stop(t+0.32);
  }

  // ===== Board model =====
  function makeCell(color){return {c:color};}
  const randColor=()=>COLORS[(Math.random()*COLORS.length)|0];

  function createBoard(){
    const b=Array.from({length:ROWS},()=>Array(COLS).fill(null));
    for(let y=0;y<ROWS;y++){
      for(let x=0;x<COLS;x++){
        do{ b[y][x]=makeCell(randColor()); }while(runHere(b,x,y));
      }
    }
    return b;
  }
  function runHere(b,x,y){
    const c=b[y][x].c;
    if(x>=2&&b[y][x-1]&&b[y][x-2]&&b[y][x-1].c===c&&b[y][x-2].c===c) return true;
    if(y>=2&&b[y-1][x]&&b[y-2][x]&&b[y-1][x].c===c&&b[y-2][x].c===c) return true;
    return false;
  }

  function findMatches(b){
    const marks = Array.from({ length: ROWS }, () => Array(COLS).fill(false));
    let any = false,
      clusters = [];
    // horiz
    for (let y = 0; y < ROWS; y++) {
      let run = 1;
      for (let x = 1; x <= COLS; x++) {
        const cont =
          x < COLS &&
          b[y][x] &&
          b[y][x - 1] &&
          b[y][x].c === b[y][x - 1].c;
        if (cont) {
          run++;
        } else {
          if (run >= 3) {
            any = true;
            const list = [];
            for (let k = 0; k < run; k++) {
              marks[y][x - 1 - k] = true;
              list.push({ x: x - 1 - k, y });
            }
            clusters.push({ cells: list, dir: 'h' });
          }
          run = 1;
        }
      }
    }
    // vert
    for (let x = 0; x < COLS; x++) {
      let run = 1;
      for (let y = 1; y <= ROWS; y++) {
        const cont =
          y < ROWS &&
          b[y][x] &&
          b[y - 1][x] &&
          b[y][x].c === b[y - 1][x].c;
        if (cont) {
          run++;
        } else {
          if (run >= 3) {
            any = true;
            const list = [];
            for (let k = 0; k < run; k++) {
              if (!marks[y - 1 - k][x]) list.push({ x, y: y - 1 - k });
              marks[y - 1 - k][x] = true;
            }
            clusters.push({ cells: list, dir: 'v' });
          }
          run = 1;
        }
      }
    }
    return any ? { marks, clusters } : null;
  }

  function applyMatches(board, match, addFX, fallFX){
    // extend marks for special shapes
    const m = match.marks;
    for (const cl of match.clusters) {
      const len = cl.cells.length;
      if (len === 4) {
        if (cl.dir === 'h') {
          const y = cl.cells[0].y;
          for (let x = 0; x < COLS; x++) m[y][x] = true;
        } else {
          const x = cl.cells[0].x;
          for (let y = 0; y < ROWS; y++) m[y][x] = true;
        }
      } else if (len >= 5) {
        if (cl.dir === 'h') {
          const y = cl.cells[0].y;
          const mid = cl.cells[(len / 2) | 0].x;
          for (let x = 0; x < COLS; x++) m[y][x] = true;
          for (let y2 = 0; y2 < ROWS; y2++) m[y2][mid] = true;
        } else {
          const x = cl.cells[0].x;
          const mid = cl.cells[(len / 2) | 0].y;
          for (let y = 0; y < ROWS; y++) m[y][x] = true;
          for (let x2 = 0; x2 < COLS; x2++) m[mid][x2] = true;
        }
      }
    }
    // T-shape detection
    const horiz = match.clusters.filter((c) => c.dir === 'h');
    const vert = match.clusters.filter((c) => c.dir === 'v');
    for (const h of horiz) {
      for (const v of vert) {
        for (const hc of h.cells) {
          for (const vc of v.cells) {
            if (hc.x === vc.x && hc.y === vc.y) {
              const set = new Set(
                h.cells.map((c) => `${c.x},${c.y}`).concat(
                  v.cells.map((c) => `${c.x},${c.y}`)
                )
              );
              if (set.size >= 5) {
                const ix = hc.x,
                  iy = hc.y;
                for (let x = 0; x < COLS; x++) m[iy][x] = true;
                for (let y = 0; y < ROWS; y++) m[y][ix] = true;
              }
            }
          }
        }
      }
    }

    let removed=0;
    for(let y=0;y<ROWS;y++){
      for(let x=0;x<COLS;x++){
        if(m[y][x]){
          if(addFX) addFX(x,y, board[y][x].c);
          board[y][x]=null; removed++;
        }
      }
    }
    // gravity with animation support
    for(let x=0;x<COLS;x++){
      const col=[];
      for(let y=ROWS-1;y>=0;y--){
        const cell=board[y][x];
        if(cell) col.push({cell,y});
      }
      let ptr=ROWS-1;
      for(const {cell,y} of col){
        board[ptr][x]=cell;
        if(fallFX && y!==ptr) fallFX(x,y,ptr,cell.c);
        if(ptr!==y) board[y][x]=null;
        ptr--;
      }
      while(ptr>=0){
        const cell=makeCell(randColor());
        board[ptr][x]=cell;
        if(fallFX) fallFX(x,ptr-ROWS,ptr,cell.c);
        ptr--;
      }
    }
    const gained = removed>=3 ? (SCORE_BASE + (removed-3)*SCORE_EXTRA) : 0;
    return {removed,gained};
  }

  // ===== Renderer + FX =====
  function drawCartoonBubble(ctx, x, y, r, color){
    ctx.beginPath();
    ctx.arc(x, y, r, 0, Math.PI*2);
    ctx.fillStyle = color;
    ctx.fill();
    ctx.lineWidth = Math.max(2, r * 0.1);
    ctx.strokeStyle = '#000';
    ctx.lineJoin = 'round';
    ctx.lineCap = 'round';
    ctx.stroke();
    ctx.fillStyle = 'rgba(255,255,255,0.6)';
    ctx.beginPath();
    ctx.arc(x - r*0.3, y - r*0.3, r*0.25, 0, Math.PI*2);
    ctx.fill();
    ctx.beginPath();
    ctx.arc(x - r*0.45, y - r*0.45, r*0.07, 0, Math.PI*2);
    ctx.fill();
  }
  function createFX(canvas){
    const fx=[];
    const ctx=canvas.getContext('2d');
    const cell=()=>Math.floor(Math.min((canvas.width/(canvas.dpr||1))/COLS,(canvas.height/(canvas.dpr||1))/ROWS));
    const off=()=>{const w=canvas.width/(canvas.dpr||1), h=canvas.height/(canvas.dpr||1); const c=cell(); return {x:Math.floor((w-c*COLS)/2), y:Math.floor((h-c*ROWS)/2)};};

    function drawBoard(board, sel, drag){
      const csize=cell(), o=off();
      const w=canvas.width/(canvas.dpr||1), h=canvas.height/(canvas.dpr||1);
      ctx.clearRect(0,0,w,h);
      ctx.fillStyle='#0e1430'; ctx.fillRect(0,0,w,h);

      const now=performance.now();
      const skip=new Set();
      for(const f of fx){
        if(f.kind==='fall'){
          const p=(now-f.t0)/f.dur;
          if(p<1) skip.add(`${f.to.x},${f.to.y}`);
        }
      }

      const dragged=[];
      for(let y=0;y<ROWS;y++){
        for(let x=0;x<COLS;x++){
          if(skip.has(`${x},${y}`)) continue;
          const t=board[y][x]; if(!t) continue;
          if(drag && ((x===drag.start.x && y===drag.start.y) || (drag.neigh && x===drag.neigh.x && y===drag.neigh.y))){
            dragged.push({x,y,t});
            continue;
          }
          const cx=o.x+x*csize+csize/2, cy=o.y+y*csize+csize/2, r=csize*0.38;
          drawCartoonBubble(ctx, cx, cy, r, t.c);
        }
      }
      if(drag){
        for(const d of dragged){
          const cx=o.x+d.x*csize+csize/2, cy=o.y+d.y*csize+csize/2, r=csize*0.38;
          let dx=0, dy=0;
          if(d.x===drag.start.x && d.y===drag.start.y){ dx=drag.dx; dy=drag.dy; }
          else { dx = drag.dx - (drag.dir==='x'?Math.sign(drag.dx)*csize:0); dy = drag.dy - (drag.dir==='y'?Math.sign(drag.dy)*csize:0); }
          drawCartoonBubble(ctx, cx+dx, cy+dy, r, d.t.c);
        }
      }
      if(sel){
        ctx.strokeStyle='#8fa1d2'; ctx.lineWidth=3;
        const x=o.x+sel.x*csize+2, y=o.y+sel.y*csize+2;
        ctx.strokeRect(x,y,csize-4,csize-4);
      }

      // FX
      for(let i=fx.length-1;i>=0;i--){
        const f=fx[i], p=(now-f.t0)/f.dur;
        if(p>=1){ fx.splice(i,1); continue; }
        if(f.kind==='burst'){
          for(const part of f.parts){
            const px = part.x + part.vx * p;
            const py = part.y + part.vy * p + 0.3*p*p*part.g;
            const alpha = 1 - p;
            ctx.fillStyle = `rgba(231,238,252,${alpha})`;
            ctx.beginPath(); ctx.arc(px, py, part.r*(1-p*0.6), 0, Math.PI*2); ctx.fill();
          }
        } else if(f.kind==='float'){
          const alpha = 1 - p;
          const y = f.y - p*30;
          ctx.fillStyle=`rgba(212,175,55,${alpha})`;
          ctx.font=`bold ${Math.max(14, Math.floor(csize*0.5))}px system-ui`;
          ctx.textAlign='center';
          ctx.fillText(f.text, f.x, y);
        } else if(f.kind==='fall'){
          const from=centerOfCell(f.from.x,f.from.y);
          const to=centerOfCell(f.to.x,f.to.y);
          const e=1-Math.pow(1-p,3);
          const x=from.x+(to.x-from.x)*e;
          const y=from.y+(to.y-from.y)*e;
          drawCartoonBubble(ctx, x, y, csize*0.38, f.color);
        } else if(f.kind==='pop'){
          ctx.save();
          ctx.globalAlpha = 1 - p;
          const r = f.r * (1 + 0.2*p);
          drawCartoonBubble(ctx, f.x, f.y, r, f.color);
          ctx.restore();
        }
      }
    }

    function centerOfCell(cx,cy){
      const csize=cell(), o=off();
      return {x:o.x+cx*csize+csize/2, y:o.y+cy*csize+csize/2};
    }

    return {
      list:fx,
      draw:drawBoard,
      burstAt(cx,cy,color){
        const c=centerOfCell(cx,cy); const parts=[];
        const csize=cell();
        for(let i=0;i<10;i++){
          const a=Math.random()*Math.PI*2, sp=(0.6+Math.random()*1.2)*csize/2;
          parts.push({x:c.x,y:c.y,vx:Math.cos(a)*sp,vy:Math.sin(a)*sp,g:csize*0.8,r:Math.max(2,csize*0.08)});
        }
        fx.push({kind:'burst',t0:performance.now(),dur:360,parts});
        fx.push({kind:'pop',t0:performance.now(),dur:300,x:c.x,y:c.y,r:csize*0.38,color});
      },
      floatScore(cx,cy,pts){
        const c=centerOfCell(cx,cy);
        fx.push({kind:'float',t0:performance.now(),dur:700,x:c.x,y:c.y,text:`+${pts}`});
      },
      fall(fromX,fromY,toX,toY,color){
        fx.push({kind:'fall',t0:performance.now(),dur:500,from:{x:fromX,y:fromY},to:{x:toX,y:toY},color});
      }
    };
  }

  function neighbors4(a,b){ return (Math.abs(a.x-b.x)+Math.abs(a.y-b.y))===1; }
  function evtToCell(canvas,e){
    const r=canvas.getBoundingClientRect();
    const x=e.clientX-r.left, y=e.clientY-r.top;
    const dpr=canvas.dpr||1;
    const c=Math.min((canvas.width/dpr)/COLS,(canvas.height/dpr)/ROWS);
    const offX=(canvas.width/dpr - c*COLS)/2, offY=(canvas.height/dpr - c*ROWS)/2;
    const cx=Math.floor((x-offX)/c), cy=Math.floor((y-offY)/c);
    if(cx<0||cx>=COLS||cy<0||cy>=ROWS) return null; return {x:cx,y:cy};
  }

  function validSwap(b,a,bp){
    const t=b[a.y][a.x]; b[a.y][a.x]=b[bp.y][bp.x]; b[bp.y][bp.x]=t;
    const match=findMatches(b);
    const ok = match && match.clusters.some(cl=>cl.cells.some(c=> (c.x===a.x&&c.y===a.y) || (c.x===bp.x&&c.y===bp.y)));
    const t2=b[a.y][a.x]; b[a.y][a.x]=b[bp.y][bp.x]; b[bp.y][bp.x]=t2;
    return ok;
  }

  // ===== Game (per board) =====
  function createGame(canvas,isUser){
    const ctx=canvas.getContext('2d'); fitCanvas(canvas);
    const fx=createFX(canvas);
    const game={ board:createBoard(), score:0, selected:null, drag:null, busy:false, over:false, isUser, fx };

    function cascade(){
      game.busy=true;
      let chain=0;
      (function step(){
        const match=findMatches(game.board);
        if(!match){ game.busy=false; return; }
        chain++;
        if(isUser){
          const largest = Math.max(...match.clusters.map(cl=>cl.cells.length));
          if(largest >= 5) matchSound(5);
          else if(largest === 4) matchSound(4);
          else pop(700+chain*80, 0.06, 0.2);
        }
        const res=applyMatches(game.board, match, (cx,cy,c)=>fx.burstAt(cx,cy,c), (x,fy,ty,c)=>fx.fall(x,fy,ty,c));
        if(match.clusters && match.clusters.length){
          const biggest = match.clusters.reduce((a,b)=> b.cells.length>a.cells.length?b:a, match.clusters[0]);
          const mid = biggest.cells[(biggest.cells.length/2)|0];
          const pts = Math.max(30, Math.floor(res.gained / Math.max(1, match.clusters.length)));
          fx.floatScore(mid.x, mid.y, pts);
        }
        game.score += res.gained;
        setTimeout(step, 700);
      })();
    }

    game.trySwap=function(a,b){
      if(game.busy||game.over) return;
      if(!neighbors4(a,b)) return;
      if(!validSwap(game.board,a,b)) return;
      const t=game.board[a.y][a.x]; game.board[a.y][a.x]=game.board[b.y][b.x]; game.board[b.y][b.x]=t;
      cascade();
    };

    game.draw=()=>fx.draw(game.board, game.selected, game.drag);
    window.addEventListener('resize',()=>{ fitCanvas(canvas); game.draw(); });

    // Pointer input (touch or mouse drag)
    if(isUser){
      canvas.addEventListener('pointerdown', e=>{ if(e.pointerType==='touch'||e.pointerType==='mouse'){ ensureAudio(); } }, {once:true});
      let start=null; let dragging=false;
      canvas.addEventListener('pointerdown', e=>{
        if(e.pointerType!=='touch'&&e.pointerType!=='mouse') return;
        if(e.pointerType==='mouse' && e.button!==0) return;
        const cell=evtToCell(canvas,e); if(!cell) return;
        start=cell; dragging=true;
        game.selected=cell;
        game.drag={start:cell,dx:0,dy:0,dir:null,neigh:null};
        game.draw();
        canvas.setPointerCapture(e.pointerId);
      });
      canvas.addEventListener('pointermove', e=>{
        if((e.pointerType!=='touch'&&e.pointerType!=='mouse')||!dragging||!start||!game.drag) return;
        const r=canvas.getBoundingClientRect();
        const x=e.clientX-r.left, y=e.clientY-r.top;
        const dpr=canvas.dpr||1;
        const c=Math.min((canvas.width/dpr)/COLS,(canvas.height/dpr)/ROWS);
        const offX=(canvas.width/dpr-c*COLS)/2, offY=(canvas.height/dpr-c*ROWS)/2;
        const dx = x - (offX + start.x*c + c/2);
        const dy = y - (offY + start.y*c + c/2);
        if(!game.drag.dir) game.drag.dir = Math.abs(dx) > Math.abs(dy) ? 'x' : 'y';
        if(game.drag.dir==='x'){
          let ndx = Math.max(-c, Math.min(c, dx));
          const target={x:start.x+(ndx>0?1:-1), y:start.y};
          if(target.x<0||target.x>=COLS){ ndx=0; game.drag.neigh=null; }
          else game.drag.neigh=target;
          game.drag.dx=ndx; game.drag.dy=0;
        } else {
          let ndy = Math.max(-c, Math.min(c, dy));
          const target={x:start.x, y:start.y+(ndy>0?1:-1)};
          if(target.y<0||target.y>=ROWS){ ndy=0; game.drag.neigh=null; }
          else game.drag.neigh=target;
          game.drag.dy=ndy; game.drag.dx=0;
        }
        game.draw();
      });
      const endDrag=e=>{
        if(e.pointerType!=='touch'&&e.pointerType!=='mouse') return;
        const dpr=canvas.dpr||1;
        const c=Math.min((canvas.width/dpr)/COLS,(canvas.height/dpr)/ROWS);
        const TH=c*0.28;
        if(dragging && start && game.drag && game.drag.neigh){
          const m=Math.max(Math.abs(game.drag.dx),Math.abs(game.drag.dy));
          if(m>TH){
            const a=start, b=game.drag.neigh;
            game.selected=null; game.drag=null; dragging=false; start=null;
            game.trySwap(a,b); game.draw();
            try{ canvas.releasePointerCapture(e.pointerId); }catch(_){ }
            return;
          }
        }
        dragging=false; start=null; game.selected=null; game.drag=null; game.draw();
        try{ canvas.releasePointerCapture(e.pointerId); }catch(_){ }
      };
      canvas.addEventListener('pointerup', endDrag);
      canvas.addEventListener('pointercancel', endDrag);
    }

    // safety
    cascade();
    return game;
  }

  // ===== Human-like Bot =====
  function findFirstGoodSwap(board){
    for(let y=0;y<ROWS;y++){
      for(let x=0;x<COLS;x++){
        const a={x,y};
        const neigh=[{x:x+1,y},{x,y:y+1}];
        for(const b of neigh){
          if(b.x>=COLS||b.y>=ROWS) continue;
          if(validSwap(board,a,b)) return {a,b};
        }
      }
    }
    return null;
  }

  function scheduleNext(delayBase=1200){
    return performance.now() + delayBase + Math.random()*400; // 1.2sâ€“1.6s
    // (feels human, not spammy)
  }

  function botThink(bot){
    if(bot.busy||bot.over) return false;
    const mv=findFirstGoodSwap(bot.board);
    if(!mv) { bot.board=createBoard(); return false; }
    const t=bot.board[mv.a.y][mv.a.x]; bot.board[mv.a.y][mv.a.x]=bot.board[mv.b.y][mv.b.x]; bot.board[mv.b.y][mv.b.x]=t;
    // resolve cascades (same as user but silent)
    (function resolve(){
      const m=findMatches(bot.board);
      if(!m){ return; }
      const res=applyMatches(bot.board,m, (cx,cy,c)=>bot.fx.burstAt(cx,cy,c), (x,fy,ty,c)=>bot.fx.fall(x,fy,ty,c)); bot.score+=res.gained;
      setTimeout(resolve, 550);
    })();
    return true;
  }

  // ===== Shell / Multiplayer =====
  const canvases={ user:$('#user'), opp1:$('#opp1'), opp2:$('#opp2'), opp3:$('#opp3') };
  const ui={ time:$('#time'), myscore:$('#myscore'), results:$('#results'), winner:$('#winner'), payout:$('#payout'), fee:$('#fee'), potFinal:$('#potFinal'), scoreList:$('#scoreList'), rematch:$('#rematch'), change:$('#change'), soundBtn:$('#soundBtn') };

  const params=new URLSearchParams(location.search);
  const n=Math.max(2,Math.min(4,parseInt(params.get('players'),10)||4));
  const stake=Math.max(0,parseInt(params.get('amount'),10)||300);
  const durSec=Math.max(10,parseInt(params.get('duration'),10)||180);
  const avatarParam=params.get('avatar')||'';
  const tgId=params.get('tgId');
  const accountId=params.get('accountId');
  const initParam=params.get('init');
  if(initParam && !window.Telegram){ const decoded=decodeURIComponent(initParam); window.Telegram={WebApp:{initData:decoded}}; try{ const parsed=Object.fromEntries(new URLSearchParams(decoded)); if(parsed.user){ window.Telegram.WebApp.initDataUnsafe={user:JSON.parse(parsed.user)}; } }catch{} }
  ui.time.textContent=fmt(durSec);

  const FLAG_EMOJIS=['ðŸ‡ºðŸ‡¸','ðŸ‡¬ðŸ‡§','ðŸ‡¨ðŸ‡¦','ðŸ‡¯ðŸ‡µ','ðŸ‡«ðŸ‡·','ðŸ‡©ðŸ‡ª','ðŸ‡®ðŸ‡³','ðŸ‡§ðŸ‡·','ðŸ‡¦ðŸ‡º','ðŸ‡ªðŸ‡¸'];
  const emojiToDataUrl=(e)=>`data:image/svg+xml,${encodeURIComponent("<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 120 120'><text y='96' font-size='96'>"+e+"</text></svg>")}`;
  const regionNames=new Intl.DisplayNames(['en'],{type:'region'});
  const flagToName=(flag)=>{ const codes=Array.from(flag).map(c=>c.codePointAt(0)-0x1F1E6+65); const cc=String.fromCharCode(...codes); return regionNames.of(cc); };

  const avatarEls=[$('#avatar1'),$('#avatar2'),$('#avatar3'),$('#avatarUser')];
  const nameEls=[$('#name1'),$('#name2'),$('#name3')];
  const scoreEls=[$('#score1'),$('#score2'),$('#score3')];
  const playerNameEl=$('#playerName');
  const userData=window?.Telegram?.WebApp?.initDataUnsafe?.user;
  const playerName=userData?.username||[userData?.first_name,userData?.last_name].filter(Boolean).join(' ')||'Player';
  function adjustNameSize(el){ if(!el) return; const len=el.textContent.length; if(len>12){ const size=Math.max(8,13-(len-12)*0.5); el.style.fontSize=size+'px'; } }
  if(playerNameEl){ playerNameEl.textContent=playerName; adjustNameSize(playerNameEl); }
  const avatarUrls=Array(n).fill('');
  if(avatarParam){ avatarEls[3].src=avatarParam; } else if(userData?.photo_url){ avatarEls[3].src=userData.photo_url; }
  for(let i=0;i<n-1;i++){ const flag=FLAG_EMOJIS[(Math.random()*FLAG_EMOJIS.length)|0]; const url=emojiToDataUrl(flag); avatarEls[i].src=url; avatarUrls[i]=url; nameEls[i].textContent=flagToName(flag); adjustNameSize(nameEls[i]); scoreEls[i].textContent='0'; }
  avatarUrls[n-1]=avatarEls[3].src;

  let games=[]; let rafId=null; let endAt=0; let last=performance.now(); let running=false;
  const botTimers=[];

  function layout(){ Object.values(canvases).forEach(c=>{ if(c) fitCanvas(c); }); }

  function startMatch(){
    layout();
    ui.time.textContent=fmt(durSec);
    games=[];
    const opp=[canvases.opp1,canvases.opp2,canvases.opp3];
    for(let i=0;i<n-1;i++){ const g=createGame(opp[i],false); games.push(g); }
    const u=createGame(canvases.user,true); games.push(u);
    botTimers.length=0;
    for(let i=0;i<n-1;i++) botTimers[i]=scheduleNext(1000+i*80);
    endAt=performance.now()+durSec*1000;
    running=true; last=performance.now();
    loop();
  }

  function updateTimer(){ const remain=Math.max(0,Math.ceil((endAt-performance.now())/1000)); ui.time.textContent=fmt(remain); if(remain<=0) finish(); }

  function finish(){
    if(!running) return; running=false; if(rafId) cancelAnimationFrame(rafId);
    const gross=stake*n; const fee=Math.round(gross*0.10); const net=gross-fee;
    const scores=games.map((g,i)=>({i,score:g.score}));
    const max=Math.max(...scores.map(s=>s.score));
    const winners=scores.filter(s=>s.score===max);
    const payout=winners.length?Math.floor(net / winners.length):0;
    ui.winner.textContent = winners.length>1 ? `Tie (${winners.map(w=>'P'+(w.i+1)).join(', ')})` : `P${winners[0].i+1}`;
    ui.payout.textContent=String(payout); ui.fee.textContent=String(fee); ui.potFinal.textContent=String(net);
    ui.scoreList.innerHTML = scores.sort((a,b)=>b.score-a.score).map(s=>`<div class="kpi"><div class="v">P${s.i+1}: ${s.score}</div><div>â€”</div></div>`).join('');
    if(!ui.results.open) ui.results.showModal();
  }

  function loop(){
    if(!running) return;
    const now=performance.now(); const dt=(now-last)/1000; last=now;
    for(const g of games) g.draw();
    for(let i=0;i<games.length-1;i++){
      const g=games[i];
      if(now>=botTimers[i] && !g.busy){ const moved=botThink(g); botTimers[i]=scheduleNext(1100+(moved?0:150)); }
      if(scoreEls[i]) scoreEls[i].textContent=String(g.score);
    }
    ui.myscore.textContent=String(games[games.length-1].score);
    updateTimer();
    rafId=requestAnimationFrame(loop);
  }

  ui.rematch.addEventListener('click', ()=>{ ui.results.close(); startMatch(); });
  ui.change.addEventListener('click', ()=>{ ui.results.close(); location.href='/games/bubblesmashroyale/lobby'; });

  ui.soundBtn.addEventListener('click', ()=>{ muted=!muted; ui.soundBtn.textContent=muted?'ðŸ”‡':'ðŸ”Š'; if(!muted) ensureAudio(); });

  window.addEventListener('resize', layout);
  layout();
  startMatch();
})();
</script>
</body>
</html>
