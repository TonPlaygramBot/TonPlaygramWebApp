<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
<title>Bubble Pop Royale â€” Power Edition</title>
<style>
  :root{ --bg:#0c1020; --panel:#11172a; --primary:#2563eb; --gold:#d4af37; --text:#e7eefc; --muted:#8fa1d2; --danger:#ff5a6b; }
  *{box-sizing:border-box;font-family:Inter,system-ui,Segoe UI,Roboto,Helvetica,Arial,sans-serif}
  html,body{height:100dvh;overscroll-behavior:none}
  body{margin:0;background:radial-gradient(1200px 800px at 70% -10%, #1a2450 0%, #0c1020 38%, #0c1020 100%) fixed;color:var(--text);overflow:hidden}
  .app{height:100dvh;display:flex;flex-direction:column;padding:12px;gap:10px;max-width:1100px;margin:0 auto}
  .tetris-grid-bg{background: repeating-linear-gradient(45deg,rgba(255,255,255,0.05)0 2px,transparent 2px 4px), radial-gradient(circle at center,#243375 0%,#18234d 80%); background-size:100px 100px,cover; background-position:0 0,center; animation:canvasDepthMove 30s linear infinite}
  header{display:flex;gap:12px;align-items:center;justify-content:space-between}
  .badge{background:#0f1736;border:1px solid #223063;border-radius:10px;padding:6px 10px;color:var(--muted);font-size:12px}
  .controls{display:grid;grid-template-columns:1fr 1fr 1fr auto;gap:8px}
  label{font-size:12px;color:var(--muted);display:block;margin-bottom:6px}
  select,button,input{width:100%;padding:10px 12px;border-radius:10px;border:1px solid #223063;background:#0e1430;color:#e7eefc}
  .btn{background:linear-gradient(180deg,#2a6cf0,#2156c8);border:none;font-weight:700;cursor:pointer}
  .hud{display:flex;gap:8px}
  .hud .panel{flex:1}
.panel{border:1px solid #223063;background:linear-gradient(180deg,#0f1530,#0a0f24);border-radius:12px;padding:10px;display:flex;flex-direction:column;align-items:center;justify-content:center;text-align:center;gap:4px}
  .score{color:var(--gold);font-weight:800}
  .timer{font-variant-numeric:tabular-nums;font-weight:800}
  .layout{display:grid;grid-template-rows:25vh 1fr;gap:10px;flex:1;min-height:0}
  .top{display:grid;grid-template-columns:repeat(3,1fr);gap:10px}
  .mini{position:relative;border:1px solid #223063;background:linear-gradient(180deg,#0f1530,#0a0f24);border-radius:12px;padding:8px;display:flex;flex-direction:column}
  .mini h3{margin:0;font-size:12px;color:var(--muted);display:flex;align-items:center;gap:4px}
  .mini .aiScore{font-size:12px;color:var(--muted);margin:2px 0 6px}
  .flagInline{width:16px;height:16px;border-radius:2px}
  .mini canvas{flex:1;width:100%;height:100%;border-radius:8px}
  .userWrap{position:relative;border:1px solid #223063;background:linear-gradient(180deg,#0f1530,#0a0f24);border-radius:14px;padding:10px;display:flex;flex-direction:column;min-height:0}
  .userHeader{display:flex;align-items:center;gap:8px;margin-bottom:8px}
  .userWrap h3{margin:0;font-size:13px;color:var(--muted)}
  #user{flex:1;width:100%;height:100%;border-radius:10px;touch-action:none}
  .overlayButtons{position:absolute;left:10px;bottom:10px;display:flex;gap:8px}
  .small{padding:8px 10px;border-radius:10px;border:1px solid #223063;background:#15204a;color:#e7eefc;font-size:12px;cursor:pointer}
  .avatar{width:32px;height:32px;border-radius:50%}
  .toast{position:fixed;left:50%;transform:translateX(-50%);bottom:16px;background:#0d1536;border:1px solid #223063;border-radius:10px;padding:8px 12px;font-size:13px;opacity:0;transition:opacity .2s}
  .toast.show{opacity:1}
  dialog{border:none;border-radius:16px;background:#0d1330;color:#e7eefc;max-width:520px;width:calc(100% - 24px)}
  .modal{padding:16px;border:1px solid #223063;border-radius:16px;background:linear-gradient(180deg,#0f1736,#0b1126)}
  .grid{display:grid;gap:10px}
  .grid.two{grid-template-columns:1fr 1fr}
.kpi{background:linear-gradient(180deg,#0f1530,#0a0f24);border:1px solid #223063;border-radius:12px;padding:10px;text-align:center}
  .kpi .v{font-size:22px;font-weight:800}
  .winner-celebration{position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);z-index:70;display:flex;flex-direction:column;align-items:center;pointer-events:none}
  .winner-celebration img{width:80px;height:80px;border-radius:50%;margin-bottom:8px;border:2px solid var(--gold)}
  .coin-burst{position:fixed;left:50%;bottom:50%;width:0;height:0;z-index:60;pointer-events:none;overflow:visible}
  .coin-img{position:absolute;left:-16px;bottom:0;width:32px;height:32px;transform:translate(-50%,0);animation-name:coin-up;animation-duration:var(--dur);animation-delay:var(--delay);animation-timing-function:ease-out;animation-fill-mode:forwards;filter:brightness(1.5) drop-shadow(0 0 4px gold)}
  @keyframes coin-up{to{transform:translate(calc(-50% + var(--dx)),160px);opacity:0}}

  @keyframes canvasDepthMove{from{background-position:0 0,center}to{background-position:100px 100px,center}}
</style>
</head>
<body>
<div class="app">
  <header>
    <div style="display:flex;align-items:center;gap:10px">
      <h1 style="margin:0;font-size:18px">Bubble Pop Royale</h1>
      <span class="badge">Local test â€¢ TPC only</span>
    </div>
  </header>
  <div class="controls">
    <div>
      <label>Players</label>
      <select id="players">
        <option value="2">2 players</option>
        <option value="3">3 players</option>
        <option value="4" selected>4 players</option>
      </select>
    </div>
    <div>
      <label>Duration</label>
      <select id="duration">
        <option value="60">1 min</option>
        <option value="180" selected>3 min</option>
        <option value="300">5 min</option>
      </select>
    </div>
    <div>
      <label>Stake per player (TPC)</label>
      <input id="stake" type="number" value="300" min="0" step="50"/>
    </div>
    <div>
      <button id="start" class="btn">Start Match</button>
    </div>
  </div>
  <div class="layout">
    <div class="top">
      <div class="mini">
        <h3><img id="avatar1" src="assets/icons/profile.svg" alt="" class="flagInline"/><span id="name1">P1</span></h3>
        <div id="score1" class="aiScore">0</div>
        <canvas id="opp1" class="tetris-grid-bg"></canvas>
      </div>
      <div class="mini">
        <h3><img id="avatar2" src="assets/icons/profile.svg" alt="" class="flagInline"/><span id="name2">P2</span></h3>
        <div id="score2" class="aiScore">0</div>
        <canvas id="opp2" class="tetris-grid-bg"></canvas>
      </div>
      <div class="mini">
        <h3><img id="avatar3" src="assets/icons/profile.svg" alt="" class="flagInline"/><span id="name3">P3</span></h3>
        <div id="score3" class="aiScore">0</div>
        <canvas id="opp3" class="tetris-grid-bg"></canvas>
      </div>
    </div>
    <div class="userWrap">
      <div class="userHeader">
        <img id="avatarUser" src="assets/icons/profile.svg" alt="" class="avatar"/>
        <h3 id="playerName">USER</h3>
        <div class="hud">
          <div class="panel">
            <strong>Time</strong>
            <span id="time" class="timer">03:00</span>
          </div>
          <div class="panel">
            <strong>Your score</strong>
            <span id="myscore" class="score">0</span>
          </div>
        </div>
      </div>
      <canvas id="user" class="tetris-grid-bg"></canvas>
      <div class="overlayButtons">
        <button id="swapBtn" class="small">Swap</button>
        <button id="soundBtn" class="small">ðŸ”Š</button>
      </div>
    </div>
  </div>
</div>
<div id="toast" class="toast"></div>
<dialog id="results">
  <div class="modal">
    <h2>Game Over</h2>
    <div class="grid two">
      <div class="kpi"><div class="v" id="winner">-</div><div>Winner</div></div>
      <div class="kpi"><div class="v" id="payout">0</div><div>Payout TPC</div></div>
    </div>
    <div class="grid" style="margin-top:10px">
      <div class="kpi"><div class="v" id="fee">0</div><div>Fee 10%</div></div>
      <div class="kpi"><div class="v" id="potFinal">0</div><div>Final Pot</div></div>
    </div>
    <div class="grid" id="scoreList" style="margin-top:10px"></div>
    <div style="display:flex;gap:8px;flex-wrap:wrap;margin-top:8px">
      <button class="btn" id="rematch">Play Again</button>
      <button class="btn" id="change">Return to Lobby</button>
    </div>
  </div>
</dialog>
<script src="/falling-ball-api.js"></script>
<script>
if(!window.__BUBBLE_ROYALE_POWER__){
window.__BUBBLE_ROYALE_POWER__ = true;
(function(){
  const params = new URLSearchParams(location.search);
  let n = Math.max(2, Math.min(4, parseInt(params.get('players'),10)||4));
  let stake = Math.max(0, parseInt(params.get('amount'),10)||300);
  let durSec = Math.max(10, parseInt(params.get('duration'),10)||180);
  const avatarParam = params.get('avatar') || '';
  const tgId = params.get('tgId');
  const FLAG_EMOJIS = ["ðŸ‡¦ðŸ‡«","ðŸ‡¦ðŸ‡½","ðŸ‡¦ðŸ‡±","ðŸ‡©ðŸ‡¿","ðŸ‡¦ðŸ‡¸","ðŸ‡¦ðŸ‡©","ðŸ‡¦ðŸ‡´","ðŸ‡¦ðŸ‡®","ðŸ‡¦ðŸ‡¶","ðŸ‡¦ðŸ‡¬","ðŸ‡¦ðŸ‡·","ðŸ‡¦ðŸ‡²","ðŸ‡¦ðŸ‡¼","ðŸ‡¦ðŸ‡º","ðŸ‡¦ðŸ‡¹","ðŸ‡¦ðŸ‡¿","ðŸ‡§ðŸ‡¸","ðŸ‡§ðŸ‡­","ðŸ‡§ðŸ‡©","ðŸ‡§ðŸ‡§","ðŸ‡§ðŸ‡¾","ðŸ‡§ðŸ‡ª","ðŸ‡§ðŸ‡¿","ðŸ‡§ðŸ‡¯","ðŸ‡§ðŸ‡²","ðŸ‡§ðŸ‡¹","ðŸ‡§ðŸ‡´","ðŸ‡§ðŸ‡¦","ðŸ‡§ðŸ‡¼","ðŸ‡§ðŸ‡»","ðŸ‡§ðŸ‡·","ðŸ‡®ðŸ‡´","ðŸ‡»ðŸ‡¬","ðŸ‡§ðŸ‡³","ðŸ‡§ðŸ‡¬","ðŸ‡§ðŸ‡«","ðŸ‡§ðŸ‡®","ðŸ‡°ðŸ‡­","ðŸ‡¨ðŸ‡²","ðŸ‡¨ðŸ‡¦","ðŸ‡¨ðŸ‡»","ðŸ‡§ðŸ‡¶","ðŸ‡°ðŸ‡¾","ðŸ‡¨ðŸ‡«","ðŸ‡¹ðŸ‡©","ðŸ‡¨ðŸ‡±","ðŸ‡¨ðŸ‡³","ðŸ‡¨ðŸ‡½","ðŸ‡¨ðŸ‡¨","ðŸ‡¨ðŸ‡´","ðŸ‡°ðŸ‡²","ðŸ‡¨ðŸ‡¬","ðŸ‡¨ðŸ‡©","ðŸ‡¨ðŸ‡°","ðŸ‡¨ðŸ‡·","ðŸ‡¨ðŸ‡®","ðŸ‡­ðŸ‡·","ðŸ‡¨ðŸ‡º","ðŸ‡¨ðŸ‡¼","ðŸ‡¨ðŸ‡¾","ðŸ‡¨ðŸ‡¿","ðŸ‡©ðŸ‡°","ðŸ‡©ðŸ‡¯","ðŸ‡©ðŸ‡²","ðŸ‡©ðŸ‡´","ðŸ‡ªðŸ‡¨","ðŸ‡ªðŸ‡¬","ðŸ‡¸ðŸ‡»","ðŸ‡¬ðŸ‡¶","ðŸ‡ªðŸ‡·","ðŸ‡ªðŸ‡ª","ðŸ‡¸ðŸ‡¿","ðŸ‡ªðŸ‡¹","ðŸ‡«ðŸ‡°","ðŸ‡«ðŸ‡´","ðŸ‡«ðŸ‡¯","ðŸ‡«ðŸ‡®","ðŸ‡«ðŸ‡·","ðŸ‡¬ðŸ‡«","ðŸ‡µðŸ‡«","ðŸ‡¹ðŸ‡«","ðŸ‡¬ðŸ‡¦","ðŸ‡¬ðŸ‡²","ðŸ‡¬ðŸ‡ª","ðŸ‡©ðŸ‡ª","ðŸ‡¬ðŸ‡­","ðŸ‡¬ðŸ‡®","ðŸ‡¬ðŸ‡·","ðŸ‡¬ðŸ‡±","ðŸ‡¬ðŸ‡©","ðŸ‡¬ðŸ‡µ","ðŸ‡¬ðŸ‡º","ðŸ‡¬ðŸ‡¹","ðŸ‡¬ðŸ‡¬","ðŸ‡¬ðŸ‡³","ðŸ‡¬ðŸ‡¼","ðŸ‡¬ðŸ‡¾","ðŸ‡­ðŸ‡¹","ðŸ‡­ðŸ‡²","ðŸ‡­ðŸ‡³","ðŸ‡­ðŸ‡°","ðŸ‡­ðŸ‡º","ðŸ‡®ðŸ‡¸","ðŸ‡®ðŸ‡³","ðŸ‡®ðŸ‡©","ðŸ‡®ðŸ‡·","ðŸ‡®ðŸ‡¶","ðŸ‡®ðŸ‡ª","ðŸ‡®ðŸ‡²","ðŸ‡®ðŸ‡±","ðŸ‡®ðŸ‡¹","ðŸ‡¯ðŸ‡²","ðŸ‡¯ðŸ‡µ","ðŸ‡¯ðŸ‡ª","ðŸ‡¯ðŸ‡´","ðŸ‡°ðŸ‡¿","ðŸ‡°ðŸ‡ª","ðŸ‡°ðŸ‡®","ðŸ‡°ðŸ‡¼","ðŸ‡°ðŸ‡¬","ðŸ‡±ðŸ‡¦","ðŸ‡±ðŸ‡»","ðŸ‡±ðŸ‡§","ðŸ‡±ðŸ‡¸","ðŸ‡±ðŸ‡·","ðŸ‡±ðŸ‡¾","ðŸ‡±ðŸ‡®","ðŸ‡±ðŸ‡¹","ðŸ‡±ðŸ‡º","ðŸ‡²ðŸ‡´","ðŸ‡²ðŸ‡¬","ðŸ‡²ðŸ‡¼","ðŸ‡²ðŸ‡¾","ðŸ‡²ðŸ‡»","ðŸ‡²ðŸ‡±","ðŸ‡²ðŸ‡¹","ðŸ‡²ðŸ‡­","ðŸ‡²ðŸ‡¶","ðŸ‡²ðŸ‡·","ðŸ‡²ðŸ‡º","ðŸ‡¾ðŸ‡¹","ðŸ‡²ðŸ‡½","ðŸ‡«ðŸ‡²","ðŸ‡²ðŸ‡©","ðŸ‡²ðŸ‡¨","ðŸ‡²ðŸ‡³","ðŸ‡²ðŸ‡ª","ðŸ‡²ðŸ‡¸","ðŸ‡²ðŸ‡¦","ðŸ‡²ðŸ‡¿","ðŸ‡²ðŸ‡²","ðŸ‡³ðŸ‡¦","ðŸ‡³ðŸ‡·","ðŸ‡³ðŸ‡µ","ðŸ‡³ðŸ‡±","ðŸ‡³ðŸ‡¨","ðŸ‡³ðŸ‡¿","ðŸ‡³ðŸ‡®","ðŸ‡³ðŸ‡ª","ðŸ‡³ðŸ‡¬","ðŸ‡³ðŸ‡º","ðŸ‡³ðŸ‡«","ðŸ‡°ðŸ‡µ","ðŸ‡²ðŸ‡°","ðŸ‡²ðŸ‡µ","ðŸ‡³ðŸ‡´","ðŸ‡´ðŸ‡²","ðŸ‡µðŸ‡°","ðŸ‡µðŸ‡¼","ðŸ‡µðŸ‡¸","ðŸ‡µðŸ‡¦","ðŸ‡µðŸ‡¬","ðŸ‡µðŸ‡¾","ðŸ‡µðŸ‡ª","ðŸ‡µðŸ‡­","ðŸ‡µðŸ‡³","ðŸ‡µðŸ‡±","ðŸ‡µðŸ‡¹","ðŸ‡µðŸ‡·","ðŸ‡¶ðŸ‡¦","ðŸ‡·ðŸ‡ª","ðŸ‡·ðŸ‡´","ðŸ‡·ðŸ‡º","ðŸ‡·ðŸ‡¼","ðŸ‡¼ðŸ‡¸","ðŸ‡¸ðŸ‡²","ðŸ‡¸ðŸ‡¹","ðŸ‡¸ðŸ‡¦","ðŸ‡¸ðŸ‡³","ðŸ‡·ðŸ‡¸","ðŸ‡¸ðŸ‡¨","ðŸ‡¸ðŸ‡±","ðŸ‡¸ðŸ‡¬","ðŸ‡¸ðŸ‡½","ðŸ‡¸ðŸ‡°","ðŸ‡¸ðŸ‡®","ðŸ‡¸ðŸ‡§","ðŸ‡¸ðŸ‡´","ðŸ‡¿ðŸ‡¦","ðŸ‡¬ðŸ‡¸","ðŸ‡°ðŸ‡·","ðŸ‡¸ðŸ‡¸","ðŸ‡ªðŸ‡¸","ðŸ‡±ðŸ‡°","ðŸ‡§ðŸ‡±","ðŸ‡¸ðŸ‡­","ðŸ‡°ðŸ‡³","ðŸ‡±ðŸ‡¨","ðŸ‡²ðŸ‡«","ðŸ‡µðŸ‡²","ðŸ‡»ðŸ‡¨","ðŸ‡¸ðŸ‡©","ðŸ‡¸ðŸ‡·","ðŸ‡¸ðŸ‡¯","ðŸ‡¸ðŸ‡ª","ðŸ‡¨ðŸ‡­","ðŸ‡¸ðŸ‡¾","ðŸ‡¹ðŸ‡¼","ðŸ‡¹ðŸ‡¯","ðŸ‡¹ðŸ‡¿","ðŸ‡¹ðŸ‡­","ðŸ‡¹ðŸ‡±","ðŸ‡¹ðŸ‡¬","ðŸ‡¹ðŸ‡°","ðŸ‡¹ðŸ‡´","ðŸ‡¹ðŸ‡¹","ðŸ‡¹ðŸ‡³","ðŸ‡¹ðŸ‡·","ðŸ‡¹ðŸ‡²","ðŸ‡¹ðŸ‡¨","ðŸ‡¹ðŸ‡»","ðŸ‡ºðŸ‡²","ðŸ‡»ðŸ‡®","ðŸ‡ºðŸ‡¬","ðŸ‡ºðŸ‡¦","ðŸ‡¦ðŸ‡ª","ðŸ‡¬ðŸ‡§","ðŸ‡ºðŸ‡¸","ðŸ‡ºðŸ‡¾","ðŸ‡ºðŸ‡¿","ðŸ‡»ðŸ‡º","ðŸ‡»ðŸ‡¦","ðŸ‡»ðŸ‡ª","ðŸ‡»ðŸ‡³","ðŸ‡¼ðŸ‡«","ðŸ‡ªðŸ‡­","ðŸ‡¾ðŸ‡ª","ðŸ‡¿ðŸ‡²","ðŸ‡¿ðŸ‡¼"];
  const emojiToDataUrl = (e)=>`data:image/svg+xml,${encodeURIComponent("<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 120 120'><text y='96' font-size='96'>"+e+"</text></svg>")}`;
  const regionNames = new Intl.DisplayNames(['en'], { type: 'region' });
  const flagToName = (flag)=>{
    const codes = Array.from(flag).map(c=>c.codePointAt(0)-0x1F1E6+65);
    const cc = String.fromCharCode(...codes);
    return regionNames.of(cc);
  };
  const accountId = params.get('accountId');
  const devAccount = params.get('dev');
  const devAccount1 = params.get('dev1');
  const devAccount2 = params.get('dev2');
  const initParam = params.get('init');
  if (initParam && !window.Telegram) {
    const decoded = decodeURIComponent(initParam);
    window.Telegram = { WebApp: { initData: decoded } };
    try {
      const parsed = Object.fromEntries(new URLSearchParams(decoded));
      if (parsed.user) {
        window.Telegram.WebApp.initDataUnsafe = { user: JSON.parse(parsed.user) };
      }
    } catch {}
  }
  async function awardDevShare(total){
    const ops=[];
    if(devAccount1||devAccount2){
      if(devAccount) ops.push(fbApi.depositAccount(devAccount, Math.round(total*0.09), {game:'bubblepop-dev'}));
      if(devAccount1) ops.push(fbApi.depositAccount(devAccount1, Math.round(total*0.01), {game:'bubblepop-dev1'}));
      if(devAccount2) ops.push(fbApi.depositAccount(devAccount2, Math.round(total*0.02), {game:'bubblepop-dev2'}));
    }else if(devAccount){
      ops.push(fbApi.depositAccount(devAccount, Math.round(total*0.1), {game:'bubblepop-dev'}));
    }
    if(ops.length){ try{ await Promise.all(ops); }catch{} }
  }
  const GRID_COLS = 12, GRID_ROWS = 18;
  const COLORS = ['#5aa2ff','#ff9d5a','#ff5a6b','#d4af37','#34d399','#a78bfa'];
  const POP_SCORE = 10;
  const LAUNCH_SPEED = 360;
  const MIN_ANGLE = (-175 * Math.PI/180);
  const MAX_ANGLE = (-5 * Math.PI/180);
  const BOUNCE_DAMP = 1;
  const SPECIALS = ['H','V','B'];
  const SPECIAL_RATE_SEED = 0.06;
  const SPECIAL_RATE_NEXT = 0.10;
  const S = (function(){
    let ctx=null, enabled=true;
    function ensure(){ if(!ctx){ ctx = new (window.AudioContext||window.webkitAudioContext)(); } if(ctx.state==='suspended') ctx.resume(); }
    function tone(freq=440, time=0.08, type='sine', gain=0.02){ if(!enabled) return; ensure(); const o = ctx.createOscillator(); const g = ctx.createGain(); o.type=type; o.frequency.value=freq; g.gain.value=gain; o.connect(g); g.connect(ctx.destination); const now = ctx.currentTime; g.gain.setValueAtTime(gain, now); g.gain.exponentialRampToValueAtTime(0.0001, now+time); o.start(now); o.stop(now+time); }
    function chord(freqs, t=0.12, type='sine', baseGain=0.02){ if(!enabled) return; ensure(); const now=ctx.currentTime; freqs.forEach((f,i)=>{ const o=ctx.createOscillator(), g=ctx.createGain(); o.type=type; o.frequency.value=f; g.gain.value=baseGain/(i+1); o.connect(g); g.connect(ctx.destination); g.gain.setValueAtTime(g.gain.value, now); g.gain.exponentialRampToValueAtTime(0.0001, now+t); o.start(now); o.stop(now+t); }); }
    return { enable(v){ enabled = v; if(v) ensure(); }, launch(){ tone(520,0.09,'triangle',0.03); }, bounce(){ tone(280,0.03,'square',0.02); }, pop(){ chord([880,660],0.07,'sine',0.03); }, clear(){ chord([330,440,660],0.12,'triangle',0.03); }, swap(){ tone(740,0.05,'sine',0.025); }, over(){ chord([220,196,174],0.35,'sawtooth',0.03); } };
  })();
  const $ = s => document.querySelector(s);
  const toast = $('#toast');
  const showToast = (m)=>{ toast.textContent=m; toast.classList.add('show'); setTimeout(()=>toast.classList.remove('show'),1200); };
  const clamp=(v,mi,ma)=>Math.max(mi,Math.min(ma,v));
  const fmt = (s)=>{ const m = String((s/60)|0).padStart(2,'0'); const ss = String(Math.max(0, s%60)).padStart(2,'0'); return `${m}:${ss}`; };
  const randColor = ()=> COLORS[(Math.random()*COLORS.length)|0];
  const chance = (p)=> Math.random()<p;
  function drawCartoonBubble(ctx, x, y, r, color, special){
    ctx.beginPath();
    ctx.arc(x, y, r, 0, Math.PI*2);
    ctx.fillStyle = color;
    ctx.fill();
    ctx.lineWidth = Math.max(2, r * 0.1);
    ctx.strokeStyle = '#000';
    ctx.lineJoin = 'round';
    ctx.lineCap = 'round';
    ctx.stroke();
    ctx.fillStyle = 'rgba(255,255,255,0.6)';
    ctx.beginPath();
    ctx.arc(x - r*0.3, y - r*0.3, r*0.25, 0, Math.PI*2);
    ctx.fill();
    ctx.beginPath();
    ctx.arc(x - r*0.45, y - r*0.45, r*0.07, 0, Math.PI*2);
    ctx.fill();
    if(special){
      ctx.fillStyle = '#0b1228';
      ctx.font = `bold ${Math.floor(r*1.0)}px system-ui`;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(special, x, y+1);
    }
  }
  function fitCanvas(c){
    const r = c.getBoundingClientRect();
    const dprBase = window.devicePixelRatio || 1;
    const dpr = dprBase * 2;
    c.style.width = r.width + 'px';
    c.style.height = r.height + 'px';
    c.width = Math.round(r.width * dpr);
    c.height = Math.round(r.height * dpr);
    const ctx = c.getContext('2d');
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    c.dpr = dpr;
  }
  function createBubbleGame(canvas){
    const ctx = canvas.getContext('2d');
    fitCanvas(canvas);
    const game = {
      cell: { w: 0, h: 0, r: 0 },
      grid: Array.from({length:GRID_ROWS},()=>Array(GRID_COLS).fill(null)),
      cur: { x:0, y:0, vx:0, vy:0, bubble: null, active:false },
      nextBubble: null,
      score: 0,
      over:false,
      aimAngle: -Math.PI/4,
      isUser:false,
      cooldown:0
    };
    function bubble(color, special=null){ return {color, special}; }
    const cw = () => canvas.width / (canvas.dpr || 1);
    const ch = () => canvas.height / (canvas.dpr || 1);
    function recomputeCell(){ const w = cw(); game.cell.w = w / GRID_COLS; game.cell.h = game.cell.w; game.cell.r = game.cell.w*0.48; }
    function seedRows(rows=4){ for(let y=0;y<rows;y++){ for(let x=0;x<GRID_COLS;x++){ if(Math.random() < 0.75){ const col = randColor(); const sp = chance(SPECIAL_RATE_SEED) ? SPECIALS[(Math.random()*SPECIALS.length)|0] : null; game.grid[y][x] = bubble(col, sp); } } } }
    function worldToCell(x,y){ return { cx: Math.round(x / game.cell.w - 0.5), cy: Math.round(y / game.cell.h - 0.5) }; }
    function cellToWorld(cx,cy){ return { x: (cx+0.5)*game.cell.w, y: (cy+0.5)*game.cell.h }; }
    function validCell(cx,cy){ return cx>=0 && cx<GRID_COLS && cy>=0 && cy<GRID_ROWS; }
    function neighbors(cx,cy){ const n = []; const dirs = [[1,0],[-1,0],[0,1],[0,-1],[1,1],[-1,-1]]; for(const [dx,dy] of dirs){ const nx=cx+dx, ny=cy+dy; if(validCell(nx,ny)) n.push([nx,ny]); } return n; }
    function collidesAny(x,y){ if(y - game.cell.r <= 0) return { hit:true, cell:{cx: Math.round(x/game.cell.w-0.5), cy:0 }}; for(let cy=0; cy<GRID_ROWS; cy++){ for(let cx=0; cx<GRID_COLS; cx++){ const obj = game.grid[cy][cx]; if(!obj) continue; const w = cellToWorld(cx,cy); const d2 = (w.x - x)*(w.x - x) + (w.y - y)*(w.y - y); if(d2 <= (game.cell.r*2 - 2)*(game.cell.r*2 - 2)){ return { hit:true, cell:{cx,cy} }; } } } return { hit:false }; }
    function placeIntoGrid(x,y,bub){ let { cx, cy } = worldToCell(x,y); cx = clamp(cx, 0, GRID_COLS-1); cy = clamp(cy, 0, GRID_ROWS-1); const ring = [[0,0],[1,0],[-1,0],[0,1],[0,-1],[1,1],[-1,-1],[1,-1],[-1,1]]; for(const [dx,dy] of ring){ const nx=cx+dx, ny=cy+dy; if(validCell(nx,ny) && !game.grid[ny][nx]){ game.grid[ny][nx]=bub; return {cx:nx,cy:ny}; } } if(!game.grid[cy][cx]){ game.grid[cy][cx]=bub; return {cx,cy}; } for(let yy=0;yy<GRID_ROWS;yy++){ if(!game.grid[yy][cx]){ game.grid[yy][cx]=bub; return {cx,cy:yy}; } } game.over = true; return {cx,cy}; }
    function floodSame(startCx,startCy,color){ const seen = new Set(); const q = [[startCx,startCy]]; const cluster = []; while(q.length){ const [cx,cy] = q.shift(); const key = cx+','+cy; if(seen.has(key)) continue; seen.add(key); if(!validCell(cx,cy)) continue; const cell = game.grid[cy][cx]; if(!cell || cell.color !== color || cell.special) continue; cluster.push([cx,cy]); for(const [nx,ny] of neighbors(cx,cy)) q.push([nx,ny]); } return cluster; }
    function removeFloating(){ const seen = new Set(); const stack = []; for(let x=0;x<GRID_COLS;x++){ if(game.grid[0][x]) stack.push([x,0]); } while(stack.length){ const [cx,cy] = stack.pop(); const k=cx+','+cy; if(seen.has(k)) continue; seen.add(k); for(const [nx,ny] of neighbors(cx,cy)){ if(validCell(nx,ny) && game.grid[ny][nx]) stack.push([nx,ny]); } } let removed = 0; for(let y=0;y<GRID_ROWS;y++){ for(let x=0;x<GRID_COLS;x++){ if(game.grid[y][x] && !seen.has(x+','+y)){ game.grid[y][x]=null; removed++; } } } return removed; }
    function triggerSpecial(cx,cy,kind){ let removed = 0; if(kind==='H'){ for(let x=0;x<GRID_COLS;x++){ if(game.grid[cy][x]){ game.grid[cy][x]=null; removed++; } } S.clear(); } else if(kind==='V'){ for(let y=0;y<GRID_ROWS;y++){ if(game.grid[y][cx]){ game.grid[y][cx]=null; removed++; } } S.clear(); } else if(kind==='B'){ for(let y=cy-1;y<=cy+1;y++){ for(let x=cx-1;x<=cx+1;x++){ if(validCell(x,y) && game.grid[y][x]){ game.grid[y][x]=null; removed++; } } } S.clear(); } game.score += removed * POP_SCORE; return removed; }
    function launchToward(targetX, targetY){ if(game.cur.active || game.over) return; const ox = cw()/2, oy = ch() - game.cell.r - 2; let ang = Math.atan2(targetY - oy, targetX - ox); ang = clamp(ang, MIN_ANGLE, MAX_ANGLE); game.cur.x = ox; game.cur.y = oy; game.cur.vx = Math.cos(ang)*LAUNCH_SPEED; game.cur.vy = Math.sin(ang)*LAUNCH_SPEED; if(!game.cur.bubble) game.cur.bubble = game.nextBubble || bubble(randColor(), chance(SPECIAL_RATE_NEXT)?SPECIALS[(Math.random()*3)|0]:null); game.cur.active = true; S.launch(); }
    function swapBubble(){ const next = game.nextBubble || bubble(randColor(), chance(SPECIAL_RATE_NEXT)?SPECIALS[(Math.random()*3)|0]:null); const curColor = game.cur.bubble ? game.cur.bubble.color : randColor(); const curSpecial = game.cur.bubble ? game.cur.bubble.special : null; game.nextBubble = { color: curColor, special: curSpecial }; game.cur.bubble = bubble(next.color, next.special); S.swap(); showToast('Swapped'); }
    function step(dt){
      if(game.over) return;
      if(game.cur.active){
        const r = game.cell.r;
        const maxMove = Math.max(Math.abs(game.cur.vx*dt), Math.abs(game.cur.vy*dt));
        const steps = Math.max(1, Math.ceil(maxMove / (r/2)));
        const stepDt = dt / steps;
        for(let i=0;i<steps && game.cur.active;i++){
          game.cur.x += game.cur.vx * stepDt;
          game.cur.y += game.cur.vy * stepDt;
          if(game.cur.x - r < 0){ game.cur.x = r; game.cur.vx = Math.abs(game.cur.vx)*BOUNCE_DAMP; S.bounce(); }
          if(game.cur.x + r > cw()){ game.cur.x = cw() - r; game.cur.vx = -Math.abs(game.cur.vx)*BOUNCE_DAMP; S.bounce(); }
          const col = collidesAny(game.cur.x, game.cur.y);
          if(col.hit || game.cur.y - r <= 0){
            const bub = game.cur.bubble || bubble(randColor(), null);
            const spot = placeIntoGrid(game.cur.x, game.cur.y, bub);
            if(bub.special){
              const cleared = triggerSpecial(spot.cx, spot.cy, bub.special);
              const floating = removeFloating();
              if(cleared+floating>0) S.pop();
            } else {
              const cluster = floodSame(spot.cx, spot.cy, bub.color);
              if(cluster.length >= 3){
                for(const [cx,cy] of cluster) game.grid[cy][cx] = null;
                game.score += cluster.length * POP_SCORE;
                const floating = removeFloating();
                game.score += floating * POP_SCORE;
                S.pop();
              }
            }
            game.cur.active = false;
            game.cur.bubble = game.nextBubble || bubble(randColor(), chance(SPECIAL_RATE_NEXT)?SPECIALS[(Math.random()*3)|0]:null);
            game.nextBubble = bubble(randColor(), chance(SPECIAL_RATE_NEXT)?SPECIALS[(Math.random()*3)|0]:null);
            for(let x=0;x<GRID_COLS;x++){ if(game.grid[GRID_ROWS-1][x]){ game.over = true; S.over(); break; } }
          }
        }
      }
    }
    function draw(){
      ctx.clearRect(0,0,cw(),ch());
      for(let y=0;y<GRID_ROWS;y++){
        for(let x=0;x<GRID_COLS;x++){
          const cell = game.grid[y][x];
          if(!cell) continue;
          const w = cellToWorld(x,y);
          drawCartoonBubble(ctx, w.x, w.y, game.cell.r, cell.color, cell.special);
        }
      }
      if(game.cur.active || game.cur.bubble){
        const y = game.cur.active ? game.cur.y : (ch() - game.cell.r - 2);
        const x = game.cur.active ? game.cur.x : (cw()/2);
        const b = game.cur.bubble || {color:COLORS[0], special:null};
        drawCartoonBubble(ctx, x, y, game.cell.r, b.color, b.special);
      }
      if(game.nextBubble){
        const nr = Math.min(game.cell.r, 24);
        const nx = cw() - nr - 10;
        const ny = ch() - nr - 10;
        drawCartoonBubble(ctx, nx, ny, nr, game.nextBubble.color, game.nextBubble.special);
      }
      if(game.isUser && game.over){
        ctx.fillStyle = 'rgba(0,0,0,0.45)';
        ctx.fillRect(0,0,cw(),ch());
        ctx.fillStyle = '#e7eefc';
        ctx.font='bold 16px system-ui';
        ctx.fillText('Board filled!', 14, 28);
      }
    }
    game.resize = function(){ fitCanvas(canvas); recomputeCell(); };
    game.tick = function(dt){ if(game.cooldown>0) game.cooldown-=dt; step(dt); draw(); };
    game.start = function(){ recomputeCell(); seedRows(4); game.cur.bubble = bubble(randColor(), chance(SPECIAL_RATE_NEXT)?SPECIALS[(Math.random()*3)|0]:null); game.nextBubble = bubble(randColor(), chance(SPECIAL_RATE_NEXT)?SPECIALS[(Math.random()*3)|0]:null); };
    function bindUserInput(){ const swapBtn = document.getElementById('swapBtn'); const soundBtn = document.getElementById('soundBtn'); let soundOn = true; let unlocked=false; const handlePointer=(e)=>{ if(!unlocked){ S.enable(true); unlocked=true; } if(!game.isUser || game.over) return; const r = canvas.getBoundingClientRect(); const x = e.clientX - r.left, y = e.clientY - r.top; launchToward(x,y); }; canvas.addEventListener('pointerdown', handlePointer); swapBtn.onclick = ()=>{ if(!game.cur.active) swapBubble(); }; soundBtn.onclick = ()=>{ soundOn = !soundOn; S.enable(soundOn); soundBtn.textContent = soundOn ? 'ðŸ”Š' : 'ðŸ”‡'; }; }
    game.bindUserInput = bindUserInput;
    return game;
  }
  function botStep(bot, dt){ if(bot.over) return; if(!bot.cur.active && bot.cooldown<=0){ const canvas = bot.__canvas; const dpr = canvas.dpr || 1; const cw = canvas.width / dpr; const ch = canvas.height / dpr; const bub = bot.cur.bubble || { color: COLORS[(Math.random()*COLORS.length)|0], special: Math.random()<0.05? ['H','V','B'][(Math.random()*3)|0] : null }; bot.cur.bubble = bub; let targetX, targetY; if(Math.random()<0.7){ const targets=[]; const dirs=[[1,0],[-1,0],[0,1],[0,-1],[1,1],[-1,-1]]; for(let y=0;y<GRID_ROWS;y++){ for(let x=0;x<GRID_COLS;x++){ const cell=bot.grid[y][x]; if(cell && cell.color===bub.color){ for(const [dx,dy] of dirs){ const nx=x+dx, ny=y+dy; if(nx>=0&&nx<GRID_COLS&&ny>=0&&ny<GRID_ROWS && !bot.grid[ny][nx]) targets.push({x:(nx+0.5)*bot.cell.w, y:(ny+0.5)*bot.cell.h}); } } } } if(targets.length){ const t=targets[(Math.random()*targets.length)|0]; targetX=t.x; targetY=t.y; } } if(targetX===undefined){ targetX=(Math.random()*cw*0.9) + cw*0.05; targetY=(Math.random()*ch*0.4) + ch*0.1; } const ox=cw/2, oy=ch - bot.cell.r - 2; let ang=Math.atan2(targetY - oy, targetX - ox); ang = clamp(ang, MIN_ANGLE, MAX_ANGLE); ang += (Math.random()-0.5)*0.1; bot.cur.x=ox; bot.cur.y=oy; bot.cur.vx=Math.cos(ang)*LAUNCH_SPEED; bot.cur.vy=Math.sin(ang)*LAUNCH_SPEED; bot.cur.active=true; bot.cooldown = 0.8 + Math.random()*0.7; } }
  const canvases = { user: $('#user'), opp1: $('#opp1'), opp2: $('#opp2'), opp3: $('#opp3') };
  const ui = { time: $('#time'), myscore: $('#myscore'), duration: $('#duration'), players: $('#players'), stake: $('#stake'), start: $('#start'), results: $('#results'), winner: $('#winner'), payout: $('#payout'), fee: $('#fee'), potFinal: $('#potFinal'), scoreList: $('#scoreList'), rematch: $('#rematch'), change: $('#change') };
  ui.players.value = n;
  ui.duration.value = durSec;
  ui.stake.value = stake;
  document.querySelector('.controls').style.display='none';
  document.querySelector('header').style.display='none';
  const avatarEls = [$('#avatar1'), $('#avatar2'), $('#avatar3'), $('#avatarUser')];
  const nameEls = [$('#name1'), $('#name2'), $('#name3')];
  const scoreEls = [$('#score1'), $('#score2'), $('#score3')];
  const playerNameEl = $('#playerName');
  const userData = window?.Telegram?.WebApp?.initDataUnsafe?.user;
  const playerName = userData?.username || [userData?.first_name, userData?.last_name].filter(Boolean).join(' ') || 'Player';
  function adjustNameSize(el){
    if(!el) return;
    const len = el.textContent.length;
    if(len > 12){
      const size = Math.max(8, 13 - (len - 12) * 0.5);
      el.style.fontSize = size + 'px';
    }
  }
  if(playerNameEl){
    playerNameEl.textContent = playerName;
    adjustNameSize(playerNameEl);
  }
  const avatarUrls = Array(n).fill('');
  if(avatarParam){
    avatarEls[3].src = avatarParam;
  } else if(userData?.photo_url){
    avatarEls[3].src = userData.photo_url;
  }
  for(let i=0;i<n-1;i++){ const flag = FLAG_EMOJIS[(Math.random()*FLAG_EMOJIS.length)|0]; const url = emojiToDataUrl(flag); avatarEls[i].src = url; avatarUrls[i] = url; nameEls[i].textContent = flagToName(flag); adjustNameSize(nameEls[i]); scoreEls[i].textContent = '0'; }
  avatarUrls[n-1] = avatarEls[3].src;
  let games = [];
  let last = performance.now();
  let endAt = 0; let running = false; let rafId = null;
  function layoutCanvases(){ Object.values(canvases).forEach(c=>{ if(!c) return; fitCanvas(c); }); }
  function startMatch(){ layoutCanvases(); ui.time.textContent = fmt(durSec); games = []; const oppSlots = [canvases.opp1, canvases.opp2, canvases.opp3]; for(let i=0;i<n-1;i++){ const g = createBubbleGame(oppSlots[i]); g.__canvas = oppSlots[i]; g.isUser = false; g.start(); games.push(g); } const userGame = createBubbleGame(canvases.user); userGame.__canvas = canvases.user; userGame.isUser = true; userGame.start(); userGame.bindUserInput(); games.push(userGame); endAt = performance.now() + durSec*1000; running = true; last = performance.now(); loop(); }
  function updateTimer(){ const remain = Math.max(0, Math.ceil((endAt - performance.now())/1000)); ui.time.textContent = fmt(remain); if(remain<=0){ finish(); } }
  function loop(){ if(!running) return; const now = performance.now(); const dt = (now - last)/1000; last = now; for(let i=0;i<games.length;i++){ const g = games[i]; if(!g.isUser){ botStep(g, dt); if(scoreEls[i]) scoreEls[i].textContent = String(g.score); } g.tick(dt); } ui.myscore.textContent = String(games[games.length-1].score); updateTimer(); rafId = requestAnimationFrame(loop); }
  function coinBurst(){ const burst=document.createElement('div'); burst.className='coin-burst'; for(let i=0;i<30;i++){ const img=document.createElement('img'); img.src='/assets/icons/ezgif-54c96d8a9b9236.webp'; img.className='coin-img'; img.style.setProperty('--dx',`${(Math.random()-0.5)*100}px`); img.style.setProperty('--delay',`${Math.random()*0.3}s`); img.style.setProperty('--dur',`${0.8+Math.random()*0.4}s`); burst.appendChild(img); } document.body.appendChild(burst); setTimeout(()=>burst.remove(),1200); }
  function celebrate(idx){ return new Promise(res=>{ const wrap=document.createElement('div'); wrap.className='winner-celebration'; const img=document.createElement('img'); img.src=avatarUrls[idx]; wrap.appendChild(img); const text=document.createElement('div'); text.textContent=`P${idx+1} Wins!`; wrap.appendChild(text); document.body.appendChild(wrap); coinBurst(); setTimeout(()=>{wrap.remove();res();},1500); }); }
  async function finish(){ if(!running) return; running=false; if(rafId) cancelAnimationFrame(rafId); const gross = stake * n; const fee = Math.round(gross*0.10); const net = gross - fee; const scores = games.map((g,i)=>({i,score:g.score})); const max = Math.max(...scores.map(s=>s.score)); const winners = scores.filter(s=>s.score===max); const payout = winners.length? Math.floor(net / winners.length) : 0; ui.winner.textContent = winners.length>1 ? `Tie (${winners.map(w=>'P'+(w.i+1)).join(', ')})` : `P${winners[0].i+1}`; ui.payout.textContent = String(payout); ui.fee.textContent = String(fee); ui.potFinal.textContent = String(net); ui.scoreList.innerHTML = scores.sort((a,b)=>b.score-a.score).map(s=>`<div class="kpi"><div class="v">P${s.i+1}: ${s.score}</div><div>â€”</div></div>`).join(''); if(winners.some(w=>w.i===n-1) && accountId){ try{ await fbApi.depositAccount(accountId, payout, {game:'bubblepop-win'}); if(tgId) await fbApi.addTransaction(tgId, 0, 'win', {game:'bubblepop', players:n, accountId}); }catch{} } await awardDevShare(gross); await celebrate(winners[0].i); if(!ui.results.open) ui.results.showModal(); }
  ui.rematch.addEventListener('click', ()=>{ ui.results.close(); startMatch(); });
  ui.change.addEventListener('click', ()=>{ ui.results.close(); location.href='/games/bubblepoproyale/lobby'; });
  window.addEventListener('resize', layoutCanvases);
  layoutCanvases();
  startMatch();
})();
}
</script>
</body>
</html>
