<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no"/>
<title>Domino Royal 3D</title>
<style>
  html,body{margin:0;height:100%;background:#ece6dc;overflow:hidden;font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial}
  #app{position:fixed;inset:0; width:100dvw; height:100dvh;}
  canvas{display:block; width:100dvw !important; height:100dvh !important; touch-action:none}
  button{font-weight:700;border:0;border-radius:999px;padding:.45rem .7rem;background:#ffd24a;color:#333;box-shadow:0 4px 12px rgba(0,0,0,.25);}
  button:active{transform:translateY(1px);}
  #status{position:fixed;top:calc(0.65rem + env(safe-area-inset-top, 0px));left:50%;transform:translateX(-50%);padding:.35rem .75rem;border-radius:999px;background:rgba(0,0,0,.55);color:#fff;font-weight:700;z-index:2;backdrop-filter:blur(6px);}
  #railControls{position:fixed;left:50%;bottom:calc(env(safe-area-inset-bottom,0px) + clamp(3.8rem, 18vh, 9.5rem));transform:translateX(-50%);display:flex;gap:.75rem;align-items:center;background:rgba(64,42,20,.88);color:#fff;border-radius:999px;padding:.55rem .9rem;box-shadow:0 14px 30px rgba(0,0,0,.45);z-index:2;pointer-events:auto;}
  #railControls button{background:#ffd24a;color:#3b250f;min-width:5.2rem;font-size:1rem;padding:.55rem 1.05rem;}
  #btnRules{position:fixed;top:calc(0.75rem + env(safe-area-inset-top,0px));right:calc(0.75rem + env(safe-area-inset-right,0px));width:2.75rem;height:2.75rem;border-radius:999px;background:rgba(0,0,0,.58);color:#fff;display:grid;place-items:center;font-size:1.3rem;box-shadow:0 6px 18px rgba(0,0,0,.35);z-index:3;backdrop-filter:blur(6px);padding:0;}
  #btnRules span{pointer-events:none;}
  #rules{position:fixed;top:0;left:0;right:0;bottom:0;display:none;align-items:center;justify-content:center;background:rgba(0,0,0,.55);z-index:3}
  #rules .card{max-width:720px;background:#fff;color:#222;border-radius:16px;box-shadow:0 12px 40px rgba(0,0,0,.25);padding:16px 18px}
  #rules h2{margin:0 0 6px 0;font-size:18px}
  #rules ol{margin:6px 0 0 18px}
  #rules .row{display:flex;gap:8px;justify-content:flex-end;margin-top:12px}
</style>
</head>
<body>
<div id="app"></div>
<div id="status" role="status">Ready</div>
<button id="btnRules" type="button" aria-label="Rules" title="Rules">
  <span aria-hidden="true">ℹ️</span>
</button>
<div id="railControls" aria-label="Game controls">
  <button id="draw" type="button">Draw</button>
  <button id="pass" type="button">Pass</button>
</div>
<div id="rules">
  <div class="card">
    <h2>Domino Royal — Rules for 2–4 players</h2>
    <ol>
      <li><b>Set:</b> Double-Six (28 tiles, 0–6). Each tile is unique (a,b) with a≤b. No duplicates.</li>
      <li><b>Dealing:</b> 7 tiles per player. The rest form the <i>stock</i> (boneyard).</li>
      <li><b>Opening:</b> The player with the highest double starts. If no double, the highest tile opens.</li>
      <li><b>On the table:</b> Build a horizontal chain across the green cloth. Only doubles stand vertically. At the cloth edges, pivot and keep the chain running horizontally.</li>
      <li><b>Matching:</b> Free ends must match in value. Doubles accept the same value on both sides.</li>
      <li><b>No move?</b> Draw from the stock until you can play. If the stock is empty, pass.</li>
      <li><b>Ending:</b> The winner is the first out. If play is blocked, the lowest pip total wins.</li>
    </ol>
    <div class="row">
      <button id="closeRules">Close</button>
    </div>
  </div>
</div>

<script type="module">
import * as THREE from "https://esm.sh/three@0.160.0";
import { OrbitControls } from "https://esm.sh/three@0.160.0/examples/jsm/controls/OrbitControls.js";
import { RoomEnvironment } from "https://esm.sh/three@0.160.0/examples/jsm/environments/RoomEnvironment.js";
import { RoundedBoxGeometry } from "https://esm.sh/three@0.160.0/examples/jsm/geometries/RoundedBoxGeometry.js";

/* ---------- Audio (SFX) ---------- */
const SFX = {
  place: new Audio("https://cdn.pixabay.com/download/audio/2022/03/15/audio_7dc2b2.mp3?filename=click-124467.mp3"),
  draw:  new Audio("https://cdn.pixabay.com/download/audio/2022/03/15/audio_b2f7c5.mp3?filename=pop-124476.mp3")
};
SFX.place.volume = 0.7; SFX.draw.volume = 0.7;

/* ---------- Renderer / Scene ---------- */
const app = document.getElementById("app");
const renderer = new THREE.WebGLRenderer({ antialias:true, alpha:true, powerPreference:"high-performance" });
renderer.setPixelRatio(Math.min(devicePixelRatio,2));
renderer.outputColorSpace = THREE.SRGBColorSpace;              // ensure gold looks vibrant
renderer.toneMapping = THREE.ACESFilmicToneMapping;
renderer.toneMappingExposure = 1.05;
function setRendererSize(){
  const vv = window.visualViewport; const w = vv ? vv.width : window.innerWidth; const h = vv ? vv.height: window.innerHeight;
  renderer.setSize(w, h, false);
}
setRendererSize();
app.appendChild(renderer.domElement);

const scene = new THREE.Scene();
const pmrem = new THREE.PMREMGenerator(renderer);
const envTex = pmrem.fromScene(new RoomEnvironment(), 0.04).texture;
scene.environment = envTex;

const camera = new THREE.PerspectiveCamera(56, 1, 0.05, 100);
function fitCamera(){
  const vv = window.visualViewport; const w= vv?vv.width:innerWidth; const h= vv?vv.height:innerHeight;
  camera.aspect = w/h; camera.updateProjectionMatrix(); setRendererSize();
}
fitCamera();

const controls = new OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;
controls.target.set(0, 0.64, 0);
controls.minDistance = 1.1; controls.maxDistance = 4; controls.maxPolarAngle = Math.PI*0.49;

/* ---------- Lights ---------- */
scene.add(new THREE.AmbientLight(0xffffff, 0.45));
scene.add(new THREE.HemisphereLight(0xffffff, 0xb8b19a, 0.55));
const key = new THREE.DirectionalLight(0xffffff, 1.6); key.position.set(3.2,3.6,2.2); key.castShadow=true; key.shadow.mapSize.set(2048,2048); scene.add(key);
const rimLight = new THREE.DirectionalLight(0xffffff, 0.55); rimLight.position.set(-2.2,2.6,-1.4); scene.add(rimLight);

const getPoolCarpetTextures = (() => {
  let cache = null;
  const clamp01 = (v) => Math.min(1, Math.max(0, v));
  const prng = (seed) => {
    let value = seed >>> 0;
    return () => {
      value = (value * 1664525 + 1013904223) % 4294967296;
      return value / 4294967296;
    };
  };
  const drawRoundedRect = (ctx, x, y, w, h, r) => {
    const radius = Math.max(0, Math.min(r, Math.min(w, h) / 2));
    ctx.beginPath();
    ctx.moveTo(x + radius, y);
    ctx.lineTo(x + w - radius, y);
    ctx.quadraticCurveTo(x + w, y, x + w, y + radius);
    ctx.lineTo(x + w, y + h - radius);
    ctx.quadraticCurveTo(x + w, y + h, x + w - radius, y + h);
    ctx.lineTo(x + radius, y + h);
    ctx.quadraticCurveTo(x, y + h, x, y + h - radius);
    ctx.lineTo(x, y + radius);
    ctx.quadraticCurveTo(x, y, x + radius, y);
    ctx.closePath();
  };
  return (renderer) => {
    if (cache) return cache;
    if (typeof document === "undefined") {
      cache = { map: null, bump: null };
      return cache;
    }
    const size = 1024;
    const canvas = document.createElement("canvas");
    canvas.width = canvas.height = size;
    const ctx = canvas.getContext("2d");

    const gradient = ctx.createLinearGradient(0, 0, size, size);
    gradient.addColorStop(0, "#7c242f");
    gradient.addColorStop(1, "#9d3642");
    ctx.fillStyle = gradient;
    ctx.fillRect(0, 0, size, size);

    const rand = prng(987654321);
    const image = ctx.getImageData(0, 0, size, size);
    const data = image.data;
    const baseColor = { r: 112, g: 28, b: 34 };
    const highlightColor = { r: 196, g: 72, b: 82 };
    const toChannel = (component) => Math.round(clamp01(component / 255) * 255);
    for (let y = 0; y < size; y++) {
      for (let x = 0; x < size; x++) {
        const idx = (y * size + x) * 4;
        const fiber = (Math.sin((x / size) * Math.PI * 14) + Math.cos((y / size) * Math.PI * 16)) * 0.08;
        const grain = (rand() - 0.5) * 0.12;
        const shade = clamp01(0.55 + fiber * 0.75 + grain * 0.6);
        const r = baseColor.r + (highlightColor.r - baseColor.r) * shade;
        const g = baseColor.g + (highlightColor.g - baseColor.g) * shade;
        const b = baseColor.b + (highlightColor.b - baseColor.b) * shade;
        data[idx] = toChannel(r);
        data[idx + 1] = toChannel(g);
        data[idx + 2] = toChannel(b);
      }
    }
    ctx.putImageData(image, 0, 0);

    ctx.globalAlpha = 0.04;
    ctx.fillStyle = "#4f1119";
    for (let row = 0; row < size; row += 3) {
      ctx.fillRect(0, row, size, 1);
    }
    ctx.globalAlpha = 1;

    const insetRatio = 0.055;
    const stripeInset = size * insetRatio;
    const stripeRadius = size * 0.08;
    const stripeWidth = size * 0.012;
    ctx.lineWidth = stripeWidth;
    ctx.strokeStyle = "#f2b7b4";
    ctx.shadowColor = "rgba(80,20,30,0.18)";
    ctx.shadowBlur = stripeWidth * 0.8;
    drawRoundedRect(ctx, stripeInset, stripeInset, size - stripeInset * 2, size - stripeInset * 2, stripeRadius);
    ctx.stroke();
    ctx.shadowBlur = 0;

    const texture = new THREE.CanvasTexture(canvas);
    texture.wrapS = texture.wrapT = THREE.ClampToEdgeWrapping;
    texture.anisotropy = renderer?.capabilities?.getMaxAnisotropy?.() ?? 8;
    texture.minFilter = THREE.LinearMipMapLinearFilter;
    texture.magFilter = THREE.LinearFilter;
    texture.generateMipmaps = true;
    texture.colorSpace = THREE.SRGBColorSpace;

    const bumpCanvas = document.createElement("canvas");
    bumpCanvas.width = bumpCanvas.height = size;
    const bumpCtx = bumpCanvas.getContext("2d");
    bumpCtx.drawImage(canvas, 0, 0);
    const bumpImage = bumpCtx.getImageData(0, 0, size, size);
    const bumpData = bumpImage.data;
    const bumpRand = prng(246813579);
    for (let i = 0; i < bumpData.length; i += 4) {
      const r = bumpData[i];
      const g = bumpData[i + 1];
      const b = bumpData[i + 2];
      const lum = (r * 0.299 + g * 0.587 + b * 0.114) / 255;
      const noise = (bumpRand() - 0.5) * 0.16;
      const v = clamp01(0.62 + lum * 0.28 + noise);
      const value = Math.floor(v * 255);
      bumpData[i] = bumpData[i + 1] = bumpData[i + 2] = value;
    }
    bumpCtx.putImageData(bumpImage, 0, 0);

    const bump = new THREE.CanvasTexture(bumpCanvas);
    bump.wrapS = bump.wrapT = THREE.ClampToEdgeWrapping;
    bump.anisotropy = Math.min(texture.anisotropy ?? 4, 6);
    bump.minFilter = THREE.LinearMipMapLinearFilter;
    bump.magFilter = THREE.LinearFilter;
    bump.generateMipmaps = true;

    cache = { map: texture, bump };
    return cache;
  };
})();

const CHAIR_CLOTH_TEXTURE_SIZE = 512;
const CHAIR_CLOTH_REPEAT = 4;
const DEFAULT_CHAIR_OPTION = Object.freeze({
  id: "crimsonVelvet",
  primary: "#8b1538",
  accent: "#5c0f26",
  highlight: "#d35a7a",
  legColor: "#1f1f1f"
});

function adjustHexColor(hex, amount) {
  const base = new THREE.Color(hex);
  const target = amount >= 0 ? new THREE.Color(0xffffff) : new THREE.Color(0x000000);
  base.lerp(target, Math.min(Math.abs(amount), 1));
  return `#${base.getHexString()}`;
}

function createChairClothTexture(option, renderer) {
  if (typeof document === "undefined") {
    return null;
  }
  const primary = option?.primary ?? "#0f6a2f";
  const accent = option?.accent ?? adjustHexColor(primary, -0.28);
  const highlight = option?.highlight ?? adjustHexColor(primary, 0.22);
  const canvas = document.createElement("canvas");
  canvas.width = canvas.height = CHAIR_CLOTH_TEXTURE_SIZE;
  const ctx = canvas.getContext("2d");
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  const shadow = adjustHexColor(accent, -0.22);
  const seam = adjustHexColor(accent, -0.35);

  const gradient = ctx.createLinearGradient(0, 0, canvas.width, canvas.height);
  gradient.addColorStop(0, adjustHexColor(primary, 0.2));
  gradient.addColorStop(0.5, primary);
  gradient.addColorStop(1, accent);
  ctx.fillStyle = gradient;
  ctx.fillRect(0, 0, canvas.width, canvas.height);

  const spacing = canvas.width / CHAIR_CLOTH_REPEAT;
  const halfSpacing = spacing / 2;
  const lineWidth = Math.max(1.6, spacing * 0.06);

  ctx.strokeStyle = seam;
  ctx.lineWidth = lineWidth;
  ctx.globalAlpha = 0.9;
  for (let offset = -canvas.height; offset <= canvas.width + canvas.height; offset += spacing) {
    ctx.beginPath();
    ctx.moveTo(offset, 0);
    ctx.lineTo(offset - canvas.height, canvas.height);
    ctx.stroke();

    ctx.beginPath();
    ctx.moveTo(offset, 0);
    ctx.lineTo(offset + canvas.height, canvas.height);
    ctx.stroke();
  }
  ctx.globalAlpha = 1;

  ctx.strokeStyle = adjustHexColor(highlight, 0.18);
  ctx.lineWidth = lineWidth * 0.55;
  ctx.globalAlpha = 0.55;
  for (let offset = -canvas.height; offset <= canvas.width + canvas.height; offset += spacing) {
    ctx.beginPath();
    ctx.moveTo(offset + halfSpacing, 0);
    ctx.lineTo(offset + halfSpacing - canvas.height, canvas.height);
    ctx.stroke();

    ctx.beginPath();
    ctx.moveTo(offset + halfSpacing, 0);
    ctx.lineTo(offset + halfSpacing + canvas.height, canvas.height);
    ctx.stroke();
  }
  ctx.globalAlpha = 1;

  ctx.fillStyle = "rgba(0, 0, 0, 0.28)";
  const tuftRadius = Math.max(1.8, spacing * 0.08);
  for (let y = -spacing; y <= canvas.height + spacing; y += spacing) {
    for (let x = -spacing; x <= canvas.width + spacing; x += spacing) {
      ctx.beginPath();
      ctx.ellipse(x + halfSpacing, y + halfSpacing, tuftRadius, tuftRadius * 0.85, 0, 0, Math.PI * 2);
      ctx.fill();
    }
  }

  ctx.save();
  ctx.globalCompositeOperation = "overlay";
  const sheenGradient = ctx.createRadialGradient(
    canvas.width * 0.28,
    canvas.height * 0.32,
    canvas.width * 0.05,
    canvas.width * 0.28,
    canvas.height * 0.32,
    canvas.width * 0.75
  );
  sheenGradient.addColorStop(0, "rgba(255, 255, 255, 0.26)");
  sheenGradient.addColorStop(0.5, "rgba(255, 255, 255, 0.08)");
  sheenGradient.addColorStop(1, "rgba(0, 0, 0, 0.35)");
  ctx.fillStyle = sheenGradient;
  ctx.fillRect(0, 0, canvas.width, canvas.height);
  ctx.restore();

  ctx.globalAlpha = 0.08;
  for (let y = 0; y < canvas.height; y += 2) {
    for (let x = 0; x < canvas.width; x += 2) {
      ctx.fillStyle = Math.random() > 0.5 ? highlight : shadow;
      ctx.fillRect(x, y, 1, 1);
    }
  }
  ctx.globalAlpha = 1;

  const texture = new THREE.CanvasTexture(canvas);
  texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
  texture.repeat.set(CHAIR_CLOTH_REPEAT, CHAIR_CLOTH_REPEAT);
  texture.anisotropy = renderer?.capabilities?.getMaxAnisotropy?.() ?? 8;
  texture.colorSpace = THREE.SRGBColorSpace;
  texture.needsUpdate = true;
  return texture;
}

function createChairFabricMaterial(option, renderer) {
  const texture = createChairClothTexture(option, renderer);
  const primary = option?.primary ?? "#0f6a2f";
  const sheenColor = option?.highlight ?? adjustHexColor(primary, 0.2);
  const material = new THREE.MeshPhysicalMaterial({
    color: new THREE.Color(adjustHexColor(primary, 0.04)),
    map: texture,
    roughness: 0.28,
    metalness: 0.08,
    clearcoat: 0.48,
    clearcoatRoughness: 0.28,
    sheen: 0.18
  });
  if ("sheenColor" in material) {
    material.sheenColor.set(sheenColor);
  }
  if ("sheenRoughness" in material) {
    material.sheenRoughness = 0.32;
  }
  if ("specularIntensity" in material) {
    material.specularIntensity = 0.65;
  }
  return material;
}

const CHAIR_DIMENSIONS = Object.freeze({
  seatWidth: 0.72,
  seatDepth: 0.72,
  seatThickness: 0.12,
  backHeight: 0.62,
  backThickness: 0.08,
  armHeight: 0.3,
  armThickness: 0.1,
  armDepth: 0.76,
  columnHeight: 0.38,
  baseThickness: 0.08,
  columnRadiusTop: 0.11,
  columnRadiusBottom: 0.15,
  baseRadius: 0.46,
  footRingRadius: 0.34,
  footRingTube: 0.03
});

function createDominoChair(option, renderer, sharedMaterials = null) {
  const material = sharedMaterials?.fabric ?? createChairFabricMaterial(option, renderer);
  const legMaterial = sharedMaterials?.leg ??
    new THREE.MeshStandardMaterial({
      color: new THREE.Color(option?.legColor ?? "#1f1f1f"),
      metalness: 0.6,
      roughness: 0.35
    });
  const metalAccent = sharedMaterials?.accent ??
    new THREE.MeshStandardMaterial({
      color: new THREE.Color("#2a2a2a"),
      metalness: 0.75,
      roughness: 0.32
    });

  const group = new THREE.Group();
  const dims = CHAIR_DIMENSIONS;

  const base = new THREE.Mesh(new THREE.CylinderGeometry(dims.baseRadius, dims.baseRadius * 1.02, dims.baseThickness, 32), legMaterial);
  base.position.y = dims.baseThickness / 2;
  base.castShadow = true;
  base.receiveShadow = true;
  group.add(base);

  const column = new THREE.Mesh(
    new THREE.CylinderGeometry(dims.columnRadiusBottom, dims.columnRadiusTop, dims.columnHeight, 24),
    legMaterial
  );
  column.position.y = dims.baseThickness + dims.columnHeight / 2;
  column.castShadow = true;
  column.receiveShadow = true;
  group.add(column);

  const footRing = new THREE.Mesh(new THREE.TorusGeometry(dims.footRingRadius, dims.footRingTube, 16, 48), metalAccent);
  footRing.rotation.x = Math.PI / 2;
  footRing.position.y = dims.baseThickness + dims.columnHeight * 0.45;
  footRing.castShadow = true;
  group.add(footRing);

  const seat = new THREE.Mesh(
    new THREE.BoxGeometry(dims.seatWidth, dims.seatThickness, dims.seatDepth),
    material
  );
  seat.position.y = dims.baseThickness + dims.columnHeight + dims.seatThickness / 2;
  seat.castShadow = true;
  seat.receiveShadow = true;
  group.add(seat);

  const cushion = new THREE.Mesh(
    new THREE.BoxGeometry(dims.seatWidth * 0.92, dims.seatThickness * 0.6, dims.seatDepth * 0.92),
    material
  );
  cushion.position.y = seat.position.y + dims.seatThickness * 0.2;
  cushion.castShadow = true;
  cushion.receiveShadow = true;
  group.add(cushion);

  const back = new THREE.Mesh(
    new THREE.BoxGeometry(dims.seatWidth * 0.98, dims.backHeight, dims.backThickness),
    material
  );
  back.position.set(0, seat.position.y + dims.backHeight / 2 - dims.seatThickness / 2, dims.seatDepth / 2 - dims.backThickness / 2);
  back.castShadow = true;
  back.receiveShadow = true;
  group.add(back);

  const armGeo = new THREE.BoxGeometry(dims.armThickness, dims.armHeight, dims.armDepth);
  const armY = seat.position.y + dims.armHeight / 2 - dims.seatThickness * 0.25;
  const armOffsetZ = (dims.armDepth - dims.seatDepth) / 2;
  const armLeft = new THREE.Mesh(armGeo, material);
  armLeft.position.set(-dims.seatWidth / 2 + dims.armThickness / 2, armY, armOffsetZ);
  armLeft.castShadow = true;
  armLeft.receiveShadow = true;
  group.add(armLeft);
  const armRight = new THREE.Mesh(armGeo, material);
  armRight.position.set(dims.seatWidth / 2 - dims.armThickness / 2, armY, armOffsetZ);
  armRight.castShadow = true;
  armRight.receiveShadow = true;
  group.add(armRight);

  const armCapGeo = new THREE.BoxGeometry(dims.armThickness * 0.9, dims.armThickness * 0.35, dims.armDepth * 0.92);
  const armCapY = armY + dims.armHeight / 2 - (dims.armThickness * 0.35) / 2;
  const armCapLeft = new THREE.Mesh(armCapGeo, material);
  armCapLeft.position.set(armLeft.position.x, armCapY, armOffsetZ * 0.94);
  armCapLeft.castShadow = true;
  armCapLeft.receiveShadow = true;
  group.add(armCapLeft);
  const armCapRight = new THREE.Mesh(armCapGeo, material);
  armCapRight.position.set(armRight.position.x, armCapY, armOffsetZ * 0.94);
  armCapRight.castShadow = true;
  armCapRight.receiveShadow = true;
  group.add(armCapRight);

  const columnCap = new THREE.Mesh(new THREE.CylinderGeometry(dims.columnRadiusTop * 1.05, dims.columnRadiusTop * 1.05, 0.02, 24), metalAccent);
  columnCap.position.y = dims.baseThickness + dims.columnHeight + 0.01;
  columnCap.castShadow = true;
  columnCap.receiveShadow = true;
  group.add(columnCap);

  return group;
}

/* ---------- World / Groups ---------- */
const arenaG = new THREE.Group();
scene.add(arenaG);

const tableG = new THREE.Group();
arenaG.add(tableG);
tableG.rotation.y = 0.10; // pak rrotullim për perspektivë
const piecesG = new THREE.Group();
tableG.add(piecesG);

/* ---------- Arena Dressings (Carpet & Walls) ---------- */
const roomWidth = 6.2;
const roomDepth = 6.2;
const wallThickness = 0.45;
const wallHeight = 3.4;
const carpetThickness = 0.12;
const carpetTextures = getPoolCarpetTextures(renderer);
const carpetMat = new THREE.MeshStandardMaterial({
  color: 0x8c2a2e,
  roughness: 0.9,
  metalness: 0.025
});
if (carpetTextures.map) {
  carpetMat.map = carpetTextures.map;
  carpetMat.map.needsUpdate = true;
}
if (carpetTextures.bump) {
  carpetMat.bumpMap = carpetTextures.bump;
  carpetMat.bumpScale = 0.18;
  carpetMat.bumpMap.needsUpdate = true;
}
const carpet = new THREE.Mesh(
  new THREE.BoxGeometry(roomWidth - wallThickness, carpetThickness, roomDepth - wallThickness),
  carpetMat
);
carpet.position.y = -carpetThickness / 2;
carpet.receiveShadow = true;
arenaG.add(carpet);

const wallMat = new THREE.MeshStandardMaterial({
  color: 0xb9ddff,
  roughness: 0.88,
  metalness: 0.06
});

const makeWall = (width, height, depth) => {
  const wall = new THREE.Mesh(new THREE.BoxGeometry(width, height, depth), wallMat);
  wall.position.y = height / 2;
  wall.receiveShadow = true;
  wall.castShadow = false;
  arenaG.add(wall);
  return wall;
};

const backWall = makeWall(roomWidth, wallHeight, wallThickness);
backWall.position.z = roomDepth / 2 - wallThickness / 2;

const frontWall = makeWall(roomWidth, wallHeight, wallThickness);
frontWall.position.z = -roomDepth / 2 + wallThickness / 2;

const leftWall = makeWall(wallThickness, wallHeight, roomDepth);
leftWall.position.x = -roomWidth / 2 + wallThickness / 2;

const rightWall = makeWall(wallThickness, wallHeight, roomDepth);
rightWall.position.x = roomWidth / 2 - wallThickness / 2;

/* ---------- Shapes ---------- */
function roundedRectShape(hw=0.95, hh=0.95, r=0.06){
  const w=hw*2, h=hh*2; const s=new THREE.Shape();
  s.moveTo(-hw+r,-hh);
  s.lineTo(hw-r,-hh); s.quadraticCurveTo(hw,-hh,hw,-hh+r);
  s.lineTo(hw,hh-r); s.quadraticCurveTo(hw,hh,hw-r,hh);
  s.lineTo(-hw+r,hh); s.quadraticCurveTo(-hw,hh,-hw,hh-r);
  s.lineTo(-hw,-hh+r); s.quadraticCurveTo(-hw,-hh,-hw+r,-hh);
  return s;
}
function roundedRectAbs(w, h, r){ return roundedRectShape(w*0.5, h*0.5, r); }
function makeClothTexture(hex="#155c2a"){ const c=document.createElement("canvas"),S=512; c.width=c.height=S; const g=c.getContext("2d"); g.fillStyle=hex; g.fillRect(0,0,S,S); g.globalAlpha=.08; g.fillStyle="#fff"; for(let i=0;i<S;i+=6){ g.fillRect(i,0,1,S); g.fillRect(0,i,S,1);} const t=new THREE.CanvasTexture(c); t.wrapS=t.wrapT=THREE.RepeatWrapping; t.repeat.set(5,5); t.anisotropy=renderer.capabilities.getMaxAnisotropy(); return t; }
function makeSpeckle(size=256, density=0.08){ const c=document.createElement('canvas'); c.width=c.height=size; const g=c.getContext('2d'); g.fillStyle='#808080'; g.fillRect(0,0,size,size); g.globalAlpha=0.25; g.fillStyle='#9a9a9a'; const dots = Math.floor(size*size*density*0.002); for(let i=0;i<dots;i++){ const x=Math.random()*size, y=Math.random()*size, r=0.5+Math.random()*1.2; g.beginPath(); g.arc(x,y,r,0,Math.PI*2); g.fill(); } const tex=new THREE.CanvasTexture(c); tex.wrapS=tex.wrapT=THREE.RepeatWrapping; tex.repeat.set(4,4); tex.anisotropy=renderer.capabilities.getMaxAnisotropy(); return tex; }

/* ---------- Materials ---------- */
const porcelainMat = new THREE.MeshPhysicalMaterial({
  color: 0xf8f8fb,
  roughness: 0.12,
  metalness: 0.2,
  clearcoat: 1.0,
  clearcoatRoughness: 0.05,
  reflectivity: 0.6,
});
const pipMat = new THREE.MeshPhysicalMaterial({
  color: 0x0a0a0a,
  roughness: 0.05,
  metalness: 0.6,
  clearcoat: 0.9,
  clearcoatRoughness: 0.04,
});
const goldMat = new THREE.MeshPhysicalMaterial({
  color: 0xFFD700,                 // brighter gold
  emissive: 0x3a2a00,              // warm self-light so it never looks black
  emissiveIntensity: 0.55,
  metalness: 1.0,
  roughness: 0.18,
  reflectivity: 1.0,
  envMapIntensity: 1.4,
  transmission: 0.0,
  side: THREE.DoubleSide,
  polygonOffset: true,
  polygonOffsetFactor: -1,
  polygonOffsetUnits: -1,
});
const wood = new THREE.MeshStandardMaterial({ color:"#5a3a19", roughness:.55, metalness:.08 });
const woodDark = new THREE.MeshStandardMaterial({ color:"#4a3115", roughness:.7, metalness:.05 });
const felt = new THREE.MeshStandardMaterial({ color:"#155c2a", map:makeClothTexture("#155c2a"), roughness:1, metalness:0 });
const baseGreen = new THREE.MeshStandardMaterial({ color:"#0f3e2d", roughness:.85, metalness:.05});
const markerMat = new THREE.MeshStandardMaterial({ color:"#15d16f", roughness:.7, metalness:0, transparent:true, opacity:.55 });

/* ---------- Dimensions (Square Table) ---------- */
const Y=0.64;
const OUT_HW = 0.95;              // gjysmë-gjerësi e bordit të jashtëm
const RIM_THICK = 0.07;           // trashësia e rim-it
const IN_HW  = 0.76;              // brenda rim-it (buzë e brendshme)
const CLOTH_HW = 0.70;            // fushë jeshile (gjysmë-gjerësi)
const RIM_H = 0.07;
const CLOTH_TOP = Y + 0.022;

// Kufijtë e zinxhirit mbi rrobë
const XMAX = CLOTH_HW - 0.06;
const ZMAX = CLOTH_HW - 0.06;

// Domino scale — pak më e vogël se më parë
const SCALE=0.68;
const TILE_UP_H = 0.20 * SCALE;
const TILE_UP_HALF = TILE_UP_H * 0.5;
const RAIL_TOP = Y + 0.02 + RIM_H;
const HAND_Y = RAIL_TOP + TILE_UP_HALF + 0.0011;

/* ---------- Table (Square Poker Style) ---------- */
{
  // baza druri (pak bevel)
  const g = new THREE.ExtrudeGeometry(roundedRectShape(OUT_HW, OUT_HW, 0.06), {depth:.02, bevelEnabled:true, bevelThickness:.012, bevelSize:.012});
  g.rotateX(-Math.PI/2);
  const m = new THREE.Mesh(g, wood); m.position.y=Y; m.castShadow=true; tableG.add(m);
}
{
  // fusha jeshile (rrobë)
  const g = new THREE.ExtrudeGeometry(roundedRectShape(CLOTH_HW, CLOTH_HW, 0.04), {depth:.012, bevelEnabled:false});
  g.rotateX(-Math.PI/2);
  const m = new THREE.Mesh(g, felt); m.position.y=Y+.022; m.receiveShadow=true; tableG.add(m);
}
{
  // rim katror me hapje brenda
  const outer = roundedRectShape(OUT_HW, OUT_HW, 0.06);
  const inner = roundedRectShape(IN_HW, IN_HW, 0.05); outer.holes.push(inner);
  const g = new THREE.ExtrudeGeometry(outer, {depth:RIM_H, bevelEnabled:true, bevelThickness:.02, bevelSize:.02});
  g.rotateX(-Math.PI/2);
  const rim = new THREE.Mesh(g, woodDark); rim.position.y=Y+.02; rim.castShadow=true; tableG.add(rim);
}
{
  // skirti poshtë si bazament
  const skirtH=.60; const skirt = new THREE.Mesh(new THREE.BoxGeometry((OUT_HW+0.05)*2, skirtH, (OUT_HW+0.05)*2), baseGreen);
  skirt.position.y=Y - skirtH/2 + 0.01; skirt.castShadow=true; skirt.receiveShadow=true; tableG.add(skirt);
}

/* ---------- Seating (Texas Hold'em Style Chairs) ---------- */
{
  const chairRadius = OUT_HW + 0.55;
  const chairHeight = CHAIR_DIMENSIONS.baseThickness + CHAIR_DIMENSIONS.columnHeight + CHAIR_DIMENSIONS.seatThickness;
  const sharedMaterials = {
    fabric: createChairFabricMaterial(DEFAULT_CHAIR_OPTION, renderer),
    leg: new THREE.MeshStandardMaterial({
      color: new THREE.Color(DEFAULT_CHAIR_OPTION.legColor ?? "#1f1f1f"),
      metalness: 0.6,
      roughness: 0.35
    }),
    accent: new THREE.MeshStandardMaterial({
      color: new THREE.Color("#2a2a2a"),
      metalness: 0.75,
      roughness: 0.32
    })
  };
  const chairPositions = [
    new THREE.Vector3(0, 0, chairRadius),
    new THREE.Vector3(chairRadius, 0, 0),
    new THREE.Vector3(0, 0, -chairRadius),
    new THREE.Vector3(-chairRadius, 0, 0)
  ];
  tableG.updateWorldMatrix(true, false);
  const lookTargetWorld = new THREE.Vector3(0, chairHeight, 0);
  tableG.localToWorld(lookTargetWorld);
  chairPositions.forEach((pos) => {
    const chair = createDominoChair(DEFAULT_CHAIR_OPTION, renderer, sharedMaterials);
    chair.position.copy(pos);
    tableG.add(chair);
    chair.lookAt(lookTargetWorld);
    chair.rotateY(Math.PI);
  });
}

/* ---------- Tile Helpers (ensure defined before use) ---------- */
function isValidTile(t){
  if(!t || typeof t.a!=="number" || typeof t.b!=="number") return false;
  if(t.a<0||t.b<0||t.a>6||t.b>6) return false; return true;
}
function canonTile(t){
  if(!isValidTile(t)) return null; let {a,b}=t; if(a>b){ const k=a; a=b; b=k; } return {a,b};
}

/* ---------- Domino EXACT per kërkesën tënde ---------- */
function pipPositions(){
  return [
    [-0.3, 0.6], [0, 0.6], [0.3, 0.6],
    [-0.3, 0.3], [0, 0.3], [0.3, 0.3],
    [-0.3, 0.0], [0, 0.0], [0.3, 0.0],
  ];
}
const INDEX_SETS = { 0: [], 1: [4], 2: [0,8], 3: [0,4,8], 4: [0,2,6,8], 5: [0,2,4,6,8], 6: [0,2,3,5,6,8] };

function addGoldPerimeter(domino){
  const inset = 0.04;
  const w = 1 - inset*2;
  const h = 2 - inset*2;
  const shape = new THREE.Shape();
  shape.moveTo(-w/2, -h/2);
  shape.lineTo( w/2, -h/2);
  shape.lineTo( w/2,  h/2);
  shape.lineTo(-w/2,  h/2);
  shape.lineTo(-w/2, -h/2);
  const hole = new THREE.Path();
  const t = 0.015;
  hole.moveTo(-w/2 + t, -h/2 + t);
  hole.lineTo( w/2 - t, -h/2 + t);
  hole.lineTo( w/2 - t,  h/2 - t);
  hole.lineTo(-w/2 + t,  h/2 - t);
  hole.lineTo(-w/2 + t, -h/2 + t);
  shape.holes.push(hole);
  const extrude = new THREE.ExtrudeGeometry(shape, { depth: 0.01, bevelEnabled: false });
  const frame = new THREE.Mesh(extrude, goldMat.clone());
  frame.position.z = 0.11;
  frame.renderOrder = 5; // sit on top
  domino.add(frame);
}

function addPips(dominoFace, count, yOffset){
  const positions = pipPositions();
  const idxs = INDEX_SETS[Math.max(0, Math.min(6, count))];
  const pipGeo = new THREE.SphereGeometry(0.085, 24, 24);
  idxs.forEach(i => {
    const [px, py] = positions[i];
    const sphere = new THREE.Mesh(pipGeo, pipMat);
    sphere.position.set(px, py + yOffset, 0.11);
    dominoFace.add(sphere);

    // Unazë ari rreth pikes (gold)
    const innerR = 0.107;
    const outerR = 0.120;
    const ringGeo = new THREE.RingGeometry(innerR, outerR, 64);
    const ring = new THREE.Mesh(ringGeo, goldMat.clone());
    ring.position.set(px, py + yOffset, 0.11);
    ring.renderOrder = 6; // above porcelain & pip
    dominoFace.add(ring);
  });
}

function makeDomino(a,b,{flat=true, faceUp=true}={}){
  const ct = canonTile({a,b}); if(!ct){ return new THREE.Group(); }
  a=ct.a; b=ct.b;

  const group = new THREE.Group();

  // Trupi SAKTËSISHT si në kodin tënd
  const bodyGeo = new RoundedBoxGeometry(1, 2, 0.22, 4, 0.06);
  const body = new THREE.Mesh(bodyGeo, porcelainMat.clone());
  body.castShadow = true; body.receiveShadow = true;

  // Vijë mesi — GOLD
  const midW = 1 - 0.08;         // sipas kodit
  const midH = 0.03;
  const midR = 0.06;
  const midShape = roundedRectAbs(midW, midH, Math.min(midR, midH/2));
  const midGeo = new THREE.ExtrudeGeometry(midShape, { depth: 0.01, bevelEnabled: false });
  const midLine = new THREE.Mesh(midGeo, goldMat.clone());
  midLine.position.z = 0.11;
  midLine.renderOrder = 5;
  body.add(midLine);

  // Kornizë ari rrethuese — GOLD
  addGoldPerimeter(body);

  // Pikat sipas kodit — faqe sipër & poshtë (në koordinata të trupit)
  if(faceUp){
    addPips(body, a, -0.8);
    addPips(body, b,  0.2);
  }

  group.add(body);

  // Integrim me sistemin ekzistues: në fushë duhen "flat" (faqe lart)
  if(flat){ group.rotation.x = -Math.PI/2; }

  // Ruaj shkallën ekzistuese të botës (ashtu si para ndryshimit)
  const sx = 0.10 / 1.0, sy = (flat? 0.016/0.22 : 0.20/2.0), sz = (flat? 0.20/2.0 : 0.016/0.22);
  group.scale.set(SCALE*sx, SCALE*sy, SCALE*sz);

  group.userData.val = [a,b];
  return group;
}

/* ---------- Game State ---------- */
const statusEl = document.getElementById('status');
const btnDraw = document.getElementById('draw');
const btnPass = document.getElementById('pass');
const btnRules = document.getElementById('btnRules');
const panelRules = document.getElementById('rules');
const closeRules = document.getElementById('closeRules');

let statusPrefix = '';
let N = 4; let players = []; let boneyard = []; let chain = [];
let ends = null; // {L:{v,x,z,dir:[dx,dz]}, R:{...}}
let current = 0; let human = 0;
let markers = {L:null, R:null}; let selectedTile = null;
let flipDir = false; // alterno drejtimin e zinxhirit pas çdo loje
const usedTileKeys = new Set();

function tileKey(tile){
  const ct = canonTile(tile);
  return ct ? `${ct.a}|${ct.b}` : '';
}

function setStatus(t){ statusEl.textContent = statusPrefix ? `${statusPrefix} • ${t}` : t; }

function genSet(){ const set=[]; for(let a=0;a<=6;a++){ for(let b=a;b<=6;b++){ set.push({a,b}); } } return set; }
function shuffle(arr){ for(let i=arr.length-1;i>0;i--){ const j=(Math.random()*(i+1))|0; [arr[i],arr[j]]=[arr[j],arr[i]]; } return arr; }

const urlParams = new URLSearchParams(window.location.search);
const requestedPlayers = Number.parseInt(urlParams.get('players') || urlParams.get('playerCount') || '', 10);
if (requestedPlayers >= 2 && requestedPlayers <= 4) {
  N = requestedPlayers;
}
const stakeAmount = Number.parseInt(urlParams.get('amount') || '', 10);
const stakeToken = urlParams.get('token') || 'TPC';
if (Number.isFinite(stakeAmount) && stakeAmount > 0) {
  statusPrefix = `Stake ${stakeAmount.toLocaleString('en-US')} ${stakeToken.toUpperCase()}`;
  setStatus('Ready');
}

function layoutSeat(idx){
  const EDGE = IN_HW;  const MARGIN = 0.04;
  const south = [ 0.00,  (EDGE - MARGIN), 0        ];
  const east  = [ (EDGE - MARGIN), 0.00,  Math.PI/2];
  const north = [ 0.00, -(EDGE - MARGIN), Math.PI  ];
  const west  = [-(EDGE - MARGIN), 0.00, -Math.PI/2];
  const seats = [south, east, north, west];
  return seats[idx % seats.length];
}

function renderHands(){
  players.forEach(p=>p.hand.forEach(h=>{ if(h.mesh){ piecesG.remove(h.mesh); h.mesh=null; } }));

  const EDGE_SPAN = CLOTH_HW - 0.08; const clamp = (v,min,max)=>Math.max(min,Math.min(max,v));
  const GAP = .092; const HOLE = 0; // equal gap for all, no special case

  players.forEach((p,pi)=>{
    const [x0,z0] = layoutSeat(pi);
    const faceUp = (pi===human);
    const start = -((p.hand.length-1)*(GAP))/2; // symmetric layout, same gap
    const isSide = (pi===1 || pi===3);

    p.hand.forEach((h,hi)=>{
      const m = makeDomino(h.a,h.b,{flat:false, faceUp});
      let offset = start + GAP*hi;
      if(isSide){ const zLine = clamp(z0 + offset, -EDGE_SPAN, EDGE_SPAN); m.position.set(x0, HAND_Y, zLine); }
      else      { const xLine = clamp(x0 + offset, -EDGE_SPAN, EDGE_SPAN); m.position.set(xLine, HAND_Y, z0); }
      const yawTowardCenter = Math.atan2(-x0, -z0);
      m.rotation.set(0, (pi===human ? 0 : yawTowardCenter), 0);
      m.rotation.z += (Math.random()*0.02-0.01);
      h.mesh = m; m.userData = {tile:h, owner:pi}; piecesG.add(m);
    });
  });
}

/* ---------- Chain Rendering ---------- */
function renderChain(){
  chain.forEach(c=>{
    if(c.mesh){
      piecesG.remove(c.mesh);
      c.mesh = null;
    }
  });
  chain.forEach(c=>{
    const domino = makeDomino(c.tile.a, c.tile.b, { flat: true, faceUp: true });
    const yPos = CLOTH_TOP + 0.008;
    domino.position.set(c.x, yPos, c.z);
    domino.rotation.y = c.rot || 0;
    c.mesh = domino;
    piecesG.add(domino);
  });
}

/* ---------- Start / Turn Order ---------- */
function highestDoubleIndex(hand){ let best=-1, idx=-1; hand.forEach((t,i)=>{ if(t.a===t.b && t.a>best){best=t.a; idx=i;} }); return idx; }
function pipSum(hand){ return hand.reduce((s,t)=>s+t.a+t.b,0); }

function startGame(){
  chain=[]; ends=null; selectedTile=null; clearMarkers();
  usedTileKeys.clear();
  flipDir = !flipDir;
  const numericN = Number.isFinite(N) ? Math.round(N) : 4;
  N = Math.max(2, Math.min(4, numericN));
  players=Array.from({length:N},(_,i)=>({id:i,hand:[]}));
  boneyard=shuffle(genSet());
  for(let r=0;r<7;r++) players.forEach(p=>p.hand.push(boneyard.pop()));
  players.forEach(p=> shuffle(p.hand)); // random order every game
  renderHands();
  let starter=0, idx=-1, bestD=-1;
  players.forEach((p,pi)=>{ const i=highestDoubleIndex(p.hand); if(i>=0 && p.hand[i].a>bestD){ bestD=p.hand[i].a; starter=pi; idx=i; } });
  if(idx<0){ idx=0; }
  const t=players[starter].hand.splice(idx,1)[0];
  const firstTile=canonTile(t) || t;
  const firstRot = (firstTile.a===firstTile.b) ? Math.PI/2 : 0;
  chain.push({tile:firstTile,x:0,z:0,rot:firstRot,double:firstTile.a===firstTile.b});
  usedTileKeys.add(tileKey(firstTile));
  const step=.10;
  if(!flipDir){
    ends={
      L:{v:firstTile.a,x:-step,z:0,dir:[-1,0],orient:Math.PI},
      R:{v:firstTile.b,x: step,z:0,dir:[ 1,0],orient:0}
    };
  }
  else{
    ends={
      L:{v:firstTile.a,x: step,z:0,dir:[ 1,0],orient:0},
      R:{v:firstTile.b,x:-step,z:0,dir:[-1,0],orient:Math.PI}
    };
  }
  renderChain(); current=(starter+1)%N; setStatus(`Turn: Player ${current+1}`); updateInteractivity();
}

/* ---------- Placement & Snake ---------- */
const STEP=.10;
function canPlayAny(hand){ if(!ends) return true; return hand.some(t=> t.a===ends.L.v||t.b===ends.L.v||t.a===ends.R.v||t.b===ends.R.v ); }
function validSidesFor(tile){ if(!ends) return {L:false,R:false}; return {L:(tile.a===ends.L.v||tile.b===ends.L.v), R:(tile.a===ends.R.v||tile.b===ends.R.v)}; }

function placeOnBoard(tile, side){
  if(!chain.length) return false; if(!isValidTile(tile)) return false;
  const end=(side<0?ends.L:ends.R); const want=end.v;
  let a=tile.a,b=tile.b; if(a!==want && b===want){ [a,b]=[b,a]; }
  if(a!==want){ return false; }
  let [dx,dz]=end.dir;
  let nx=end.x+dx*STEP, nz=end.z+dz*STEP;
  // table bounds (square)
  if(Math.abs(nx)>XMAX || Math.abs(nz)>ZMAX){ const ndx=-dz, ndz=dx; dx=ndx; dz=ndz; nx=end.x+dx*STEP; nz=end.z+dz*STEP; }
  const isDouble=(a===b);
  const isHorizontal=Math.abs(dx)>=Math.abs(dz);
  let rot;
  if(isDouble){
    rot = isHorizontal ? Math.PI/2 : 0;
  } else if(isHorizontal){
    rot = (dx>=0) ? 0 : Math.PI;
  } else {
    rot = (dz>=0) ? Math.PI/2 : -Math.PI/2;
  }
  const placedTile=canonTile({a,b}) || {a,b};
  const key = tileKey(placedTile);
  if(usedTileKeys.has(key)){
    return false;
  }
  chain.push({tile:placedTile,x:nx,z:nz,rot,double:isDouble});
  usedTileKeys.add(key);
  const newVal=(side<0? b : a);
  let nextOrient;
  if(isHorizontal){
    nextOrient = (dx>=0) ? 0 : Math.PI;
  } else {
    nextOrient = (dz>=0) ? Math.PI/2 : -Math.PI/2;
  }
  const updatedEnd={v:newVal,x:nx,z:nz,dir:[dx,dz],orient:nextOrient};
  if(side<0) ends.L=updatedEnd; else ends.R=updatedEnd;
  renderChain(); SFX.place.currentTime=0; SFX.place.play();
  return true;
}
function nextCandidate(end){
  let {x,z,dir:[dx,dz]}=end; let ang=Math.atan2(dz,dx);
  let nx=x+dx*STEP, nz=z+dz*STEP;
  if(Math.abs(nx)>XMAX || Math.abs(nz)>ZMAX){ const ndx=-dz, ndz=dx; dx=ndx; dz=ndz; ang=Math.atan2(dz,dx); nx=x+dx*STEP; nz=z+dz*STEP; }
  return {nx,nz,rot:ang,dx,dz};
}

/* ---------- Markers for manual placement ---------- */
function clearMarkers(){ if(markers.L){piecesG.remove(markers.L);markers.L=null;} if(markers.R){piecesG.remove(markers.R);markers.R=null;} }
function makeMarker(){ const g=new THREE.TorusGeometry(.045, .005, 12, 32); const m=new THREE.Mesh(g, markerMat.clone()); m.rotation.x=-Math.PI/2; m.position.y=Y+.031; m.renderOrder=10; return m; }
function showMarkersFor(tile){
  clearMarkers(); if(!ends) return;
  const canL = (tile.a===ends.L.v||tile.b===ends.L.v), canR=(tile.a===ends.R.v||tile.b===ends.R.v);
  if(canL){ const c=nextCandidate(ends.L); const mk=makeMarker(); mk.position.x=c.nx; mk.position.z=c.nz; mk.userData={marker:true, side:-1}; piecesG.add(mk); markers.L=mk; }
  if(canR){ const c=nextCandidate(ends.R); const mk=makeMarker(); mk.position.x=c.nx; mk.position.z=c.nz; mk.userData={marker:true, side:1}; piecesG.add(mk); markers.R=mk; }
}

/* ---------- Interactivity ---------- */
const raycaster=new THREE.Raycaster(); const pointer=new THREE.Vector2();
function findPickRoot(o){
  let n=o; while(n){ if(n.userData && (n.userData.owner!==undefined || n.userData.marker)) return n; n=n.parent; } return o;
}
function humanPickTile(obj){ const tile = obj.userData.tile; selectedTile = tile; showMarkersFor(tile); setStatus('Pick a side (tap marker)'); }

renderer.domElement.addEventListener('pointerdown',ev=>{
  // FIX: përdor madhësinë e saktë të canvas-it (rect) për koordinatat NDC
  const rect = renderer.domElement.getBoundingClientRect();
  const x = ((ev.clientX - rect.left)/rect.width)*2 - 1;
  const y = -(((ev.clientY - rect.top)/rect.height)*2 - 1);
  pointer.set(x,y); raycaster.setFromCamera(pointer,camera);
  const hits=raycaster.intersectObjects(piecesG.children,true); if(!hits.length) return; const hit=hits[0];
  const obj=findPickRoot(hit.object);
  const isHumanTurn=(current===human);
  if(!isHumanTurn) return;
  if(obj.userData && obj.userData.owner===human){ humanPickTile(obj); return; }
  if(obj.userData && obj.userData.marker && selectedTile){
    const side=obj.userData.side; const idx=players[human].hand.indexOf(selectedTile); if(idx>=0) players[human].hand.splice(idx,1);
    if(!placeOnBoard(selectedTile, side)){ players[human].hand.splice(idx,0,selectedTile); }
    selectedTile=null; clearMarkers(); renderHands(); nextTurn(); return;
  }
});

btnDraw.addEventListener('click',()=>{ if(current!==human) return;
  while(boneyard.length){ const t=boneyard.pop(); if(!isValidTile(t)) continue; players[human].hand.push(t); const canL=(t.a===ends?.L?.v||t.b===ends?.L?.v); const canR=(t.a===ends?.R?.v||t.b===ends?.R?.v); if(canL||canR) break; }
  clearMarkers(); selectedTile=null; renderHands(); SFX.draw.currentTime=0; SFX.draw.play();
});
btnPass.addEventListener('click',()=>{ if(current===human){ clearMarkers(); selectedTile=null; nextTurn(); }});

startGame();

function blockedAndWinner(){
  if(!ends) return null;
  const nobodyCan = players.every(p=> !canPlayAny(p.hand));
  if(nobodyCan && boneyard.length===0){
    let best=Infinity, win=-1; players.forEach((p,pi)=>{ const s=pipSum(p.hand); if(s<best){best=s;win=pi;} });
    return {blocked:true, winner:win, reason:`Blocked. Lowest hand = Player ${win+1} (${best})`};
  }
  return null;
}

function updateInteractivity(){
  const blk = blockedAndWinner(); if(blk){ setStatus(blk.reason); return; }
  setStatus(`Turn: Player ${current+1}`);
  renderHands(); renderChain();
}
function nextTurn(){
  if(players[human].hand.length===0){ setStatus('You won!'); return; }
  current=(current+1)%N; const blk = blockedAndWinner(); if(blk){ setStatus(blk.reason); return; }
  updateInteractivity(); if(current!==human) setTimeout(cpuPlay,450);
}
function cpuPlay(){
  const p=players[current]; let playable=-1, side=1;
  if(ends){
    for(let i=0;i<p.hand.length;i++){ const t=p.hand[i]; if(!isValidTile(t)) continue; if(t.a===ends.L.v||t.b===ends.L.v){ playable=i; side=-1; break;} if(t.a===ends.R.v||t.b===ends.R.v){ playable=i; side=1; break;} }
  } else { playable=0; }
  if(playable<0){ if(boneyard.length){ const d=boneyard.pop(); if(isValidTile(d)) p.hand.push(d); renderHands(); SFX.draw.currentTime=0; SFX.draw.play(); setTimeout(cpuPlay,350); return;} nextTurn(); return; }
  const tile=p.hand.splice(playable,1)[0]; placeOnBoard(tile, side); renderHands(); if(p.hand.length===0){ setStatus(`Player ${current+1} won!`); return;} nextTurn();
}

/* ---------- Rules panel handlers ---------- */
btnRules.addEventListener('click',()=>{ panelRules.style.display='flex'; });
closeRules.addEventListener('click',()=>{ panelRules.style.display='none'; });
panelRules.addEventListener('click',(e)=>{ if(e.target===panelRules) panelRules.style.display='none'; });

/* ---------- Mini tests (console) ---------- */
console.assert(document.getElementById('draw') && document.getElementById('pass'), 'UI buttons exist');
(()=>{ const s=genSet(); const key=t=>`${t.a},${t.b}`; const uniq=new Set(s.map(key));
  console.assert(s.length===28 && uniq.size===28,'double-six: 28 unique');
  console.assert(s.some(t=>t.a===0&&t.b===0) && s.some(t=>t.a===6&&t.b===6),'set contains 00 and 66');
  console.assert(s.every(t=>t.a>=0 && t.b>=0 && t.a<=6 && t.b<=6 && t.a<=t.b),'values in range and sorted');
})();
(()=>{ const ct1=canonTile({a:6,b:2}); const ct2=canonTile({a:2,b:6});
  console.assert(ct1.a===2 && ct1.b===6 && ct2.a===2 && ct2.b===6,'canonTile symmetric and idempotent');
})();
(()=>{ const bad1=canonTile({a:-1,b:3}); const bad2=canonTile({a:9,b:1});
  console.assert(bad1===null && bad2===null,'canonTile rejects out-of-range values');
})();
(()=>{ const m=makeDomino(6,6,{flat:true,faceUp:true}); const anyRing=m.children.some(ch=>ch.geometry?.type==='RingGeometry'); console.assert(anyRing,'perimeter/pip rings exist (flat)'); })();
(()=>{ const m=makeDomino(3,4,{flat:false,faceUp:true}); const pipCount=m.children.reduce((n,ch)=>n+(ch.geometry?.type==='SphereGeometry'?1:0),0); console.assert(pipCount>0,'pips exist'); })();

/* ---------- Loop & Resize ---------- */
function tick(){ controls.update(); renderer.render(scene,camera); requestAnimationFrame(tick);} tick();
function onResize(){ fitCamera(); }
addEventListener('resize', onResize); if(window.visualViewport){ visualViewport.addEventListener('resize', onResize); }

camera.position.set(2.0, 1.7, 2.05);
</script>
</body>
</html>
