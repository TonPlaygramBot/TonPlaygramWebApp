<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no"/>
<title>Domino Royal 3D</title>
<style>
  html,body{margin:0;height:100%;background:#ece6dc;overflow:hidden;font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial}
  #app{position:fixed;inset:0; width:100dvw; height:100dvh;}
  canvas{display:block; width:100dvw !important; height:100dvh !important; touch-action:none}
  button{font-weight:700;border:0;border-radius:999px;padding:.45rem .7rem;background:#ffd24a;color:#333;box-shadow:0 4px 12px rgba(0,0,0,.25);}
  button:active{transform:translateY(1px);}
  #status{position:fixed;top:calc(0.65rem + env(safe-area-inset-top, 0px));left:50%;transform:translateX(-50%);padding:.35rem .75rem;border-radius:999px;background:rgba(0,0,0,.55);color:#fff;font-weight:700;z-index:2;backdrop-filter:blur(6px);}
  #railControls{position:fixed;left:50%;bottom:calc(env(safe-area-inset-bottom,0px) + clamp(2.4rem, 14vh, 6.4rem));transform:translateX(-50%);display:flex;flex-direction:row;flex-wrap:wrap;justify-content:center;gap:.5rem;align-items:center;background:transparent;color:#fff;padding:0;box-shadow:none;z-index:2;pointer-events:auto;}
  #railControls button{background:rgba(12,16,28,.72);color:#ffe8a3;font-size:.95rem;padding:.55rem .9rem;border-radius:999px;border:1px solid rgba(255,255,255,.14);box-shadow:0 8px 18px rgba(0,0,0,.35);backdrop-filter:blur(8px);}
  #draw{font-size:1rem;padding:.6rem 1rem;background:linear-gradient(135deg, rgba(255,210,74,.95), rgba(255,196,45,.85));color:#3b250f;border:0;}
  #pass{background:rgba(255,210,74,.12);color:#ffe8a3;border:1px solid rgba(255,210,74,.35);}
  #viewToggle{position:fixed;top:calc(0.75rem + env(safe-area-inset-top,0px));right:calc(3.6rem + env(safe-area-inset-right,0px));height:2.75rem;padding:0 1rem;border-radius:999px;background:rgba(0,0,0,.7);color:#ffe8a3;border:1px solid rgba(255,255,255,.14);display:grid;place-items:center;font-weight:800;letter-spacing:.02em;box-shadow:0 6px 18px rgba(0,0,0,.35);z-index:3;backdrop-filter:blur(7px);}
  #viewToggle[aria-pressed="true"]{background:rgba(255,210,74,.16);border-color:rgba(255,210,74,.5);color:#fef08a;box-shadow:0 0 0 1px rgba(255,210,74,.24),0 10px 18px rgba(0,0,0,.28);}
  #viewToggle:active{transform:translateY(1px);}
  #btnRules{position:fixed;top:calc(0.75rem + env(safe-area-inset-top,0px));right:calc(0.75rem + env(safe-area-inset-right,0px));width:2.75rem;height:2.75rem;border-radius:999px;background:rgba(0,0,0,.58);color:#fff;display:grid;place-items:center;font-size:1.3rem;box-shadow:0 6px 18px rgba(0,0,0,.35);z-index:3;backdrop-filter:blur(6px);padding:0;}
  #btnRules span{pointer-events:none;}
  #configButton{position:fixed;top:calc(0.75rem + env(safe-area-inset-top,0px));left:calc(0.75rem + env(safe-area-inset-left,0px));width:3rem;height:3rem;border-radius:999px;background:rgba(0,0,0,.7);color:#fff;border:1px solid rgba(255,255,255,.18);display:grid;place-items:center;box-shadow:0 6px 18px rgba(0,0,0,.35);z-index:3;backdrop-filter:blur(8px);padding:0;transition:background .2s ease, border-color .2s ease;}
  #configButton:hover{background:rgba(0,0,0,.6);border-color:rgba(148,197,255,.45);}
  #configButton svg{width:1.4rem;height:1.4rem;}
  #configPanel{position:fixed;top:calc(4.4rem + env(safe-area-inset-top,0px));left:calc(0.75rem + env(safe-area-inset-left,0px));max-width:min(320px, 84vw);max-height:min(72dvh, 480px);background:rgba(3,7,18,.92);color:#fff;border-radius:1.25rem;box-shadow:0 24px 40px rgba(2,6,23,.55);padding:0.85rem 1rem;border:1px solid rgba(148,197,255,.2);z-index:3;backdrop-filter:blur(10px);display:none;flex-direction:column;gap:0.65rem;overflow:hidden;}
  #configPanel.active{display:flex;}
  #configPanel h3{margin:0;font-size:.62rem;text-transform:uppercase;letter-spacing:.28rem;color:rgba(148,197,255,.75);}
  #configSections{display:flex;flex-direction:column;gap:.55rem;overflow-y:auto;padding-right:.3rem;margin-right:-.3rem;scrollbar-gutter:stable both-edges;overscroll-behavior:contain;}
  #configSections::-webkit-scrollbar{width:.35rem;}
  #configSections::-webkit-scrollbar-thumb{background:rgba(148,197,255,.35);border-radius:999px;}
  #configSections::-webkit-scrollbar-track{background:transparent;}
  .config-section{display:flex;flex-direction:column;gap:.3rem;}
  .config-options{display:grid;grid-template-columns:repeat(auto-fit,minmax(128px,1fr));gap:.45rem;}
  .config-option{border-radius:0.85rem;border:1px solid rgba(255,255,255,.12);background:rgba(15,23,42,.55);color:#e2e8f0;padding:.4rem .5rem;display:flex;flex-direction:column;align-items:flex-start;gap:.3rem;font-size:clamp(.62rem,1.75vw,.72rem);line-height:1.35;font-weight:600;transition:border-color .2s ease, box-shadow .2s ease, transform .2s ease;}
  .config-option span{font-size:clamp(.5rem,1.45vw,.58rem);text-transform:uppercase;letter-spacing:.24rem;color:rgba(148,197,255,.68);}
  .config-option.active{border-color:rgba(56,189,248,.7);background:rgba(56,189,248,.15);box-shadow:0 0 0 1px rgba(56,189,248,.35),0 12px 24px rgba(8,145,178,.28);}
  .config-option:disabled{opacity:.45;cursor:not-allowed;}
  .config-option:not(.active):hover{border-color:rgba(255,255,255,.32);transform:translateY(-1px);}
  .config-close{display:flex;justify-content:flex-end;}
  .config-close button{background:rgba(255,255,255,.1);border:1px solid rgba(255,255,255,.12);color:#f1f5f9;border-radius:999px;padding:.35rem;display:grid;place-items:center;transition:background .2s ease, border-color .2s ease;}
  .config-close button:hover{background:rgba(248,250,252,.16);border-color:rgba(248,250,252,.38);}
  @media (max-width:640px){
    #configPanel{left:50%;transform:translateX(-50%);top:calc(4.75rem + env(safe-area-inset-top,0px));}
  }
  #rules{position:fixed;top:0;left:0;right:0;bottom:0;display:none;align-items:center;justify-content:center;background:rgba(0,0,0,.55);z-index:3}
  #rules .card{max-width:720px;background:#fff;color:#222;border-radius:16px;box-shadow:0 12px 40px rgba(0,0,0,.25);padding:16px 18px}
  #rules h2{margin:0 0 6px 0;font-size:18px}
  #rules ol{margin:6px 0 0 18px}
  #rules .row{display:flex;gap:8px;justify-content:flex-end;margin-top:12px}
</style>
</head>
<body>
<div id="app"></div>
<div id="status" role="status">Ready</div>
<button id="configButton" type="button" aria-label="Table setup">
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.8" aria-hidden="true">
    <path stroke-linecap="round" stroke-linejoin="round" d="M12 15.5a3.5 3.5 0 1 0 0-7 3.5 3.5 0 0 0 0 7z" />
    <path
      stroke-linecap="round"
      stroke-linejoin="round"
      d="m19.4 13.5-.44 1.74a1 1 0 0 1-1.07.75l-1.33-.14a7.03 7.03 0 0 1-1.01.59l-.2 1.32a1 1 0 0 1-.98.84h-1.9a1 1 0 0 1-.98-.84l-.2-1.32a7.03 7.03 0 0 1-1.01-.59l-1.33.14a1 1 0 0 1-1.07-.75L4.6 13.5a1 1 0 0 1 .24-.96l1-.98a6.97 6.97 0 0 1 0-1.12l-1-.98a1 1 0 0 1-.24-.96l.44-1.74a1 1 0 0 1 1.07-.75l1.33.14c.32-.23.66-.43 1.01-.6l.2-1.31a1 1 0 0 1 .98-.84h1.9a1 1 0 0 1 .98.84l.2 1.31c.35.17.69.37 1.01.6l1.33-.14a1 1 0 0 1 1.07.75l.44 1.74a1 1 0 0 1-.24.96l-1 .98c.03.37.03.75 0 1.12l1 .98a1 1 0 0 1 .24.96z"
    />
  </svg>
</button>
<div
  id="configPanel"
  role="dialog"
  aria-modal="true"
  aria-labelledby="configTitle"
  tabindex="-1"
  aria-hidden="true"
>
  <div class="config-close">
    <button id="configClose" type="button" aria-label="Close table setup">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.8" aria-hidden="true">
        <path stroke-linecap="round" stroke-linejoin="round" d="m6 6 12 12M18 6 6 18" />
      </svg>
    </button>
  </div>
  <h3 id="configTitle">Table Setup</h3>
  <div id="configSections"></div>
</div>
<button id="viewToggle" type="button" aria-label="Switch to 2D view" title="Switch to 2D view">2D</button>
<button id="btnRules" type="button" aria-label="Rules" title="Rules">
  <span aria-hidden="true">ℹ️</span>
</button>
<div id="railControls" aria-label="Game controls">
  <button id="draw" type="button">Draw</button>
  <button id="pass" type="button">Pass</button>
</div>
<div id="rules">
  <div class="card">
    <h2>Domino Royal — Rules for 2–4 players</h2>
    <ol>
      <li><b>Set:</b> Double-Six (28 tiles, 0–6). Each tile is unique (a,b) with a≤b. No duplicates.</li>
      <li><b>Dealing:</b> 7 tiles per player. The rest form the <i>stock</i> (boneyard).</li>
      <li><b>Opening:</b> The player with the highest double starts. If no double, the highest tile opens.</li>
      <li><b>On the table:</b> Every tile lies flat on the green cloth, touching end-to-end without overlapping. Keep the chain flush as you pivot at the rails so the spacing stays even.</li>
      <li><b>Matching:</b> The touching halves must show the same pip value. Doubles stand upright in place; all other tiles extend the snake in a straight line.</li>
      <li><b>No move?</b> Draw from the face-down stock stack near you (tap the Draw button below it) until you can play. If the stock is empty, pass.</li>
      <li><b>Ending:</b> The winner is the first out. If play is blocked, the lowest pip total wins.</li>
    </ol>
    <div class="row">
      <button id="closeRules">Close</button>
    </div>
  </div>
</div>

<script type="module">
import * as THREE from "https://esm.sh/three@0.160.0";
import { OrbitControls } from "https://esm.sh/three@0.160.0/examples/jsm/controls/OrbitControls.js";
import { RoomEnvironment } from "https://esm.sh/three@0.160.0/examples/jsm/environments/RoomEnvironment.js";
import { RoundedBoxGeometry } from "https://esm.sh/three@0.160.0/examples/jsm/geometries/RoundedBoxGeometry.js";
import { GLTFLoader } from "https://esm.sh/three@0.160.0/examples/jsm/loaders/GLTFLoader.js";
import { DRACOLoader } from "https://esm.sh/three@0.160.0/examples/jsm/loaders/DRACOLoader.js";

/* ---------- Audio (SFX) ---------- */
function createSfx(url) {
  const audio = new Audio(url);
  audio.preload = 'auto';
  audio.crossOrigin = 'anonymous';
  return audio;
}
const SFX = {
  place: createSfx("https://cdn.pixabay.com/download/audio/2022/03/15/audio_7dc2b2.mp3?filename=click-124467.mp3"),
  draw: createSfx("https://cdn.pixabay.com/download/audio/2022/03/15/audio_b2f7c5.mp3?filename=pop-124476.mp3"),
  pass: createSfx("https://cdn.pixabay.com/download/audio/2022/10/11/audio_5b4d94.mp3?filename=airy-whoosh-124467.mp3")
};
SFX.place.volume = 0.7;
SFX.draw.volume = 0.7;
SFX.pass.volume = 0.55;
SFX.pass.playbackRate = 0.92;

function playPassSfx() {
  try {
    SFX.pass.currentTime = 0;
    void SFX.pass.play();
  } catch {}
}

/* ---------- Renderer / Scene ---------- */
const app = document.getElementById("app");
const renderer = new THREE.WebGLRenderer({ antialias:true, alpha:true, powerPreference:"high-performance" });
const devicePixelRatioTarget = Math.max(1, Math.min((window.devicePixelRatio || 1) * 1.25, 3));
renderer.setPixelRatio(devicePixelRatioTarget);
renderer.shadowMap.enabled = true;
renderer.shadowMap.autoUpdate = true;
renderer.shadowMap.type = THREE.PCFSoftShadowMap;
renderer.physicallyCorrectLights = true;
renderer.outputColorSpace = THREE.SRGBColorSpace;              // ensure gold looks vibrant
renderer.toneMapping = THREE.ACESFilmicToneMapping;
renderer.toneMappingExposure = 1.12;
function setRendererSize(){
  const vv = window.visualViewport; const w = vv ? vv.width : window.innerWidth; const h = vv ? vv.height: window.innerHeight;
  renderer.setSize(w, h, false);
}
setRendererSize();
app.appendChild(renderer.domElement);
renderer.domElement.style.touchAction = 'none';

const scene = new THREE.Scene();
const textureLoader = new THREE.TextureLoader();
const pmrem = new THREE.PMREMGenerator(renderer);
const envTex = pmrem.fromScene(new RoomEnvironment(), 0.04).texture;
scene.environment = envTex;

const MODEL_SCALE = 0.75;
const TABLE_SCALE = 0.85;
const ARENA_GROWTH = 1.45;
const TABLE_RADIUS = 3.4 * MODEL_SCALE * TABLE_SCALE;
const BASE_TABLE_HEIGHT = 1.08 * MODEL_SCALE * TABLE_SCALE;
const STOOL_SCALE = 1.5 * 1.3;
const SEAT_WIDTH = 0.9 * MODEL_SCALE * STOOL_SCALE;
const SEAT_DEPTH = 0.95 * MODEL_SCALE * STOOL_SCALE;
const SEAT_THICKNESS = 0.09 * MODEL_SCALE * STOOL_SCALE;
const BACK_HEIGHT = 0.68 * MODEL_SCALE * STOOL_SCALE;
const BACK_THICKNESS = 0.08 * MODEL_SCALE * STOOL_SCALE;
const ARM_HEIGHT = 0.3 * MODEL_SCALE * STOOL_SCALE;
const ARM_THICKNESS = 0.125 * MODEL_SCALE * STOOL_SCALE;
const ARM_DEPTH = SEAT_DEPTH * 0.75;
const COLUMN_HEIGHT = 0.5 * MODEL_SCALE * STOOL_SCALE;
const BASE_THICKNESS = 0.08 * MODEL_SCALE * STOOL_SCALE;
const COLUMN_RADIUS_TOP = 0.2 * MODEL_SCALE;
const COLUMN_RADIUS_BOTTOM = 0.26 * MODEL_SCALE;
const BASE_RADIUS = 0.72 * MODEL_SCALE;
const FOOT_RING_RADIUS = 0.52 * MODEL_SCALE;
const FOOT_RING_TUBE = 0.04 * MODEL_SCALE;
const CHAIR_GAP = 0.12 * MODEL_SCALE;
const CHAIR_RADIUS = TABLE_RADIUS + SEAT_DEPTH / 2 + CHAIR_GAP;
const CHAIR_BASE_HEIGHT = BASE_TABLE_HEIGHT - SEAT_THICKNESS * 0.85;
const STOOL_HEIGHT = CHAIR_BASE_HEIGHT + SEAT_THICKNESS;
const TABLE_HEIGHT_LIFT = 0.05 * MODEL_SCALE * TABLE_SCALE;
const TABLE_HEIGHT = STOOL_HEIGHT + TABLE_HEIGHT_LIFT;
const HUMAN_SEAT_INDEX = 0;
const CHAIR_SEAT_ANGLES = Object.freeze([
  THREE.MathUtils.degToRad(90),
  THREE.MathUtils.degToRad(315),
  THREE.MathUtils.degToRad(270),
  THREE.MathUtils.degToRad(225)
]);
const CHAIR_SEAT_RADII = Object.freeze([
  CHAIR_RADIUS,
  CHAIR_RADIUS * 0.94,
  CHAIR_RADIUS * 1.02,
  CHAIR_RADIUS * 0.94
]);
const ARENA_WALL_HEIGHT = 3.6 * 1.3;
const ARENA_WALL_CENTER_Y = ARENA_WALL_HEIGHT / 2;
const ARENA_WALL_INNER_RADIUS = TABLE_RADIUS * ARENA_GROWTH * 2.4;
const CARPET_RADIUS = TABLE_RADIUS * ARENA_GROWTH * 2.2;
const FLOOR_RADIUS = TABLE_RADIUS * ARENA_GROWTH * 3.2;
const CAMERA_TARGET_LIFT = 0.08 * MODEL_SCALE;
const CAMERA_TARGET_EXTRA = 0.12 * MODEL_SCALE;
const CAMERA_FOV = 52;
const CAMERA_NEAR = 0.1;
const CAMERA_FAR = 5000;
const CAMERA_MIN_POLAR = 0.92;
const CAMERA_MAX_POLAR = 1.22;
const CAMERA_INITIAL_PHI = THREE.MathUtils.lerp(CAMERA_MIN_POLAR, CAMERA_MAX_POLAR, 0.35);
const CAMERA_BASE_RADIUS = TABLE_RADIUS;
const CAMERA_MIN_RADIUS = CAMERA_BASE_RADIUS * 0.55;
const CAMERA_MAX_RADIUS = CAMERA_BASE_RADIUS * 3.2;
const CAMERA_DEFAULT_AZIMUTH = CHAIR_SEAT_ANGLES[HUMAN_SEAT_INDEX] ?? Math.PI / 2;
const CAMERA_LATERAL_OFFSET = { portrait: 0.78, landscape: 0.58 };
const CAMERA_REAR_OFFSET = { portrait: 1.85, landscape: 1.35 };
const CAMERA_HEIGHT_BOOST = { portrait: 1.95, landscape: 1.58 };
const CAMERA_TARGET = new THREE.Vector3(0, TABLE_HEIGHT + CAMERA_TARGET_LIFT + CAMERA_TARGET_EXTRA, 0);
const CAMERA_TOPDOWN_RADIUS = TABLE_RADIUS * 2.35;
const CAMERA_TOPDOWN_MIN_RADIUS = TABLE_RADIUS * 1.2;
const CAMERA_TOPDOWN_MAX_RADIUS = TABLE_RADIUS * 3.6;
const CAMERA_TOPDOWN_MIN_POLAR = THREE.MathUtils.degToRad(2);
const CAMERA_TOPDOWN_MAX_POLAR = THREE.MathUtils.degToRad(18);
const UP = new THREE.Vector3(0, 1, 0);

const VIEW_MODES = Object.freeze({ threeD: '3d', twoD: '2d' });
let cameraViewMode = VIEW_MODES.threeD;

const urlParams = new URLSearchParams(window.location.search);
const entryMode = (urlParams.get('entry') || '').toLowerCase();
const shouldRunHallwayEntry = entryMode === 'hallway';
const shouldShowSeatLabel = shouldRunHallwayEntry;

function seatBasisForAngle(angle, radius = CHAIR_RADIUS) {
  const useAngle = Number.isFinite(angle) ? angle : CAMERA_DEFAULT_AZIMUTH;
  const useRadius = Number.isFinite(radius) ? radius : CHAIR_RADIUS;
  const position = new THREE.Vector3(
    Math.cos(useAngle) * useRadius,
    0,
    Math.sin(useAngle) * useRadius
  );
  const forward = position.clone();
  if (forward.lengthSq() > 0) {
    forward.multiplyScalar(-1 / forward.length());
  } else {
    forward.set(0, 0, -1);
  }
  const right = new THREE.Vector3().crossVectors(UP, forward).normalize();
  if (right.lengthSq() === 0) {
    right.set(1, 0, 0);
  }
  return { position, forward, right };
}

function seatBasisForIndex(index = 0) {
  const safeIndex = Number.isFinite(index) ? index : 0;
  const angle = CHAIR_SEAT_ANGLES[safeIndex % CHAIR_SEAT_ANGLES.length] ?? CAMERA_DEFAULT_AZIMUTH;
  const radius = CHAIR_SEAT_RADII[safeIndex % CHAIR_SEAT_RADII.length] ?? CHAIR_RADIUS;
  return seatBasisForAngle(angle, radius);
}

const camera = new THREE.PerspectiveCamera(CAMERA_FOV, 1, CAMERA_NEAR, CAMERA_FAR);
function fitCamera(){
  const vv = window.visualViewport; const w= vv?vv.width:innerWidth; const h= vv?vv.height:innerHeight;
  camera.aspect = w/h; camera.updateProjectionMatrix(); setRendererSize();
}
fitCamera();

const controls = new OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;
controls.dampingFactor = 0.08;
controls.enableZoom = true;
controls.zoomSpeed = 1.05;
controls.enablePan = true;
controls.panSpeed = 0.9;
controls.screenSpacePanning = true;
controls.enableRotate = true;
controls.minDistance = CAMERA_MIN_RADIUS;
controls.maxDistance = CAMERA_MAX_RADIUS;
controls.minPolarAngle = CAMERA_MIN_POLAR;
controls.maxPolarAngle = CAMERA_MAX_POLAR;
controls.touches.ONE = THREE.TOUCH.ROTATE;
controls.touches.TWO = THREE.TOUCH.DOLLY_PAN;
controls.touches.THREE = THREE.TOUCH.PAN;
controls.target.copy(CAMERA_TARGET);

let cameraHasUserControl = false;
controls.addEventListener('start', () => {
  cameraHasUserControl = true;
});
renderer.domElement.addEventListener(
  'wheel',
  () => {
    cameraHasUserControl = true;
  },
  { passive: true }
);

function computeDesiredCameraPosition() {
  const dom = renderer.domElement;
  const width = dom?.clientWidth || window.innerWidth || 1;
  const height = dom?.clientHeight || window.innerHeight || 1;
  const isPortrait = height >= width;

  const seat = seatBasisForIndex(HUMAN_SEAT_INDEX);
  const seatHeight = CHAIR_BASE_HEIGHT + SEAT_THICKNESS;
  const seatAnchor = seat.position.clone();
  seatAnchor.y = seatHeight;

  const retreat = isPortrait ? CAMERA_REAR_OFFSET.portrait : CAMERA_REAR_OFFSET.landscape;
  const lateral = isPortrait ? CAMERA_LATERAL_OFFSET.portrait : CAMERA_LATERAL_OFFSET.landscape;
  const elevation = isPortrait ? CAMERA_HEIGHT_BOOST.portrait : CAMERA_HEIGHT_BOOST.landscape;

  const desiredPosition = seatAnchor
    .clone()
    .addScaledVector(seat.forward, -retreat)
    .addScaledVector(seat.right, lateral);
  desiredPosition.y = seatHeight + elevation;
  return desiredPosition;
}

function computeTopDownCameraPosition() {
  const lift = Math.max(TABLE_HEIGHT + CAMERA_TARGET_EXTRA, CAMERA_TOPDOWN_RADIUS);
  return CAMERA_TARGET.clone().add(new THREE.Vector3(0, lift, 0.0001));
}

function getActiveCameraConstraints() {
  if (cameraViewMode === VIEW_MODES.twoD) {
    return {
      minPolar: CAMERA_TOPDOWN_MIN_POLAR,
      maxPolar: CAMERA_TOPDOWN_MAX_POLAR,
      minRadius: CAMERA_TOPDOWN_MIN_RADIUS,
      maxRadius: CAMERA_TOPDOWN_MAX_RADIUS
    };
  }

  return {
    minPolar: CAMERA_MIN_POLAR,
    maxPolar: CAMERA_MAX_POLAR,
    minRadius: CAMERA_MIN_RADIUS,
    maxRadius: CAMERA_MAX_RADIUS
  };
}

function getDesiredCameraPosition() {
  if (cameraViewMode === VIEW_MODES.twoD) {
    return computeTopDownCameraPosition();
  }
  return computeDesiredCameraPosition();
}

function applyCameraConstraints() {
  const { minPolar, maxPolar, minRadius, maxRadius } = getActiveCameraConstraints();
  controls.minPolarAngle = minPolar;
  controls.maxPolarAngle = maxPolar;
  controls.minDistance = minRadius;
  controls.maxDistance = maxRadius;
  controls.enableRotate = cameraViewMode !== VIEW_MODES.twoD;
}

function clampCameraPosition(position) {
  const { minPolar, maxPolar, minRadius, maxRadius } = getActiveCameraConstraints();
  const offset = position.clone().sub(CAMERA_TARGET);
  const spherical = new THREE.Spherical().setFromVector3(offset);
  if (!Number.isFinite(spherical.radius) || spherical.radius <= 0) {
    spherical.radius = minRadius;
    spherical.theta = CAMERA_DEFAULT_AZIMUTH;
    spherical.phi = THREE.MathUtils.clamp(CAMERA_INITIAL_PHI, minPolar, maxPolar);
  }
  spherical.radius = THREE.MathUtils.clamp(spherical.radius, minRadius, maxRadius);
  spherical.phi = THREE.MathUtils.clamp(spherical.phi, minPolar, maxPolar);
  const clampedOffset = new THREE.Vector3().setFromSpherical(spherical);
  return CAMERA_TARGET.clone().add(clampedOffset);
}

function positionCameraForViewport({ force = false } = {}) {
  fitCamera();
  applyCameraConstraints();
  const desiredPosition = getDesiredCameraPosition();
  const clampedDesired = clampCameraPosition(desiredPosition);
  if (!cameraHasUserControl || force) {
    camera.position.copy(clampedDesired);
    if (force) {
      cameraHasUserControl = false;
    }
  } else {
    camera.position.copy(clampCameraPosition(camera.position));
  }

  controls.target.copy(CAMERA_TARGET);
  controls.update();
}

function updateViewToggleLabel() {
  const isTopDown = cameraViewMode === VIEW_MODES.twoD;
  if (viewToggle) {
    viewToggle.textContent = isTopDown ? '3D' : '2D';
    viewToggle.setAttribute('aria-pressed', isTopDown ? 'true' : 'false');
    const nextLabel = isTopDown ? 'Switch to 3D view' : 'Switch to 2D view';
    viewToggle.setAttribute('aria-label', nextLabel);
    viewToggle.title = nextLabel;
  }
}

function setCameraViewMode(mode = VIEW_MODES.threeD) {
  if (!Object.values(VIEW_MODES).includes(mode)) return;
  if (mode === cameraViewMode) return;

  cameraViewMode = mode;
  cameraHasUserControl = false;
  applyCameraConstraints();
  positionCameraForViewport({ force: true });
  updateViewToggleLabel();
  renderHands();
}

function toggleCameraViewMode() {
  const next = cameraViewMode === VIEW_MODES.twoD ? VIEW_MODES.threeD : VIEW_MODES.twoD;
  setCameraViewMode(next);
}


/* ---------- Lights ---------- */
scene.add(new THREE.AmbientLight(0xffffff, 0.45));
scene.add(new THREE.HemisphereLight(0xffffff, 0xb8b19a, 0.55));
const key = new THREE.DirectionalLight(0xffffff, 1.6); key.position.set(3.2,3.6,2.2); key.castShadow=true; key.shadow.mapSize.set(2048,2048); scene.add(key);
const rimLight = new THREE.DirectionalLight(0xffffff, 0.55); rimLight.position.set(-2.2,2.6,-1.4); scene.add(rimLight);

const getPoolCarpetTextures = (() => {
  let cache = null;
  const clamp01 = (v) => Math.min(1, Math.max(0, v));
  const prng = (seed) => {
    let value = seed >>> 0;
    return () => {
      value = (value * 1664525 + 1013904223) % 4294967296;
      return value / 4294967296;
    };
  };
  const drawRoundedRect = (ctx, x, y, w, h, r) => {
    const radius = Math.max(0, Math.min(r, Math.min(w, h) / 2));
    ctx.beginPath();
    ctx.moveTo(x + radius, y);
    ctx.lineTo(x + w - radius, y);
    ctx.quadraticCurveTo(x + w, y, x + w, y + radius);
    ctx.lineTo(x + w, y + h - radius);
    ctx.quadraticCurveTo(x + w, y + h, x + w - radius, y + h);
    ctx.lineTo(x + radius, y + h);
    ctx.quadraticCurveTo(x, y + h, x, y + h - radius);
    ctx.lineTo(x, y + radius);
    ctx.quadraticCurveTo(x, y, x + radius, y);
    ctx.closePath();
  };
  return (renderer) => {
    if (cache) return cache;
    if (typeof document === "undefined") {
      cache = { map: null, bump: null };
      return cache;
    }
    const size = 1024;
    const canvas = document.createElement("canvas");
    canvas.width = canvas.height = size;
    const ctx = canvas.getContext("2d");

    // Match Pool Royale's crimson carpet palette.
    const gradient = ctx.createLinearGradient(0, 0, size, size);
    gradient.addColorStop(0, "#7c242f");
    gradient.addColorStop(1, "#9d3642");
    ctx.fillStyle = gradient;
    ctx.fillRect(0, 0, size, size);

    const rand = prng(987654321);
    const image = ctx.getImageData(0, 0, size, size);
    const data = image.data;
    const baseColor = { r: 112, g: 28, b: 34 };
    const highlightColor = { r: 196, g: 72, b: 82 };
    const toChannel = (component) => Math.round(clamp01(component / 255) * 255);
    for (let y = 0; y < size; y++) {
      for (let x = 0; x < size; x++) {
        const idx = (y * size + x) * 4;
        const fiber = (Math.sin((x / size) * Math.PI * 14) + Math.cos((y / size) * Math.PI * 16)) * 0.08;
        const grain = (rand() - 0.5) * 0.12;
        const shade = clamp01(0.55 + fiber * 0.75 + grain * 0.6);
        const r = baseColor.r + (highlightColor.r - baseColor.r) * shade;
        const g = baseColor.g + (highlightColor.g - baseColor.g) * shade;
        const b = baseColor.b + (highlightColor.b - baseColor.b) * shade;
        data[idx] = toChannel(r);
        data[idx + 1] = toChannel(g);
        data[idx + 2] = toChannel(b);
      }
    }
    ctx.putImageData(image, 0, 0);

    ctx.globalAlpha = 0.04;
    ctx.fillStyle = "#4f1119";
    for (let row = 0; row < size; row += 3) {
      ctx.fillRect(0, row, size, 1);
    }
    ctx.globalAlpha = 1;

    const insetRatio = 0.055;
    const stripeInset = size * insetRatio;
    const stripeRadius = size * 0.08;
    const stripeWidth = size * 0.012;
    ctx.lineWidth = stripeWidth;
    ctx.strokeStyle = "#f2b7b4";
    ctx.shadowColor = "rgba(80,20,30,0.18)";
    ctx.shadowBlur = stripeWidth * 0.8;
    drawRoundedRect(ctx, stripeInset, stripeInset, size - stripeInset * 2, size - stripeInset * 2, stripeRadius);
    ctx.stroke();
    ctx.shadowBlur = 0;

    const texture = new THREE.CanvasTexture(canvas);
    texture.wrapS = texture.wrapT = THREE.ClampToEdgeWrapping;
    texture.anisotropy = renderer?.capabilities?.getMaxAnisotropy?.() ?? 8;
    texture.minFilter = THREE.LinearMipMapLinearFilter;
    texture.magFilter = THREE.LinearFilter;
    texture.generateMipmaps = true;
    texture.colorSpace = THREE.SRGBColorSpace;

    const bumpCanvas = document.createElement("canvas");
    bumpCanvas.width = bumpCanvas.height = size;
    const bumpCtx = bumpCanvas.getContext("2d");
    bumpCtx.drawImage(canvas, 0, 0);
    const bumpImage = bumpCtx.getImageData(0, 0, size, size);
    const bumpData = bumpImage.data;
    const bumpRand = prng(246813579);
    for (let i = 0; i < bumpData.length; i += 4) {
      const r = bumpData[i];
      const g = bumpData[i + 1];
      const b = bumpData[i + 2];
      const lum = (r * 0.299 + g * 0.587 + b * 0.114) / 255;
      const noise = (bumpRand() - 0.5) * 0.16;
      const v = clamp01(0.62 + lum * 0.28 + noise);
      const value = Math.floor(v * 255);
      bumpData[i] = bumpData[i + 1] = bumpData[i + 2] = value;
    }
    bumpCtx.putImageData(bumpImage, 0, 0);

    const bump = new THREE.CanvasTexture(bumpCanvas);
    bump.wrapS = bump.wrapT = THREE.ClampToEdgeWrapping;
    bump.anisotropy = Math.min(texture.anisotropy ?? 4, 6);
    bump.minFilter = THREE.LinearMipMapLinearFilter;
    bump.magFilter = THREE.LinearFilter;
    bump.generateMipmaps = true;

    cache = { map: texture, bump };
    return cache;
  };
})();

const CHAIR_CLOTH_TEXTURE_SIZE = 512;
const CHAIR_CLOTH_REPEAT = 4;
const DEFAULT_CHAIR_THEME = Object.freeze({
  id: "ruby",
  label: "Ruby",
  seatColor: "#8b0000",
  legColor: "#1f1f1f",
  highlight: "#d46a6a"
});

const CHAIR_THEME_OPTIONS = Object.freeze([
  DEFAULT_CHAIR_THEME,
  { id: "slate", label: "Slate", seatColor: "#374151", legColor: "#0f172a", highlight: "#9ca3af" },
  { id: "teal", label: "Teal", seatColor: "#0f766e", legColor: "#082f2a", highlight: "#34d399" },
  { id: "amber", label: "Amber", seatColor: "#b45309", legColor: "#2f2410", highlight: "#fbbf24" },
  { id: "violet", label: "Violet", seatColor: "#7c3aed", legColor: "#2b1059", highlight: "#d8b4fe" },
  { id: "frost", label: "Frost", seatColor: "#1f2937", legColor: "#0f172a", highlight: "#94a3b8" }
]);

const CHAIR_MODEL_URLS = [
  "https://raw.githubusercontent.com/KhronosGroup/glTF-Sample-Models/master/2.0/AntiqueChair/glTF-Binary/AntiqueChair.glb",
  "https://raw.githubusercontent.com/KhronosGroup/glTF-Sample-Assets/main/Models/SheenChair/glTF-Binary/SheenChair.glb",
  "https://raw.githubusercontent.com/KhronosGroup/glTF-Sample-Assets/main/Models/AntiqueChair/glTF-Binary/AntiqueChair.glb"
];
const TARGET_CHAIR_SIZE = new THREE.Vector3(1.3162499970197679, 1.9173749900311232, 1.7001562547683715);
const TARGET_CHAIR_MIN_Y = -0.8570624993294478;
const TARGET_CHAIR_CENTER_Z = -0.1553906416893005;

const clamp01f = (value) => Math.min(1, Math.max(0, value));
const normalizeHue = (h) => {
  let hue = h % 360;
  if (hue < 0) hue += 360;
  return hue;
};

let chairTemplatePromise = null;
let chairTemplateBounds = null;

function fitChairModelToFootprint(model) {
  const box = new THREE.Box3().setFromObject(model);
  const size = box.getSize(new THREE.Vector3());
  const targetMax = Math.max(TARGET_CHAIR_SIZE.x, TARGET_CHAIR_SIZE.y, TARGET_CHAIR_SIZE.z);
  const currentMax = Math.max(size.x, size.y, size.z);
  if (currentMax > 0) {
    const scale = targetMax / currentMax;
    model.scale.multiplyScalar(scale);
  }

  const scaledBox = new THREE.Box3().setFromObject(model);
  const scaledCenter = scaledBox.getCenter(new THREE.Vector3());
  const offset = new THREE.Vector3(
    -scaledCenter.x,
    TARGET_CHAIR_MIN_Y - scaledBox.min.y,
    TARGET_CHAIR_CENTER_Z - scaledCenter.z
  );
  model.position.add(offset);
}

function extractChairMaterials(model) {
  const upholstery = new Set();
  const metal = new Set();
  model.traverse((obj) => {
    if (!obj.isMesh) return;
    const mats = Array.isArray(obj.material) ? obj.material : [obj.material];
    mats.forEach((mat) => {
      if (!mat) return;
      if (mat.map) mat.map.colorSpace = THREE.SRGBColorSpace;
      if (mat.emissiveMap) mat.emissiveMap.colorSpace = THREE.SRGBColorSpace;
      const bucket = (mat.metalness ?? 0) > 0.35 ? metal : upholstery;
      bucket.add(mat);
    });
  });
  const upholsteryArr = Array.from(upholstery);
  const metalArr = Array.from(metal);
  return {
    seat: upholsteryArr[0] ?? metalArr[0] ?? null,
    leg: metalArr[0] ?? upholsteryArr[0] ?? null,
    upholstery: upholsteryArr,
    metal: metalArr
  };
}

async function ensureMurlanChairTemplate() {
  if (chairTemplatePromise) return chairTemplatePromise;
  chairTemplatePromise = (async () => {
    const loader = new GLTFLoader();
    const draco = new DRACOLoader();
    draco.setDecoderPath("https://www.gstatic.com/draco/v1/decoders/");
    loader.setDRACOLoader(draco);

    let gltf = null;
    let lastError = null;
    for (const url of CHAIR_MODEL_URLS) {
      try {
        gltf = await loader.loadAsync(url);
        break;
      } catch (error) {
        lastError = error;
      }
    }
    if (!gltf) {
      throw lastError || new Error("Failed to load chair model");
    }

    const model = gltf.scene || gltf.scenes?.[0];
    if (!model) {
      throw new Error("Chair model missing scene");
    }

    model.traverse((obj) => {
      if (!obj.isMesh) return;
      obj.castShadow = true;
      obj.receiveShadow = true;
      const mats = Array.isArray(obj.material) ? obj.material : [obj.material];
      mats.forEach((mat) => {
        if (mat?.map) mat.map.colorSpace = THREE.SRGBColorSpace;
        if (mat?.emissiveMap) mat.emissiveMap.colorSpace = THREE.SRGBColorSpace;
      });
    });

    fitChairModelToFootprint(model);
    chairTemplateBounds = new THREE.Box3().setFromObject(model);

    return { chairTemplate: model, materials: extractChairMaterials(model) };
  })();

  return chairTemplatePromise;
}

function cloneChairWithTheme(chairData, option) {
  const { chairTemplate, materials } = chairData;
  const clone = chairTemplate.clone(true);
  const upholsterySet = new Set(materials.upholstery);
  const metalSet = new Set(materials.metal);

  clone.traverse((obj) => {
    if (!obj.isMesh) return;
    const mats = Array.isArray(obj.material) ? obj.material : [obj.material];
    const themed = mats.map((mat) => {
      if (!mat) return mat;
      const next = mat.clone();
      if (upholsterySet.has(mat)) {
        if (next.color) next.color.set(option?.seatColor ?? DEFAULT_CHAIR_THEME.seatColor);
        if (next.emissive) next.emissive.set(option?.highlight ?? option?.seatColor ?? DEFAULT_CHAIR_THEME.highlight);
      } else if (metalSet.has(mat)) {
        if (next.color) next.color.set(option?.legColor ?? DEFAULT_CHAIR_THEME.legColor);
      }
      return next;
    });
    obj.material = Array.isArray(obj.material) ? themed : themed[0];
    obj.castShadow = true;
    obj.receiveShadow = true;
  });

  return clone;
}
const hslString = (h, s, l) => {
  const sat = clamp01f(s);
  const light = clamp01f(l);
  return `hsl(${normalizeHue(h)}, ${Math.round(sat * 100)}%, ${Math.round(light * 100)}%)`;
};
const hslToHexNumber = (h, s, l) => {
  const color = new THREE.Color();
  color.setHSL(normalizeHue(h) / 360, clamp01f(s), clamp01f(l));
  return color.getHex();
};
const hslToHexString = (h, s, l) => `#${hslToHexNumber(h, s, l).toString(16).padStart(6, '0')}`;
const shiftLightness = (light, delta) => clamp01f(light + delta);
const shiftSaturation = (sat, delta) => clamp01f(sat + delta);

const WOOD_FINISH_PRESETS = Object.freeze([
  Object.freeze({ id: 'birch', label: 'Birch', hue: 38, sat: 0.25, light: 0.84, contrast: 0.42 }),
  Object.freeze({ id: 'maple', label: 'Maple', hue: 35, sat: 0.22, light: 0.78, contrast: 0.44 }),
  Object.freeze({ id: 'oak', label: 'Oak', hue: 32, sat: 0.34, light: 0.7, contrast: 0.52 }),
  Object.freeze({ id: 'cherry', label: 'Cherry', hue: 14, sat: 0.42, light: 0.6, contrast: 0.58 }),
  Object.freeze({ id: 'teak', label: 'Teak', hue: 28, sat: 0.4, light: 0.52, contrast: 0.6 }),
  Object.freeze({ id: 'walnut', label: 'Walnut', hue: 22, sat: 0.4, light: 0.44, contrast: 0.64 }),
  Object.freeze({ id: 'smokedOak', label: 'Smoked Oak', hue: 28, sat: 0.35, light: 0.28, contrast: 0.75 }),
  Object.freeze({ id: 'wenge', label: 'Wenge', hue: 24, sat: 0.38, light: 0.22, contrast: 0.8 }),
  Object.freeze({ id: 'ebony', label: 'Eben', hue: 25, sat: 0.35, light: 0.18, contrast: 0.85 })
]);

const WOOD_PRESETS_BY_ID = Object.freeze(
  WOOD_FINISH_PRESETS.reduce((acc, preset) => {
    acc[preset.id] = preset;
    return acc;
  }, {})
);

const WOOD_GRAIN_OPTIONS = Object.freeze([
  Object.freeze({
    id: 'estateBands',
    label: 'Estate Bands',
    rail: {
      repeat: { x: 0.12, y: 0.68 },
      rotation: Math.PI / 2,
      textureSize: 3072
    },
    frame: {
      repeat: { x: 0.32, y: 0.4 },
      rotation: 0,
      textureSize: 3072
    }
  }),
  Object.freeze({
    id: 'studioVeins',
    label: 'Studio Veins',
    rail: {
      repeat: { x: 0.1, y: 0.56 },
      rotation: Math.PI / 14,
      textureSize: 3072
    },
    frame: {
      repeat: { x: 0.24, y: 0.38 },
      rotation: Math.PI / 2,
      textureSize: 3072
    }
  })
]);

const WOOD_GRAIN_OPTIONS_BY_ID = Object.freeze(
  WOOD_GRAIN_OPTIONS.reduce((acc, option) => {
    acc[option.id] = option;
    return acc;
  }, {})
);

const DEFAULT_WOOD_GRAIN_ID = WOOD_GRAIN_OPTIONS[0]?.id ?? 'estateBands';
const DEFAULT_WOOD_TEXTURE_SIZE = 1024;
const DEFAULT_WOOD_ROUGHNESS_SIZE = 512;
const WOOD_TEXTURE_BASE_CACHE = new Map();

function makeCacheKey({
  hue,
  sat,
  light,
  contrast,
  textureSize,
  roughnessSize,
  roughnessBase,
  roughnessVariance,
  sharedKey
}) {
  const parts = [
    sharedKey ?? 'solo',
    Number.isFinite(hue) ? hue.toFixed(4) : '0',
    Number.isFinite(sat) ? sat.toFixed(4) : '0',
    Number.isFinite(light) ? light.toFixed(4) : '0',
    Number.isFinite(contrast) ? contrast.toFixed(4) : '0',
    textureSize ?? DEFAULT_WOOD_TEXTURE_SIZE,
    roughnessSize ?? DEFAULT_WOOD_ROUGHNESS_SIZE,
    Number.isFinite(roughnessBase) ? roughnessBase.toFixed(4) : '0',
    Number.isFinite(roughnessVariance) ? roughnessVariance.toFixed(4) : '0'
  ];
  return parts.join('|');
}

function makeNaturalWoodTexture(width, height, hue, sat, light, contrast) {
  if (typeof document === 'undefined') return null;
  const canvas = document.createElement('canvas');
  canvas.width = width;
  canvas.height = height;
  const ctx = canvas.getContext('2d');
  if (!ctx) return null;
  ctx.fillStyle = hslString(hue, sat, light);
  ctx.fillRect(0, 0, width, height);

  for (let i = 0; i < 3000; i += 1) {
    const x = Math.random() * width;
    const y = Math.random() * height;
    const grainLen = 50 + Math.random() * 200;
    const curve = Math.sin(y / 40 + Math.random() * 2) * 10;
    ctx.strokeStyle = hslString(hue, sat * 0.6, light - Math.random() * contrast);
    ctx.lineWidth = 0.8 + Math.random() * 1.2;
    ctx.globalAlpha = 0.25 + Math.random() * 0.3;
    ctx.beginPath();
    ctx.moveTo(x, y);
    ctx.quadraticCurveTo(x + curve, y + grainLen / 2, x, y + grainLen);
    ctx.stroke();
  }

  for (let i = 0; i < 40; i += 1) {
    const kx = Math.random() * width;
    const ky = Math.random() * height;
    const r = 8 + Math.random() * 15;
    const grad = ctx.createRadialGradient(kx, ky, 0, kx, ky, r);
    grad.addColorStop(0, hslString(hue, sat * 0.9, light - 0.3));
    grad.addColorStop(1, hslString(hue, sat * 0.4, light));
    ctx.fillStyle = grad;
    ctx.globalAlpha = 0.7;
    ctx.beginPath();
    ctx.arc(kx, ky, r, 0, Math.PI * 2);
    ctx.fill();
  }
  ctx.globalAlpha = 1;

  const texture = new THREE.CanvasTexture(canvas);
  texture.colorSpace = THREE.SRGBColorSpace;
  texture.anisotropy = 16;
  texture.needsUpdate = true;
  return texture;
}

function makeRoughnessMap(width, height, base, variance) {
  if (typeof document === 'undefined') return null;
  const canvas = document.createElement('canvas');
  canvas.width = width;
  canvas.height = height;
  const ctx = canvas.getContext('2d');
  if (!ctx) return null;
  const imageData = ctx.createImageData(width, height);
  const data = imageData.data;
  for (let i = 0; i < data.length; i += 4) {
    const value = clamp01f(base + (Math.random() - 0.5) * variance);
    const channel = Math.round(value * 255);
    data[i] = data[i + 1] = data[i + 2] = channel;
    data[i + 3] = 255;
  }
  ctx.putImageData(imageData, 0, 0);
  const texture = new THREE.CanvasTexture(canvas);
  texture.needsUpdate = true;
  return texture;
}

function disposeWoodTextures(material) {
  if (!material) return;
  const textures = material.userData?.__woodTextures;
  if (textures) {
    const { map, roughnessMap } = textures;
    if (map?.dispose) map.dispose();
    if (roughnessMap && roughnessMap !== map && roughnessMap.dispose) {
      roughnessMap.dispose();
    }
    delete material.userData.__woodTextures;
  }
  if (material.map && material.map.dispose) {
    material.map.dispose();
  }
  if (material.roughnessMap && material.roughnessMap !== material.map && material.roughnessMap.dispose) {
    material.roughnessMap.dispose();
  }
  material.map = null;
  material.roughnessMap = null;
}

function cloneWoodTexture(texture, repeatVec, rotation) {
  if (!texture) return null;
  const clone = texture.clone();
  clone.repeat.copy(repeatVec ?? new THREE.Vector2(1, 1));
  clone.center.set(0.5, 0.5);
  if (typeof rotation === 'number' && rotation !== 0) {
    clone.rotation = rotation;
  }
  clone.needsUpdate = true;
  return clone;
}

function ensureSharedWoodTextures({
  hue,
  sat,
  light,
  contrast,
  textureSize,
  roughnessSize,
  roughnessBase,
  roughnessVariance,
  sharedKey
}) {
  if (typeof document === 'undefined') {
    return { map: null, roughnessMap: null };
  }
  const key = makeCacheKey({
    hue,
    sat,
    light,
    contrast,
    textureSize,
    roughnessSize,
    roughnessBase,
    roughnessVariance,
    sharedKey
  });
  let entry = WOOD_TEXTURE_BASE_CACHE.get(key);
  if (!entry) {
    const map = makeNaturalWoodTexture(textureSize, textureSize, hue, sat, light, contrast);
    const roughnessMap = makeRoughnessMap(roughnessSize, roughnessSize, roughnessBase, roughnessVariance);
    if (map) {
      map.wrapS = map.wrapT = THREE.RepeatWrapping;
      map.center.set(0.5, 0.5);
      map.needsUpdate = true;
    }
    if (roughnessMap) {
      roughnessMap.wrapS = roughnessMap.wrapT = THREE.RepeatWrapping;
      roughnessMap.center.set(0.5, 0.5);
      roughnessMap.needsUpdate = true;
    }
    entry = { map, roughnessMap };
    WOOD_TEXTURE_BASE_CACHE.set(key, entry);
  }
  return entry;
}

function applyWoodTextures(
  material,
  {
    hue,
    sat,
    light,
    contrast,
    repeat = { x: 1, y: 1 },
    rotation = 0,
    textureSize = DEFAULT_WOOD_TEXTURE_SIZE,
    roughnessSize = DEFAULT_WOOD_ROUGHNESS_SIZE,
    roughnessBase = 0.18,
    roughnessVariance = 0.25,
    sharedKey = null
  } = {}
) {
  if (!material) return null;
  disposeWoodTextures(material);
  const repeatVec = new THREE.Vector2(repeat?.x ?? 1, repeat?.y ?? 1);
  let map = null;
  let roughnessMap = null;
  if (typeof document !== 'undefined') {
    const baseTextures = sharedKey
      ? ensureSharedWoodTextures({
          hue,
          sat,
          light,
          contrast,
          textureSize,
          roughnessSize,
          roughnessBase,
          roughnessVariance,
          sharedKey
        })
      : {
          map: makeNaturalWoodTexture(textureSize, textureSize, hue, sat, light, contrast),
          roughnessMap: makeRoughnessMap(roughnessSize, roughnessSize, roughnessBase, roughnessVariance)
        };
    map = cloneWoodTexture(baseTextures.map, repeatVec, rotation);
    roughnessMap = cloneWoodTexture(baseTextures.roughnessMap, repeatVec, rotation);
    if (map) {
      map.wrapS = map.wrapT = THREE.RepeatWrapping;
      map.needsUpdate = true;
    }
    if (roughnessMap) {
      roughnessMap.wrapS = roughnessMap.wrapT = THREE.RepeatWrapping;
      roughnessMap.needsUpdate = true;
    }
  }
  material.map = map ?? null;
  material.roughnessMap = roughnessMap ?? null;
  material.color.setHex(0xffffff);
  material.needsUpdate = true;
  material.userData = material.userData || {};
  material.userData.__woodTextures = { map: material.map, roughnessMap: material.roughnessMap };
  material.userData.__woodOptions = {
    hue,
    sat,
    light,
    contrast,
    repeat: { x: repeatVec.x, y: repeatVec.y },
    rotation,
    textureSize,
    roughnessSize,
    roughnessBase,
    roughnessVariance,
    sharedKey
  };
  material.userData.woodRepeat = repeatVec.clone();
  if (material.map) material.map.needsUpdate = true;
  if (material.roughnessMap) material.roughnessMap.needsUpdate = true;
  return { map: material.map, roughnessMap: material.roughnessMap };
}

function makeTableWoodOption({ id, label, presetId, grainId }) {
  const fallbackPreset = WOOD_PRESETS_BY_ID.walnut ?? WOOD_FINISH_PRESETS[0];
  const preset = (presetId && WOOD_PRESETS_BY_ID[presetId]) || fallbackPreset;
  return Object.freeze({
    id,
    label,
    presetId,
    grainId,
    baseHex: hslToHexString(preset.hue, preset.sat, preset.light),
    rimHex: hslToHexString(preset.hue, shiftSaturation(preset.sat, 0.04), shiftLightness(preset.light, -0.08)),
    accentHex: hslToHexString(preset.hue, shiftSaturation(preset.sat, 0.12), shiftLightness(preset.light, -0.18))
  });
}

function resolveWoodComponents(option) {
  const fallbackPreset = WOOD_PRESETS_BY_ID.walnut ?? WOOD_FINISH_PRESETS[0];
  const preset = (option?.presetId && WOOD_PRESETS_BY_ID[option.presetId]) || fallbackPreset;
  const fallbackGrain = WOOD_GRAIN_OPTIONS_BY_ID[DEFAULT_WOOD_GRAIN_ID] ?? WOOD_GRAIN_OPTIONS[0];
  const grain = (option?.grainId && WOOD_GRAIN_OPTIONS_BY_ID[option.grainId]) || fallbackGrain;
  return { preset, grain };
}

const TABLE_WOOD_OPTIONS = Object.freeze([
  makeTableWoodOption({ id: 'oakEstate', label: 'Lis Estate', presetId: 'oak', grainId: 'estateBands' }),
  makeTableWoodOption({ id: 'teakStudio', label: 'Tik Studio', presetId: 'teak', grainId: 'studioVeins' })
]);

const TABLE_CLOTH_OPTIONS = Object.freeze([
  { id: "crimson", label: "Crimson Cloth", feltTop: "#b0122d", feltBottom: "#650a1b", border: "#2b050c", emissive: "#6c101f", emissiveIntensity: 0.5 },
  { id: "emerald", label: "Emerald Cloth", feltTop: "#1fa44d", feltBottom: "#0b7030", border: "#043018", emissive: "#0f6a2f", emissiveIntensity: 0.72 },
  { id: "arctic", label: "Arctic Cloth", feltTop: "#3b82f6", feltBottom: "#1d4ed8", border: "#0a1c4d", emissive: "#2563eb", emissiveIntensity: 0.62 },
  { id: "sunset", label: "Sunset Cloth", feltTop: "#f97316", feltBottom: "#c2410c", border: "#3b1203", emissive: "#e2580f", emissiveIntensity: 0.58 },
  { id: "violet", label: "Violet Cloth", feltTop: "#8b5cf6", feltBottom: "#5b21b6", border: "#241055", emissive: "#6d28d9", emissiveIntensity: 0.58 },
  { id: "amber", label: "Amber Cloth", feltTop: "#f59e0b", feltBottom: "#b45309", border: "#3b1a02", emissive: "#d97706", emissiveIntensity: 0.54 }
]);

const TABLE_BASE_OPTIONS = Object.freeze([
  { id: "obsidian", label: "Obsidian Base", base: "#141414", column: "#0b0d10", trim: "#1f232a" },
  { id: "forestBronze", label: "Forest Base", base: "#101714", column: "#0a0f0c", trim: "#1f2d24" },
  { id: "midnightChrome", label: "Midnight Base", base: "#0f172a", column: "#0a1020", trim: "#1e2f4a" },
  { id: "emberCopper", label: "Copper Base", base: "#231312", column: "#140707", trim: "#5c2d1b" },
  { id: "violetShadow", label: "Violet Shadow Base", base: "#1f1130", column: "#130622", trim: "#3f1b5b" },
  { id: "desertGold", label: "Desert Base", base: "#1c1a12", column: "#0f0d06", trim: "#5a4524" }
]);

const DOMINO_STYLE_OPTIONS = Object.freeze([
  {
    id: 'imperialIvory',
    label: 'Imperial Ivory',
    preview: ['#f7f1e4', '#d8af37'],
    body: {
      color: '#f7f1e4',
      roughness: 0.16,
      metalness: 0.24,
      clearcoat: 1.0,
      clearcoatRoughness: 0.05,
      reflectivity: 0.72,
      sheen: 0.35,
      sheenColor: '#fff7d1'
    },
    pip: {
      color: '#121314',
      metalness: 0.55,
      roughness: 0.22,
      clearcoat: 0.6,
      clearcoatRoughness: 0.05,
      emissive: '#080808',
      emissiveIntensity: 0.12,
      sheen: 0.12
    },
    accent: {
      color: '#d8af37',
      emissive: '#7a5300',
      emissiveIntensity: 0.52,
      metalness: 1.0,
      roughness: 0.22,
      reflectivity: 1.0,
      ringInner: 0.104,
      ringOuter: 0.122
    }
  },
  {
    id: 'obsidianPlatinum',
    label: 'Obsidian Platinum',
    preview: ['#090909', '#c5ccd9'],
    body: {
      color: '#0b0c10',
      roughness: 0.24,
      metalness: 0.32,
      clearcoat: 1.0,
      clearcoatRoughness: 0.04,
      reflectivity: 0.6,
      sheen: 0.25,
      sheenColor: '#1f2937'
    },
    pip: {
      color: '#dce6ff',
      metalness: 0.74,
      roughness: 0.18,
      clearcoat: 0.55,
      clearcoatRoughness: 0.03,
      emissive: '#6b87ff',
      emissiveIntensity: 0.08,
      sheen: 0.18
    },
    accent: {
      color: '#d7dce3',
      emissive: '#5b636f',
      emissiveIntensity: 0.38,
      metalness: 1.0,
      roughness: 0.14,
      reflectivity: 1.0,
      ringInner: 0.106,
      ringOuter: 0.124
    }
  },
  {
    id: 'midnightRose',
    label: 'Midnight Rose',
    preview: ['#0d1533', '#c27c6a'],
    body: {
      color: '#101b38',
      roughness: 0.2,
      metalness: 0.26,
      clearcoat: 1.0,
      clearcoatRoughness: 0.04,
      reflectivity: 0.66,
      sheen: 0.42,
      sheenColor: '#27446d'
    },
    pip: {
      color: '#f1f2f8',
      metalness: 0.35,
      roughness: 0.14,
      clearcoat: 0.5,
      clearcoatRoughness: 0.05,
      emissive: '#2a3f63',
      emissiveIntensity: 0.1,
      sheen: 0.2
    },
    accent: {
      color: '#c27c6a',
      emissive: '#5b3126',
      emissiveIntensity: 0.46,
      metalness: 1.0,
      roughness: 0.18,
      reflectivity: 1.0,
      ringInner: 0.105,
      ringOuter: 0.123
    }
  },
  {
    id: 'auroraJade',
    label: 'Aurora Jade',
    preview: ['#0e3b2c', '#d0b58f'],
    body: {
      color: '#0e3b2c',
      roughness: 0.22,
      metalness: 0.28,
      clearcoat: 1.0,
      clearcoatRoughness: 0.05,
      reflectivity: 0.68,
      sheen: 0.36,
      sheenColor: '#1c6d53'
    },
    pip: {
      color: '#f1f5f2',
      metalness: 0.42,
      roughness: 0.16,
      clearcoat: 0.55,
      clearcoatRoughness: 0.04,
      emissive: '#215544',
      emissiveIntensity: 0.08,
      sheen: 0.16
    },
    accent: {
      color: '#d0b58f',
      emissive: '#7a5b36',
      emissiveIntensity: 0.44,
      metalness: 0.92,
      roughness: 0.19,
      reflectivity: 0.96,
      ringInner: 0.104,
      ringOuter: 0.121
    }
  },
  {
    id: 'frostedOpal',
    label: 'Frosted Opal',
    preview: ['#e8eef4', '#7a93d2'],
    body: {
      color: '#e8eef4',
      roughness: 0.18,
      metalness: 0.22,
      clearcoat: 1.0,
      clearcoatRoughness: 0.05,
      reflectivity: 0.7,
      sheen: 0.4,
      sheenColor: '#ffffff'
    },
    pip: {
      color: '#182235',
      metalness: 0.58,
      roughness: 0.2,
      clearcoat: 0.55,
      clearcoatRoughness: 0.04,
      emissive: '#1c3a6b',
      emissiveIntensity: 0.09,
      sheen: 0.18
    },
    accent: {
      color: '#7a93d2',
      emissive: '#31497a',
      emissiveIntensity: 0.42,
      metalness: 0.95,
      roughness: 0.17,
      reflectivity: 1.0,
      ringInner: 0.106,
      ringOuter: 0.123
    }
  }
]);

const TABLE_SETUP_SECTIONS = [
  { key: "tableWood", label: "Table Wood", options: TABLE_WOOD_OPTIONS },
  { key: "tableCloth", label: "Table Cloth", options: TABLE_CLOTH_OPTIONS },
  { key: "tableBase", label: "Bazamenti", options: TABLE_BASE_OPTIONS },
  { key: "dominoStyle", label: "Domino", options: DOMINO_STYLE_OPTIONS },
  { key: "chairTheme", label: "Stolat", options: CHAIR_THEME_OPTIONS }
];

const DEFAULT_APPEARANCE = { tableWood: 0, tableCloth: 1, tableBase: 0, dominoStyle: 0, chairTheme: 0 };
const APPEARANCE_STORAGE_KEY = "dominoRoyalArenaAppearanceV2";
const LEGACY_APPEARANCE_KEYS = ["dominoRoyalArenaAppearance"];
let appearance = { ...DEFAULT_APPEARANCE };

function normalizeAppearance(raw) {
  const normalized = { ...DEFAULT_APPEARANCE };
  const source = raw && typeof raw === "object" ? raw : {};
  const limits = [
    ["tableWood", TABLE_WOOD_OPTIONS.length],
    ["tableCloth", TABLE_CLOTH_OPTIONS.length],
    ["tableBase", TABLE_BASE_OPTIONS.length],
    ["dominoStyle", DOMINO_STYLE_OPTIONS.length],
    ["chairTheme", CHAIR_THEME_OPTIONS.length]
  ];
  limits.forEach(([key, max]) => {
    const value = Number(source[key]);
    if (Number.isFinite(value)) {
      normalized[key] = Math.min(Math.max(0, Math.round(value)), Math.max(0, max - 1));
    }
  });
  return normalized;
}

try {
  const keysToCheck = [APPEARANCE_STORAGE_KEY, ...LEGACY_APPEARANCE_KEYS];
  for (const key of keysToCheck) {
    const stored = window.localStorage?.getItem(key);
    if (!stored) continue;
    const parsed = JSON.parse(stored);
    if (parsed && typeof parsed === "object") {
      appearance = normalizeAppearance({ ...appearance, ...parsed });
      if (key !== APPEARANCE_STORAGE_KEY) {
        window.localStorage?.setItem(APPEARANCE_STORAGE_KEY, JSON.stringify(appearance));
      }
      break;
    }
  }
  appearance = normalizeAppearance(appearance);
} catch (error) {
  console.warn("Failed to load Domino Royal appearance", error);
  appearance = normalizeAppearance(appearance);
}

function adjustHexColor(hex, amount) {
  const base = new THREE.Color(hex);
  const target = amount >= 0 ? new THREE.Color(0xffffff) : new THREE.Color(0x000000);
  base.lerp(target, Math.min(Math.abs(amount), 1));
  return `#${base.getHexString()}`;
}

function createCarbonFiberTexture(
  renderer,
  {
    tile = 4,
    primary = '#171c24',
    secondary = '#10141c',
    highlight = 'rgba(255, 255, 255, 0.08)'
  } = {}
) {
  if (typeof document === 'undefined') {
    return null;
  }

  const size = 256;
  const canvas = document.createElement('canvas');
  canvas.width = canvas.height = size;
  const ctx = canvas.getContext('2d');

  ctx.fillStyle = secondary;
  ctx.fillRect(0, 0, size, size);

  const cell = size / 16;
  for (let y = 0; y < size; y += cell) {
    for (let x = 0; x < size; x += cell) {
      const evenCell = ((x + y) / cell) % 2 === 0;
      ctx.fillStyle = evenCell ? primary : secondary;
      ctx.fillRect(x, y, cell, cell);

      ctx.fillStyle = evenCell ? 'rgba(255, 255, 255, 0.05)' : 'rgba(0, 0, 0, 0.25)';
      ctx.beginPath();
      ctx.moveTo(x, y + cell * 0.15);
      ctx.lineTo(x + cell * 0.85, y + cell);
      ctx.lineTo(x + cell, y + cell * 0.85);
      ctx.lineTo(x + cell * 0.15, y);
      ctx.closePath();
      ctx.fill();
    }
  }

  ctx.globalAlpha = 0.35;
  ctx.strokeStyle = highlight;
  ctx.lineWidth = cell * 0.18;
  for (let offset = -size; offset <= size * 2; offset += cell * 2) {
    ctx.beginPath();
    ctx.moveTo(offset, 0);
    ctx.lineTo(offset + size, size);
    ctx.stroke();
  }

  ctx.globalAlpha = 0.2;
  ctx.strokeStyle = 'rgba(0, 0, 0, 0.7)';
  for (let offset = -size; offset <= size * 2; offset += cell * 2) {
    ctx.beginPath();
    ctx.moveTo(offset + cell, 0);
    ctx.lineTo(offset + size + cell, size);
    ctx.stroke();
  }

  ctx.globalAlpha = 1;

  const texture = new THREE.CanvasTexture(canvas);
  texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
  texture.repeat.set(tile, tile);
  const maxAnisotropy =
    (renderer?.capabilities && typeof renderer.capabilities.getMaxAnisotropy === 'function'
      ? renderer.capabilities.getMaxAnisotropy()
      : renderer?.capabilities?.anisotropy) || 4;
  texture.anisotropy = Math.min(maxAnisotropy, 16);
  texture.colorSpace = THREE.SRGBColorSpace;
  texture.needsUpdate = true;
  return texture;
}

function createChairClothTexture(option, renderer) {
  if (typeof document === "undefined") {
    return null;
  }
  const primary = option?.seatColor ?? "#8b0000";
  const accent = adjustHexColor(primary, -0.28);
  const highlight = option?.highlight ?? adjustHexColor(primary, 0.22);
  const canvas = document.createElement("canvas");
  canvas.width = canvas.height = CHAIR_CLOTH_TEXTURE_SIZE;
  const ctx = canvas.getContext("2d");
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  const shadow = adjustHexColor(accent, -0.22);
  const seam = adjustHexColor(accent, -0.35);

  const gradient = ctx.createLinearGradient(0, 0, canvas.width, canvas.height);
  gradient.addColorStop(0, adjustHexColor(primary, 0.2));
  gradient.addColorStop(0.5, primary);
  gradient.addColorStop(1, accent);
  ctx.fillStyle = gradient;
  ctx.fillRect(0, 0, canvas.width, canvas.height);

  const spacing = canvas.width / CHAIR_CLOTH_REPEAT;
  const halfSpacing = spacing / 2;
  const lineWidth = Math.max(1.6, spacing * 0.06);

  ctx.strokeStyle = seam;
  ctx.lineWidth = lineWidth;
  ctx.globalAlpha = 0.9;
  for (let offset = -canvas.height; offset <= canvas.width + canvas.height; offset += spacing) {
    ctx.beginPath();
    ctx.moveTo(offset, 0);
    ctx.lineTo(offset - canvas.height, canvas.height);
    ctx.stroke();

    ctx.beginPath();
    ctx.moveTo(offset, 0);
    ctx.lineTo(offset + canvas.height, canvas.height);
    ctx.stroke();
  }
  ctx.globalAlpha = 1;

  ctx.strokeStyle = adjustHexColor(highlight, 0.18);
  ctx.lineWidth = lineWidth * 0.55;
  ctx.globalAlpha = 0.55;
  for (let offset = -canvas.height; offset <= canvas.width + canvas.height; offset += spacing) {
    ctx.beginPath();
    ctx.moveTo(offset + halfSpacing, 0);
    ctx.lineTo(offset + halfSpacing - canvas.height, canvas.height);
    ctx.stroke();

    ctx.beginPath();
    ctx.moveTo(offset + halfSpacing, 0);
    ctx.lineTo(offset + halfSpacing + canvas.height, canvas.height);
    ctx.stroke();
  }
  ctx.globalAlpha = 1;

  ctx.fillStyle = "rgba(0, 0, 0, 0.28)";
  const tuftRadius = Math.max(1.8, spacing * 0.08);
  for (let y = -spacing; y <= canvas.height + spacing; y += spacing) {
    for (let x = -spacing; x <= canvas.width + spacing; x += spacing) {
      ctx.beginPath();
      ctx.ellipse(x + halfSpacing, y + halfSpacing, tuftRadius, tuftRadius * 0.85, 0, 0, Math.PI * 2);
      ctx.fill();
    }
  }

  ctx.save();
  ctx.globalCompositeOperation = "overlay";
  const sheenGradient = ctx.createRadialGradient(
    canvas.width * 0.28,
    canvas.height * 0.32,
    canvas.width * 0.05,
    canvas.width * 0.28,
    canvas.height * 0.32,
    canvas.width * 0.75
  );
  sheenGradient.addColorStop(0, "rgba(255, 255, 255, 0.26)");
  sheenGradient.addColorStop(0.5, "rgba(255, 255, 255, 0.08)");
  sheenGradient.addColorStop(1, "rgba(0, 0, 0, 0.35)");
  ctx.fillStyle = sheenGradient;
  ctx.fillRect(0, 0, canvas.width, canvas.height);
  ctx.restore();

  ctx.globalAlpha = 0.08;
  for (let y = 0; y < canvas.height; y += 2) {
    for (let x = 0; x < canvas.width; x += 2) {
      ctx.fillStyle = Math.random() > 0.5 ? highlight : shadow;
      ctx.fillRect(x, y, 1, 1);
    }
  }
  ctx.globalAlpha = 1;

  const texture = new THREE.CanvasTexture(canvas);
  texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
  texture.repeat.set(CHAIR_CLOTH_REPEAT, CHAIR_CLOTH_REPEAT);
  texture.anisotropy = renderer?.capabilities?.getMaxAnisotropy?.() ?? 8;
  texture.colorSpace = THREE.SRGBColorSpace;
  texture.needsUpdate = true;
  return texture;
}

function createChairFabricMaterial(option, renderer) {
  const texture = createChairClothTexture(option, renderer);
  const primary = option?.seatColor ?? "#8b0000";
  const sheenColor = option?.highlight ?? adjustHexColor(primary, 0.2);
  const material = new THREE.MeshPhysicalMaterial({
    color: new THREE.Color(adjustHexColor(primary, 0.04)),
    map: texture,
    roughness: 0.28,
    metalness: 0.08,
    clearcoat: 0.48,
    clearcoatRoughness: 0.28,
    sheen: 0.18
  });
  if ("sheenColor" in material) {
    material.sheenColor.set(sheenColor);
  }
  if ("sheenRoughness" in material) {
    material.sheenRoughness = 0.32;
  }
  if ("specularIntensity" in material) {
    material.specularIntensity = 0.65;
  }
  return material;
}

const CHAIR_DIMENSIONS = Object.freeze({
  seatWidth: SEAT_WIDTH,
  seatDepth: SEAT_DEPTH,
  seatThickness: SEAT_THICKNESS,
  backHeight: BACK_HEIGHT,
  backThickness: BACK_THICKNESS,
  armHeight: ARM_HEIGHT,
  armThickness: ARM_THICKNESS,
  armDepth: ARM_DEPTH,
  columnHeight: COLUMN_HEIGHT,
  baseThickness: BASE_THICKNESS,
  columnRadiusTop: COLUMN_RADIUS_TOP,
  columnRadiusBottom: COLUMN_RADIUS_BOTTOM,
  baseRadius: BASE_RADIUS,
  footRingRadius: FOOT_RING_RADIUS,
  footRingTube: FOOT_RING_TUBE
});

function createDominoChair(option, renderer, sharedMaterials = null) {
  const material = sharedMaterials?.fabric ?? createChairFabricMaterial(option, renderer);
  const legMaterial = sharedMaterials?.leg ??
    new THREE.MeshStandardMaterial({
      color: new THREE.Color(option?.legColor ?? "#1f1f1f"),
      metalness: 0.6,
      roughness: 0.35
    });
  const metalAccent = sharedMaterials?.accent ??
    new THREE.MeshStandardMaterial({
      color: new THREE.Color("#2a2a2a"),
      metalness: 0.75,
      roughness: 0.32
    });

  const group = new THREE.Group();
  const dims = CHAIR_DIMENSIONS;

  const base = new THREE.Mesh(new THREE.CylinderGeometry(dims.baseRadius, dims.baseRadius * 1.02, dims.baseThickness, 32), legMaterial);
  base.position.y = dims.baseThickness / 2;
  base.castShadow = true;
  base.receiveShadow = true;
  group.add(base);

  const column = new THREE.Mesh(
    new THREE.CylinderGeometry(dims.columnRadiusBottom, dims.columnRadiusTop, dims.columnHeight, 24),
    legMaterial
  );
  column.position.y = dims.baseThickness + dims.columnHeight / 2;
  column.castShadow = true;
  column.receiveShadow = true;
  group.add(column);

  const footRing = new THREE.Mesh(new THREE.TorusGeometry(dims.footRingRadius, dims.footRingTube, 16, 48), metalAccent);
  footRing.rotation.x = Math.PI / 2;
  footRing.position.y = dims.baseThickness + dims.columnHeight * 0.45;
  footRing.castShadow = true;
  group.add(footRing);

  const seat = new THREE.Mesh(
    new THREE.BoxGeometry(dims.seatWidth, dims.seatThickness, dims.seatDepth),
    material
  );
  seat.position.y = dims.baseThickness + dims.columnHeight + dims.seatThickness / 2;
  seat.castShadow = true;
  seat.receiveShadow = true;
  group.add(seat);

  const cushion = new THREE.Mesh(
    new THREE.BoxGeometry(dims.seatWidth * 0.92, dims.seatThickness * 0.6, dims.seatDepth * 0.92),
    material
  );
  cushion.position.y = seat.position.y + dims.seatThickness * 0.2;
  cushion.castShadow = true;
  cushion.receiveShadow = true;
  group.add(cushion);

  const back = new THREE.Mesh(
    new THREE.BoxGeometry(dims.seatWidth * 0.98, dims.backHeight, dims.backThickness),
    material
  );
  back.position.set(0, seat.position.y + dims.backHeight / 2 - dims.seatThickness / 2, dims.seatDepth / 2 - dims.backThickness / 2);
  back.castShadow = true;
  back.receiveShadow = true;
  group.add(back);

  const armGeo = new THREE.BoxGeometry(dims.armThickness, dims.armHeight, dims.armDepth);
  const armY = seat.position.y + dims.armHeight / 2 - dims.seatThickness * 0.25;
  const armOffsetZ = (dims.armDepth - dims.seatDepth) / 2;
  const armLeft = new THREE.Mesh(armGeo, material);
  armLeft.position.set(-dims.seatWidth / 2 + dims.armThickness / 2, armY, armOffsetZ);
  armLeft.castShadow = true;
  armLeft.receiveShadow = true;
  group.add(armLeft);
  const armRight = new THREE.Mesh(armGeo, material);
  armRight.position.set(dims.seatWidth / 2 - dims.armThickness / 2, armY, armOffsetZ);
  armRight.castShadow = true;
  armRight.receiveShadow = true;
  group.add(armRight);

  const armCapGeo = new THREE.BoxGeometry(dims.armThickness * 0.9, dims.armThickness * 0.35, dims.armDepth * 0.92);
  const armCapY = armY + dims.armHeight / 2 - (dims.armThickness * 0.35) / 2;
  const armCapLeft = new THREE.Mesh(armCapGeo, material);
  armCapLeft.position.set(armLeft.position.x, armCapY, armOffsetZ * 0.94);
  armCapLeft.castShadow = true;
  armCapLeft.receiveShadow = true;
  group.add(armCapLeft);
  const armCapRight = new THREE.Mesh(armCapGeo, material);
  armCapRight.position.set(armRight.position.x, armCapY, armOffsetZ * 0.94);
  armCapRight.castShadow = true;
  armCapRight.receiveShadow = true;
  group.add(armCapRight);

  const columnCap = new THREE.Mesh(new THREE.CylinderGeometry(dims.columnRadiusTop * 1.05, dims.columnRadiusTop * 1.05, 0.02, 24), metalAccent);
  columnCap.position.y = dims.baseThickness + dims.columnHeight + 0.01;
  columnCap.castShadow = true;
  columnCap.receiveShadow = true;
  group.add(columnCap);

  return group;
}

/* ---------- World / Groups ---------- */
const arenaG = new THREE.Group();
scene.add(arenaG);

const tableG = new THREE.Group();
arenaG.add(tableG);
tableG.rotation.y = 0;
const piecesG = new THREE.Group();
tableG.add(piecesG);

/* ---------- Arena Dressings (Carpet & Walls) ---------- */
const floor = new THREE.Mesh(
  new THREE.CircleGeometry(FLOOR_RADIUS, 96),
  new THREE.MeshStandardMaterial({ color: 0x0b1120, roughness: 0.92, metalness: 0.12 })
);
floor.rotation.x = -Math.PI / 2;
floor.position.y = 0;
floor.receiveShadow = true;
arenaG.add(floor);

const carpetTextures = getPoolCarpetTextures(renderer);
// Match Pool Royale's red carpet finish.
const carpetMat = new THREE.MeshStandardMaterial({
  color: 0x8c2a2e,
  roughness: 0.9,
  metalness: 0.025
});
if (carpetTextures.map) {
  carpetMat.map = carpetTextures.map;
  carpetMat.map.needsUpdate = true;
  carpetMat.map.repeat.set(5, 5);
}
if (carpetTextures.bump) {
  carpetMat.bumpMap = carpetTextures.bump;
  carpetMat.bumpScale = 0.18;
  carpetMat.bumpMap.needsUpdate = true;
  carpetMat.bumpMap.repeat.set(5, 5);
}
const carpet = new THREE.Mesh(new THREE.CircleGeometry(CARPET_RADIUS, 96), carpetMat);
carpet.rotation.x = -Math.PI / 2;
carpet.position.y = 0.01;
carpet.receiveShadow = true;
arenaG.add(carpet);

// Align the arena walls with Pool Royale's light blue tone.
const wallMaterial = new THREE.MeshStandardMaterial({
  color: 0xb9ddff,
  roughness: 0.88,
  metalness: 0.06,
  side: THREE.DoubleSide
});
const wall = new THREE.Mesh(
  new THREE.CylinderGeometry(
    ARENA_WALL_INNER_RADIUS,
    ARENA_WALL_INNER_RADIUS * 1.02,
    ARENA_WALL_HEIGHT,
    80,
    1,
    true
  ),
  wallMaterial
);
wall.position.y = ARENA_WALL_CENTER_Y;
wall.receiveShadow = false;
wall.castShadow = false;
arenaG.add(wall);

const ARENA_DOOR_DIMENSIONS = Object.freeze({ width: 2.8, height: 3.4, thickness: 0.12 });
const carbonFiberTextureBase = createCarbonFiberTexture(renderer, { tile: 4.5 });
const hallwayDoorTexture = carbonFiberTextureBase ? carbonFiberTextureBase.clone() : null;
if (hallwayDoorTexture) {
  hallwayDoorTexture.repeat.set(2.6, 2.8);
  hallwayDoorTexture.needsUpdate = true;
}
const hallwayDoorMaterialConfig = {
  color: 0x1a1f26,
  roughness: 0.32,
  metalness: 0.55,
  envMapIntensity: 1.05
};
if (hallwayDoorTexture) {
  hallwayDoorMaterialConfig.map = hallwayDoorTexture;
}
const hallwayDoorMaterial = new THREE.MeshStandardMaterial(hallwayDoorMaterialConfig);
const hallwayHandleMaterial = new THREE.MeshStandardMaterial({
  color: 0xffd87c,
  metalness: 1,
  roughness: 0.18,
  emissive: 0xffeab5,
  emissiveIntensity: 0.28
});
const hallwayDoorZ = ARENA_WALL_INNER_RADIUS - ARENA_DOOR_DIMENSIONS.thickness * 0.5;
const hallwayDoorPivot = new THREE.Group();
hallwayDoorPivot.position.set(-ARENA_DOOR_DIMENSIONS.width / 2, ARENA_DOOR_DIMENSIONS.height / 2, hallwayDoorZ);

const hallwayDoor = new THREE.Mesh(
  new THREE.BoxGeometry(
    ARENA_DOOR_DIMENSIONS.width,
    ARENA_DOOR_DIMENSIONS.height,
    ARENA_DOOR_DIMENSIONS.thickness
  ),
  hallwayDoorMaterial
);
hallwayDoor.castShadow = true;
hallwayDoor.receiveShadow = true;
hallwayDoor.position.set(ARENA_DOOR_DIMENSIONS.width / 2, 0, 0);
hallwayDoorPivot.add(hallwayDoor);

const hallwayHandlePlate = new THREE.Mesh(
  new THREE.BoxGeometry(0.16, 0.46, 0.02),
  new THREE.MeshStandardMaterial({
    color: 0xffd87c,
    metalness: 0.95,
    roughness: 0.18,
    emissive: 0xffe6aa,
    emissiveIntensity: 0.32
  })
);
hallwayHandlePlate.position.set(
  ARENA_DOOR_DIMENSIONS.width - 0.6,
  -0.35,
  ARENA_DOOR_DIMENSIONS.thickness / 2 - 0.005
);
hallwayHandlePlate.castShadow = false;
hallwayHandlePlate.receiveShadow = false;
hallwayDoor.add(hallwayHandlePlate);

const hallwayHandle = new THREE.Mesh(new THREE.CylinderGeometry(0.05, 0.05, 0.3, 24), hallwayHandleMaterial);
hallwayHandle.rotation.z = Math.PI / 2;
hallwayHandle.position.set(ARENA_DOOR_DIMENSIONS.width - 0.6, -0.35, ARENA_DOOR_DIMENSIONS.thickness / 2 + 0.03);
hallwayHandle.castShadow = true;
hallwayHandle.receiveShadow = false;
hallwayDoor.add(hallwayHandle);

const hallwayDoorFrame = new THREE.Mesh(
  new THREE.BoxGeometry(
    ARENA_DOOR_DIMENSIONS.width + 0.32,
    ARENA_DOOR_DIMENSIONS.height + 0.28,
    ARENA_DOOR_DIMENSIONS.thickness * 0.8
  ),
  new THREE.MeshStandardMaterial({
    color: 0xf2d79b,
    roughness: 0.18,
    metalness: 0.94,
    emissive: 0xffe4b5,
    emissiveIntensity: 0.4
  })
);
hallwayDoorFrame.position.set(ARENA_DOOR_DIMENSIONS.width / 2, 0, -ARENA_DOOR_DIMENSIONS.thickness * 0.45);
hallwayDoorFrame.castShadow = false;
hallwayDoorFrame.receiveShadow = false;
hallwayDoorPivot.add(hallwayDoorFrame);

const hallwayDoorGroup = new THREE.Group();
hallwayDoorGroup.add(hallwayDoorPivot);
arenaG.add(hallwayDoorGroup);

const ARENA_WALKWAY_LENGTH = 14;
const ARENA_WALKWAY_WIDTH = 4.2;
const walkwayFloorMaterial = new THREE.MeshStandardMaterial({
  color: 0x08090f,
  roughness: 0.24,
  metalness: 0.72,
  envMapIntensity: 1.1
});
const walkwayFloor = new THREE.Mesh(
  new THREE.PlaneGeometry(ARENA_WALKWAY_WIDTH, ARENA_WALKWAY_LENGTH),
  walkwayFloorMaterial
);
walkwayFloor.rotation.x = -Math.PI / 2;
walkwayFloor.position.set(
  0,
  0.005,
  hallwayDoorZ + ARENA_WALKWAY_LENGTH / 2 - ARENA_DOOR_DIMENSIONS.thickness * 0.5
);
walkwayFloor.receiveShadow = true;
arenaG.add(walkwayFloor);

const walkwayRunnerMaterialConfig = {
  color: new THREE.Color(carpetMat.color.getHex()),
  roughness: carpetMat.roughness,
  metalness: carpetMat.metalness
};
if (carpetTextures.map) {
  const walkwayMap = carpetTextures.map.clone();
  walkwayMap.wrapS = walkwayMap.wrapT = THREE.RepeatWrapping;
  walkwayMap.repeat.set(ARENA_WALKWAY_WIDTH / 1.6, ARENA_WALKWAY_LENGTH / 3.2);
  walkwayMap.colorSpace = THREE.SRGBColorSpace;
  walkwayMap.needsUpdate = true;
  walkwayRunnerMaterialConfig.map = walkwayMap;
}
if (carpetTextures.bump) {
  const walkwayBump = carpetTextures.bump.clone();
  walkwayBump.wrapS = walkwayBump.wrapT = THREE.RepeatWrapping;
  walkwayBump.repeat.set(ARENA_WALKWAY_WIDTH / 1.6, ARENA_WALKWAY_LENGTH / 3.2);
  walkwayBump.needsUpdate = true;
  walkwayRunnerMaterialConfig.bumpMap = walkwayBump;
  walkwayRunnerMaterialConfig.bumpScale = 0.18;
}
const walkwayRunner = new THREE.Mesh(
  new THREE.PlaneGeometry(ARENA_WALKWAY_WIDTH * 0.42, ARENA_WALKWAY_LENGTH * 0.92),
  new THREE.MeshStandardMaterial(walkwayRunnerMaterialConfig)
);
walkwayRunner.rotation.x = -Math.PI / 2;
walkwayRunner.position.set(0, walkwayFloor.position.y + 0.008, walkwayFloor.position.z);
walkwayRunner.receiveShadow = true;
arenaG.add(walkwayRunner);

const walkwayTrimMat = new THREE.MeshStandardMaterial({
  color: 0xba7c2c,
  roughness: 0.26,
  metalness: 0.88,
  emissive: 0xffc978,
  emissiveIntensity: 0.25
});
const walkwayTrimGeo = new THREE.BoxGeometry(ARENA_WALKWAY_WIDTH + 0.2, 0.12, 0.4);
const walkwayFrontTrim = new THREE.Mesh(walkwayTrimGeo, walkwayTrimMat);
walkwayFrontTrim.position.set(0, 0.06, hallwayDoorZ - 0.2);
walkwayFrontTrim.castShadow = false;
walkwayFrontTrim.receiveShadow = false;
arenaG.add(walkwayFrontTrim);
const walkwayOuterTrim = walkwayFrontTrim.clone();
walkwayOuterTrim.position.z = walkwayFloor.position.z + ARENA_WALKWAY_LENGTH / 2 - 0.2;
arenaG.add(walkwayOuterTrim);

const walkwaySideGeo = new THREE.BoxGeometry(0.35, 1.2, ARENA_WALKWAY_LENGTH);
const walkwayWallTexture = textureLoader.load(
  'https://images.unsplash.com/photo-1549187774-b4e9b0445b41?auto=format&fit=crop&w=1600&q=80'
);
walkwayWallTexture.wrapS = THREE.RepeatWrapping;
walkwayWallTexture.wrapT = THREE.RepeatWrapping;
walkwayWallTexture.colorSpace = THREE.SRGBColorSpace;
walkwayWallTexture.repeat.set(ARENA_WALKWAY_LENGTH / 2.2, 1.4);
const walkwaySideMat = new THREE.MeshStandardMaterial({
  map: walkwayWallTexture,
  roughness: 0.48,
  metalness: 0.4,
  envMapIntensity: 0.8
});
const walkwaySideAccentGeo = new THREE.BoxGeometry(0.12, 0.9, ARENA_WALKWAY_LENGTH - 0.6);
const walkwaySideAccentMat = new THREE.MeshStandardMaterial({
  color: 0x321c46,
  roughness: 0.32,
  metalness: 0.58,
  emissive: 0xffb964,
  emissiveIntensity: 0.4
});
const walkwaySideCrownGeo = new THREE.BoxGeometry(0.38, 0.1, ARENA_WALKWAY_LENGTH);
const walkwaySideCrownMat = new THREE.MeshStandardMaterial({
  color: 0xf2c36b,
  roughness: 0.22,
  metalness: 0.94
});

function createWalkwaySide(offsetX) {
  const sideGroup = new THREE.Group();
  const base = new THREE.Mesh(walkwaySideGeo, walkwaySideMat);
  base.castShadow = true;
  base.receiveShadow = true;
  sideGroup.add(base);

  const accent = new THREE.Mesh(walkwaySideAccentGeo, walkwaySideAccentMat);
  accent.position.set(offsetX > 0 ? -0.11 : 0.11, 0, 0);
  accent.castShadow = false;
  accent.receiveShadow = true;
  sideGroup.add(accent);

  const crown = new THREE.Mesh(walkwaySideCrownGeo, walkwaySideCrownMat);
  crown.position.y = 0.55;
  crown.castShadow = true;
  crown.receiveShadow = false;
  sideGroup.add(crown);

  const lightStripGeo = new THREE.BoxGeometry(0.18, 0.08, ARENA_WALKWAY_LENGTH - 0.4);
  const lightStripMat = new THREE.MeshStandardMaterial({
    color: 0xffd27e,
    emissive: 0xfff1b5,
    emissiveIntensity: 0.85,
    metalness: 0.7,
    roughness: 0.18
  });
  const lightStrip = new THREE.Mesh(lightStripGeo, lightStripMat);
  lightStrip.position.set(offsetX > 0 ? -0.14 : 0.14, -0.25, 0);
  lightStrip.castShadow = false;
  lightStrip.receiveShadow = false;
  sideGroup.add(lightStrip);

  sideGroup.position.set(offsetX, 0.6, walkwayFloor.position.z);
  arenaG.add(sideGroup);
  return sideGroup;
}

const walkwaySideLeft = createWalkwaySide(-ARENA_WALKWAY_WIDTH / 2 - 0.175);
const walkwaySideRight = createWalkwaySide(ARENA_WALKWAY_WIDTH / 2 + 0.175);

const walkwayPortalHeaderTexture = carbonFiberTextureBase ? carbonFiberTextureBase.clone() : null;
if (walkwayPortalHeaderTexture) {
  walkwayPortalHeaderTexture.repeat.set((ARENA_WALKWAY_WIDTH + 0.4) / 1.4, 1.6);
  walkwayPortalHeaderTexture.needsUpdate = true;
}
const walkwayPortalHeaderMaterialConfig = {
  color: 0x1c1f26,
  metalness: 0.68,
  roughness: 0.28,
  emissive: 0x140812,
  emissiveIntensity: 0.35,
  envMapIntensity: 0.9
};
if (walkwayPortalHeaderTexture) {
  walkwayPortalHeaderMaterialConfig.map = walkwayPortalHeaderTexture;
}
const walkwayPortalHeader = new THREE.Mesh(
  new THREE.BoxGeometry(ARENA_WALKWAY_WIDTH + 0.4, 0.22, 0.5),
  new THREE.MeshStandardMaterial(walkwayPortalHeaderMaterialConfig)
);
walkwayPortalHeader.position.set(0, 1.42, hallwayDoorZ - 0.05);
walkwayPortalHeader.castShadow = true;
arenaG.add(walkwayPortalHeader);

const walkwayPortalCrown = new THREE.Mesh(
  new THREE.TorusGeometry((ARENA_WALKWAY_WIDTH + 0.4) / 2, 0.05, 16, 48),
  new THREE.MeshStandardMaterial({
    color: 0xf7d891,
    emissive: 0xffeeba,
    emissiveIntensity: 0.6,
    metalness: 0.92,
    roughness: 0.15
  })
);
walkwayPortalCrown.rotation.x = Math.PI / 2;
walkwayPortalCrown.position.set(0, 1.52, hallwayDoorZ - 0.12);
walkwayPortalCrown.castShadow = false;
arenaG.add(walkwayPortalCrown);

const walkwayCeiling = new THREE.Mesh(
  new THREE.PlaneGeometry(ARENA_WALKWAY_WIDTH + 0.8, ARENA_WALKWAY_LENGTH + 1.2),
  new THREE.MeshStandardMaterial({
    color: 0x18111f,
    side: THREE.DoubleSide,
    roughness: 0.35,
    metalness: 0.45,
    emissive: 0x1a0a13,
    emissiveIntensity: 0.28
  })
);
walkwayCeiling.rotation.x = Math.PI / 2;
walkwayCeiling.position.set(0, 1.95, walkwayFloor.position.z);
walkwayCeiling.receiveShadow = false;
arenaG.add(walkwayCeiling);

const chandelier = new THREE.Group();
const chandelierRing = new THREE.Mesh(
  new THREE.TorusGeometry(0.95, 0.08, 24, 64),
  new THREE.MeshStandardMaterial({
    color: 0xf2d79b,
    emissive: 0xfff0c5,
    emissiveIntensity: 0.8,
    metalness: 0.9,
    roughness: 0.18
  })
);
chandelier.add(chandelierRing);
const chandelierCore = new THREE.Mesh(
  new THREE.CylinderGeometry(0.08, 0.16, 0.6, 24),
  new THREE.MeshStandardMaterial({
    color: 0x21142d,
    metalness: 0.65,
    roughness: 0.28,
    emissive: 0x110712,
    emissiveIntensity: 0.3
  })
);
chandelierCore.position.y = -0.35;
chandelier.add(chandelierCore);
chandelier.position.set(0, walkwayCeiling.position.y - 0.18, walkwayFloor.position.z);
arenaG.add(chandelier);

const walkwayFrontLight = new THREE.Mesh(
  new THREE.BoxGeometry(ARENA_WALKWAY_WIDTH + 0.25, 0.08, 0.12),
  new THREE.MeshStandardMaterial({
    color: 0xffd89a,
    emissive: 0xffecb3,
    emissiveIntensity: 0.9,
    metalness: 0.78,
    roughness: 0.22
  })
);
walkwayFrontLight.position.set(0, 0.18, hallwayDoorZ + 0.18);
arenaG.add(walkwayFrontLight);
const walkwayRearLight = walkwayFrontLight.clone();
walkwayRearLight.position.z = walkwayFloor.position.z + ARENA_WALKWAY_LENGTH / 2 - 0.25;
arenaG.add(walkwayRearLight);

const hallwayAmbient = new THREE.PointLight(0xffe2b5, 1.3, 18, 1.8);
hallwayAmbient.position.set(0, walkwayCeiling.position.y - 0.05, walkwayFloor.position.z);
hallwayAmbient.castShadow = true;
arenaG.add(hallwayAmbient);

const hallwayDoorState = {
  pivot: hallwayDoorPivot,
  openAngle: THREE.MathUtils.degToRad(100),
  closedAngle: 0
};
const walkwayFarZ = walkwayFloor.position.z + ARENA_WALKWAY_LENGTH / 2;
const walkwayEntryZ = walkwayFarZ + 1.5;

function easeInOutCubic(t) {
  if (t <= 0) return 0;
  if (t >= 1) return 1;
  return t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;
}

let entrySequenceActive = false;
let entryStartTime = 0;
let entryCameraCurve = null;
let entryTargetCurve = null;
const ENTRY_TOTAL_DURATION = 6500;
const ENTRY_SEAT_REMOVAL_PROGRESS = 0.78;

function configureEntryCurves(finalPosition) {
  const approachHeight = 1.55;
  const interiorHeight = CHAIR_BASE_HEIGHT + SEAT_THICKNESS + 0.35;
  entryCameraCurve = new THREE.CatmullRomCurve3(
    [
      new THREE.Vector3(0, approachHeight, walkwayEntryZ),
      new THREE.Vector3(0, approachHeight, hallwayDoorZ + 0.6),
      new THREE.Vector3(0, interiorHeight, hallwayDoorZ - 3.4),
      finalPosition.clone()
    ],
    false,
    'catmullrom',
    0.45
  );
  entryTargetCurve = new THREE.CatmullRomCurve3(
    [
      new THREE.Vector3(0, 1.35, hallwayDoorZ - 1.4),
      new THREE.Vector3(0, interiorHeight, hallwayDoorZ - 2.8),
      CAMERA_TARGET.clone()
    ],
    false,
    'catmullrom',
    0.45
  );
}

function startHallwayEntry() {
  fitCamera();
  const finalDesired = clampCameraPosition(getDesiredCameraPosition());
  configureEntryCurves(finalDesired);
  entrySequenceActive = true;
  entryStartTime = performance.now();
  controls.enabled = false;
  cameraHasUserControl = false;
  if (entryCameraCurve) {
    const startPoint = entryCameraCurve.getPoint(0);
    camera.position.copy(startPoint);
  }
  if (entryTargetCurve) {
    controls.target.copy(entryTargetCurve.getPoint(0));
  } else {
    controls.target.copy(CAMERA_TARGET);
  }
  if (hallwayDoorState) {
    hallwayDoorState.pivot.rotation.y = hallwayDoorState.closedAngle;
  }
}

function updateEntrySequence(now) {
  if (!entrySequenceActive) {
    return;
  }
  const timestamp = Number.isFinite(now) ? now : performance.now();
  const elapsed = Math.max(0, timestamp - entryStartTime);
  const progress = Math.min(elapsed / ENTRY_TOTAL_DURATION, 1);

  const doorPhase = easeInOutCubic(Math.min(progress / 0.35, 1));
  if (hallwayDoorState?.pivot) {
    const angle = THREE.MathUtils.lerp(
      hallwayDoorState.closedAngle,
      hallwayDoorState.closedAngle - hallwayDoorState.openAngle,
      doorPhase
    );
    hallwayDoorState.pivot.rotation.y = angle;
  }

  if (entryCameraCurve) {
    const cameraPhase = easeInOutCubic(Math.min(Math.max((progress - 0.05) / 0.85, 0), 1));
    const point = entryCameraCurve.getPoint(cameraPhase);
    camera.position.copy(point);
  }

  if (entryTargetCurve) {
    const targetPhase = easeInOutCubic(Math.min(Math.max((progress - 0.08) / 0.75, 0), 1));
    const targetPoint = entryTargetCurve.getPoint(targetPhase);
    controls.target.copy(targetPoint);
  }

  if (shouldRunHallwayEntry && seatLabelShouldDisplay && progress >= ENTRY_SEAT_REMOVAL_PROGRESS) {
    disposeSeatLabel();
  }

  if (progress >= 1) {
    entrySequenceActive = false;
    controls.enabled = true;
    controls.target.copy(CAMERA_TARGET);
    if (shouldRunHallwayEntry && seatLabelShouldDisplay) {
      disposeSeatLabel();
    }
    positionCameraForViewport({ force: true });
  }
}

/* ---------- Shapes & Table Build ---------- */
function createRegularPolygonShape(sides = 8, radius = 1) {
  const shape = new THREE.Shape();
  for (let i = 0; i < sides; i += 1) {
    const angle = (i / sides) * Math.PI * 2 - Math.PI / 2;
    const x = Math.cos(angle) * radius;
    const y = Math.sin(angle) * radius;
    if (i === 0) {
      shape.moveTo(x, y);
    } else {
      shape.lineTo(x, y);
    }
  }
  shape.closePath();
  return shape;
}

function makeClothTexture({ top = "#155c2a", bottom = "#0b3a1d", border = "#041f10" } = {}) {
  const size = 512;
  const canvas = document.createElement("canvas");
  canvas.width = canvas.height = size;
  const ctx = canvas.getContext("2d");
  const gradient = ctx.createLinearGradient(0, 0, size, size);
  gradient.addColorStop(0, top);
  gradient.addColorStop(1, bottom);
  ctx.fillStyle = gradient;
  ctx.fillRect(0, 0, size, size);

  ctx.save();
  ctx.globalCompositeOperation = "screen";
  const glow = ctx.createRadialGradient(size * 0.5, size * 0.45, size * 0.12, size * 0.5, size * 0.45, size * 0.6);
  glow.addColorStop(0, "rgba(255,255,255,0.25)");
  glow.addColorStop(0.65, "rgba(255,255,255,0.08)");
  glow.addColorStop(1, "rgba(255,255,255,0)");
  ctx.fillStyle = glow;
  ctx.fillRect(0, 0, size, size);
  ctx.restore();

  ctx.globalAlpha = 0.12;
  ctx.strokeStyle = border;
  ctx.lineWidth = size * 0.012;
  ctx.strokeRect(0, 0, size, size);
  ctx.globalAlpha = 1;

  ctx.globalAlpha = 0.16;
  ctx.fillStyle = "#ffffff";
  for (let i = 0; i < size; i += 6) {
    ctx.fillRect(i, 0, 1, size);
    ctx.fillRect(0, i, size, 1);
  }
  ctx.globalAlpha = 1;

  const prng = (() => {
    let value = 246813579;
    return () => {
      value = (value * 1664525 + 1013904223) % 4294967296;
      return value / 4294967296;
    };
  })();
  const image = ctx.getImageData(0, 0, size, size);
  const { data } = image;
  for (let idx = 0; idx < data.length; idx += 4) {
    const fiber = (prng() - 0.5) * 0.18;
    const greenFactor = 1 + fiber * 0.9;
    const sideFactor = 1 + fiber * 0.45;
    data[idx] = Math.min(255, Math.max(0, data[idx] * sideFactor));
    data[idx + 1] = Math.min(255, Math.max(0, data[idx + 1] * greenFactor));
    data[idx + 2] = Math.min(255, Math.max(0, data[idx + 2] * sideFactor));
  }
  ctx.putImageData(image, 0, 0);

  const texture = new THREE.CanvasTexture(canvas);
  texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
  texture.repeat.set(18 * 5, 18 * 5);
  texture.anisotropy = renderer.capabilities.getMaxAnisotropy();
  texture.colorSpace = THREE.SRGBColorSpace;
  return texture;
}

function roundedRectAbs(width, height, radius) {
  const hw = width / 2;
  const hh = height / 2;
  const r = Math.min(Math.max(radius, 0), Math.min(hw, hh));
  const shape = new THREE.Shape();
  shape.moveTo(-hw + r, -hh);
  shape.lineTo(hw - r, -hh);
  shape.quadraticCurveTo(hw, -hh, hw, -hh + r);
  shape.lineTo(hw, hh - r);
  shape.quadraticCurveTo(hw, hh, hw - r, hh);
  shape.lineTo(-hw + r, hh);
  shape.quadraticCurveTo(-hw, hh, -hw, hh - r);
  shape.lineTo(-hw, -hh + r);
  shape.quadraticCurveTo(-hw, -hh, -hw + r, -hh);
  shape.closePath();
  return shape;
}

const tableMaterials = {
  top: new THREE.MeshStandardMaterial({ roughness: 0.55, metalness: 0.12 }),
  rim: new THREE.MeshStandardMaterial({ roughness: 0.6, metalness: 0.14 }),
  accent: new THREE.MeshStandardMaterial({ roughness: 0.4, metalness: 0.32 }),
  felt: new THREE.MeshStandardMaterial({ roughness: 1, metalness: 0 }),
  base: new THREE.MeshStandardMaterial({ roughness: 0.35, metalness: 0.65 }),
  column: new THREE.MeshStandardMaterial({ roughness: 0.32, metalness: 0.72 }),
  trim: new THREE.MeshStandardMaterial({ roughness: 0.22, metalness: 0.85 })
};

function updateTableMaterials() {
  const wood = TABLE_WOOD_OPTIONS[appearance.tableWood] ?? TABLE_WOOD_OPTIONS[0];
  const { preset, grain } = resolveWoodComponents(wood);
  const sharedKey = `domino-wood-${wood?.id ?? preset.id ?? 'default'}`;
  applyWoodTextures(tableMaterials.top, {
    hue: preset.hue,
    sat: preset.sat,
    light: preset.light,
    contrast: preset.contrast,
    repeat: grain?.frame?.repeat ?? grain?.rail?.repeat ?? { x: 0.24, y: 0.38 },
    rotation: grain?.frame?.rotation ?? 0,
    textureSize: grain?.frame?.textureSize ?? DEFAULT_WOOD_TEXTURE_SIZE,
    roughnessBase: 0.16,
    roughnessVariance: 0.28,
    sharedKey
  });
  applyWoodTextures(tableMaterials.rim, {
    hue: preset.hue,
    sat: preset.sat,
    light: preset.light,
    contrast: preset.contrast,
    repeat: grain?.rail?.repeat ?? grain?.frame?.repeat ?? { x: 0.12, y: 0.62 },
    rotation: grain?.rail?.rotation ?? 0,
    textureSize: grain?.rail?.textureSize ?? DEFAULT_WOOD_TEXTURE_SIZE,
    roughnessBase: 0.18,
    roughnessVariance: 0.32,
    sharedKey
  });
  if (!tableMaterials.top.map) {
    tableMaterials.top.color.set(wood.baseHex);
  }
  if (!tableMaterials.rim.map) {
    tableMaterials.rim.color.set(wood.rimHex ?? wood.baseHex);
  }
  tableMaterials.accent.color.set(wood.accentHex);
  tableMaterials.accent.needsUpdate = true;

  const cloth = TABLE_CLOTH_OPTIONS[appearance.tableCloth] ?? TABLE_CLOTH_OPTIONS[0];
  tableMaterials.felt.color.set(0xffffff);
  tableMaterials.felt.emissive.set(cloth.emissive ?? adjustHexColor(cloth.feltTop, 0.2));
  tableMaterials.felt.emissiveIntensity = cloth.emissiveIntensity ?? 0.34;
  if (tableMaterials.felt.map) {
    tableMaterials.felt.map.dispose();
  }
  tableMaterials.felt.map = makeClothTexture({ top: cloth.feltTop, bottom: cloth.feltBottom, border: cloth.border });
  tableMaterials.felt.map.needsUpdate = true;
  tableMaterials.felt.needsUpdate = true;

  const base = TABLE_BASE_OPTIONS[appearance.tableBase] ?? TABLE_BASE_OPTIONS[0];
  tableMaterials.base.color.set(base.base);
  tableMaterials.column.color.set(base.column);
  tableMaterials.trim.color.set(base.trim);
}
updateTableMaterials();

const tableParts = {};
const chairs = [];
let seatLabelMesh = null;
let seatLabelShouldDisplay = shouldShowSeatLabel;

function disposeSeatLabel({ persistPreference = true } = {}) {
  if (seatLabelMesh) {
    seatLabelMesh.parent?.remove(seatLabelMesh);
    if (seatLabelMesh.material?.map?.dispose) {
      seatLabelMesh.material.map.dispose();
    }
    if (seatLabelMesh.material?.dispose) {
      seatLabelMesh.material.dispose();
    }
    if (seatLabelMesh.geometry?.dispose) {
      seatLabelMesh.geometry.dispose();
    }
    seatLabelMesh = null;
  }
  if (persistPreference) {
    seatLabelShouldDisplay = false;
  }
}

function createSeatLabelMesh() {
  const canvas = document.createElement('canvas');
  canvas.width = 512;
  canvas.height = 256;
  const ctx = canvas.getContext('2d');
  ctx.fillStyle = 'rgba(12, 16, 24, 0.85)';
  ctx.fillRect(0, 0, canvas.width, canvas.height);
  ctx.strokeStyle = '#ffd24a';
  ctx.lineWidth = 18;
  ctx.strokeRect(12, 12, canvas.width - 24, canvas.height - 24);
  ctx.fillStyle = '#ffd24a';
  ctx.font = 'bold 140px "Inter", Arial';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.fillText('SEAT', canvas.width / 2, canvas.height / 2);
  const texture = new THREE.CanvasTexture(canvas);
  texture.anisotropy = Math.min(renderer.capabilities.getMaxAnisotropy?.() || 4, 8);
  texture.colorSpace = THREE.SRGBColorSpace;
  const material = new THREE.MeshBasicMaterial({ map: texture, transparent: true, depthWrite: false });
  const geometry = new THREE.PlaneGeometry(1.6, 0.8);
  const mesh = new THREE.Mesh(geometry, material);
  mesh.renderOrder = 12;
  return mesh;
}

const TABLE_OUTER_RADIUS = TABLE_RADIUS;
const TABLE_INNER_RADIUS = TABLE_OUTER_RADIUS * 0.84;
const CLOTH_RADIUS = TABLE_OUTER_RADIUS * 0.72;
const TABLE_TOP_DEPTH = 0.06 * MODEL_SCALE * TABLE_SCALE;
const RIM_THICK = 0.08 * MODEL_SCALE;
const TABLE_BASE_Y = TABLE_HEIGHT - TABLE_TOP_DEPTH;
const CLOTH_TOP = TABLE_HEIGHT;
const RAIL_TOP = CLOTH_TOP + 0.04 * MODEL_SCALE;

(function buildTable() {
  const sides = 8;
  const topShape = createRegularPolygonShape(sides, TABLE_OUTER_RADIUS);
  const feltShape = createRegularPolygonShape(sides, CLOTH_RADIUS);
  const rimInnerShape = createRegularPolygonShape(sides, TABLE_INNER_RADIUS);

  const topShapeWithHole = topShape.clone();
  topShapeWithHole.holes.push(feltShape);
  const topGeo = new THREE.ExtrudeGeometry(topShapeWithHole, {
    depth: TABLE_TOP_DEPTH,
    bevelEnabled: true,
    bevelThickness: TABLE_TOP_DEPTH * 0.55,
    bevelSize: TABLE_TOP_DEPTH * 0.5,
    bevelSegments: 8
  });
  topGeo.rotateX(-Math.PI / 2);
  const topMesh = new THREE.Mesh(topGeo, tableMaterials.top);
  topMesh.position.y = TABLE_BASE_Y;
  topMesh.castShadow = true;
  topMesh.receiveShadow = true;
  tableG.add(topMesh);
  tableParts.top = topMesh;

  const feltGeo = new THREE.ExtrudeGeometry(feltShape, { depth: 0.01, bevelEnabled: false });
  feltGeo.rotateX(-Math.PI / 2);
  const feltMesh = new THREE.Mesh(feltGeo, tableMaterials.felt);
  feltMesh.position.y = CLOTH_TOP + 0.0025;
  feltMesh.receiveShadow = true;
  tableG.add(feltMesh);
  tableParts.felt = feltMesh;

  const rimShape = topShape.clone();
  rimShape.holes.push(rimInnerShape);
  const rimGeo = new THREE.ExtrudeGeometry(rimShape, {
    depth: RIM_THICK,
    bevelEnabled: true,
    bevelThickness: RIM_THICK * 0.45,
    bevelSize: RIM_THICK * 0.42,
    bevelSegments: 6
  });
  rimGeo.rotateX(-Math.PI / 2);
  const rimMesh = new THREE.Mesh(rimGeo, tableMaterials.rim);
  rimMesh.position.y = TABLE_BASE_Y + TABLE_TOP_DEPTH * 0.55;
  rimMesh.castShadow = true;
  rimMesh.receiveShadow = true;
  tableG.add(rimMesh);
  tableParts.rim = rimMesh;

  const accentShape = rimInnerShape.clone();
  accentShape.holes.push(feltShape);
  const accentGeo = new THREE.ExtrudeGeometry(accentShape, { depth: 0.012, bevelEnabled: false });
  accentGeo.rotateX(-Math.PI / 2);
  const accentMesh = new THREE.Mesh(accentGeo, tableMaterials.accent);
  accentMesh.position.y = CLOTH_TOP - 0.003;
  tableG.add(accentMesh);
  tableParts.accent = accentMesh;

  const columnHeight = TABLE_HEIGHT + 0.25;
  const column = new THREE.Mesh(
    new THREE.CylinderGeometry(TABLE_OUTER_RADIUS * 0.34, TABLE_OUTER_RADIUS * 0.48, columnHeight, 48),
    tableMaterials.column
  );
  column.position.y = TABLE_BASE_Y - columnHeight / 2;
  column.castShadow = true;
  column.receiveShadow = true;
  tableG.add(column);
  tableParts.column = column;

  const base = new THREE.Mesh(
    new THREE.CylinderGeometry(TABLE_OUTER_RADIUS * 0.86, TABLE_OUTER_RADIUS * 0.96, 0.16, 64),
    tableMaterials.base
  );
  base.position.y = column.position.y - columnHeight / 2 - 0.08;
  base.castShadow = true;
  base.receiveShadow = true;
  tableG.add(base);
  tableParts.base = base;

  const trim = new THREE.Mesh(
    new THREE.TorusGeometry(TABLE_OUTER_RADIUS * 0.9, 0.035, 16, 64),
    tableMaterials.trim
  );
  trim.rotation.x = Math.PI / 2;
  trim.position.y = base.position.y + 0.08;
  tableG.add(trim);
  tableParts.trim = trim;
})();

const SCALE = MODEL_SCALE * 0.92;
const DOMINO_SCALE = 1.5 * 0.85; // shrink domino tiles by 15% from previous upscale
const DOMINO_WORLD_SCALE = SCALE * DOMINO_SCALE;
const DOMINO_WIDTH = DOMINO_WORLD_SCALE * 0.10;
const DOMINO_LENGTH = DOMINO_WORLD_SCALE * (0.016 / 0.22) * 2;
const DOUBLE_END_SHIFT = Math.max(0, (DOMINO_LENGTH - DOMINO_WIDTH) / 2);
const DOMINO_CHAIN_GAP = DOMINO_LENGTH * 0.03;
const STEP = DOMINO_LENGTH + DOMINO_CHAIN_GAP;
const DOMINO_HAND_GAP = DOMINO_LENGTH * 1.25;
const TILE_UP_H = 0.2 * DOMINO_WORLD_SCALE;
const TILE_UP_HALF = TILE_UP_H / 2;
const XMAX = CLOTH_RADIUS - 0.32 - DOMINO_CHAIN_GAP * 0.5;
const ZMAX = CLOTH_RADIUS - 0.32 - DOMINO_CHAIN_GAP * 0.5;
const HAND_Y = RAIL_TOP + TILE_UP_HALF + 0.0012;
const CHAIN_TILE_Y = CLOTH_TOP + 0.02;

/* ---------- Materials ---------- */
const SHARED_DOMINO_MATERIALS = new Set();
let porcelainMat = null;
let pipMat = null;
let accentMat = null;
let currentDominoStyleOption = DOMINO_STYLE_OPTIONS[DEFAULT_APPEARANCE.dominoStyle] ?? DOMINO_STYLE_OPTIONS[0];
let dominoStyleProfile = {
  ringInner: currentDominoStyleOption?.accent?.ringInner ?? 0.107,
  ringOuter: currentDominoStyleOption?.accent?.ringOuter ?? 0.12,
  midlineDepth: currentDominoStyleOption?.accent?.midlineDepth ?? 0.01,
  pipRadius: currentDominoStyleOption?.pip?.radius ?? 0.085,
  ringEmissiveIntensity: currentDominoStyleOption?.accent?.ringEmissiveIntensity ?? 0.55
};

function disposeDominoBaseMaterials() {
  if (porcelainMat) {
    porcelainMat.dispose?.();
    porcelainMat = null;
  }
  if (accentMat) {
    accentMat.dispose?.();
    accentMat = null;
  }
  if (pipMat) {
    SHARED_DOMINO_MATERIALS.delete(pipMat);
    pipMat.dispose?.();
    pipMat = null;
  }
}

function buildDominoMaterial(options = {}, defaults = {}) {
  const params = { ...defaults, ...options };
  const material = new THREE.MeshPhysicalMaterial({
    color: new THREE.Color(params.color ?? defaults.color ?? '#ffffff'),
    roughness: params.roughness ?? 0.2,
    metalness: params.metalness ?? 0.2,
    clearcoat: params.clearcoat ?? 1.0,
    clearcoatRoughness: params.clearcoatRoughness ?? 0.05,
    reflectivity: params.reflectivity ?? 0.6,
    transmission: params.transmission ?? 0,
    thickness: params.thickness ?? 0,
    iridescence: params.iridescence ?? 0,
    iridescenceIOR: params.iridescenceIOR ?? 1.3,
    sheen: params.sheen ?? 0,
    sheenRoughness: params.sheenRoughness ?? 0.7,
    specularIntensity: params.specularIntensity ?? 1.0
  });
  if (params.emissive) {
    material.emissive.set(params.emissive);
  }
  if (typeof params.emissiveIntensity === 'number') {
    material.emissiveIntensity = params.emissiveIntensity;
  }
  if (params.sheenColor) {
    material.sheenColor.set(params.sheenColor);
  }
  if (params.specularColor) {
    material.specularColor.set(params.specularColor);
  }
  if (typeof params.envMapIntensity === 'number') {
    material.envMapIntensity = params.envMapIntensity;
  }
  if (typeof params.ior === 'number') {
    material.ior = params.ior;
  }
  if (typeof params.opacity === 'number') {
    material.opacity = params.opacity;
  }
  if (typeof params.transparent === 'boolean') {
    material.transparent = params.transparent;
  }
  if (typeof params.side === 'number') {
    material.side = params.side;
  }
  return material;
}

function applyDominoStyle(option = DOMINO_STYLE_OPTIONS[0]) {
  const style = option ?? DOMINO_STYLE_OPTIONS[0];
  currentDominoStyleOption = style;
  disposeDominoBaseMaterials();
  porcelainMat = buildDominoMaterial(style.body, {
    color: '#f8f8fb',
    roughness: 0.12,
    metalness: 0.2,
    clearcoat: 1.0,
    clearcoatRoughness: 0.05,
    reflectivity: 0.68,
    sheen: 0.25,
    sheenColor: '#fefaf2',
    envMapIntensity: 1.18
  });
  pipMat = buildDominoMaterial(style.pip, {
    color: '#0a0a0a',
    roughness: 0.05,
    metalness: 0.6,
    clearcoat: 0.9,
    clearcoatRoughness: 0.04,
    sheen: 0.12,
    envMapIntensity: 0.85
  });
  accentMat = buildDominoMaterial(style.accent, {
    color: '#d7b03b',
    emissive: '#593d00',
    emissiveIntensity: 0.55,
    metalness: 1.0,
    roughness: 0.18,
    reflectivity: 1.0,
    envMapIntensity: 1.42,
    side: THREE.DoubleSide
  });
  accentMat.polygonOffset = true;
  accentMat.polygonOffsetFactor = -1;
  accentMat.polygonOffsetUnits = -1;
  SHARED_DOMINO_MATERIALS.add(pipMat);
  dominoStyleProfile = {
    ringInner: style.accent?.ringInner ?? 0.107,
    ringOuter: style.accent?.ringOuter ?? 0.12,
    midlineDepth: style.accent?.midlineDepth ?? 0.01,
    pipRadius: style.pip?.radius ?? 0.085,
    ringEmissiveIntensity: style.accent?.ringEmissiveIntensity ?? accentMat.emissiveIntensity ?? 0.55
  };
}

applyDominoStyle(currentDominoStyleOption);
const markerMat = new THREE.MeshStandardMaterial({ color:"#15d16f", roughness:.7, metalness:0, transparent:true, opacity:.55 });

/* ---------- Game Collections (pre-declare for style refresh) ---------- */
let N = 4;
let players = [];
let boneyard = [];
let chain = [];

const boneyardStackG = new THREE.Group();
const BONEYARD_STACK_POSITION = new THREE.Vector3(0, CLOTH_TOP + 0.0075, CLOTH_RADIUS * 0.45);
boneyardStackG.position.copy(BONEYARD_STACK_POSITION);
piecesG.add(boneyardStackG);
const BONEYARD_STACK_STEP = DOMINO_WORLD_SCALE * 0.22 * 0.1 * 1.02;
const MAX_BONEYARD_DISPLAY = 12;
let boneyardStackVisible = 0;
let boneyardStackTopLocal = 0;

const drawAnimations = [];
const DRAW_ANIM_DURATION = 480;
const placementAnimations = [];
const PLACE_ANIM_DURATION = 640;
const PLACE_ANIM_ARC = 0.05;
const CPU_PLAY_DELAY = 2000;

const TMP_WORLD_POS = new THREE.Vector3();
const TMP_WORLD_QUAT = new THREE.Quaternion();
const TMP_WORLD_SCALE = new THREE.Vector3();

function disposeDominoMesh(mesh){
  if(!mesh) return;
  piecesG.remove(mesh);
  try{
    mesh.traverse((child)=>{
      if(!child.isMesh) return;
      if(child.geometry?.dispose){
        try{ child.geometry.dispose(); }catch{}
      }
      const materials = Array.isArray(child.material) ? child.material : [child.material];
      materials.forEach((material)=>{
        if(!material || SHARED_DOMINO_MATERIALS.has(material)) return;
        if(material.dispose){
          try{ material.dispose(); }catch{}
        }
      });
    });
  }catch{}
}

function clearExistingDominoMeshes(){
  if(Array.isArray(players)){
    players.forEach((player)=>{
      player?.hand?.forEach((tile)=>{
        if(tile?.mesh){
          disposeDominoMesh(tile.mesh);
          tile.mesh = null;
        }
      });
    });
  }
  if(Array.isArray(chain)){
    chain.forEach((segment)=>{
      if(segment?.mesh){
        disposeDominoMesh(segment.mesh);
        segment.mesh = null;
      }
    });
  }
  drawAnimations.forEach((anim)=>{
    if(anim?.mesh){
      disposeDominoMesh(anim.mesh);
    }
  });
  drawAnimations.length = 0;
  placementAnimations.forEach((anim)=>{
    if(anim?.mesh){
      disposeDominoMesh(anim.mesh);
    }
  });
  placementAnimations.length = 0;
  boneyardStackG.clear();
  boneyardStackVisible = 0;
  boneyardStackTopLocal = 0;
}

const configButtonEl = document.getElementById('configButton');
const configPanelEl = document.getElementById('configPanel');
const configSectionsEl = document.getElementById('configSections');
const configCloseEl = document.getElementById('configClose');
if (configButtonEl) {
  configButtonEl.setAttribute('aria-controls', 'configPanel');
  configButtonEl.setAttribute('aria-expanded', 'false');
}
if (configPanelEl) {
  configPanelEl.setAttribute('aria-hidden', 'true');
}

function saveAppearance() {
  try {
    const normalized = normalizeAppearance(appearance);
    appearance = normalized;
    localStorage.setItem(APPEARANCE_STORAGE_KEY, JSON.stringify(normalized));
  } catch (error) {
    console.warn('Failed to persist Domino appearance', error);
  }
}

function applyAppearanceChange({ refresh = true } = {}) {
  appearance = normalizeAppearance(appearance);
  clearExistingDominoMeshes();
  updateTableMaterials();
  applyDominoStyle(DOMINO_STYLE_OPTIONS[appearance.dominoStyle] ?? DOMINO_STYLE_OPTIONS[0]);
  Object.values(tableMaterials).forEach((material) => {
    if (material && typeof material.needsUpdate === 'boolean') {
      material.needsUpdate = true;
    }
    if (material?.map) {
      material.map.needsUpdate = true;
    }
    if (material?.roughnessMap) {
      material.roughnessMap.needsUpdate = true;
    }
  });
  buildChairs(CHAIR_THEME_OPTIONS[appearance.chairTheme] ?? DEFAULT_CHAIR_THEME);
  renderHands();
  renderChain();
  renderBoneyardStack();
  saveAppearance();
  if (refresh) {
    refreshConfigUI();
  }
}

function createOptionPreview(key, option) {
  const swatch = document.createElement('div');
  swatch.style.width = '100%';
  swatch.style.height = '1.5rem';
  swatch.style.borderRadius = '0.75rem';
  swatch.style.border = '1px solid rgba(255,255,255,0.12)';
  switch (key) {
    case 'tableWood':
      swatch.style.position = 'relative';
      swatch.style.overflow = 'hidden';
      swatch.style.background = `linear-gradient(135deg, ${option.baseHex ?? option.top}, ${option.accentHex ?? option.rim})`;
      {
        const sheen = document.createElement('div');
        sheen.style.position = 'absolute';
        sheen.style.inset = '0';
        sheen.style.background = 'linear-gradient(135deg, rgba(255,255,255,0.14), rgba(15,23,42,0.55))';
        sheen.style.pointerEvents = 'none';
        swatch.appendChild(sheen);
      }
      {
        const grain = (option?.grainId && WOOD_GRAIN_OPTIONS_BY_ID[option.grainId]) || WOOD_GRAIN_OPTIONS[0];
        if (grain?.label) {
          const badge = document.createElement('span');
          badge.textContent = grain.label.slice(0, 16);
          badge.style.position = 'absolute';
          badge.style.right = '0.4rem';
          badge.style.bottom = '0.35rem';
          badge.style.padding = '0.12rem 0.4rem';
          badge.style.borderRadius = '999px';
          badge.style.fontSize = '0.5rem';
          badge.style.fontWeight = '700';
          badge.style.letterSpacing = '0.12em';
          badge.style.textTransform = 'uppercase';
          badge.style.color = 'rgba(226,232,240,0.92)';
          badge.style.background = 'rgba(15,23,42,0.7)';
          badge.style.pointerEvents = 'none';
          swatch.appendChild(badge);
        }
      }
      break;
    case 'tableCloth':
      swatch.style.background = `linear-gradient(135deg, ${option.feltTop}, ${option.feltBottom})`;
      break;
    case 'tableBase':
      swatch.style.background = `linear-gradient(135deg, ${option.base}, ${option.trim})`;
      break;
    case 'dominoStyle':
      swatch.style.position = 'relative';
      swatch.style.overflow = 'hidden';
      {
        const [topColor, bottomColor] = Array.isArray(option.preview) && option.preview.length >= 2
          ? option.preview
          : ['#1f2937', '#0f172a'];
        swatch.style.background = `linear-gradient(135deg, ${topColor}, ${bottomColor})`;
      }
      {
        const pip = document.createElement('div');
        pip.style.position = 'absolute';
        pip.style.width = '0.58rem';
        pip.style.height = '0.58rem';
        pip.style.borderRadius = '50%';
        pip.style.left = '0.5rem';
        pip.style.top = '0.46rem';
        pip.style.background = option.pip?.color ?? '#111827';
        pip.style.boxShadow = `0 0 0 2px ${option.accent?.color ?? '#d8af37'}`;
        pip.style.opacity = '0.95';
        pip.style.pointerEvents = 'none';
        swatch.appendChild(pip);
      }
      {
        const inset = document.createElement('div');
        inset.style.position = 'absolute';
        inset.style.inset = 'auto 0.4rem 0.3rem 0.4rem';
        inset.style.height = '0.22rem';
        inset.style.borderRadius = '999px';
        inset.style.background = option.accent?.color ?? '#d8af37';
        inset.style.opacity = '0.9';
        inset.style.boxShadow = '0 0.15rem 0.35rem rgba(0,0,0,0.32)';
        inset.style.pointerEvents = 'none';
        swatch.appendChild(inset);
      }
      break;
    case 'chairTheme':
      swatch.style.background = option.seatColor;
      break;
    default:
      swatch.style.background = '#1f2937';
  }
  return swatch;
}

function refreshConfigUI() {
  if (!configSectionsEl) return;
  configSectionsEl.replaceChildren();
  TABLE_SETUP_SECTIONS.forEach((section) => {
    const wrapper = document.createElement('div');
    wrapper.className = 'config-section';
    const label = document.createElement('h4');
    label.textContent = section.label;
    wrapper.appendChild(label);
    const optionsGrid = document.createElement('div');
    optionsGrid.className = 'config-options';
    section.options.forEach((option, idx) => {
      const button = document.createElement('button');
      button.type = 'button';
      button.className = 'config-option';
      if (appearance[section.key] === idx) {
        button.classList.add('active');
      }
      button.appendChild(createOptionPreview(section.key, option));
      const name = document.createElement('span');
      name.textContent = option.label ?? option.id;
      button.appendChild(name);
      button.addEventListener('click', () => {
        if (appearance[section.key] === idx) return;
        appearance[section.key] = idx;
        applyAppearanceChange({ refresh: false });
        refreshConfigUI();
      });
      optionsGrid.appendChild(button);
    });
    wrapper.appendChild(optionsGrid);
    configSectionsEl.appendChild(wrapper);
  });
}

function closeConfigPanel() {
  configPanelEl?.classList.remove('active');
  configPanelEl?.setAttribute('aria-hidden', 'true');
  configButtonEl?.setAttribute('aria-expanded', 'false');
}

configButtonEl?.addEventListener('click', () => {
  const isOpen = configPanelEl?.classList.toggle('active');
  if (typeof isOpen === 'boolean') {
    configPanelEl?.setAttribute('aria-hidden', String(!isOpen));
    configButtonEl?.setAttribute('aria-expanded', String(isOpen));
    if (isOpen) {
      refreshConfigUI();
      window.requestAnimationFrame(() => {
        try {
          configPanelEl?.focus?.();
        } catch {}
      });
    }
  }
});
configCloseEl?.addEventListener('click', () => closeConfigPanel());
document.addEventListener('click', (event) => {
  if (!configPanelEl?.classList.contains('active')) return;
  if (configPanelEl.contains(event.target) || configButtonEl?.contains(event.target)) return;
  closeConfigPanel();
});
document.addEventListener('keydown', (event) => {
  if (event.key === 'Escape') {
    closeConfigPanel();
  }
});

applyAppearanceChange({ refresh: false });
refreshConfigUI();


/* ---------- Seating (Texas Hold'em Style Chairs) ---------- */
const CHAIR_TEXTURE_PROPS = Object.freeze([
  'map',
  'normalMap',
  'roughnessMap',
  'metalnessMap',
  'aoMap',
  'alphaMap',
  'emissiveMap',
  'bumpMap',
  'displacementMap',
  'clearcoatMap',
  'clearcoatRoughnessMap',
  'clearcoatNormalMap',
  'specularMap',
  'sheenColorMap',
  'sheenRoughnessMap'
]);

function disposeChairResources(root) {
  root.traverse((child) => {
    if (!child.isMesh) return;
    if (child.geometry?.dispose) {
      child.geometry.dispose();
    }
    const materials = Array.isArray(child.material) ? child.material : [child.material];
    materials.forEach((material) => {
      if (!material) return;
      CHAIR_TEXTURE_PROPS.forEach((prop) => {
        const texture = material[prop];
        if (texture?.isTexture) {
          texture.dispose();
        }
      });
      if (material.dispose) {
        material.dispose();
      }
    });
  });
}

async function buildChairs(option = CHAIR_THEME_OPTIONS[appearance.chairTheme] ?? DEFAULT_CHAIR_THEME) {
  disposeSeatLabel({ persistPreference: false });
  while (chairs.length) {
    const chair = chairs.pop();
    chair.parent?.remove(chair);
    disposeChairResources(chair);
  }

  const lookTarget = new THREE.Vector3(0, TABLE_HEIGHT, 0);
  let chairData = null;
  try {
    chairData = await ensureMurlanChairTemplate();
  } catch (error) {
    console.warn("Falling back to procedural chair for Domino", error);
  }

  const seatBottomOffset = chairData ? -chairTemplateBounds.min.y : CHAIR_DIMENSIONS.baseThickness + CHAIR_DIMENSIONS.columnHeight;
  const labelHeight = chairData
    ? seatBottomOffset + chairTemplateBounds.max.y + 0.12
    : CHAIR_DIMENSIONS.baseThickness + CHAIR_DIMENSIONS.columnHeight + CHAIR_DIMENSIONS.seatThickness + 0.72;
  const labelDepth = chairData
    ? -chairTemplateBounds.getSize(new THREE.Vector3()).z * 0.35
    : -CHAIR_DIMENSIONS.seatDepth * 0.35;

  const sharedMaterials = chairData
    ? null
    : {
        fabric: createChairFabricMaterial(option, renderer),
        leg: new THREE.MeshStandardMaterial({
          color: new THREE.Color(option.legColor ?? "#1f1f1f"),
          metalness: 0.6,
          roughness: 0.35
        }),
        accent: new THREE.MeshStandardMaterial({
          color: new THREE.Color(adjustHexColor(option.legColor ?? "#1f1f1f", 0.15)),
          metalness: 0.75,
          roughness: 0.32
        })
      };

  CHAIR_SEAT_ANGLES.forEach((angle, index) => {
    const radius = CHAIR_SEAT_RADII[index] ?? CHAIR_RADIUS;
    const basis = seatBasisForAngle(angle, radius);
    const wrapper = new THREE.Group();
    wrapper.position.set(basis.position.x, CHAIR_BASE_HEIGHT, basis.position.z);
    wrapper.lookAt(lookTarget);

    const chair = chairData
      ? cloneChairWithTheme(chairData, option)
      : createDominoChair(option, renderer, sharedMaterials);
    chair.position.y = -seatBottomOffset;
    wrapper.add(chair);

    tableG.add(wrapper);
    chairs.push(wrapper);

    if (seatLabelShouldDisplay && shouldShowSeatLabel && index === HUMAN_SEAT_INDEX) {
      seatLabelMesh = createSeatLabelMesh();
      seatLabelMesh.position.set(0, labelHeight, labelDepth);
      seatLabelMesh.rotation.x = -Math.PI / 16;
      wrapper.add(seatLabelMesh);
    }
  });
}

/* ---------- Tile Helpers (ensure defined before use) ---------- */
function isValidTile(t){
  if(!t || typeof t.a!=="number" || typeof t.b!=="number") return false;
  if(t.a<0||t.b<0||t.a>6||t.b>6) return false; return true;
}
function canonTile(t){
  if(!isValidTile(t)) return null; let {a,b}=t; if(a>b){ const k=a; a=b; b=k; } return {a,b};
}

/* ---------- Domino EXACT for your request ---------- */
function pipPositions(){
  return [
    [-0.3, 0.6], [0, 0.6], [0.3, 0.6],
    [-0.3, 0.3], [0, 0.3], [0.3, 0.3],
    [-0.3, 0.0], [0, 0.0], [0.3, 0.0],
  ];
}
const INDEX_SETS = { 0: [], 1: [4], 2: [0,8], 3: [0,4,8], 4: [0,2,6,8], 5: [0,2,4,6,8], 6: [0,2,3,5,6,8] };

function addAccentPerimeter(domino){
  const inset = 0.04;
  const w = 1 - inset*2;
  const h = 2 - inset*2;
  const shape = new THREE.Shape();
  shape.moveTo(-w/2, -h/2);
  shape.lineTo( w/2, -h/2);
  shape.lineTo( w/2,  h/2);
  shape.lineTo(-w/2,  h/2);
  shape.lineTo(-w/2, -h/2);
  const hole = new THREE.Path();
  const t = 0.015;
  hole.moveTo(-w/2 + t, -h/2 + t);
  hole.lineTo( w/2 - t, -h/2 + t);
  hole.lineTo( w/2 - t,  h/2 - t);
  hole.lineTo(-w/2 + t,  h/2 - t);
  hole.lineTo(-w/2 + t, -h/2 + t);
  shape.holes.push(hole);
  const frameDepth = Math.max(0.004, dominoStyleProfile.midlineDepth ?? 0.01);
  const extrude = new THREE.ExtrudeGeometry(shape, { depth: frameDepth, bevelEnabled: false });
  const frame = new THREE.Mesh(extrude, accentMat.clone());
  frame.material.emissiveIntensity = dominoStyleProfile.ringEmissiveIntensity ?? frame.material.emissiveIntensity;
  frame.position.z = 0.11;
  frame.renderOrder = 5; // sit on top
  domino.add(frame);
}

function addPips(dominoFace, count, yOffset){
  const positions = pipPositions();
  const idxs = INDEX_SETS[Math.max(0, Math.min(6, count))];
  const pipRadius = dominoStyleProfile.pipRadius ?? 0.085;
  const pipGeo = new THREE.SphereGeometry(pipRadius, 32, 32);
  idxs.forEach(i => {
    const [px, py] = positions[i];
    const sphere = new THREE.Mesh(pipGeo, pipMat);
    sphere.position.set(px, py + yOffset, 0.11);
    dominoFace.add(sphere);

    // Luxury accent ring around each pip
    const innerR = dominoStyleProfile.ringInner ?? 0.107;
    const outerR = dominoStyleProfile.ringOuter ?? 0.120;
    const ringGeo = new THREE.RingGeometry(innerR, outerR, 64);
    const ring = new THREE.Mesh(ringGeo, accentMat.clone());
    ring.material.emissiveIntensity = dominoStyleProfile.ringEmissiveIntensity ?? ring.material.emissiveIntensity;
    ring.position.set(px, py + yOffset, 0.11);
    ring.renderOrder = 6; // above porcelain & pip
    dominoFace.add(ring);
  });
}

function makeDomino(a,b,{flat=true, faceUp=true, preserveOrder=false}={}){
  const tile = {a,b};
  if(!isValidTile(tile)){ return new THREE.Group(); }
  const oriented = preserveOrder ? tile : canonTile(tile);
  if(!oriented){ return new THREE.Group(); }
  ({a,b} = oriented);

  const group = new THREE.Group();

  // Body EXACTLY as in your code
  const bodyGeo = new RoundedBoxGeometry(1, 2, 0.22, 4, 0.06);
  const bodyMaterial = porcelainMat.clone();
  bodyMaterial.envMapIntensity = porcelainMat.envMapIntensity;
  const body = new THREE.Mesh(bodyGeo, bodyMaterial);
  body.castShadow = true; body.receiveShadow = true;

  // Center line — accent
  const midW = 1 - 0.08;         // sipas kodit
  const midH = 0.03;
  const midR = 0.06;
  const midShape = roundedRectAbs(midW, midH, Math.min(midR, midH/2));
  const midDepth = Math.max(0.004, dominoStyleProfile.midlineDepth ?? 0.01);
  const midGeo = new THREE.ExtrudeGeometry(midShape, { depth: midDepth, bevelEnabled: false });
  const midLine = new THREE.Mesh(midGeo, accentMat.clone());
  midLine.material.emissiveIntensity = dominoStyleProfile.ringEmissiveIntensity ?? midLine.material.emissiveIntensity;
  midLine.position.z = 0.11;
  midLine.renderOrder = 5;
  body.add(midLine);

  // Luxurious surrounding frame — accent
  addAccentPerimeter(body);

  // Dots per your code — top & bottom faces (in body coordinates)
  if(faceUp){
    addPips(body, a, -0.8);
    addPips(body, b,  0.2);
  }

  group.add(body);

  // Invisible collider to make touch / pick detection more forgiving on mobile
  const colliderGeo = new THREE.BoxGeometry(1.85, faceUp ? 0.82 : 1.4, 1.85);
  const colliderMat = new THREE.MeshBasicMaterial({ transparent: true, opacity: 0, depthWrite: false });
  const collider = new THREE.Mesh(colliderGeo, colliderMat);
  collider.name = 'touchCollider';
  collider.renderOrder = -1;
  collider.castShadow = false;
  collider.receiveShadow = false;
  group.add(collider);

  // Integration with the existing system: on the board they must be flat (face up)
  if(flat){ group.rotation.x = -Math.PI/2; }

  // Keep the existing world scale (same as before the change)
  const sx = 0.10 / 1.0, sy = (flat? 0.016/0.22 : 0.20/2.0), sz = (flat? 0.20/2.0 : 0.016/0.22);
  group.scale.set(DOMINO_WORLD_SCALE * sx, DOMINO_WORLD_SCALE * sy, DOMINO_WORLD_SCALE * sz);

  group.userData.val = [a,b];
  return group;
}

/* ---------- Game State ---------- */
const statusEl = document.getElementById('status');
const btnDraw = document.getElementById('draw');
const btnPass = document.getElementById('pass');
const btnRules = document.getElementById('btnRules');
const viewToggle = document.getElementById('viewToggle');
const panelRules = document.getElementById('rules');
const closeRules = document.getElementById('closeRules');

let statusPrefix = '';
let ends = null; // {L:{v,x,z,dir:[dx,dz]}, R:{...}}
let current = 0; let human = 0;
let markers = {L:null, R:null}; let selectedTile = null;
let flipDir = false; // alternate chain direction after each game
const usedTileKeys = new Set();
let gameFinished = false;
let winnerIndex = null;
let revealAllHands = false;
let winnerHighlight = null;
let winnerHighlightStart = 0;
let cpuMoveTimeout = null;

function tileKey(tile){
  const ct = canonTile(tile);
  return ct ? `${ct.a}|${ct.b}` : '';
}

function setStatus(t){ statusEl.textContent = statusPrefix ? `${statusPrefix} • ${t}` : t; }

function genSet(){ const set=[]; for(let a=0;a<=6;a++){ for(let b=a;b<=6;b++){ set.push({a,b}); } } return set; }
function shuffle(arr){ for(let i=arr.length-1;i>0;i--){ const j=(Math.random()*(i+1))|0; [arr[i],arr[j]]=[arr[j],arr[i]]; } return arr; }

const requestedPlayers = Number.parseInt(urlParams.get('players') || urlParams.get('playerCount') || '', 10);
if (requestedPlayers >= 2 && requestedPlayers <= 4) {
  N = requestedPlayers;
}
const stakeAmount = Number.parseInt(urlParams.get('amount') || '', 10);
const stakeToken = urlParams.get('token') || 'TPC';
if (Number.isFinite(stakeAmount) && stakeAmount > 0) {
  statusPrefix = `Stake ${stakeAmount.toLocaleString('en-US')} ${stakeToken.toUpperCase()}`;
  setStatus('Ready');
}

function layoutSeat(idx){
  const EDGE = CLOTH_RADIUS;
  const MARGIN = EDGE * 0.16;
  const south = [0, EDGE - MARGIN, 0];
  const east = [EDGE - MARGIN, 0, Math.PI / 2];
  const north = [0, -(EDGE - MARGIN), Math.PI];
  const west = [-(EDGE - MARGIN), 0, -Math.PI / 2];
  const seats = [south, east, north, west];
  return seats[idx % seats.length];
}

function renderHands(){
  players.forEach(p=>p.hand.forEach(h=>{ if(h.mesh){ piecesG.remove(h.mesh); h.mesh=null; } }));

  const EDGE_SPAN = CLOTH_RADIUS - 0.28;
  const BASE_GAP = DOMINO_HAND_GAP;
  const MIN_GAP = DOMINO_LENGTH * 1.05;
  const MAX_SPAN = Math.max(0, EDGE_SPAN * 2 - DOMINO_LENGTH * 0.6);

  const isTopDown = cameraViewMode === VIEW_MODES.twoD;

  players.forEach((p,pi)=>{
    const [x0,z0] = layoutSeat(pi);
    const isHuman = pi === human;
    const faceUp = revealAllHands || isHuman || (gameFinished && pi === winnerIndex);
    const count = p.hand.length;
    const isSide = (pi===1 || pi===3);
    const openFlat = isTopDown && isHuman;

    const gapBase = openFlat ? BASE_GAP * 1.3 : BASE_GAP;
    const handY = openFlat ? CLOTH_TOP + 0.018 : HAND_Y;

    let span = 0;
    let gap = 0;
    if(count>1){
      const desiredSpan = gapBase * (count-1);
      const minSpan = Math.min(MIN_GAP * (count-1), MAX_SPAN);
      span = Math.min(Math.max(desiredSpan, minSpan), MAX_SPAN);
      gap = span/(count-1);
    }

    let start = count>1 ? -span/2 : 0;
    if(count>1){
      const axisCenter = isSide ? z0 : x0;
      const minLimit = -EDGE_SPAN;
      const maxLimit = EDGE_SPAN;
      const minStart = minLimit - axisCenter;
      const maxStart = maxLimit - axisCenter - span;
      if(minStart <= maxStart){
        if(start < minStart) start = minStart;
        if(start > maxStart) start = maxStart;
      } else {
        start = (minStart + maxStart) / 2;
      }
    }

    p.hand.forEach((h,hi)=>{
      const m = makeDomino(h.a,h.b,{flat: openFlat, faceUp});
      const offset = count>1 ? start + gap*hi : 0;
      if(isSide){
        m.position.set(x0, handY, z0 + offset);
      }
      else{
        m.position.set(x0 + offset, handY, z0);
      }
      const yawTowardCenter = Math.atan2(-x0, -z0);
      if(openFlat){
        m.rotation.set(-Math.PI/2, yawTowardCenter, 0);
      } else {
        m.rotation.set(0, (pi===human ? 0 : yawTowardCenter), 0);
        m.rotation.z += (Math.random()*0.006-0.003);
      }
      h.mesh = m; m.userData = {tile:h, owner:pi}; piecesG.add(m);
    });
  });
}

/* ---------- Chain Rendering ---------- */
const DOMINO_FLAT_EULER = new THREE.Euler(-Math.PI / 2, 0, 0, 'XYZ');

function orientDominoFlat(domino, yawAngle = 0) {
  DOMINO_FLAT_EULER.set(-Math.PI / 2, Number.isFinite(yawAngle) ? yawAngle : 0, 0, 'XYZ');
  domino.setRotationFromEuler(DOMINO_FLAT_EULER);
}

function renderChain(){
  chain.forEach(c=>{
    if(c.mesh){
      piecesG.remove(c.mesh);
      c.mesh = null;
    }
  });
  chain.forEach(c=>{
    if(c.animating){
      return;
    }
    const domino = makeDomino(c.tile.a, c.tile.b, { flat: true, faceUp: true, preserveOrder: true });
    const yPos = CHAIN_TILE_Y;
    domino.position.set(c.x, yPos, c.z);
    domino.renderOrder = 5;
    domino.traverse((child) => {
      if (child.isMesh) {
        child.renderOrder = 5;
      }
    });
    // Ensure every domino on the field is completely flat (no tilt)
    orientDominoFlat(domino, c.rot ?? 0);
    c.mesh = domino;
    piecesG.add(domino);
  });
}

function renderBoneyardStack(){
  boneyardStackG.clear();
  const available = Array.isArray(boneyard) ? boneyard.length : 0;
  const visible = Math.min(available, MAX_BONEYARD_DISPLAY);
  boneyardStackVisible = visible;
  boneyardStackTopLocal = visible > 0 ? (visible - 1) * BONEYARD_STACK_STEP : 0;
  if(visible === 0){
    return;
  }

  for(let i=0;i<visible;i++){
    const domino = makeDomino(0,0,{flat:true, faceUp:false});
    orientDominoFlat(domino, Math.PI/2);
    domino.rotation.z = Math.PI;
    domino.position.set((i%2===0?1:-1)*0.0045, i * BONEYARD_STACK_STEP, (i%3-1)*0.0035);
    domino.userData = { stock:true };
    boneyardStackG.add(domino);
  }
}

function getBoneyardTopWorld(){
  if(!boneyardStackVisible){
    return null;
  }
  const localTop = new THREE.Vector3(0, boneyardStackTopLocal, 0);
  return boneyardStackG.localToWorld(localTop);
}

function spawnDrawAnimation(startWorld, seatIndex = human){
  if(!startWorld){
    return;
  }
  const start = startWorld.clone ? startWorld.clone() : new THREE.Vector3().copy(startWorld);
  const domino = makeDomino(0,0,{flat:true, faceUp:false});
  orientDominoFlat(domino, Math.PI/2);
  domino.rotation.z = Math.PI;
  domino.userData = { stockAnim:true };
  domino.position.copy(start);
  piecesG.add(domino);

  const [seatX, seatZ] = layoutSeat(seatIndex);
  const end = new THREE.Vector3(seatX * 0.55, HAND_Y + 0.012, seatZ - 0.08);
  drawAnimations.push({
    mesh: domino,
    start,
    end,
    startTime: performance.now(),
    duration: DRAW_ANIM_DURATION,
    arc: 0.05
  });
}

function clearWinnerHighlight(){
  if(!winnerHighlight){
    return;
  }
  if(winnerHighlight.parent){
    winnerHighlight.parent.remove(winnerHighlight);
  }
  try{
    winnerHighlight.geometry?.dispose?.();
  }catch{}
  const mat = winnerHighlight.material;
  try{
    mat?.dispose?.();
  }catch{}
  winnerHighlight = null;
  winnerHighlightStart = 0;
}

function showWinnerHighlight(index){
  clearWinnerHighlight();
  if(!Number.isInteger(index) || index < 0 || index >= chairs.length){
    return;
  }
  const seat = chairs[index];
  if(!seat){
    return;
  }
  const radius = SEAT_WIDTH * 0.72;
  const ring = new THREE.Mesh(
    new THREE.TorusGeometry(radius, 0.028, 32, 96),
    new THREE.MeshBasicMaterial({ color: 0xffd24a, transparent: true, opacity: 0.6 })
  );
  ring.rotation.x = -Math.PI / 2;
  ring.position.set(seat.position.x, 0.04, seat.position.z);
  ring.renderOrder = 2;
  tableG.add(ring);
  winnerHighlight = ring;
  winnerHighlightStart = performance.now();
}

function attachMeshPreserveWorld(mesh){
  if(!mesh){
    return;
  }
  mesh.updateMatrixWorld(true);
  mesh.matrixWorld.decompose(TMP_WORLD_POS, TMP_WORLD_QUAT, TMP_WORLD_SCALE);
  if(mesh.parent){
    mesh.parent.remove(mesh);
  }
  piecesG.add(mesh);
  mesh.position.copy(TMP_WORLD_POS);
  mesh.quaternion.copy(TMP_WORLD_QUAT);
  mesh.scale.copy(TMP_WORLD_SCALE);
}

function takeTileMeshForAnimation(tile){
  if(!tile || !tile.mesh){
    return null;
  }
  const mesh = tile.mesh;
  tile.mesh = null;
  const data = mesh.userData || (mesh.userData = {});
  delete data.owner;
  delete data.tile;
  data.animating = true;
  attachMeshPreserveWorld(mesh);
  return mesh;
}

function spawnPlacementAnimation(tile, segment, { duration = PLACE_ANIM_DURATION, mesh: providedMesh } = {}){
  if(!segment){
    return;
  }
  let mesh = providedMesh;
  if(!mesh){
    mesh = takeTileMeshForAnimation(tile);
  } else {
    if(tile && tile.mesh === mesh){
      tile.mesh = null;
    }
    const data = mesh.userData || (mesh.userData = {});
    delete data.owner;
    delete data.tile;
    data.animating = true;
    attachMeshPreserveWorld(mesh);
  }
  if(!mesh){
    segment.animating = false;
    renderChain();
    return;
  }

  mesh.renderOrder = 6;
  mesh.traverse((child)=>{
    if(child.isMesh){
      child.renderOrder = 6;
    }
  });

  const start = mesh.position.clone();
  const startQuat = mesh.quaternion.clone();
  const startScale = mesh.scale.clone();
  const end = new THREE.Vector3(segment.x, CHAIN_TILE_Y, segment.z);
  const orientTarget = new THREE.Object3D();
  orientDominoFlat(orientTarget, segment.rot ?? 0);
  const endQuat = orientTarget.quaternion.clone();

  placementAnimations.push({
    mesh,
    start,
    end,
    startQuat,
    endQuat,
    startScale,
    endScale: startScale.clone(),
    startTime: performance.now(),
    duration: duration || PLACE_ANIM_DURATION,
    arc: PLACE_ANIM_ARC,
    segment
  });
}

/* ---------- Start / Turn Order ---------- */
function drawTileFromStock(){
  while(boneyard.length){
    const tile = boneyard.pop();
    if(!isValidTile(tile)){
      continue;
    }
    renderBoneyardStack();
    return tile;
  }
  renderBoneyardStack();
  return null;
}

function highestDoubleIndex(hand){ let best=-1, idx=-1; hand.forEach((t,i)=>{ if(t.a===t.b && t.a>best){best=t.a; idx=i;} }); return idx; }
function pipSum(hand){ return hand.reduce((s,t)=>s+t.a+t.b,0); }

const VALUE_MAX_OCCURRENCES = 8; // each pip value appears 8 times in a double-six set (including doubles)

function valueOccurrencesInTiles(tiles, value, skipIndex=-1){
  let total = 0;
  tiles.forEach((t,i)=>{
    if(skipIndex===i) return;
    if(!isValidTile(t)) return;
    if(t.a===value) total++;
    if(t.b===value) total++;
  });
  return total;
}

function valueOccurrencesInChain(value){
  let total = 0;
  chain.forEach(c=>{
    const {a,b} = c.tile;
    if(a===value) total++;
    if(b===value) total++;
  });
  return total;
}

function enumerateMoves(hand){
  const moves = [];
  if(!hand || !hand.length) return moves;
  if(!ends){
    hand.forEach((tile,index)=>{
      if(!isValidTile(tile)) return;
      moves.push({tile,index,side:1,match:tile.a,other:tile.b});
    });
    return moves;
  }
  hand.forEach((tile,index)=>{
    if(!isValidTile(tile)) return;
    const {L,R} = validSidesFor(tile);
    if(L){
      const match = ends.L.v;
      const other = (tile.a===match) ? tile.b : tile.a;
      moves.push({tile,index,side:-1,match,other});
    }
    if(R){
      const match = ends.R.v;
      const other = (tile.a===match) ? tile.b : tile.a;
      moves.push({tile,index,side:1,match,other});
    }
  });
  return moves;
}

function scoreMove(player, move){
  const {tile,index,other,side} = move;
  const futureHand = [];
  player.hand.forEach((t, i) => { if (i !== index && isValidTile(t)) futureHand.push(t); });

  let score = 0;
  const sum = tile.a + tile.b;
  score += sum * 1.1; // prefer dumping high pips to avoid being stuck later
  if(tile.a===tile.b){
    score += 8; // doubles can open/close branches effectively
  }

  const sameValueRemaining = valueOccurrencesInTiles(player.hand, other, index);
  score += sameValueRemaining * 2.75; // keeping follow-up options for ourselves

  const occurrencesFromTile = (tile.a === tile.b) ? 2 : ((tile.a === other || tile.b === other) ? 1 : 0);
  const knownElsewhere = valueOccurrencesInChain(other) + sameValueRemaining + occurrencesFromTile;
  const remainingElsewhere = Math.max(0, VALUE_MAX_OCCURRENCES - knownElsewhere);
  if(remainingElsewhere === 0){
    score += 7.5; // completely choke the value — strong blocking move
  } else if(remainingElsewhere <= 2){
    score += 3.75;
  } else if(remainingElsewhere >= 5 && sameValueRemaining === 0){
    score -= 1.5; // avoid handing tempo back when opponents likely own the value
  }
  score += (VALUE_MAX_OCCURRENCES - remainingElsewhere) * 1.1;

  if(ends){
    const leftEnd = ends.L;
    const rightEnd = ends.R;
    const currentEndValue = (side < 0 ? leftEnd?.v : rightEnd?.v);
    if(currentEndValue === other && tile.a !== tile.b){
      // keeping the same value on the end makes it predictable — slight penalty unless it's a double
      score -= 1.5;
    }
    if(sameValueRemaining === 0 && remainingElsewhere > 0){
      // avoid stranding ourselves with no follow-up on that end unless it is a blocking move
      score -= 2.4;
    }
    const probeEnd = side < 0 ? leftEnd : rightEnd;
    if (probeEnd) {
      const projection = nextCandidate(probeEnd);
      if (Math.abs(projection.nx) > XMAX * 0.92 || Math.abs(projection.nz) > ZMAX * 0.92) {
        score += 1.1; // reward steering the snake before it hits the rails
      }
    }

    const futureLeftValue = (side < 0 ? other : leftEnd?.v);
    const futureRightValue = (side > 0 ? other : rightEnd?.v);
    const countMatches = (value) => {
      if(!Number.isFinite(value)) return 0;
      return futureHand.reduce((count, t) => count + ((t.a === value || t.b === value) ? 1 : 0), 0);
    };
    const leftMatches = countMatches(futureLeftValue);
    const rightMatches = countMatches(futureRightValue);
    if(Number.isFinite(futureLeftValue)){
      score += leftMatches * 1.4;
      if(leftMatches === 0){
        score -= remainingElsewhere > 0 ? 3.5 : 0.75;
      }
    }
    if(Number.isFinite(futureRightValue)){
      score += rightMatches * 1.4;
      if(rightMatches === 0){
        score -= remainingElsewhere > 0 ? 3.5 : 0.75;
      }
    }
  } else {
    // opening move heuristics: reward heavy doubles slightly more to secure tempo
    if(tile.a === tile.b){
      score += 5 + tile.a * 0.6;
    } else {
      score += sum * 0.35;
    }
  }

  if(sameValueRemaining >= 2){
    score += 1.2; // encourage offloading duplicate values early
  }

  const futurePipSum = futureHand.reduce((s, t) => s + t.a + t.b, 0);
  score += (42 - futurePipSum) * 0.12; // bias toward lighter remaining hand

  const futureValues = new Set();
  futureHand.forEach((t) => { futureValues.add(t.a); futureValues.add(t.b); });
  if (!futureValues.has(other) && remainingElsewhere === 0) {
    score += 6; // we lock that value completely
  }

  const futureDoubleCount = futureHand.filter((t) => t.a === t.b).length;
  if (tile.a === tile.b) {
    score += 2.5 + futureDoubleCount * 0.85; // chain strong doubles back-to-back
  } else if (futureDoubleCount === 0 && remainingElsewhere <= 2) {
    score += 1.8; // keep variety when low on doubles
  }

  score += Math.random() * 0.1; // tiny randomness to avoid deterministic loops
  return score;
}

function cpuDrawUntilPlayable(player){
  let drew = false;
  while(boneyard.length){
    const tile = drawTileFromStock();
    if(!tile) break;
    player.hand.push(tile);
    drew = true;
    if(!ends) break;
    const {L,R} = validSidesFor(tile);
    if(L || R) break;
  }
  return drew;
}

function startGame(){
  clearMarkers();
  clearExistingDominoMeshes();
  selectedTile=null;
  chain=[];
  ends=null;
  usedTileKeys.clear();
  gameFinished = false;
  winnerIndex = null;
  revealAllHands = false;
  clearWinnerHighlight();
  if(cpuMoveTimeout){
    clearTimeout(cpuMoveTimeout);
    cpuMoveTimeout = null;
  }
  flipDir = !flipDir;
  const numericN = Number.isFinite(N) ? Math.round(N) : 4;
  N = Math.max(2, Math.min(4, numericN));
  players=Array.from({length:N},(_,i)=>({id:i,hand:[]}));
  boneyard=shuffle(genSet());
  renderBoneyardStack();
  for(let r=0;r<7;r++){
    players.forEach(p=>{
      const dealt = drawTileFromStock();
      if(dealt){
        p.hand.push(dealt);
      }
    });
  }
  players.forEach(p=> shuffle(p.hand)); // random order every game
  renderHands();
  let starter=0, idx=-1, bestD=-1;
  players.forEach((p,pi)=>{ const i=highestDoubleIndex(p.hand); if(i>=0 && p.hand[i].a>bestD){ bestD=p.hand[i].a; starter=pi; idx=i; } });
  if(idx<0){ idx=0; }
  const t=players[starter].hand.splice(idx,1)[0];
  const firstTile=canonTile(t) || t;
  const firstRot = (firstTile.a===firstTile.b) ? Math.PI/2 : 0;
  chain.push({tile:firstTile,x:0,z:0,rot:firstRot,double:firstTile.a===firstTile.b});
  usedTileKeys.add(tileKey(firstTile));
  const step=STEP;
  const isDoubleStart = firstTile.a === firstTile.b;
  if(!flipDir){
    if(isDoubleStart){
      ends={
        L:{v:firstTile.a,x: DOUBLE_END_SHIFT,z:0,dir:[-1,0],orient:Math.PI},
        R:{v:firstTile.b,x:-DOUBLE_END_SHIFT,z:0,dir:[ 1,0],orient:0}
      };
    } else {
      ends={
        L:{v:firstTile.a,x:-step,z:0,dir:[-1,0],orient:Math.PI},
        R:{v:firstTile.b,x: step,z:0,dir:[ 1,0],orient:0}
      };
    }
  }
  else{
    if(isDoubleStart){
      ends={
        L:{v:firstTile.a,x:-DOUBLE_END_SHIFT,z:0,dir:[ 1,0],orient:0},
        R:{v:firstTile.b,x: DOUBLE_END_SHIFT,z:0,dir:[-1,0],orient:Math.PI}
      };
    } else {
      ends={
        L:{v:firstTile.a,x: step,z:0,dir:[ 1,0],orient:0},
        R:{v:firstTile.b,x:-step,z:0,dir:[-1,0],orient:Math.PI}
      };
    }
  }
  renderChain();
  current=(starter-1+N)%N;
  updateInteractivity();
  if(current!==human){
    scheduleCpuPlay();
  }
}

/* ---------- Placement & Snake ---------- */
function canPlayAny(hand){ if(!ends) return true; return hand.some(t=> t.a===ends.L.v||t.b===ends.L.v||t.a===ends.R.v||t.b===ends.R.v ); }
function validSidesFor(tile){ if(!ends) return {L:false,R:false}; return {L:(tile.a===ends.L.v||tile.b===ends.L.v), R:(tile.a===ends.R.v||tile.b===ends.R.v)}; }

function placeOnBoard(tile, side, options = {}){
  if(!chain.length || !isValidTile(tile)){
    return { success:false };
  }
  const end = (side < 0 ? ends?.L : ends?.R);
  if(!end){
    return { success:false };
  }
  const want = end.v;
  let a = tile.a, b = tile.b;
  if(a !== want && b === want){
    [a, b] = [b, a];
  }
  if(a !== want){
    return { success:false };
  }
  let [dx, dz] = end.dir;
  let nx = end.x + dx * STEP;
  let nz = end.z + dz * STEP;
  const railMargin = STEP * 0.65;
  const nearRail = Math.abs(nx) > (XMAX - railMargin) || Math.abs(nz) > (ZMAX - railMargin);
  if(Math.abs(nx) > XMAX || Math.abs(nz) > ZMAX || nearRail){
    const centerVecX = -end.x;
    const centerVecZ = -end.z;
    const candidates = [
      { dx: -dz, dz: dx },
      { dx: dz, dz: -dx }
    ];
    let best = null;
    let bestScore = -Infinity;
    for(const candidate of candidates){
      const candX = end.x + candidate.dx * STEP;
      const candZ = end.z + candidate.dz * STEP;
      const exceeds = Math.abs(candX) > XMAX || Math.abs(candZ) > ZMAX;
      const towardCenter = candidate.dx * centerVecX + candidate.dz * centerVecZ;
      const distance = Math.hypot(candX, candZ);
      let score = towardCenter - distance * 0.02;
      if(exceeds){
        score -= STEP * 25;
      }
      if(score > bestScore){
        bestScore = score;
        best = { dx: candidate.dx, dz: candidate.dz, x: candX, z: candZ, exceeds };
      }
    }
    if(best){
      dx = best.dx;
      dz = best.dz;
      nx = best.x;
      nz = best.z;
      if(best.exceeds){
        // fallback: clamp within limits if still slightly over the rail
        nx = Math.max(-XMAX + DOMINO_CHAIN_GAP, Math.min(XMAX - DOMINO_CHAIN_GAP, nx));
        nz = Math.max(-ZMAX + DOMINO_CHAIN_GAP, Math.min(ZMAX - DOMINO_CHAIN_GAP, nz));
      }
    }
  }
  const isDouble = (a === b);
  const isHorizontal = Math.abs(dx) >= Math.abs(dz);
  let rot;
  if(isDouble){
    rot = isHorizontal ? Math.PI / 2 : 0;
  } else if(isHorizontal){
    rot = (dx >= 0) ? 0 : Math.PI;
  } else {
    rot = (dz >= 0) ? Math.PI / 2 : -Math.PI / 2;
  }
  const orientedTile = { a, b };
  const key = tileKey(orientedTile);
  if(usedTileKeys.has(key)){
    return { success:false };
  }

  const segment = { tile: orientedTile, x: nx, z: nz, rot, double: isDouble, mesh: null };
  const animate = !!options.animate;
  if(animate){
    segment.animating = true;
  }
  chain.push(segment);
  usedTileKeys.add(key);

  const newVal = b;
  let nextOrient;
  if(isHorizontal){
    nextOrient = (dx >= 0) ? 0 : Math.PI;
  } else {
    nextOrient = (dz >= 0) ? Math.PI / 2 : -Math.PI / 2;
  }
  const updatedEnd = { v: newVal, x: nx, z: nz, dir: [dx, dz], orient: nextOrient };
  if(side < 0){
    ends.L = updatedEnd;
  } else {
    ends.R = updatedEnd;
  }

  if(animate){
    spawnPlacementAnimation(tile, segment, { duration: options.duration, mesh: options.animateMesh });
  } else {
    renderChain();
  }
  SFX.place.currentTime = 0;
  SFX.place.play();
  return { success:true, segment, end: updatedEnd };
}
function nextCandidate(end){
  let {x,z,dir:[dx,dz]}=end;
  let nx=x+dx*STEP, nz=z+dz*STEP;
  const railMargin = STEP * 0.65;
  if(Math.abs(nx)>XMAX || Math.abs(nz)>ZMAX || Math.abs(nx) > (XMAX - railMargin) || Math.abs(nz) > (ZMAX - railMargin)){
    const centerVecX = -x;
    const centerVecZ = -z;
    const candidates = [
      { dx: -dz, dz: dx },
      { dx: dz, dz: -dx }
    ];
    let best = { dx, dz, x: nx, z: nz, exceeds: (Math.abs(nx)>XMAX || Math.abs(nz)>ZMAX) };
    let bestScore = -Infinity;
    for(const candidate of candidates){
      const candX = x + candidate.dx * STEP;
      const candZ = z + candidate.dz * STEP;
      const exceeds = Math.abs(candX) > XMAX || Math.abs(candZ) > ZMAX;
      const towardCenter = candidate.dx * centerVecX + candidate.dz * centerVecZ;
      const distance = Math.hypot(candX, candZ);
      let score = towardCenter - distance * 0.02;
      if(exceeds){
        score -= STEP * 25;
      }
      if(score > bestScore){
        bestScore = score;
        best = { dx: candidate.dx, dz: candidate.dz, x: candX, z: candZ, exceeds };
      }
    }
    dx = best.dx;
    dz = best.dz;
    nx = best.exceeds ? Math.max(-XMAX + DOMINO_CHAIN_GAP, Math.min(XMAX - DOMINO_CHAIN_GAP, best.x)) : best.x;
    nz = best.exceeds ? Math.max(-ZMAX + DOMINO_CHAIN_GAP, Math.min(ZMAX - DOMINO_CHAIN_GAP, best.z)) : best.z;
  }
  const ang=Math.atan2(dz,dx);
  return {nx,nz,rot:ang,dx,dz};
}

/* ---------- Markers for manual placement ---------- */
function clearMarkers(){ if(markers.L){piecesG.remove(markers.L);markers.L=null;} if(markers.R){piecesG.remove(markers.R);markers.R=null;} }
function makeMarker(){ const g=new THREE.TorusGeometry(.098, .02, 24, 72); const m=new THREE.Mesh(g, markerMat.clone()); m.rotation.x=-Math.PI/2; m.position.y=CLOTH_TOP+0.011; m.renderOrder=10; return m; }
function showMarkersFor(tile){
  clearMarkers(); if(!ends) return;
  const canL = (tile.a===ends.L.v||tile.b===ends.L.v), canR=(tile.a===ends.R.v||tile.b===ends.R.v);
  if(canL){ const c=nextCandidate(ends.L); const mk=makeMarker(); mk.position.x=c.nx; mk.position.z=c.nz; mk.userData={marker:true, side:-1}; piecesG.add(mk); markers.L=mk; }
  if(canR){ const c=nextCandidate(ends.R); const mk=makeMarker(); mk.position.x=c.nx; mk.position.z=c.nz; mk.userData={marker:true, side:1}; piecesG.add(mk); markers.R=mk; }
}

/* ---------- Interactivity ---------- */
const raycaster=new THREE.Raycaster(); const pointer=new THREE.Vector2();
const activePointers = new Set();
function findPickRoot(o){
  let n=o; while(n){ if(n.userData && (n.userData.owner!==undefined || n.userData.marker)) return n; n=n.parent; } return o;
}
function humanPickTile(obj){ const tile = obj.userData.tile; selectedTile = tile; showMarkersFor(tile); setStatus('Pick a side (tap marker)'); }

renderer.domElement.addEventListener('pointerdown',ev=>{
  activePointers.add(ev.pointerId);
  if(gameFinished){
    return;
  }
  if(ev.pointerType==='touch' && activePointers.size>1){
    return;
  }
  // FIX: use the exact canvas size (rect) for the NDC coordinates
  const rect = renderer.domElement.getBoundingClientRect();
  const x = ((ev.clientX - rect.left)/rect.width)*2 - 1;
  const y = -(((ev.clientY - rect.top)/rect.height)*2 - 1);
  pointer.set(x,y); raycaster.setFromCamera(pointer,camera);
  const hits=raycaster.intersectObjects(piecesG.children,true); if(!hits.length) return; const hit=hits[0];
  const obj=findPickRoot(hit.object);
  const isHumanTurn=(current===human);
  if(!isHumanTurn) return;
  if(obj.userData && obj.userData.owner===human){ humanPickTile(obj); return; }
  if(obj.userData && obj.userData.marker && selectedTile){
    const side=obj.userData.side;
    const idx=players[human].hand.indexOf(selectedTile);
    if(idx>=0){
      const [picked] = players[human].hand.splice(idx,1);
      const placement = placeOnBoard(picked, side, { animate: true });
      if(!placement.success){
        players[human].hand.splice(idx,0,picked);
        selectedTile = picked;
        clearMarkers();
        renderHands();
        showMarkersFor(selectedTile);
        return;
      }
    }
    selectedTile=null; clearMarkers(); renderHands(); nextTurn(); return;
  }
});
renderer.domElement.addEventListener('pointerup',ev=>{ activePointers.delete(ev.pointerId); });
renderer.domElement.addEventListener('pointercancel',ev=>{ activePointers.delete(ev.pointerId); });
renderer.domElement.addEventListener('pointerleave',ev=>{ activePointers.delete(ev.pointerId); });

btnDraw.addEventListener('click',()=>{ if(current!==human || gameFinished) return; let drewTile=false;
  while(boneyard.length){
    const startWorld = getBoneyardTopWorld();
    const t=drawTileFromStock();
    if(!t) break;
    players[human].hand.push(t);
    spawnDrawAnimation(startWorld, human);
    drewTile = true;
    const canL=(t.a===ends?.L?.v||t.b===ends?.L?.v); const canR=(t.a===ends?.R?.v||t.b===ends?.R?.v);
    if(canL||canR) break;
  }
  clearMarkers(); selectedTile=null; renderHands(); if(drewTile){ SFX.draw.currentTime=0; SFX.draw.play(); }
});
btnPass.addEventListener('click',()=>{
  if(current===human && !gameFinished){
    clearMarkers();
    selectedTile=null;
    playPassSfx();
    nextTurn();
  }
});

startGame();

function blockedAndWinner(){
  if(!ends) return null;
  const nobodyCan = players.every(p=> !canPlayAny(p.hand));
  if(nobodyCan && boneyard.length===0){
    let best=Infinity, win=-1; players.forEach((p,pi)=>{ const s=pipSum(p.hand); if(s<best){best=s;win=pi;} });
    return {blocked:true, winner:win, reason:`Blocked. Lowest hand = Player ${win+1} (${best})`};
  }
  return null;
}

function scheduleCpuPlay(delay = CPU_PLAY_DELAY){
  if(cpuMoveTimeout){
    clearTimeout(cpuMoveTimeout);
    cpuMoveTimeout = null;
  }
  if(gameFinished){
    return;
  }
  const safeDelay = Math.max(0, Number.isFinite(delay) ? delay : CPU_PLAY_DELAY);
  cpuMoveTimeout = setTimeout(()=>{
    cpuMoveTimeout = null;
    if(!gameFinished){
      cpuPlay();
    }
  }, safeDelay);
}

function finishGame({ winner = null, reason = '', revealAll = false } = {}){
  if(gameFinished){
    return;
  }
  gameFinished = true;
  winnerIndex = Number.isInteger(winner) ? winner : null;
  revealAllHands = !!revealAll;
  if(cpuMoveTimeout){
    clearTimeout(cpuMoveTimeout);
    cpuMoveTimeout = null;
  }
  if(revealAllHands === false && Number.isInteger(winnerIndex) && winnerIndex >= 0){
    showWinnerHighlight(winnerIndex);
  } else if(revealAllHands){
    if(Number.isInteger(winnerIndex) && winnerIndex >= 0){
      showWinnerHighlight(winnerIndex);
    } else {
      clearWinnerHighlight();
    }
  } else {
    clearWinnerHighlight();
  }
  clearMarkers();
  selectedTile = null;
  renderHands();
  renderChain();
  if(reason){
    setStatus(reason);
  } else if(winnerIndex !== null){
    setStatus(winnerIndex === human ? 'You won!' : `Player ${winnerIndex+1} won!`);
  } else {
    setStatus('Game over');
  }
}

function checkForBlockedGame(){
  if(gameFinished){
    return true;
  }
  const blk = blockedAndWinner();
  if(blk){
    finishGame({ winner: blk.winner, reason: blk.reason, revealAll: true });
    return true;
  }
  return false;
}

function updateInteractivity(){
  if(gameFinished){
    renderHands();
    renderChain();
    return;
  }
  setStatus(`Turn: Player ${current+1}`);
  renderHands(); renderChain();
}
function nextTurn(){
  if(gameFinished){
    return;
  }
  const player = players[current];
  if(player && player.hand.length === 0){
    finishGame({ winner: current, reason: current === human ? 'You won!' : `Player ${current+1} won!` });
    return;
  }
  if(checkForBlockedGame()){
    return;
  }
  current=(current-1+N)%N;
  if(checkForBlockedGame()){
    return;
  }
  updateInteractivity();
  if(gameFinished){
    return;
  }
  if(current!==human){
    scheduleCpuPlay();
  }
}
function cpuPlay(){
  if(gameFinished){
    return;
  }
  const player = players[current];
  if(!player){ nextTurn(); return; }

  const moves = enumerateMoves(player.hand).map(move => ({ ...move, score: scoreMove(player, move) }));
  moves.sort((a,b)=> b.score - a.score);

  if(!moves.length){
    const drew = cpuDrawUntilPlayable(player);
    if(drew){
      renderHands();
      SFX.draw.currentTime = 0; SFX.draw.play();
      if(canPlayAny(player.hand)){
        scheduleCpuPlay();
      } else {
        playPassSfx();
        nextTurn();
      }
    } else {
      playPassSfx();
      nextTurn();
    }
    return;
  }

  for(const move of moves){
    const tile = player.hand[move.index];
    if(!tile) continue;
    const picked = player.hand.splice(move.index,1)[0];
    const placement = placeOnBoard(picked, move.side, { animate: true });
    if(placement.success){
      renderHands();
      if(player.hand.length===0){
        finishGame({ winner: current, reason: current === human ? 'You won!' : `Player ${current+1} won!` });
        return;
      }
      nextTurn();
      return;
    }
    player.hand.splice(move.index,0,picked);
  }

  // Fallback: if all scored moves failed (shouldn't happen) just draw or pass
  const drew = cpuDrawUntilPlayable(player);
  if(drew){
    renderHands();
    SFX.draw.currentTime = 0; SFX.draw.play();
    if(canPlayAny(player.hand)){
      scheduleCpuPlay();
    } else {
      playPassSfx();
      nextTurn();
    }
  } else {
    playPassSfx();
    nextTurn();
  }
}

/* ---------- Rules panel handlers ---------- */
btnRules.addEventListener('click',()=>{ panelRules.style.display='flex'; });
closeRules.addEventListener('click',()=>{ panelRules.style.display='none'; });
panelRules.addEventListener('click',(e)=>{ if(e.target===panelRules) panelRules.style.display='none'; });
if (viewToggle) {
  viewToggle.addEventListener('click', toggleCameraViewMode);
}
updateViewToggleLabel();

/* ---------- Mini tests (console) ---------- */
console.assert(document.getElementById('draw') && document.getElementById('pass'), 'UI buttons exist');
(()=>{ const s=genSet(); const key=t=>`${t.a},${t.b}`; const uniq=new Set(s.map(key));
  console.assert(s.length===28 && uniq.size===28,'double-six: 28 unique');
  console.assert(s.some(t=>t.a===0&&t.b===0) && s.some(t=>t.a===6&&t.b===6),'set contains 00 and 66');
  console.assert(s.every(t=>t.a>=0 && t.b>=0 && t.a<=6 && t.b<=6 && t.a<=t.b),'values in range and sorted');
})();
(()=>{ const ct1=canonTile({a:6,b:2}); const ct2=canonTile({a:2,b:6});
  console.assert(ct1.a===2 && ct1.b===6 && ct2.a===2 && ct2.b===6,'canonTile symmetric and idempotent');
})();
(()=>{ const bad1=canonTile({a:-1,b:3}); const bad2=canonTile({a:9,b:1});
  console.assert(bad1===null && bad2===null,'canonTile rejects out-of-range values');
})();
(()=>{ const m=makeDomino(6,6,{flat:true,faceUp:true}); const anyRing=m.children.some(ch=>ch.geometry?.type==='RingGeometry'); console.assert(anyRing,'perimeter/pip rings exist (flat)'); })();
(()=>{ const m=makeDomino(3,4,{flat:false,faceUp:true}); const pipCount=m.children.reduce((n,ch)=>n+(ch.geometry?.type==='SphereGeometry'?1:0),0); console.assert(pipCount>0,'pips exist'); })();

function updateDrawAnimations(now){
  const timestamp = Number.isFinite(now) ? now : performance.now();
  for(let i=drawAnimations.length-1;i>=0;i--){
    const anim = drawAnimations[i];
    const elapsed = timestamp - anim.startTime;
    const t = Math.min(1, elapsed / (anim.duration || DRAW_ANIM_DURATION));
    const ease = 1 - Math.pow(1 - t, 3);
    const pos = anim.start.clone();
    pos.lerp(anim.end, ease);
    if(anim.arc){
      pos.y += Math.sin(Math.PI * ease) * anim.arc;
    }
    anim.mesh.position.copy(pos);
    if(t >= 1){
      piecesG.remove(anim.mesh);
      drawAnimations.splice(i,1);
    }
  }
}

function updatePlacementAnimations(now){
  const timestamp = Number.isFinite(now) ? now : performance.now();
  for(let i=placementAnimations.length-1;i>=0;i--){
    const anim = placementAnimations[i];
    const elapsed = timestamp - anim.startTime;
    const duration = anim.duration || PLACE_ANIM_DURATION;
    const t = duration > 0 ? Math.min(1, elapsed / duration) : 1;
    const ease = 1 - Math.pow(1 - t, 3);

    const pos = anim.start.clone().lerp(anim.end, ease);
    if(anim.arc){
      pos.y += Math.sin(Math.PI * ease) * anim.arc;
    }
    anim.mesh.position.copy(pos);

    if(anim.endQuat && anim.startQuat){
      const quat = anim.startQuat.clone().slerp(anim.endQuat, ease);
      anim.mesh.quaternion.copy(quat);
    }

    if(anim.endScale && anim.startScale){
      const scale = anim.startScale.clone().lerp(anim.endScale, ease);
      anim.mesh.scale.copy(scale);
    }

    if(t >= 1){
      if(anim.segment){
        anim.segment.animating = false;
      }
      disposeDominoMesh(anim.mesh);
      placementAnimations.splice(i,1);
      renderChain();
    }
  }
}

function updateWinnerHighlight(now){
  if(!winnerHighlight){
    return;
  }
  const mat = winnerHighlight.material;
  if(!mat){
    return;
  }
  const timestamp = Number.isFinite(now) ? now : performance.now();
  const elapsed = Math.max(0, (timestamp - winnerHighlightStart) / 1000);
  const pulse = 0.55 + Math.sin(elapsed * 3.2) * 0.35;
  mat.opacity = Math.min(0.95, Math.max(0.25, pulse));
  const scale = 1 + Math.sin(elapsed * 1.6) * 0.06;
  winnerHighlight.scale.setScalar(scale);
}

/* ---------- Loop & Resize ---------- */
function tick(now){
  updateEntrySequence(now);
  updateDrawAnimations(now);
  updatePlacementAnimations(now);
  updateWinnerHighlight(now);
  controls.update();
  renderer.render(scene,camera);
  requestAnimationFrame(tick);
}
requestAnimationFrame(tick);
function onResize(){
  if (entrySequenceActive) {
    fitCamera();
    const finalDesired = clampCameraPosition(getDesiredCameraPosition());
    configureEntryCurves(finalDesired);
    const now = performance.now();
    const elapsed = Math.max(0, now - entryStartTime);
    const progress = Math.min(elapsed / ENTRY_TOTAL_DURATION, 1);
    if (entryCameraCurve) {
      const cameraPhase = easeInOutCubic(Math.min(Math.max((progress - 0.05) / 0.85, 0), 1));
      const point = entryCameraCurve.getPoint(cameraPhase);
      camera.position.copy(point);
    }
    if (entryTargetCurve) {
      const targetPhase = easeInOutCubic(Math.min(Math.max((progress - 0.08) / 0.75, 0), 1));
      const targetPoint = entryTargetCurve.getPoint(targetPhase);
      controls.target.copy(targetPoint);
    }
  } else {
    positionCameraForViewport();
  }
}
addEventListener('resize', onResize); if(window.visualViewport){ visualViewport.addEventListener('resize', onResize); }

if (shouldRunHallwayEntry) {
  startHallwayEntry();
} else {
  positionCameraForViewport({ force: true });
}
</script>
</body>
</html>
