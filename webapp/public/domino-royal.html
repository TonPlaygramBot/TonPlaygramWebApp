<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no"/>
<title>Domino Royal 3D</title>
<style>
  html,body{margin:0;height:100%;background:#ece6dc;overflow:hidden;font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial}
  #app{position:fixed;inset:0; width:100dvw; height:100dvh;}
  canvas{display:block; width:100dvw !important; height:100dvh !important; touch-action:none}
  button{font-weight:700;border:0;border-radius:999px;padding:.45rem .7rem;background:#ffd24a;color:#333;box-shadow:0 4px 12px rgba(0,0,0,.25);}
  button:active{transform:translateY(1px);}
  #status{position:fixed;top:calc(0.65rem + env(safe-area-inset-top, 0px));left:50%;transform:translateX(-50%);padding:.35rem .75rem;border-radius:999px;background:rgba(0,0,0,.55);color:#fff;font-weight:700;z-index:2;backdrop-filter:blur(6px);}
  #railControls{position:fixed;left:50%;bottom:calc(env(safe-area-inset-bottom,0px) + clamp(2.4rem, 14vh, 6.4rem));transform:translateX(-50%);display:flex;flex-direction:column;gap:.65rem;align-items:stretch;background:rgba(64,42,20,.88);color:#fff;border-radius:1.25rem;padding:.75rem .95rem 1rem .95rem;box-shadow:0 14px 30px rgba(0,0,0,.45);z-index:2;pointer-events:auto;min-width:clamp(8.5rem, 46vw, 13rem);}
  #railControls button{background:#ffd24a;color:#3b250f;font-size:1.05rem;padding:.7rem 1.1rem;border-radius:.9rem;}
  #draw{font-size:1.1rem;padding:.82rem 1.2rem;box-shadow:0 6px 18px rgba(0,0,0,.35);}
  #pass{background:rgba(255,210,74,.22);color:#f8e6b5;border:2px solid rgba(255,210,74,.55);}
  #btnRules{position:fixed;top:calc(0.75rem + env(safe-area-inset-top,0px));right:calc(0.75rem + env(safe-area-inset-right,0px));width:2.75rem;height:2.75rem;border-radius:999px;background:rgba(0,0,0,.58);color:#fff;display:grid;place-items:center;font-size:1.3rem;box-shadow:0 6px 18px rgba(0,0,0,.35);z-index:3;backdrop-filter:blur(6px);padding:0;}
  #btnRules span{pointer-events:none;}
  #configButton{position:fixed;top:calc(0.75rem + env(safe-area-inset-top,0px));left:calc(0.75rem + env(safe-area-inset-left,0px));width:3rem;height:3rem;border-radius:999px;background:rgba(0,0,0,.7);color:#fff;border:1px solid rgba(255,255,255,.18);display:grid;place-items:center;box-shadow:0 6px 18px rgba(0,0,0,.35);z-index:3;backdrop-filter:blur(8px);padding:0;transition:background .2s ease, border-color .2s ease;}
  #configButton:hover{background:rgba(0,0,0,.6);border-color:rgba(148,197,255,.45);}
  #configButton svg{width:1.4rem;height:1.4rem;}
  #configPanel{position:fixed;top:calc(4.4rem + env(safe-area-inset-top,0px));left:calc(0.75rem + env(safe-area-inset-left,0px));max-width:min(320px, 84vw);background:rgba(3,7,18,.92);color:#fff;border-radius:1.25rem;box-shadow:0 24px 40px rgba(2,6,23,.55);padding:1rem;border:1px solid rgba(148,197,255,.2);z-index:3;backdrop-filter:blur(10px);display:none;flex-direction:column;gap:0.75rem;}
  #configPanel.active{display:flex;}
  #configPanel h3{margin:0;font-size:.65rem;text-transform:uppercase;letter-spacing:.3rem;color:rgba(148,197,255,.75);}
  .config-section{display:flex;flex-direction:column;gap:.35rem;}
  .config-options{display:grid;grid-template-columns:repeat(2,minmax(0,1fr));gap:.5rem;}
  .config-option{border-radius:0.9rem;border:1px solid rgba(255,255,255,.12);background:rgba(15,23,42,.55);color:#e2e8f0;padding:.45rem .55rem;display:flex;flex-direction:column;align-items:flex-start;gap:.35rem;font-size:.75rem;font-weight:600;transition:border-color .2s ease, box-shadow .2s ease, transform .2s ease;}
  .config-option span{font-size:.62rem;text-transform:uppercase;letter-spacing:.28rem;color:rgba(148,197,255,.7);}
  .config-option.active{border-color:rgba(56,189,248,.7);background:rgba(56,189,248,.15);box-shadow:0 0 0 1px rgba(56,189,248,.35),0 12px 24px rgba(8,145,178,.28);}
  .config-option:disabled{opacity:.45;cursor:not-allowed;}
  .config-option:not(.active):hover{border-color:rgba(255,255,255,.32);transform:translateY(-1px);}
  .config-close{display:flex;justify-content:flex-end;}
  .config-close button{background:rgba(255,255,255,.1);border:1px solid rgba(255,255,255,.12);color:#f1f5f9;border-radius:999px;padding:.35rem;display:grid;place-items:center;transition:background .2s ease, border-color .2s ease;}
  .config-close button:hover{background:rgba(248,250,252,.16);border-color:rgba(248,250,252,.38);}
  @media (max-width:640px){
    #configPanel{left:50%;transform:translateX(-50%);top:calc(4.75rem + env(safe-area-inset-top,0px));}
  }
  #rules{position:fixed;top:0;left:0;right:0;bottom:0;display:none;align-items:center;justify-content:center;background:rgba(0,0,0,.55);z-index:3}
  #rules .card{max-width:720px;background:#fff;color:#222;border-radius:16px;box-shadow:0 12px 40px rgba(0,0,0,.25);padding:16px 18px}
  #rules h2{margin:0 0 6px 0;font-size:18px}
  #rules ol{margin:6px 0 0 18px}
  #rules .row{display:flex;gap:8px;justify-content:flex-end;margin-top:12px}
</style>
</head>
<body>
<div id="app"></div>
<div id="status" role="status">Ready</div>
<button id="configButton" type="button" aria-label="Table setup">
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.8" aria-hidden="true">
    <path stroke-linecap="round" stroke-linejoin="round" d="M12 15.5a3.5 3.5 0 1 0 0-7 3.5 3.5 0 0 0 0 7z" />
    <path
      stroke-linecap="round"
      stroke-linejoin="round"
      d="m19.4 13.5-.44 1.74a1 1 0 0 1-1.07.75l-1.33-.14a7.03 7.03 0 0 1-1.01.59l-.2 1.32a1 1 0 0 1-.98.84h-1.9a1 1 0 0 1-.98-.84l-.2-1.32a7.03 7.03 0 0 1-1.01-.59l-1.33.14a1 1 0 0 1-1.07-.75L4.6 13.5a1 1 0 0 1 .24-.96l1-.98a6.97 6.97 0 0 1 0-1.12l-1-.98a1 1 0 0 1-.24-.96l.44-1.74a1 1 0 0 1 1.07-.75l1.33.14c.32-.23.66-.43 1.01-.6l.2-1.31a1 1 0 0 1 .98-.84h1.9a1 1 0 0 1 .98.84l.2 1.31c.35.17.69.37 1.01.6l1.33-.14a1 1 0 0 1 1.07.75l.44 1.74a1 1 0 0 1-.24.96l-1 .98c.03.37.03.75 0 1.12l1 .98a1 1 0 0 1 .24.96z"
    />
  </svg>
</button>
<div
  id="configPanel"
  role="dialog"
  aria-modal="true"
  aria-labelledby="configTitle"
  tabindex="-1"
  aria-hidden="true"
>
  <div class="config-close">
    <button id="configClose" type="button" aria-label="Close table setup">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.8" aria-hidden="true">
        <path stroke-linecap="round" stroke-linejoin="round" d="m6 6 12 12M18 6 6 18" />
      </svg>
    </button>
  </div>
  <h3 id="configTitle">Table Setup</h3>
  <div id="configSections"></div>
</div>
<button id="btnRules" type="button" aria-label="Rules" title="Rules">
  <span aria-hidden="true">ℹ️</span>
</button>
<div id="railControls" aria-label="Game controls">
  <button id="draw" type="button">Draw</button>
  <button id="pass" type="button">Pass</button>
</div>
<div id="rules">
  <div class="card">
    <h2>Domino Royal — Rules for 2–4 players</h2>
    <ol>
      <li><b>Set:</b> Double-Six (28 tiles, 0–6). Each tile is unique (a,b) with a≤b. No duplicates.</li>
      <li><b>Dealing:</b> 7 tiles per player. The rest form the <i>stock</i> (boneyard).</li>
      <li><b>Opening:</b> The player with the highest double starts. If no double, the highest tile opens.</li>
      <li><b>On the table:</b> Every tile lies flat on the green cloth, touching end-to-end without overlapping. Keep the chain flush as you pivot at the rails so the spacing stays even.</li>
      <li><b>Matching:</b> The touching halves must show the same pip value. Doubles stand upright in place; all other tiles extend the snake in a straight line.</li>
      <li><b>No move?</b> Draw from the face-down stock stack near you (tap the Draw button below it) until you can play. If the stock is empty, pass.</li>
      <li><b>Ending:</b> The winner is the first out. If play is blocked, the lowest pip total wins.</li>
    </ol>
    <div class="row">
      <button id="closeRules">Close</button>
    </div>
  </div>
</div>

<script type="module">
import * as THREE from "https://esm.sh/three@0.160.0";
import { OrbitControls } from "https://esm.sh/three@0.160.0/examples/jsm/controls/OrbitControls.js";
import { RoomEnvironment } from "https://esm.sh/three@0.160.0/examples/jsm/environments/RoomEnvironment.js";
import { RoundedBoxGeometry } from "https://esm.sh/three@0.160.0/examples/jsm/geometries/RoundedBoxGeometry.js";

/* ---------- Audio (SFX) ---------- */
const SFX = {
  place: new Audio("https://cdn.pixabay.com/download/audio/2022/03/15/audio_7dc2b2.mp3?filename=click-124467.mp3"),
  draw:  new Audio("https://cdn.pixabay.com/download/audio/2022/03/15/audio_b2f7c5.mp3?filename=pop-124476.mp3")
};
SFX.place.volume = 0.7; SFX.draw.volume = 0.7;

/* ---------- Renderer / Scene ---------- */
const app = document.getElementById("app");
const renderer = new THREE.WebGLRenderer({ antialias:true, alpha:true, powerPreference:"high-performance" });
renderer.setPixelRatio(Math.min(devicePixelRatio,2));
renderer.outputColorSpace = THREE.SRGBColorSpace;              // ensure gold looks vibrant
renderer.toneMapping = THREE.ACESFilmicToneMapping;
renderer.toneMappingExposure = 1.05;
function setRendererSize(){
  const vv = window.visualViewport; const w = vv ? vv.width : window.innerWidth; const h = vv ? vv.height: window.innerHeight;
  renderer.setSize(w, h, false);
}
setRendererSize();
app.appendChild(renderer.domElement);
renderer.domElement.style.touchAction = 'none';

const scene = new THREE.Scene();
const pmrem = new THREE.PMREMGenerator(renderer);
const envTex = pmrem.fromScene(new RoomEnvironment(), 0.04).texture;
scene.environment = envTex;

const MODEL_SCALE = 0.75;
const ARENA_GROWTH = 1.45;
const TABLE_RADIUS = 3.4 * MODEL_SCALE;
const BASE_TABLE_HEIGHT = 1.08 * MODEL_SCALE;
const STOOL_SCALE = 1.5 * 1.3;
const SEAT_WIDTH = 0.9 * MODEL_SCALE * STOOL_SCALE;
const SEAT_DEPTH = 0.95 * MODEL_SCALE * STOOL_SCALE;
const SEAT_THICKNESS = 0.09 * MODEL_SCALE * STOOL_SCALE;
const BACK_HEIGHT = 0.68 * MODEL_SCALE * STOOL_SCALE;
const BACK_THICKNESS = 0.08 * MODEL_SCALE * STOOL_SCALE;
const ARM_HEIGHT = 0.3 * MODEL_SCALE * STOOL_SCALE;
const ARM_THICKNESS = 0.125 * MODEL_SCALE * STOOL_SCALE;
const ARM_DEPTH = SEAT_DEPTH * 0.75;
const COLUMN_HEIGHT = 0.5 * MODEL_SCALE * STOOL_SCALE;
const BASE_THICKNESS = 0.08 * MODEL_SCALE * STOOL_SCALE;
const COLUMN_RADIUS_TOP = 0.2 * MODEL_SCALE;
const COLUMN_RADIUS_BOTTOM = 0.26 * MODEL_SCALE;
const BASE_RADIUS = 0.72 * MODEL_SCALE;
const FOOT_RING_RADIUS = 0.52 * MODEL_SCALE;
const FOOT_RING_TUBE = 0.04 * MODEL_SCALE;
const CHAIR_GAP = 0.12 * MODEL_SCALE;
const CHAIR_RADIUS = TABLE_RADIUS + SEAT_DEPTH / 2 + CHAIR_GAP;
const CHAIR_BASE_HEIGHT = BASE_TABLE_HEIGHT - SEAT_THICKNESS * 0.85;
const STOOL_HEIGHT = CHAIR_BASE_HEIGHT + SEAT_THICKNESS;
const TABLE_HEIGHT_LIFT = 0.05 * MODEL_SCALE;
const TABLE_HEIGHT = STOOL_HEIGHT + TABLE_HEIGHT_LIFT;
const ARENA_WALL_HEIGHT = 3.6 * 1.3;
const ARENA_WALL_CENTER_Y = ARENA_WALL_HEIGHT / 2;
const ARENA_WALL_INNER_RADIUS = TABLE_RADIUS * ARENA_GROWTH * 2.4;
const CARPET_RADIUS = TABLE_RADIUS * ARENA_GROWTH * 2.2;
const FLOOR_RADIUS = TABLE_RADIUS * ARENA_GROWTH * 3.2;
const CAMERA_TARGET_LIFT = 0.08 * MODEL_SCALE;
const CAMERA_TARGET_EXTRA = 0.12 * MODEL_SCALE;
const CAMERA_FOV = 52;
const CAMERA_NEAR = 0.1;
const CAMERA_FAR = 5000;
const CAMERA_MIN_POLAR = 0.92;
const CAMERA_MAX_POLAR = 1.22;
const CAMERA_INITIAL_PHI = THREE.MathUtils.lerp(CAMERA_MIN_POLAR, CAMERA_MAX_POLAR, 0.35);
const CAMERA_BASE_RADIUS = TABLE_RADIUS;
const CAMERA_MIN_RADIUS = CAMERA_BASE_RADIUS * 0.95;
const CAMERA_MAX_RADIUS = CAMERA_BASE_RADIUS * 2.4;
const CAMERA_INITIAL_RADIUS = CAMERA_BASE_RADIUS * 1.35;
const CAMERA_DEFAULT_AZIMUTH = Math.PI / 2;
const CAMERA_TARGET = new THREE.Vector3(0, TABLE_HEIGHT + CAMERA_TARGET_LIFT + CAMERA_TARGET_EXTRA, 0);

const camera = new THREE.PerspectiveCamera(CAMERA_FOV, 1, CAMERA_NEAR, CAMERA_FAR);
function fitCamera(){
  const vv = window.visualViewport; const w= vv?vv.width:innerWidth; const h= vv?vv.height:innerHeight;
  camera.aspect = w/h; camera.updateProjectionMatrix(); setRendererSize();
}
fitCamera();

const controls = new OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;
controls.dampingFactor = 0.08;
controls.enableZoom = true;
controls.enablePan = false;
controls.enableRotate = true;
controls.minDistance = CAMERA_MIN_RADIUS;
controls.maxDistance = CAMERA_MAX_RADIUS;
controls.minPolarAngle = CAMERA_MIN_POLAR;
controls.maxPolarAngle = CAMERA_MAX_POLAR;
controls.touches.ONE = THREE.TOUCH.ROTATE;
controls.touches.TWO = THREE.TOUCH.DOLLY_PAN;
controls.touches.THREE = THREE.TOUCH.PAN;
controls.target.copy(CAMERA_TARGET);

let cameraHasUserControl = false;
controls.addEventListener('start', () => {
  cameraHasUserControl = true;
});
renderer.domElement.addEventListener(
  'wheel',
  () => {
    cameraHasUserControl = true;
  },
  { passive: true }
);

function positionCameraForViewport({ force = false } = {}) {
  fitCamera();
  const dom = renderer.domElement;
  const width = dom?.clientWidth || window.innerWidth || 1;
  const height = dom?.clientHeight || window.innerHeight || 1;
  const isPortrait = height >= width;
  const portraitBoost = isPortrait ? 1.08 : 1;
  const desiredRadius = THREE.MathUtils.clamp(
    CAMERA_INITIAL_RADIUS * portraitBoost,
    CAMERA_MIN_RADIUS,
    CAMERA_MAX_RADIUS
  );

  if (!cameraHasUserControl || force) {
    const spherical = new THREE.Spherical(desiredRadius, CAMERA_INITIAL_PHI, CAMERA_DEFAULT_AZIMUTH);
    const offset = new THREE.Vector3().setFromSpherical(spherical);
    camera.position.copy(CAMERA_TARGET).add(offset);
  } else {
    const offset = camera.position.clone().sub(CAMERA_TARGET);
    const spherical = new THREE.Spherical().setFromVector3(offset);
    spherical.radius = THREE.MathUtils.clamp(spherical.radius, CAMERA_MIN_RADIUS, CAMERA_MAX_RADIUS);
    spherical.phi = THREE.MathUtils.clamp(spherical.phi, CAMERA_MIN_POLAR, CAMERA_MAX_POLAR);
    const clampedOffset = new THREE.Vector3().setFromSpherical(spherical);
    camera.position.copy(CAMERA_TARGET).add(clampedOffset);
  }

  controls.target.copy(CAMERA_TARGET);
  controls.update();
}


/* ---------- Lights ---------- */
scene.add(new THREE.AmbientLight(0xffffff, 0.45));
scene.add(new THREE.HemisphereLight(0xffffff, 0xb8b19a, 0.55));
const key = new THREE.DirectionalLight(0xffffff, 1.6); key.position.set(3.2,3.6,2.2); key.castShadow=true; key.shadow.mapSize.set(2048,2048); scene.add(key);
const rimLight = new THREE.DirectionalLight(0xffffff, 0.55); rimLight.position.set(-2.2,2.6,-1.4); scene.add(rimLight);

const getPoolCarpetTextures = (() => {
  let cache = null;
  const clamp01 = (v) => Math.min(1, Math.max(0, v));
  const prng = (seed) => {
    let value = seed >>> 0;
    return () => {
      value = (value * 1664525 + 1013904223) % 4294967296;
      return value / 4294967296;
    };
  };
  const drawRoundedRect = (ctx, x, y, w, h, r) => {
    const radius = Math.max(0, Math.min(r, Math.min(w, h) / 2));
    ctx.beginPath();
    ctx.moveTo(x + radius, y);
    ctx.lineTo(x + w - radius, y);
    ctx.quadraticCurveTo(x + w, y, x + w, y + radius);
    ctx.lineTo(x + w, y + h - radius);
    ctx.quadraticCurveTo(x + w, y + h, x + w - radius, y + h);
    ctx.lineTo(x + radius, y + h);
    ctx.quadraticCurveTo(x, y + h, x, y + h - radius);
    ctx.lineTo(x, y + radius);
    ctx.quadraticCurveTo(x, y, x + radius, y);
    ctx.closePath();
  };
  return (renderer) => {
    if (cache) return cache;
    if (typeof document === "undefined") {
      cache = { map: null, bump: null };
      return cache;
    }
    const size = 1024;
    const canvas = document.createElement("canvas");
    canvas.width = canvas.height = size;
    const ctx = canvas.getContext("2d");

    const gradient = ctx.createLinearGradient(0, 0, size, size);
    gradient.addColorStop(0, "#0f172a");
    gradient.addColorStop(1, "#1e3a8a");
    ctx.fillStyle = gradient;
    ctx.fillRect(0, 0, size, size);

    const rand = prng(987654321);
    const image = ctx.getImageData(0, 0, size, size);
    const data = image.data;
    const baseColor = { r: 15, g: 23, b: 42 };
    const highlightColor = { r: 30, g: 58, b: 138 };
    const toChannel = (component) => Math.round(clamp01(component / 255) * 255);
    for (let y = 0; y < size; y++) {
      for (let x = 0; x < size; x++) {
        const idx = (y * size + x) * 4;
        const fiber = (Math.sin((x / size) * Math.PI * 14) + Math.cos((y / size) * Math.PI * 16)) * 0.08;
        const grain = (rand() - 0.5) * 0.12;
        const shade = clamp01(0.55 + fiber * 0.75 + grain * 0.6);
        const r = baseColor.r + (highlightColor.r - baseColor.r) * shade;
        const g = baseColor.g + (highlightColor.g - baseColor.g) * shade;
        const b = baseColor.b + (highlightColor.b - baseColor.b) * shade;
        data[idx] = toChannel(r);
        data[idx + 1] = toChannel(g);
        data[idx + 2] = toChannel(b);
      }
    }
    ctx.putImageData(image, 0, 0);

    ctx.globalAlpha = 0.04;
  ctx.fillStyle = "#0b1a38";
    for (let row = 0; row < size; row += 3) {
      ctx.fillRect(0, row, size, 1);
    }
    ctx.globalAlpha = 1;

    const insetRatio = 0.055;
    const stripeInset = size * insetRatio;
    const stripeRadius = size * 0.08;
    const stripeWidth = size * 0.012;
    ctx.lineWidth = stripeWidth;
    ctx.strokeStyle = "#f2b7b4";
    ctx.shadowColor = "rgba(80,20,30,0.18)";
    ctx.shadowBlur = stripeWidth * 0.8;
    drawRoundedRect(ctx, stripeInset, stripeInset, size - stripeInset * 2, size - stripeInset * 2, stripeRadius);
    ctx.stroke();
    ctx.shadowBlur = 0;

    const texture = new THREE.CanvasTexture(canvas);
    texture.wrapS = texture.wrapT = THREE.ClampToEdgeWrapping;
    texture.anisotropy = renderer?.capabilities?.getMaxAnisotropy?.() ?? 8;
    texture.minFilter = THREE.LinearMipMapLinearFilter;
    texture.magFilter = THREE.LinearFilter;
    texture.generateMipmaps = true;
    texture.colorSpace = THREE.SRGBColorSpace;

    const bumpCanvas = document.createElement("canvas");
    bumpCanvas.width = bumpCanvas.height = size;
    const bumpCtx = bumpCanvas.getContext("2d");
    bumpCtx.drawImage(canvas, 0, 0);
    const bumpImage = bumpCtx.getImageData(0, 0, size, size);
    const bumpData = bumpImage.data;
    const bumpRand = prng(246813579);
    for (let i = 0; i < bumpData.length; i += 4) {
      const r = bumpData[i];
      const g = bumpData[i + 1];
      const b = bumpData[i + 2];
      const lum = (r * 0.299 + g * 0.587 + b * 0.114) / 255;
      const noise = (bumpRand() - 0.5) * 0.16;
      const v = clamp01(0.62 + lum * 0.28 + noise);
      const value = Math.floor(v * 255);
      bumpData[i] = bumpData[i + 1] = bumpData[i + 2] = value;
    }
    bumpCtx.putImageData(bumpImage, 0, 0);

    const bump = new THREE.CanvasTexture(bumpCanvas);
    bump.wrapS = bump.wrapT = THREE.ClampToEdgeWrapping;
    bump.anisotropy = Math.min(texture.anisotropy ?? 4, 6);
    bump.minFilter = THREE.LinearMipMapLinearFilter;
    bump.magFilter = THREE.LinearFilter;
    bump.generateMipmaps = true;

    cache = { map: texture, bump };
    return cache;
  };
})();

const CHAIR_CLOTH_TEXTURE_SIZE = 512;
const CHAIR_CLOTH_REPEAT = 4;
const DEFAULT_CHAIR_THEME = Object.freeze({
  id: "ruby",
  label: "Rubi",
  seatColor: "#8b0000",
  legColor: "#1f1f1f",
  highlight: "#d46a6a"
});

const CHAIR_THEME_OPTIONS = Object.freeze([
  DEFAULT_CHAIR_THEME,
  { id: "slate", label: "Guri", seatColor: "#374151", legColor: "#0f172a", highlight: "#9ca3af" },
  { id: "teal", label: "Bruz", seatColor: "#0f766e", legColor: "#082f2a", highlight: "#34d399" },
  { id: "amber", label: "Qelibari", seatColor: "#b45309", legColor: "#2f2410", highlight: "#fbbf24" },
  { id: "violet", label: "Vjollcë", seatColor: "#7c3aed", legColor: "#2b1059", highlight: "#d8b4fe" },
  { id: "frost", label: "Akull", seatColor: "#1f2937", legColor: "#0f172a", highlight: "#94a3b8" }
]);

const TABLE_WOOD_OPTIONS = Object.freeze([
  { id: "walnutHeritage", label: "Arre Heritage", top: "#5b3a1f", rim: "#3b2414", accent: "#d4b07a" },
  { id: "mapleChevron", label: "Panjo Chevron", top: "#c48c56", rim: "#8a5d32", accent: "#f2d4a5" },
  { id: "oakEstate", label: "Lis Estate", top: "#8b5a2b", rim: "#59381c", accent: "#ddb88a" },
  { id: "teakStudio", label: "Tik Studio", top: "#754c28", rim: "#4a2e17", accent: "#c99a6b" },
  { id: "wengeShadow", label: "Wenge Hije", top: "#2b1b13", rim: "#160d08", accent: "#c5a37a" },
  { id: "ebonyClassic", label: "Eben Klasik", top: "#1a1a1c", rim: "#0f0f12", accent: "#c7c9d1" }
]);

const TABLE_CLOTH_OPTIONS = Object.freeze([
  { id: "crimson", label: "Rrobë e Kuqe", feltTop: "#960019", feltBottom: "#4a0012", border: "#210308" },
  { id: "emerald", label: "Rrobë Smerald", feltTop: "#0f6a2f", feltBottom: "#054d24", border: "#021a0b" },
  { id: "arctic", label: "Rrobë Akull", feltTop: "#2563eb", feltBottom: "#1d4ed8", border: "#071a42" },
  { id: "sunset", label: "Rrobë Perëndim", feltTop: "#ea580c", feltBottom: "#c2410c", border: "#320e03" },
  { id: "violet", label: "Rrobë Vjollcë", feltTop: "#7c3aed", feltBottom: "#5b21b6", border: "#1f0a47" },
  { id: "amber", label: "Rrobë Qelibari", feltTop: "#b7791f", feltBottom: "#92571a", border: "#2b1402" }
]);

const TABLE_BASE_OPTIONS = Object.freeze([
  { id: "obsidian", label: "Bazë Obsidian", base: "#141414", column: "#0b0d10", trim: "#1f232a" },
  { id: "forestBronze", label: "Bazë Pylli", base: "#101714", column: "#0a0f0c", trim: "#1f2d24" },
  { id: "midnightChrome", label: "Bazë Mesnate", base: "#0f172a", column: "#0a1020", trim: "#1e2f4a" },
  { id: "emberCopper", label: "Bazë Bakri", base: "#231312", column: "#140707", trim: "#5c2d1b" },
  { id: "violetShadow", label: "Bazë Hije Vjollcë", base: "#1f1130", column: "#130622", trim: "#3f1b5b" },
  { id: "desertGold", label: "Bazë Shkretëtirë", base: "#1c1a12", column: "#0f0d06", trim: "#5a4524" }
]);

const TABLE_SETUP_SECTIONS = [
  { key: "tableWood", label: "Dru i Tavolinës", options: TABLE_WOOD_OPTIONS },
  { key: "tableCloth", label: "Rroba e Tavolinës", options: TABLE_CLOTH_OPTIONS },
  { key: "tableBase", label: "Bazamenti", options: TABLE_BASE_OPTIONS },
  { key: "chairTheme", label: "Stolat", options: CHAIR_THEME_OPTIONS }
];

const DEFAULT_APPEARANCE = { tableWood: 0, tableCloth: 1, tableBase: 0, chairTheme: 0 };
const APPEARANCE_STORAGE_KEY = "dominoRoyalArenaAppearanceV2";
const LEGACY_APPEARANCE_KEYS = ["dominoRoyalArenaAppearance"];
let appearance = { ...DEFAULT_APPEARANCE };

function normalizeAppearance(raw) {
  const normalized = { ...DEFAULT_APPEARANCE };
  const source = raw && typeof raw === "object" ? raw : {};
  const limits = [
    ["tableWood", TABLE_WOOD_OPTIONS.length],
    ["tableCloth", TABLE_CLOTH_OPTIONS.length],
    ["tableBase", TABLE_BASE_OPTIONS.length],
    ["chairTheme", CHAIR_THEME_OPTIONS.length]
  ];
  limits.forEach(([key, max]) => {
    const value = Number(source[key]);
    if (Number.isFinite(value)) {
      normalized[key] = Math.min(Math.max(0, Math.round(value)), Math.max(0, max - 1));
    }
  });
  return normalized;
}

try {
  const keysToCheck = [APPEARANCE_STORAGE_KEY, ...LEGACY_APPEARANCE_KEYS];
  for (const key of keysToCheck) {
    const stored = window.localStorage?.getItem(key);
    if (!stored) continue;
    const parsed = JSON.parse(stored);
    if (parsed && typeof parsed === "object") {
      appearance = normalizeAppearance({ ...appearance, ...parsed });
      if (key !== APPEARANCE_STORAGE_KEY) {
        window.localStorage?.setItem(APPEARANCE_STORAGE_KEY, JSON.stringify(appearance));
      }
      break;
    }
  }
  appearance = normalizeAppearance(appearance);
} catch (error) {
  console.warn("Failed to load Domino Royal appearance", error);
  appearance = normalizeAppearance(appearance);
}

function adjustHexColor(hex, amount) {
  const base = new THREE.Color(hex);
  const target = amount >= 0 ? new THREE.Color(0xffffff) : new THREE.Color(0x000000);
  base.lerp(target, Math.min(Math.abs(amount), 1));
  return `#${base.getHexString()}`;
}

function createChairClothTexture(option, renderer) {
  if (typeof document === "undefined") {
    return null;
  }
  const primary = option?.seatColor ?? "#8b0000";
  const accent = adjustHexColor(primary, -0.28);
  const highlight = option?.highlight ?? adjustHexColor(primary, 0.22);
  const canvas = document.createElement("canvas");
  canvas.width = canvas.height = CHAIR_CLOTH_TEXTURE_SIZE;
  const ctx = canvas.getContext("2d");
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  const shadow = adjustHexColor(accent, -0.22);
  const seam = adjustHexColor(accent, -0.35);

  const gradient = ctx.createLinearGradient(0, 0, canvas.width, canvas.height);
  gradient.addColorStop(0, adjustHexColor(primary, 0.2));
  gradient.addColorStop(0.5, primary);
  gradient.addColorStop(1, accent);
  ctx.fillStyle = gradient;
  ctx.fillRect(0, 0, canvas.width, canvas.height);

  const spacing = canvas.width / CHAIR_CLOTH_REPEAT;
  const halfSpacing = spacing / 2;
  const lineWidth = Math.max(1.6, spacing * 0.06);

  ctx.strokeStyle = seam;
  ctx.lineWidth = lineWidth;
  ctx.globalAlpha = 0.9;
  for (let offset = -canvas.height; offset <= canvas.width + canvas.height; offset += spacing) {
    ctx.beginPath();
    ctx.moveTo(offset, 0);
    ctx.lineTo(offset - canvas.height, canvas.height);
    ctx.stroke();

    ctx.beginPath();
    ctx.moveTo(offset, 0);
    ctx.lineTo(offset + canvas.height, canvas.height);
    ctx.stroke();
  }
  ctx.globalAlpha = 1;

  ctx.strokeStyle = adjustHexColor(highlight, 0.18);
  ctx.lineWidth = lineWidth * 0.55;
  ctx.globalAlpha = 0.55;
  for (let offset = -canvas.height; offset <= canvas.width + canvas.height; offset += spacing) {
    ctx.beginPath();
    ctx.moveTo(offset + halfSpacing, 0);
    ctx.lineTo(offset + halfSpacing - canvas.height, canvas.height);
    ctx.stroke();

    ctx.beginPath();
    ctx.moveTo(offset + halfSpacing, 0);
    ctx.lineTo(offset + halfSpacing + canvas.height, canvas.height);
    ctx.stroke();
  }
  ctx.globalAlpha = 1;

  ctx.fillStyle = "rgba(0, 0, 0, 0.28)";
  const tuftRadius = Math.max(1.8, spacing * 0.08);
  for (let y = -spacing; y <= canvas.height + spacing; y += spacing) {
    for (let x = -spacing; x <= canvas.width + spacing; x += spacing) {
      ctx.beginPath();
      ctx.ellipse(x + halfSpacing, y + halfSpacing, tuftRadius, tuftRadius * 0.85, 0, 0, Math.PI * 2);
      ctx.fill();
    }
  }

  ctx.save();
  ctx.globalCompositeOperation = "overlay";
  const sheenGradient = ctx.createRadialGradient(
    canvas.width * 0.28,
    canvas.height * 0.32,
    canvas.width * 0.05,
    canvas.width * 0.28,
    canvas.height * 0.32,
    canvas.width * 0.75
  );
  sheenGradient.addColorStop(0, "rgba(255, 255, 255, 0.26)");
  sheenGradient.addColorStop(0.5, "rgba(255, 255, 255, 0.08)");
  sheenGradient.addColorStop(1, "rgba(0, 0, 0, 0.35)");
  ctx.fillStyle = sheenGradient;
  ctx.fillRect(0, 0, canvas.width, canvas.height);
  ctx.restore();

  ctx.globalAlpha = 0.08;
  for (let y = 0; y < canvas.height; y += 2) {
    for (let x = 0; x < canvas.width; x += 2) {
      ctx.fillStyle = Math.random() > 0.5 ? highlight : shadow;
      ctx.fillRect(x, y, 1, 1);
    }
  }
  ctx.globalAlpha = 1;

  const texture = new THREE.CanvasTexture(canvas);
  texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
  texture.repeat.set(CHAIR_CLOTH_REPEAT, CHAIR_CLOTH_REPEAT);
  texture.anisotropy = renderer?.capabilities?.getMaxAnisotropy?.() ?? 8;
  texture.colorSpace = THREE.SRGBColorSpace;
  texture.needsUpdate = true;
  return texture;
}

function createChairFabricMaterial(option, renderer) {
  const texture = createChairClothTexture(option, renderer);
  const primary = option?.seatColor ?? "#8b0000";
  const sheenColor = option?.highlight ?? adjustHexColor(primary, 0.2);
  const material = new THREE.MeshPhysicalMaterial({
    color: new THREE.Color(adjustHexColor(primary, 0.04)),
    map: texture,
    roughness: 0.28,
    metalness: 0.08,
    clearcoat: 0.48,
    clearcoatRoughness: 0.28,
    sheen: 0.18
  });
  if ("sheenColor" in material) {
    material.sheenColor.set(sheenColor);
  }
  if ("sheenRoughness" in material) {
    material.sheenRoughness = 0.32;
  }
  if ("specularIntensity" in material) {
    material.specularIntensity = 0.65;
  }
  return material;
}

const CHAIR_DIMENSIONS = Object.freeze({
  seatWidth: SEAT_WIDTH,
  seatDepth: SEAT_DEPTH,
  seatThickness: SEAT_THICKNESS,
  backHeight: BACK_HEIGHT,
  backThickness: BACK_THICKNESS,
  armHeight: ARM_HEIGHT,
  armThickness: ARM_THICKNESS,
  armDepth: ARM_DEPTH,
  columnHeight: COLUMN_HEIGHT,
  baseThickness: BASE_THICKNESS,
  columnRadiusTop: COLUMN_RADIUS_TOP,
  columnRadiusBottom: COLUMN_RADIUS_BOTTOM,
  baseRadius: BASE_RADIUS,
  footRingRadius: FOOT_RING_RADIUS,
  footRingTube: FOOT_RING_TUBE
});

function createDominoChair(option, renderer, sharedMaterials = null) {
  const material = sharedMaterials?.fabric ?? createChairFabricMaterial(option, renderer);
  const legMaterial = sharedMaterials?.leg ??
    new THREE.MeshStandardMaterial({
      color: new THREE.Color(option?.legColor ?? "#1f1f1f"),
      metalness: 0.6,
      roughness: 0.35
    });
  const metalAccent = sharedMaterials?.accent ??
    new THREE.MeshStandardMaterial({
      color: new THREE.Color("#2a2a2a"),
      metalness: 0.75,
      roughness: 0.32
    });

  const group = new THREE.Group();
  const dims = CHAIR_DIMENSIONS;

  const base = new THREE.Mesh(new THREE.CylinderGeometry(dims.baseRadius, dims.baseRadius * 1.02, dims.baseThickness, 32), legMaterial);
  base.position.y = dims.baseThickness / 2;
  base.castShadow = true;
  base.receiveShadow = true;
  group.add(base);

  const column = new THREE.Mesh(
    new THREE.CylinderGeometry(dims.columnRadiusBottom, dims.columnRadiusTop, dims.columnHeight, 24),
    legMaterial
  );
  column.position.y = dims.baseThickness + dims.columnHeight / 2;
  column.castShadow = true;
  column.receiveShadow = true;
  group.add(column);

  const footRing = new THREE.Mesh(new THREE.TorusGeometry(dims.footRingRadius, dims.footRingTube, 16, 48), metalAccent);
  footRing.rotation.x = Math.PI / 2;
  footRing.position.y = dims.baseThickness + dims.columnHeight * 0.45;
  footRing.castShadow = true;
  group.add(footRing);

  const seat = new THREE.Mesh(
    new THREE.BoxGeometry(dims.seatWidth, dims.seatThickness, dims.seatDepth),
    material
  );
  seat.position.y = dims.baseThickness + dims.columnHeight + dims.seatThickness / 2;
  seat.castShadow = true;
  seat.receiveShadow = true;
  group.add(seat);

  const cushion = new THREE.Mesh(
    new THREE.BoxGeometry(dims.seatWidth * 0.92, dims.seatThickness * 0.6, dims.seatDepth * 0.92),
    material
  );
  cushion.position.y = seat.position.y + dims.seatThickness * 0.2;
  cushion.castShadow = true;
  cushion.receiveShadow = true;
  group.add(cushion);

  const back = new THREE.Mesh(
    new THREE.BoxGeometry(dims.seatWidth * 0.98, dims.backHeight, dims.backThickness),
    material
  );
  back.position.set(0, seat.position.y + dims.backHeight / 2 - dims.seatThickness / 2, dims.seatDepth / 2 - dims.backThickness / 2);
  back.castShadow = true;
  back.receiveShadow = true;
  group.add(back);

  const armGeo = new THREE.BoxGeometry(dims.armThickness, dims.armHeight, dims.armDepth);
  const armY = seat.position.y + dims.armHeight / 2 - dims.seatThickness * 0.25;
  const armOffsetZ = (dims.armDepth - dims.seatDepth) / 2;
  const armLeft = new THREE.Mesh(armGeo, material);
  armLeft.position.set(-dims.seatWidth / 2 + dims.armThickness / 2, armY, armOffsetZ);
  armLeft.castShadow = true;
  armLeft.receiveShadow = true;
  group.add(armLeft);
  const armRight = new THREE.Mesh(armGeo, material);
  armRight.position.set(dims.seatWidth / 2 - dims.armThickness / 2, armY, armOffsetZ);
  armRight.castShadow = true;
  armRight.receiveShadow = true;
  group.add(armRight);

  const armCapGeo = new THREE.BoxGeometry(dims.armThickness * 0.9, dims.armThickness * 0.35, dims.armDepth * 0.92);
  const armCapY = armY + dims.armHeight / 2 - (dims.armThickness * 0.35) / 2;
  const armCapLeft = new THREE.Mesh(armCapGeo, material);
  armCapLeft.position.set(armLeft.position.x, armCapY, armOffsetZ * 0.94);
  armCapLeft.castShadow = true;
  armCapLeft.receiveShadow = true;
  group.add(armCapLeft);
  const armCapRight = new THREE.Mesh(armCapGeo, material);
  armCapRight.position.set(armRight.position.x, armCapY, armOffsetZ * 0.94);
  armCapRight.castShadow = true;
  armCapRight.receiveShadow = true;
  group.add(armCapRight);

  const columnCap = new THREE.Mesh(new THREE.CylinderGeometry(dims.columnRadiusTop * 1.05, dims.columnRadiusTop * 1.05, 0.02, 24), metalAccent);
  columnCap.position.y = dims.baseThickness + dims.columnHeight + 0.01;
  columnCap.castShadow = true;
  columnCap.receiveShadow = true;
  group.add(columnCap);

  return group;
}

/* ---------- World / Groups ---------- */
const arenaG = new THREE.Group();
scene.add(arenaG);

const tableG = new THREE.Group();
arenaG.add(tableG);
tableG.rotation.y = 0;
const piecesG = new THREE.Group();
tableG.add(piecesG);

/* ---------- Arena Dressings (Carpet & Walls) ---------- */
const floor = new THREE.Mesh(
  new THREE.CircleGeometry(FLOOR_RADIUS, 96),
  new THREE.MeshStandardMaterial({ color: 0x0b1120, roughness: 0.92, metalness: 0.12 })
);
floor.rotation.x = -Math.PI / 2;
floor.position.y = 0;
floor.receiveShadow = true;
arenaG.add(floor);

const carpetTextures = getPoolCarpetTextures(renderer);
const carpetMat = new THREE.MeshStandardMaterial({
  color: 0x0f172a,
  roughness: 0.92,
  metalness: 0.04
});
if (carpetTextures.map) {
  carpetMat.map = carpetTextures.map;
  carpetMat.map.needsUpdate = true;
  carpetMat.map.repeat.set(1, 1);
}
if (carpetTextures.bump) {
  carpetMat.bumpMap = carpetTextures.bump;
  carpetMat.bumpScale = 0.22;
  carpetMat.bumpMap.needsUpdate = true;
  carpetMat.bumpMap.repeat.set(1, 1);
}
const carpet = new THREE.Mesh(new THREE.CircleGeometry(CARPET_RADIUS, 96), carpetMat);
carpet.rotation.x = -Math.PI / 2;
carpet.position.y = 0.01;
carpet.receiveShadow = true;
arenaG.add(carpet);

const wallMaterial = new THREE.MeshStandardMaterial({
  color: 0x1e293b,
  emissive: 0x0b1120,
  emissiveIntensity: 0.25,
  roughness: 0.9,
  metalness: 0.08,
  side: THREE.DoubleSide
});
const wall = new THREE.Mesh(
  new THREE.CylinderGeometry(
    ARENA_WALL_INNER_RADIUS,
    ARENA_WALL_INNER_RADIUS * 1.02,
    ARENA_WALL_HEIGHT,
    80,
    1,
    true
  ),
  wallMaterial
);
wall.position.y = ARENA_WALL_CENTER_Y;
wall.receiveShadow = false;
wall.castShadow = false;
arenaG.add(wall);

/* ---------- Shapes & Table Build ---------- */
function createRegularPolygonShape(sides = 8, radius = 1) {
  const shape = new THREE.Shape();
  for (let i = 0; i < sides; i += 1) {
    const angle = (i / sides) * Math.PI * 2 - Math.PI / 2;
    const x = Math.cos(angle) * radius;
    const y = Math.sin(angle) * radius;
    if (i === 0) {
      shape.moveTo(x, y);
    } else {
      shape.lineTo(x, y);
    }
  }
  shape.closePath();
  return shape;
}

function makeClothTexture({ top = "#155c2a", bottom = "#0b3a1d", border = "#041f10" } = {}) {
  const size = 512;
  const canvas = document.createElement("canvas");
  canvas.width = canvas.height = size;
  const ctx = canvas.getContext("2d");
  const gradient = ctx.createLinearGradient(0, 0, size, size);
  gradient.addColorStop(0, top);
  gradient.addColorStop(1, bottom);
  ctx.fillStyle = gradient;
  ctx.fillRect(0, 0, size, size);

  ctx.globalAlpha = 0.12;
  ctx.strokeStyle = border;
  ctx.lineWidth = size * 0.012;
  ctx.strokeRect(0, 0, size, size);
  ctx.globalAlpha = 1;

  ctx.globalAlpha = 0.08;
  ctx.fillStyle = "#ffffff";
  for (let i = 0; i < size; i += 6) {
    ctx.fillRect(i, 0, 1, size);
    ctx.fillRect(0, i, size, 1);
  }
  ctx.globalAlpha = 1;

  const texture = new THREE.CanvasTexture(canvas);
  texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
  texture.repeat.set(5, 5);
  texture.anisotropy = renderer.capabilities.getMaxAnisotropy();
  texture.colorSpace = THREE.SRGBColorSpace;
  return texture;
}

function roundedRectAbs(width, height, radius) {
  const hw = width / 2;
  const hh = height / 2;
  const r = Math.min(Math.max(radius, 0), Math.min(hw, hh));
  const shape = new THREE.Shape();
  shape.moveTo(-hw + r, -hh);
  shape.lineTo(hw - r, -hh);
  shape.quadraticCurveTo(hw, -hh, hw, -hh + r);
  shape.lineTo(hw, hh - r);
  shape.quadraticCurveTo(hw, hh, hw - r, hh);
  shape.lineTo(-hw + r, hh);
  shape.quadraticCurveTo(-hw, hh, -hw, hh - r);
  shape.lineTo(-hw, -hh + r);
  shape.quadraticCurveTo(-hw, -hh, -hw + r, -hh);
  shape.closePath();
  return shape;
}

const tableMaterials = {
  top: new THREE.MeshStandardMaterial({ roughness: 0.55, metalness: 0.12 }),
  rim: new THREE.MeshStandardMaterial({ roughness: 0.6, metalness: 0.14 }),
  accent: new THREE.MeshStandardMaterial({ roughness: 0.4, metalness: 0.32 }),
  felt: new THREE.MeshStandardMaterial({ roughness: 1, metalness: 0 }),
  base: new THREE.MeshStandardMaterial({ roughness: 0.35, metalness: 0.65 }),
  column: new THREE.MeshStandardMaterial({ roughness: 0.32, metalness: 0.72 }),
  trim: new THREE.MeshStandardMaterial({ roughness: 0.22, metalness: 0.85 })
};

function updateTableMaterials() {
  const wood = TABLE_WOOD_OPTIONS[appearance.tableWood] ?? TABLE_WOOD_OPTIONS[0];
  tableMaterials.top.color.set(wood.top);
  tableMaterials.rim.color.set(wood.rim);
  tableMaterials.accent.color.set(wood.accent);

  const cloth = TABLE_CLOTH_OPTIONS[appearance.tableCloth] ?? TABLE_CLOTH_OPTIONS[0];
  tableMaterials.felt.color.set(cloth.feltTop);
  if (tableMaterials.felt.map) {
    tableMaterials.felt.map.dispose();
  }
  tableMaterials.felt.map = makeClothTexture({ top: cloth.feltTop, bottom: cloth.feltBottom, border: cloth.border });
  tableMaterials.felt.map.needsUpdate = true;

  const base = TABLE_BASE_OPTIONS[appearance.tableBase] ?? TABLE_BASE_OPTIONS[0];
  tableMaterials.base.color.set(base.base);
  tableMaterials.column.color.set(base.column);
  tableMaterials.trim.color.set(base.trim);
}
updateTableMaterials();

const tableParts = {};
const chairs = [];
const TABLE_OUTER_RADIUS = TABLE_RADIUS;
const TABLE_INNER_RADIUS = TABLE_OUTER_RADIUS * 0.84;
const CLOTH_RADIUS = TABLE_OUTER_RADIUS * 0.72;
const TABLE_TOP_DEPTH = 0.06 * MODEL_SCALE;
const RIM_THICK = 0.08 * MODEL_SCALE;
const TABLE_BASE_Y = TABLE_HEIGHT - TABLE_TOP_DEPTH;
const CLOTH_TOP = TABLE_HEIGHT;
const RAIL_TOP = CLOTH_TOP + 0.04 * MODEL_SCALE;

(function buildTable() {
  const sides = 8;
  const topShape = createRegularPolygonShape(sides, TABLE_OUTER_RADIUS);
  const feltShape = createRegularPolygonShape(sides, CLOTH_RADIUS);
  const rimInnerShape = createRegularPolygonShape(sides, TABLE_INNER_RADIUS);

  const topGeo = new THREE.ExtrudeGeometry(topShape, {
    depth: TABLE_TOP_DEPTH,
    bevelEnabled: true,
    bevelThickness: TABLE_TOP_DEPTH * 0.55,
    bevelSize: TABLE_TOP_DEPTH * 0.5,
    bevelSegments: 8
  });
  topGeo.rotateX(-Math.PI / 2);
  const topMesh = new THREE.Mesh(topGeo, tableMaterials.top);
  topMesh.position.y = TABLE_BASE_Y;
  topMesh.castShadow = true;
  topMesh.receiveShadow = true;
  tableG.add(topMesh);
  tableParts.top = topMesh;

  const feltGeo = new THREE.ExtrudeGeometry(feltShape, { depth: 0.01, bevelEnabled: false });
  feltGeo.rotateX(-Math.PI / 2);
  const feltMesh = new THREE.Mesh(feltGeo, tableMaterials.felt);
  feltMesh.position.y = CLOTH_TOP;
  feltMesh.receiveShadow = true;
  tableG.add(feltMesh);
  tableParts.felt = feltMesh;

  const rimShape = topShape.clone();
  rimShape.holes.push(rimInnerShape);
  const rimGeo = new THREE.ExtrudeGeometry(rimShape, {
    depth: RIM_THICK,
    bevelEnabled: true,
    bevelThickness: RIM_THICK * 0.45,
    bevelSize: RIM_THICK * 0.42,
    bevelSegments: 6
  });
  rimGeo.rotateX(-Math.PI / 2);
  const rimMesh = new THREE.Mesh(rimGeo, tableMaterials.rim);
  rimMesh.position.y = TABLE_BASE_Y + TABLE_TOP_DEPTH * 0.55;
  rimMesh.castShadow = true;
  rimMesh.receiveShadow = true;
  tableG.add(rimMesh);
  tableParts.rim = rimMesh;

  const accentShape = rimInnerShape.clone();
  accentShape.holes.push(feltShape);
  const accentGeo = new THREE.ExtrudeGeometry(accentShape, { depth: 0.012, bevelEnabled: false });
  accentGeo.rotateX(-Math.PI / 2);
  const accentMesh = new THREE.Mesh(accentGeo, tableMaterials.accent);
  accentMesh.position.y = CLOTH_TOP - 0.003;
  tableG.add(accentMesh);
  tableParts.accent = accentMesh;

  const columnHeight = TABLE_HEIGHT + 0.25;
  const column = new THREE.Mesh(
    new THREE.CylinderGeometry(TABLE_OUTER_RADIUS * 0.34, TABLE_OUTER_RADIUS * 0.48, columnHeight, 48),
    tableMaterials.column
  );
  column.position.y = TABLE_BASE_Y - columnHeight / 2;
  column.castShadow = true;
  column.receiveShadow = true;
  tableG.add(column);
  tableParts.column = column;

  const base = new THREE.Mesh(
    new THREE.CylinderGeometry(TABLE_OUTER_RADIUS * 0.86, TABLE_OUTER_RADIUS * 0.96, 0.16, 64),
    tableMaterials.base
  );
  base.position.y = column.position.y - columnHeight / 2 - 0.08;
  base.castShadow = true;
  base.receiveShadow = true;
  tableG.add(base);
  tableParts.base = base;

  const trim = new THREE.Mesh(
    new THREE.TorusGeometry(TABLE_OUTER_RADIUS * 0.9, 0.035, 16, 64),
    tableMaterials.trim
  );
  trim.rotation.x = Math.PI / 2;
  trim.position.y = base.position.y + 0.08;
  tableG.add(trim);
  tableParts.trim = trim;
})();

const SCALE = MODEL_SCALE * 0.92;
const DOMINO_LENGTH = SCALE * (0.016 / 0.22) * 2;
const DOMINO_CHAIN_GAP = DOMINO_LENGTH * 0.08;
const STEP = DOMINO_LENGTH + DOMINO_CHAIN_GAP;
const DOMINO_HAND_GAP = DOMINO_LENGTH * 1.12;
const TILE_UP_H = 0.2 * SCALE;
const TILE_UP_HALF = TILE_UP_H / 2;
const XMAX = CLOTH_RADIUS - 0.32 - DOMINO_CHAIN_GAP * 0.5;
const ZMAX = CLOTH_RADIUS - 0.32 - DOMINO_CHAIN_GAP * 0.5;
const HAND_Y = RAIL_TOP + TILE_UP_HALF + 0.0012;

/* ---------- Materials ---------- */
const porcelainMat = new THREE.MeshPhysicalMaterial({
  color: 0xf8f8fb,
  roughness: 0.12,
  metalness: 0.2,
  clearcoat: 1.0,
  clearcoatRoughness: 0.05,
  reflectivity: 0.6,
});
const pipMat = new THREE.MeshPhysicalMaterial({
  color: 0x0a0a0a,
  roughness: 0.05,
  metalness: 0.6,
  clearcoat: 0.9,
  clearcoatRoughness: 0.04,
});
const goldMat = new THREE.MeshPhysicalMaterial({
  color: 0xFFD700,                 // brighter gold
  emissive: 0x3a2a00,              // warm self-light so it never looks black
  emissiveIntensity: 0.55,
  metalness: 1.0,
  roughness: 0.18,
  reflectivity: 1.0,
  envMapIntensity: 1.4,
  transmission: 0.0,
  side: THREE.DoubleSide,
  polygonOffset: true,
  polygonOffsetFactor: -1,
  polygonOffsetUnits: -1,
});
const markerMat = new THREE.MeshStandardMaterial({ color:"#15d16f", roughness:.7, metalness:0, transparent:true, opacity:.55 });

const boneyardStackG = new THREE.Group();
const BONEYARD_STACK_POSITION = new THREE.Vector3(-TABLE_RADIUS * 0.55, CLOTH_TOP + 0.0075, TABLE_RADIUS * 0.55);
boneyardStackG.position.copy(BONEYARD_STACK_POSITION);
piecesG.add(boneyardStackG);
const BONEYARD_STACK_STEP = SCALE * 0.22 * 0.1 * 1.02;
const MAX_BONEYARD_DISPLAY = 12;
let boneyardStackVisible = 0;
let boneyardStackTopLocal = 0;

const drawAnimations = [];
const DRAW_ANIM_DURATION = 480;

const configButtonEl = document.getElementById('configButton');
const configPanelEl = document.getElementById('configPanel');
const configSectionsEl = document.getElementById('configSections');
const configCloseEl = document.getElementById('configClose');
if (configButtonEl) {
  configButtonEl.setAttribute('aria-controls', 'configPanel');
  configButtonEl.setAttribute('aria-expanded', 'false');
}
if (configPanelEl) {
  configPanelEl.setAttribute('aria-hidden', 'true');
}

function saveAppearance() {
  try {
    const normalized = normalizeAppearance(appearance);
    appearance = normalized;
    localStorage.setItem(APPEARANCE_STORAGE_KEY, JSON.stringify(normalized));
  } catch (error) {
    console.warn('Failed to persist Domino appearance', error);
  }
}

function applyAppearanceChange({ refresh = true } = {}) {
  appearance = normalizeAppearance(appearance);
  updateTableMaterials();
  Object.values(tableMaterials).forEach((material) => {
    if (material && typeof material.needsUpdate === 'boolean') {
      material.needsUpdate = true;
    }
    if (material?.map) {
      material.map.needsUpdate = true;
    }
  });
  buildChairs(CHAIR_THEME_OPTIONS[appearance.chairTheme] ?? DEFAULT_CHAIR_THEME);
  saveAppearance();
  if (refresh) {
    refreshConfigUI();
  }
}

function createOptionPreview(key, option) {
  const swatch = document.createElement('div');
  swatch.style.width = '100%';
  swatch.style.height = '1.5rem';
  swatch.style.borderRadius = '0.75rem';
  swatch.style.border = '1px solid rgba(255,255,255,0.12)';
  switch (key) {
    case 'tableWood':
      swatch.style.background = `linear-gradient(135deg, ${option.top}, ${option.rim})`;
      break;
    case 'tableCloth':
      swatch.style.background = `linear-gradient(135deg, ${option.feltTop}, ${option.feltBottom})`;
      break;
    case 'tableBase':
      swatch.style.background = `linear-gradient(135deg, ${option.base}, ${option.trim})`;
      break;
    case 'chairTheme':
      swatch.style.background = option.seatColor;
      break;
    default:
      swatch.style.background = '#1f2937';
  }
  return swatch;
}

function refreshConfigUI() {
  if (!configSectionsEl) return;
  configSectionsEl.replaceChildren();
  TABLE_SETUP_SECTIONS.forEach((section) => {
    const wrapper = document.createElement('div');
    wrapper.className = 'config-section';
    const label = document.createElement('h4');
    label.textContent = section.label;
    wrapper.appendChild(label);
    const optionsGrid = document.createElement('div');
    optionsGrid.className = 'config-options';
    section.options.forEach((option, idx) => {
      const button = document.createElement('button');
      button.type = 'button';
      button.className = 'config-option';
      if (appearance[section.key] === idx) {
        button.classList.add('active');
      }
      button.appendChild(createOptionPreview(section.key, option));
      const name = document.createElement('span');
      name.textContent = option.label ?? option.id;
      button.appendChild(name);
      button.addEventListener('click', () => {
        if (appearance[section.key] === idx) return;
        appearance[section.key] = idx;
        applyAppearanceChange({ refresh: false });
        refreshConfigUI();
      });
      optionsGrid.appendChild(button);
    });
    wrapper.appendChild(optionsGrid);
    configSectionsEl.appendChild(wrapper);
  });
}

function closeConfigPanel() {
  configPanelEl?.classList.remove('active');
  configPanelEl?.setAttribute('aria-hidden', 'true');
  configButtonEl?.setAttribute('aria-expanded', 'false');
}

configButtonEl?.addEventListener('click', () => {
  const isOpen = configPanelEl?.classList.toggle('active');
  if (typeof isOpen === 'boolean') {
    configPanelEl?.setAttribute('aria-hidden', String(!isOpen));
    configButtonEl?.setAttribute('aria-expanded', String(isOpen));
    if (isOpen) {
      refreshConfigUI();
      window.requestAnimationFrame(() => {
        try {
          configPanelEl?.focus?.();
        } catch {}
      });
    }
  }
});
configCloseEl?.addEventListener('click', () => closeConfigPanel());
document.addEventListener('click', (event) => {
  if (!configPanelEl?.classList.contains('active')) return;
  if (configPanelEl.contains(event.target) || event.target === configButtonEl) return;
  closeConfigPanel();
});
document.addEventListener('keydown', (event) => {
  if (event.key === 'Escape') {
    closeConfigPanel();
  }
});

applyAppearanceChange({ refresh: false });
refreshConfigUI();


/* ---------- Seating (Texas Hold'em Style Chairs) ---------- */
const CHAIR_TEXTURE_PROPS = Object.freeze([
  'map',
  'normalMap',
  'roughnessMap',
  'metalnessMap',
  'aoMap',
  'alphaMap',
  'emissiveMap',
  'bumpMap',
  'displacementMap',
  'clearcoatMap',
  'clearcoatRoughnessMap',
  'clearcoatNormalMap',
  'specularMap',
  'sheenColorMap',
  'sheenRoughnessMap'
]);

function disposeChairResources(root) {
  root.traverse((child) => {
    if (!child.isMesh) return;
    if (child.geometry?.dispose) {
      child.geometry.dispose();
    }
    const materials = Array.isArray(child.material) ? child.material : [child.material];
    materials.forEach((material) => {
      if (!material) return;
      CHAIR_TEXTURE_PROPS.forEach((prop) => {
        const texture = material[prop];
        if (texture?.isTexture) {
          texture.dispose();
        }
      });
      if (material.dispose) {
        material.dispose();
      }
    });
  });
}

function buildChairs(option = CHAIR_THEME_OPTIONS[appearance.chairTheme] ?? DEFAULT_CHAIR_THEME) {
  while (chairs.length) {
    const chair = chairs.pop();
    chair.parent?.remove(chair);
    disposeChairResources(chair);
  }
  const sharedMaterials = {
    fabric: createChairFabricMaterial(option, renderer),
    leg: new THREE.MeshStandardMaterial({
      color: new THREE.Color(option.legColor ?? "#1f1f1f"),
      metalness: 0.6,
      roughness: 0.35
    }),
    accent: new THREE.MeshStandardMaterial({
      color: new THREE.Color(adjustHexColor(option.legColor ?? "#1f1f1f", 0.15)),
      metalness: 0.75,
      roughness: 0.32
    })
  };
  const angles = Array.from({ length: 6 }, (_, i) => Math.PI / 2 - (i * (Math.PI * 2)) / 6);
  const lookTarget = new THREE.Vector3(0, TABLE_HEIGHT, 0);
  const seatBottomOffset = CHAIR_DIMENSIONS.baseThickness + CHAIR_DIMENSIONS.columnHeight;
  angles.forEach((angle) => {
    const wrapper = new THREE.Group();
    wrapper.position.set(Math.cos(angle) * CHAIR_RADIUS, CHAIR_BASE_HEIGHT, Math.sin(angle) * CHAIR_RADIUS);
    wrapper.lookAt(lookTarget);
    wrapper.rotateY(Math.PI);

    const chair = createDominoChair(option, renderer, sharedMaterials);
    chair.position.y = -seatBottomOffset;
    wrapper.add(chair);

    tableG.add(wrapper);
    chairs.push(wrapper);
  });
}

/* ---------- Tile Helpers (ensure defined before use) ---------- */
function isValidTile(t){
  if(!t || typeof t.a!=="number" || typeof t.b!=="number") return false;
  if(t.a<0||t.b<0||t.a>6||t.b>6) return false; return true;
}
function canonTile(t){
  if(!isValidTile(t)) return null; let {a,b}=t; if(a>b){ const k=a; a=b; b=k; } return {a,b};
}

/* ---------- Domino EXACT per kërkesën tënde ---------- */
function pipPositions(){
  return [
    [-0.3, 0.6], [0, 0.6], [0.3, 0.6],
    [-0.3, 0.3], [0, 0.3], [0.3, 0.3],
    [-0.3, 0.0], [0, 0.0], [0.3, 0.0],
  ];
}
const INDEX_SETS = { 0: [], 1: [4], 2: [0,8], 3: [0,4,8], 4: [0,2,6,8], 5: [0,2,4,6,8], 6: [0,2,3,5,6,8] };

function addGoldPerimeter(domino){
  const inset = 0.04;
  const w = 1 - inset*2;
  const h = 2 - inset*2;
  const shape = new THREE.Shape();
  shape.moveTo(-w/2, -h/2);
  shape.lineTo( w/2, -h/2);
  shape.lineTo( w/2,  h/2);
  shape.lineTo(-w/2,  h/2);
  shape.lineTo(-w/2, -h/2);
  const hole = new THREE.Path();
  const t = 0.015;
  hole.moveTo(-w/2 + t, -h/2 + t);
  hole.lineTo( w/2 - t, -h/2 + t);
  hole.lineTo( w/2 - t,  h/2 - t);
  hole.lineTo(-w/2 + t,  h/2 - t);
  hole.lineTo(-w/2 + t, -h/2 + t);
  shape.holes.push(hole);
  const extrude = new THREE.ExtrudeGeometry(shape, { depth: 0.01, bevelEnabled: false });
  const frame = new THREE.Mesh(extrude, goldMat.clone());
  frame.position.z = 0.11;
  frame.renderOrder = 5; // sit on top
  domino.add(frame);
}

function addPips(dominoFace, count, yOffset){
  const positions = pipPositions();
  const idxs = INDEX_SETS[Math.max(0, Math.min(6, count))];
  const pipGeo = new THREE.SphereGeometry(0.085, 24, 24);
  idxs.forEach(i => {
    const [px, py] = positions[i];
    const sphere = new THREE.Mesh(pipGeo, pipMat);
    sphere.position.set(px, py + yOffset, 0.11);
    dominoFace.add(sphere);

    // Unazë ari rreth pikes (gold)
    const innerR = 0.107;
    const outerR = 0.120;
    const ringGeo = new THREE.RingGeometry(innerR, outerR, 64);
    const ring = new THREE.Mesh(ringGeo, goldMat.clone());
    ring.position.set(px, py + yOffset, 0.11);
    ring.renderOrder = 6; // above porcelain & pip
    dominoFace.add(ring);
  });
}

function makeDomino(a,b,{flat=true, faceUp=true}={}){
  const ct = canonTile({a,b}); if(!ct){ return new THREE.Group(); }
  a=ct.a; b=ct.b;

  const group = new THREE.Group();

  // Trupi SAKTËSISHT si në kodin tënd
  const bodyGeo = new RoundedBoxGeometry(1, 2, 0.22, 4, 0.06);
  const body = new THREE.Mesh(bodyGeo, porcelainMat.clone());
  body.castShadow = true; body.receiveShadow = true;

  // Vijë mesi — GOLD
  const midW = 1 - 0.08;         // sipas kodit
  const midH = 0.03;
  const midR = 0.06;
  const midShape = roundedRectAbs(midW, midH, Math.min(midR, midH/2));
  const midGeo = new THREE.ExtrudeGeometry(midShape, { depth: 0.01, bevelEnabled: false });
  const midLine = new THREE.Mesh(midGeo, goldMat.clone());
  midLine.position.z = 0.11;
  midLine.renderOrder = 5;
  body.add(midLine);

  // Kornizë ari rrethuese — GOLD
  addGoldPerimeter(body);

  // Pikat sipas kodit — faqe sipër & poshtë (në koordinata të trupit)
  if(faceUp){
    addPips(body, a, -0.8);
    addPips(body, b,  0.2);
  }

  group.add(body);

  // Invisible collider to make touch / pick detection more forgiving on mobile
  const colliderGeo = new THREE.BoxGeometry(1.85, faceUp ? 0.82 : 1.4, 1.85);
  const colliderMat = new THREE.MeshBasicMaterial({ transparent: true, opacity: 0, depthWrite: false });
  const collider = new THREE.Mesh(colliderGeo, colliderMat);
  collider.name = 'touchCollider';
  collider.renderOrder = -1;
  collider.castShadow = false;
  collider.receiveShadow = false;
  group.add(collider);

  // Integrim me sistemin ekzistues: në fushë duhen "flat" (faqe lart)
  if(flat){ group.rotation.x = -Math.PI/2; }

  // Ruaj shkallën ekzistuese të botës (ashtu si para ndryshimit)
  const sx = 0.10 / 1.0, sy = (flat? 0.016/0.22 : 0.20/2.0), sz = (flat? 0.20/2.0 : 0.016/0.22);
  group.scale.set(SCALE*sx, SCALE*sy, SCALE*sz);

  group.userData.val = [a,b];
  return group;
}

/* ---------- Game State ---------- */
const statusEl = document.getElementById('status');
const btnDraw = document.getElementById('draw');
const btnPass = document.getElementById('pass');
const btnRules = document.getElementById('btnRules');
const panelRules = document.getElementById('rules');
const closeRules = document.getElementById('closeRules');

let statusPrefix = '';
let N = 4; let players = []; let boneyard = []; let chain = [];
let ends = null; // {L:{v,x,z,dir:[dx,dz]}, R:{...}}
let current = 0; let human = 0;
let markers = {L:null, R:null}; let selectedTile = null;
let flipDir = false; // alterno drejtimin e zinxhirit pas çdo loje
const usedTileKeys = new Set();

function tileKey(tile){
  const ct = canonTile(tile);
  return ct ? `${ct.a}|${ct.b}` : '';
}

function setStatus(t){ statusEl.textContent = statusPrefix ? `${statusPrefix} • ${t}` : t; }

function genSet(){ const set=[]; for(let a=0;a<=6;a++){ for(let b=a;b<=6;b++){ set.push({a,b}); } } return set; }
function shuffle(arr){ for(let i=arr.length-1;i>0;i--){ const j=(Math.random()*(i+1))|0; [arr[i],arr[j]]=[arr[j],arr[i]]; } return arr; }

const urlParams = new URLSearchParams(window.location.search);
const requestedPlayers = Number.parseInt(urlParams.get('players') || urlParams.get('playerCount') || '', 10);
if (requestedPlayers >= 2 && requestedPlayers <= 4) {
  N = requestedPlayers;
}
const stakeAmount = Number.parseInt(urlParams.get('amount') || '', 10);
const stakeToken = urlParams.get('token') || 'TPC';
if (Number.isFinite(stakeAmount) && stakeAmount > 0) {
  statusPrefix = `Stake ${stakeAmount.toLocaleString('en-US')} ${stakeToken.toUpperCase()}`;
  setStatus('Ready');
}

function layoutSeat(idx){
  const EDGE = CLOTH_RADIUS;
  const MARGIN = EDGE * 0.16;
  const south = [0, EDGE - MARGIN, 0];
  const east = [EDGE - MARGIN, 0, Math.PI / 2];
  const north = [0, -(EDGE - MARGIN), Math.PI];
  const west = [-(EDGE - MARGIN), 0, -Math.PI / 2];
  const seats = [south, east, north, west];
  return seats[idx % seats.length];
}

function renderHands(){
  players.forEach(p=>p.hand.forEach(h=>{ if(h.mesh){ piecesG.remove(h.mesh); h.mesh=null; } }));

  const EDGE_SPAN = CLOTH_RADIUS - 0.28;
  const clamp = (v,min,max)=>Math.max(min,Math.min(max,v));
  const BASE_GAP = DOMINO_HAND_GAP;
  const MIN_GAP = DOMINO_LENGTH * 0.98;
  const MAX_SPAN = EDGE_SPAN * 2 - DOMINO_LENGTH * 0.6;
  const HOLE = 0; // equal gap for all, no special case

  players.forEach((p,pi)=>{
    const [x0,z0] = layoutSeat(pi);
    const faceUp = (pi===human);
    const count = p.hand.length;
    const desiredSpan = count>1 ? BASE_GAP * (count-1) : 0;
    let span = desiredSpan;
    if(count>1){
      span = Math.min(desiredSpan, MAX_SPAN);
      span = Math.max(span, MIN_GAP * (count-1));
    }
    const gap = count>1 ? span/(count-1 || 1) : BASE_GAP; // safe division when count>1
    const start = -span/2; // symmetric layout
    const isSide = (pi===1 || pi===3);

    p.hand.forEach((h,hi)=>{
      const m = makeDomino(h.a,h.b,{flat:false, faceUp});
      let offset = start + gap*hi;
      if(isSide){ const zLine = clamp(z0 + offset, -EDGE_SPAN, EDGE_SPAN); m.position.set(x0, HAND_Y, zLine); }
      else      { const xLine = clamp(x0 + offset, -EDGE_SPAN, EDGE_SPAN); m.position.set(xLine, HAND_Y, z0); }
      const yawTowardCenter = Math.atan2(-x0, -z0);
      m.rotation.set(0, (pi===human ? 0 : yawTowardCenter), 0);
      m.rotation.z += (Math.random()*0.02-0.01);
      h.mesh = m; m.userData = {tile:h, owner:pi}; piecesG.add(m);
    });
  });
}

/* ---------- Chain Rendering ---------- */
const DOMINO_UP = new THREE.Vector3(0, 1, 0);
const DOMINO_FORWARD = new THREE.Vector3();
const DOMINO_RIGHT = new THREE.Vector3();
const DOMINO_BASIS = new THREE.Matrix4();

function orientDominoFlat(domino, yawAngle = 0) {
  const angle = Number.isFinite(yawAngle) ? yawAngle : 0;
  DOMINO_FORWARD.set(Math.cos(angle), 0, Math.sin(angle));
  if (DOMINO_FORWARD.lengthSq() === 0) {
    DOMINO_FORWARD.set(1, 0, 0);
  } else {
    DOMINO_FORWARD.normalize();
  }

  DOMINO_RIGHT.crossVectors(DOMINO_FORWARD, DOMINO_UP);
  if (DOMINO_RIGHT.lengthSq() === 0) {
    DOMINO_RIGHT.set(0, 0, 1);
  } else {
    DOMINO_RIGHT.normalize();
  }

  DOMINO_BASIS.makeBasis(DOMINO_RIGHT, DOMINO_FORWARD, DOMINO_UP);
  domino.setRotationFromMatrix(DOMINO_BASIS);
}

function renderChain(){
  chain.forEach(c=>{
    if(c.mesh){
      piecesG.remove(c.mesh);
      c.mesh = null;
    }
  });
  chain.forEach(c=>{
    const domino = makeDomino(c.tile.a, c.tile.b, { flat: true, faceUp: true });
    const yPos = CLOTH_TOP + 0.008;
    domino.position.set(c.x, yPos, c.z);
    // Siguro që çdo domino në fushë të jetë krejtësisht e sheshtë (pa tilt)
    orientDominoFlat(domino, c.rot ?? 0);
    c.mesh = domino;
    piecesG.add(domino);
  });
}

function renderBoneyardStack(){
  boneyardStackG.clear();
  const available = Array.isArray(boneyard) ? boneyard.length : 0;
  const visible = Math.min(available, MAX_BONEYARD_DISPLAY);
  boneyardStackVisible = visible;
  boneyardStackTopLocal = visible > 0 ? (visible - 1) * BONEYARD_STACK_STEP : 0;
  if(visible === 0){
    return;
  }

  for(let i=0;i<visible;i++){
    const domino = makeDomino(0,0,{flat:true, faceUp:false});
    orientDominoFlat(domino, Math.PI/2);
    domino.rotation.z = Math.PI;
    domino.position.set((i%2===0?1:-1)*0.0045, i * BONEYARD_STACK_STEP, (i%3-1)*0.0035);
    domino.userData = { stock:true };
    boneyardStackG.add(domino);
  }
}

function getBoneyardTopWorld(){
  if(!boneyardStackVisible){
    return null;
  }
  const localTop = new THREE.Vector3(0, boneyardStackTopLocal, 0);
  return boneyardStackG.localToWorld(localTop);
}

function spawnDrawAnimation(startWorld, seatIndex = human){
  if(!startWorld){
    return;
  }
  const start = startWorld.clone ? startWorld.clone() : new THREE.Vector3().copy(startWorld);
  const domino = makeDomino(0,0,{flat:true, faceUp:false});
  orientDominoFlat(domino, Math.PI/2);
  domino.rotation.z = Math.PI;
  domino.userData = { stockAnim:true };
  domino.position.copy(start);
  piecesG.add(domino);

  const [seatX, seatZ] = layoutSeat(seatIndex);
  const end = new THREE.Vector3(seatX * 0.55, HAND_Y + 0.012, seatZ - 0.08);
  drawAnimations.push({
    mesh: domino,
    start,
    end,
    startTime: performance.now(),
    duration: DRAW_ANIM_DURATION,
    arc: 0.05
  });
}

/* ---------- Start / Turn Order ---------- */
function drawTileFromStock(){
  while(boneyard.length){
    const tile = boneyard.pop();
    if(!isValidTile(tile)){
      continue;
    }
    renderBoneyardStack();
    return tile;
  }
  renderBoneyardStack();
  return null;
}

function highestDoubleIndex(hand){ let best=-1, idx=-1; hand.forEach((t,i)=>{ if(t.a===t.b && t.a>best){best=t.a; idx=i;} }); return idx; }
function pipSum(hand){ return hand.reduce((s,t)=>s+t.a+t.b,0); }

const VALUE_MAX_OCCURRENCES = 8; // each pip value appears 8 times in a double-six set (including doubles)

function valueOccurrencesInTiles(tiles, value, skipIndex=-1){
  let total = 0;
  tiles.forEach((t,i)=>{
    if(skipIndex===i) return;
    if(!isValidTile(t)) return;
    if(t.a===value) total++;
    if(t.b===value) total++;
  });
  return total;
}

function valueOccurrencesInChain(value){
  let total = 0;
  chain.forEach(c=>{
    const {a,b} = c.tile;
    if(a===value) total++;
    if(b===value) total++;
  });
  return total;
}

function enumerateMoves(hand){
  const moves = [];
  if(!hand || !hand.length) return moves;
  if(!ends){
    hand.forEach((tile,index)=>{
      if(!isValidTile(tile)) return;
      moves.push({tile,index,side:1,match:tile.a,other:tile.b});
    });
    return moves;
  }
  hand.forEach((tile,index)=>{
    if(!isValidTile(tile)) return;
    const {L,R} = validSidesFor(tile);
    if(L){
      const match = ends.L.v;
      const other = (tile.a===match) ? tile.b : tile.a;
      moves.push({tile,index,side:-1,match,other});
    }
    if(R){
      const match = ends.R.v;
      const other = (tile.a===match) ? tile.b : tile.a;
      moves.push({tile,index,side:1,match,other});
    }
  });
  return moves;
}

function scoreMove(player, move){
  const {tile,index,other,side} = move;
  let score = 0;
  const sum = tile.a + tile.b;
  score += sum; // prefer dumping high pips to avoid being stuck later
  if(tile.a===tile.b){
    score += 6; // doubles can open/close branches effectively
  }

  const sameValueRemaining = valueOccurrencesInTiles(player.hand, other, index);
  score += sameValueRemaining * 2.5; // keeping follow-up options for ourselves

  const occurrencesFromTile = (tile.a === tile.b) ? 2 : ((tile.a === other || tile.b === other) ? 1 : 0);
  const knownElsewhere = valueOccurrencesInChain(other) + sameValueRemaining + occurrencesFromTile;
  const remainingElsewhere = Math.max(0, VALUE_MAX_OCCURRENCES - knownElsewhere);
  if(remainingElsewhere === 0){
    score += 6; // completely choke the value — strong blocking move
  } else if(remainingElsewhere <= 2){
    score += 3;
  }
  score += (VALUE_MAX_OCCURRENCES - remainingElsewhere) * 1.25;

  if(ends){
    const currentEndValue = (side < 0 ? ends.L.v : ends.R.v);
    if(currentEndValue === other && tile.a !== tile.b){
      // keeping the same value on the end makes it predictable — slight penalty unless it's a double
      score -= 1.5;
    }
    if(sameValueRemaining === 0 && remainingElsewhere > 0){
      // avoid stranding ourselves with no follow-up on that end unless it is a blocking move
      score -= 2;
    }
    const probeEnd = side < 0 ? ends.L : ends.R;
    if (probeEnd) {
      const projection = nextCandidate(probeEnd);
      if (Math.abs(projection.nx) > XMAX * 0.92 || Math.abs(projection.nz) > ZMAX * 0.92) {
        score += 1.1; // reward steering the snake before it hits the rails
      }
    }
  }

  const futureHand = [];
  player.hand.forEach((t, i) => { if (i !== index && isValidTile(t)) futureHand.push(t); });
  const futurePipSum = futureHand.reduce((s, t) => s + t.a + t.b, 0);
  score += (42 - futurePipSum) * 0.12; // bias toward lighter remaining hand

  const futureValues = new Set();
  futureHand.forEach((t) => { futureValues.add(t.a); futureValues.add(t.b); });
  if (!futureValues.has(other) && remainingElsewhere === 0) {
    score += 8; // we lock that value completely
  }

  const futureDoubleCount = futureHand.filter((t) => t.a === t.b).length;
  if (tile.a === tile.b) {
    score += 2 + futureDoubleCount * 0.75; // chain strong doubles back-to-back
  } else if (futureDoubleCount === 0 && remainingElsewhere <= 2) {
    score += 1.5; // keep variety when low on doubles
  }

  score += Math.random() * 0.25; // tiny randomness to avoid deterministic loops
  return score;
}

function cpuDrawUntilPlayable(player){
  let drew = false;
  while(boneyard.length){
    const tile = drawTileFromStock();
    if(!tile) break;
    player.hand.push(tile);
    drew = true;
    if(!ends) break;
    const {L,R} = validSidesFor(tile);
    if(L || R) break;
  }
  return drew;
}

function startGame(){
  chain=[]; ends=null; selectedTile=null; clearMarkers();
  usedTileKeys.clear();
  flipDir = !flipDir;
  const numericN = Number.isFinite(N) ? Math.round(N) : 4;
  N = Math.max(2, Math.min(4, numericN));
  players=Array.from({length:N},(_,i)=>({id:i,hand:[]}));
  boneyard=shuffle(genSet());
  renderBoneyardStack();
  for(let r=0;r<7;r++){
    players.forEach(p=>{
      const dealt = drawTileFromStock();
      if(dealt){
        p.hand.push(dealt);
      }
    });
  }
  players.forEach(p=> shuffle(p.hand)); // random order every game
  renderHands();
  let starter=0, idx=-1, bestD=-1;
  players.forEach((p,pi)=>{ const i=highestDoubleIndex(p.hand); if(i>=0 && p.hand[i].a>bestD){ bestD=p.hand[i].a; starter=pi; idx=i; } });
  if(idx<0){ idx=0; }
  const t=players[starter].hand.splice(idx,1)[0];
  const firstTile=canonTile(t) || t;
  const firstRot = (firstTile.a===firstTile.b) ? Math.PI/2 : 0;
  chain.push({tile:firstTile,x:0,z:0,rot:firstRot,double:firstTile.a===firstTile.b});
  usedTileKeys.add(tileKey(firstTile));
  const step=STEP;
  if(!flipDir){
    ends={
      L:{v:firstTile.a,x:-step,z:0,dir:[-1,0],orient:Math.PI},
      R:{v:firstTile.b,x: step,z:0,dir:[ 1,0],orient:0}
    };
  }
  else{
    ends={
      L:{v:firstTile.a,x: step,z:0,dir:[ 1,0],orient:0},
      R:{v:firstTile.b,x:-step,z:0,dir:[-1,0],orient:Math.PI}
    };
  }
  renderChain(); current=(starter+1)%N; setStatus(`Turn: Player ${current+1}`); updateInteractivity();
}

/* ---------- Placement & Snake ---------- */
function canPlayAny(hand){ if(!ends) return true; return hand.some(t=> t.a===ends.L.v||t.b===ends.L.v||t.a===ends.R.v||t.b===ends.R.v ); }
function validSidesFor(tile){ if(!ends) return {L:false,R:false}; return {L:(tile.a===ends.L.v||tile.b===ends.L.v), R:(tile.a===ends.R.v||tile.b===ends.R.v)}; }

function placeOnBoard(tile, side){
  if(!chain.length) return false; if(!isValidTile(tile)) return false;
  const end=(side<0?ends.L:ends.R); const want=end.v;
  let a=tile.a,b=tile.b; if(a!==want && b===want){ [a,b]=[b,a]; }
  if(a!==want){ return false; }
  let [dx,dz]=end.dir;
  let nx=end.x+dx*STEP, nz=end.z+dz*STEP;
  // table bounds (square)
  if(Math.abs(nx)>XMAX || Math.abs(nz)>ZMAX){ const ndx=-dz, ndz=dx; dx=ndx; dz=ndz; nx=end.x+dx*STEP; nz=end.z+dz*STEP; }
  const isDouble=(a===b);
  const isHorizontal=Math.abs(dx)>=Math.abs(dz);
  let rot;
  if(isDouble){
    rot = isHorizontal ? Math.PI/2 : 0;
  } else if(isHorizontal){
    rot = (dx>=0) ? 0 : Math.PI;
  } else {
    rot = (dz>=0) ? Math.PI/2 : -Math.PI/2;
  }
  const orientedTile = {a,b};
  const key = tileKey(orientedTile);
  if(usedTileKeys.has(key)){
    return false;
  }
  chain.push({tile:orientedTile,x:nx,z:nz,rot,double:isDouble});
  usedTileKeys.add(key);
  const newVal=b;
  let nextOrient;
  if(isHorizontal){
    nextOrient = (dx>=0) ? 0 : Math.PI;
  } else {
    nextOrient = (dz>=0) ? Math.PI/2 : -Math.PI/2;
  }
  const updatedEnd={v:newVal,x:nx,z:nz,dir:[dx,dz],orient:nextOrient};
  if(side<0) ends.L=updatedEnd; else ends.R=updatedEnd;
  renderChain(); SFX.place.currentTime=0; SFX.place.play();
  return true;
}
function nextCandidate(end){
  let {x,z,dir:[dx,dz]}=end; let ang=Math.atan2(dz,dx);
  let nx=x+dx*STEP, nz=z+dz*STEP;
  if(Math.abs(nx)>XMAX || Math.abs(nz)>ZMAX){ const ndx=-dz, ndz=dx; dx=ndx; dz=ndz; ang=Math.atan2(dz,dx); nx=x+dx*STEP; nz=z+dz*STEP; }
  return {nx,nz,rot:ang,dx,dz};
}

/* ---------- Markers for manual placement ---------- */
function clearMarkers(){ if(markers.L){piecesG.remove(markers.L);markers.L=null;} if(markers.R){piecesG.remove(markers.R);markers.R=null;} }
function makeMarker(){ const g=new THREE.TorusGeometry(.098, .02, 24, 72); const m=new THREE.Mesh(g, markerMat.clone()); m.rotation.x=-Math.PI/2; m.position.y=CLOTH_TOP+0.011; m.renderOrder=10; return m; }
function showMarkersFor(tile){
  clearMarkers(); if(!ends) return;
  const canL = (tile.a===ends.L.v||tile.b===ends.L.v), canR=(tile.a===ends.R.v||tile.b===ends.R.v);
  if(canL){ const c=nextCandidate(ends.L); const mk=makeMarker(); mk.position.x=c.nx; mk.position.z=c.nz; mk.userData={marker:true, side:-1}; piecesG.add(mk); markers.L=mk; }
  if(canR){ const c=nextCandidate(ends.R); const mk=makeMarker(); mk.position.x=c.nx; mk.position.z=c.nz; mk.userData={marker:true, side:1}; piecesG.add(mk); markers.R=mk; }
}

/* ---------- Interactivity ---------- */
const raycaster=new THREE.Raycaster(); const pointer=new THREE.Vector2();
const activePointers = new Set();
function findPickRoot(o){
  let n=o; while(n){ if(n.userData && (n.userData.owner!==undefined || n.userData.marker)) return n; n=n.parent; } return o;
}
function humanPickTile(obj){ const tile = obj.userData.tile; selectedTile = tile; showMarkersFor(tile); setStatus('Pick a side (tap marker)'); }

renderer.domElement.addEventListener('pointerdown',ev=>{
  activePointers.add(ev.pointerId);
  if(ev.pointerType==='touch' && activePointers.size>1){
    return;
  }
  // FIX: përdor madhësinë e saktë të canvas-it (rect) për koordinatat NDC
  const rect = renderer.domElement.getBoundingClientRect();
  const x = ((ev.clientX - rect.left)/rect.width)*2 - 1;
  const y = -(((ev.clientY - rect.top)/rect.height)*2 - 1);
  pointer.set(x,y); raycaster.setFromCamera(pointer,camera);
  const hits=raycaster.intersectObjects(piecesG.children,true); if(!hits.length) return; const hit=hits[0];
  const obj=findPickRoot(hit.object);
  const isHumanTurn=(current===human);
  if(!isHumanTurn) return;
  if(obj.userData && obj.userData.owner===human){ humanPickTile(obj); return; }
  if(obj.userData && obj.userData.marker && selectedTile){
    const side=obj.userData.side; const idx=players[human].hand.indexOf(selectedTile); if(idx>=0) players[human].hand.splice(idx,1);
    if(!placeOnBoard(selectedTile, side)){ players[human].hand.splice(idx,0,selectedTile); }
    selectedTile=null; clearMarkers(); renderHands(); nextTurn(); return;
  }
});
renderer.domElement.addEventListener('pointerup',ev=>{ activePointers.delete(ev.pointerId); });
renderer.domElement.addEventListener('pointercancel',ev=>{ activePointers.delete(ev.pointerId); });
renderer.domElement.addEventListener('pointerleave',ev=>{ activePointers.delete(ev.pointerId); });

btnDraw.addEventListener('click',()=>{ if(current!==human) return; let drewTile=false;
  while(boneyard.length){
    const startWorld = getBoneyardTopWorld();
    const t=drawTileFromStock();
    if(!t) break;
    players[human].hand.push(t);
    spawnDrawAnimation(startWorld, human);
    drewTile = true;
    const canL=(t.a===ends?.L?.v||t.b===ends?.L?.v); const canR=(t.a===ends?.R?.v||t.b===ends?.R?.v);
    if(canL||canR) break;
  }
  clearMarkers(); selectedTile=null; renderHands(); if(drewTile){ SFX.draw.currentTime=0; SFX.draw.play(); }
});
btnPass.addEventListener('click',()=>{ if(current===human){ clearMarkers(); selectedTile=null; nextTurn(); }});

startGame();

function blockedAndWinner(){
  if(!ends) return null;
  const nobodyCan = players.every(p=> !canPlayAny(p.hand));
  if(nobodyCan && boneyard.length===0){
    let best=Infinity, win=-1; players.forEach((p,pi)=>{ const s=pipSum(p.hand); if(s<best){best=s;win=pi;} });
    return {blocked:true, winner:win, reason:`Blocked. Lowest hand = Player ${win+1} (${best})`};
  }
  return null;
}

function updateInteractivity(){
  const blk = blockedAndWinner(); if(blk){ setStatus(blk.reason); return; }
  setStatus(`Turn: Player ${current+1}`);
  renderHands(); renderChain();
}
function nextTurn(){
  if(players[human].hand.length===0){ setStatus('You won!'); return; }
  current=(current+1)%N; const blk = blockedAndWinner(); if(blk){ setStatus(blk.reason); return; }
  updateInteractivity(); if(current!==human) setTimeout(cpuPlay,450);
}
function cpuPlay(){
  const player = players[current];
  if(!player){ nextTurn(); return; }

  const moves = enumerateMoves(player.hand).map(move => ({ ...move, score: scoreMove(player, move) }));
  moves.sort((a,b)=> b.score - a.score);

  if(!moves.length){
    const drew = cpuDrawUntilPlayable(player);
    if(drew){
      renderHands();
      SFX.draw.currentTime = 0; SFX.draw.play();
      if(canPlayAny(player.hand)){
        setTimeout(cpuPlay, 350);
      } else {
        nextTurn();
      }
    } else {
      nextTurn();
    }
    return;
  }

  for(const move of moves){
    const tile = player.hand[move.index];
    if(!tile) continue;
    const picked = player.hand.splice(move.index,1)[0];
    const placed = placeOnBoard(picked, move.side);
    if(placed){
      renderHands();
      if(player.hand.length===0){
        setStatus(`Player ${current+1} won!`);
        return;
      }
      nextTurn();
      return;
    }
    player.hand.splice(move.index,0,picked);
  }

  // Fallback: if all scored moves failed (shouldn't happen) just draw or pass
  const drew = cpuDrawUntilPlayable(player);
  if(drew){
    renderHands();
    SFX.draw.currentTime = 0; SFX.draw.play();
    if(canPlayAny(player.hand)){
      setTimeout(cpuPlay, 350);
    } else {
      nextTurn();
    }
  } else {
    nextTurn();
  }
}

/* ---------- Rules panel handlers ---------- */
btnRules.addEventListener('click',()=>{ panelRules.style.display='flex'; });
closeRules.addEventListener('click',()=>{ panelRules.style.display='none'; });
panelRules.addEventListener('click',(e)=>{ if(e.target===panelRules) panelRules.style.display='none'; });

/* ---------- Mini tests (console) ---------- */
console.assert(document.getElementById('draw') && document.getElementById('pass'), 'UI buttons exist');
(()=>{ const s=genSet(); const key=t=>`${t.a},${t.b}`; const uniq=new Set(s.map(key));
  console.assert(s.length===28 && uniq.size===28,'double-six: 28 unique');
  console.assert(s.some(t=>t.a===0&&t.b===0) && s.some(t=>t.a===6&&t.b===6),'set contains 00 and 66');
  console.assert(s.every(t=>t.a>=0 && t.b>=0 && t.a<=6 && t.b<=6 && t.a<=t.b),'values in range and sorted');
})();
(()=>{ const ct1=canonTile({a:6,b:2}); const ct2=canonTile({a:2,b:6});
  console.assert(ct1.a===2 && ct1.b===6 && ct2.a===2 && ct2.b===6,'canonTile symmetric and idempotent');
})();
(()=>{ const bad1=canonTile({a:-1,b:3}); const bad2=canonTile({a:9,b:1});
  console.assert(bad1===null && bad2===null,'canonTile rejects out-of-range values');
})();
(()=>{ const m=makeDomino(6,6,{flat:true,faceUp:true}); const anyRing=m.children.some(ch=>ch.geometry?.type==='RingGeometry'); console.assert(anyRing,'perimeter/pip rings exist (flat)'); })();
(()=>{ const m=makeDomino(3,4,{flat:false,faceUp:true}); const pipCount=m.children.reduce((n,ch)=>n+(ch.geometry?.type==='SphereGeometry'?1:0),0); console.assert(pipCount>0,'pips exist'); })();

function updateDrawAnimations(now){
  const timestamp = Number.isFinite(now) ? now : performance.now();
  for(let i=drawAnimations.length-1;i>=0;i--){
    const anim = drawAnimations[i];
    const elapsed = timestamp - anim.startTime;
    const t = Math.min(1, elapsed / (anim.duration || DRAW_ANIM_DURATION));
    const ease = 1 - Math.pow(1 - t, 3);
    const pos = anim.start.clone();
    pos.lerp(anim.end, ease);
    if(anim.arc){
      pos.y += Math.sin(Math.PI * ease) * anim.arc;
    }
    anim.mesh.position.copy(pos);
    if(t >= 1){
      piecesG.remove(anim.mesh);
      drawAnimations.splice(i,1);
    }
  }
}

/* ---------- Loop & Resize ---------- */
function tick(now){ updateDrawAnimations(now); controls.update(); renderer.render(scene,camera); requestAnimationFrame(tick); }
requestAnimationFrame(tick);
function onResize(){ positionCameraForViewport(); }
addEventListener('resize', onResize); if(window.visualViewport){ visualViewport.addEventListener('resize', onResize); }

positionCameraForViewport({ force: true });
</script>
</body>
</html>
