<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, viewport-fit=cover, user-scalable=no"
    />
    <title>Murlan Royale ‚Äì Card Table with Jokers</title>
    <style>
      :root {
        --shadow: rgba(0, 0, 0, 0.45);
        --gold: #f5cc4e;
        --ui: #2563eb;
        --ui2: #0ea5e9;
        --card-scale: 1;
        --avatar-scale: 1;
        --my-card-scale: 1;
        --card-w: calc(clamp(44px, 9.6vw, 70px) * var(--card-scale));
        --card-h: calc(var(--card-w) * 1.45);
        --avatar-size: calc(54px * var(--avatar-scale));
        --seat-bg-color: #f5f5dc;
        --player-frame-color: #000;
        --highlight-straight: rgba(14, 165, 233, 0.35);
        --highlight-double: rgba(59, 130, 246, 0.35);
        --highlight-triple: rgba(239, 68, 68, 0.35);
        --highlight-lowest: rgba(234, 179, 8, 0.35);
        --highlight-highest: rgba(34, 197, 94, 0.35);
        --highlight-quad: rgba(147, 51, 234, 0.35);
        --highlight-bomb: rgba(244, 63, 94, 0.35);
      }
      * {
        box-sizing: border-box;
      }
      html,
      body {
        height: 100%;
        margin: 0;
      }
      body {
        font-family:
          ui-sans-serif,
          system-ui,
          -apple-system,
          Segoe UI,
          Roboto,
          Helvetica,
          Arial;
        color: #fff;
        overflow: hidden;
        height: 100vh;
        width: 100vw;
      }

      /* TABLE */
      .stage {
        position: relative;
        width: 100vw;
        height: 100vh;
        display: grid;
        place-items: center;
        perspective: 1100px;
      }
      .stage::before {
        content: '';
        position: absolute;
        inset: 0;
        background: url('assets/icons/de2a24a7-922a-4400-8edc-027a1017224e.webp')
          center/cover no-repeat;
        z-index: 0;
      }

      /* CENTER: community pile + pot */
      .center {
        position: absolute;
        left: 50%;
        top: 45%;
        transform: translate(-50%, -50%);
        display: flex;
        gap: 10px;
        place-items: center;
        z-index: 2;
      }
      .pile-area {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 4px;
      }
      .pile {
        display: flex;
        gap: 6px;
        padding: 4px;
        border: 4px solid #000;
        border-radius: 12px;
        background: var(--seat-bg-color);
        box-shadow: 4px 4px 0 #d4ccb3;
        justify-content: center;
      }
      .pile .card {
        transform: scale(1.3);
      }
      .pile .card:not(:first-child) {
        margin-left: calc(var(--card-w) * -0.6);
      }
      .pile-player {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 4px;
      }
      .pile-player .avatar {
        width: calc(var(--avatar-size) * 0.7);
        height: calc(var(--avatar-size) * 0.7);
        border: 2px solid rgba(255, 255, 255, 0.65);
      }
      .pot {
        display: none;
      }

      /* PLAYERS ON TABLE PERIMETER  (user fixed bottom) */
      .seats {
        position: absolute;
        inset: 0;
        z-index: 2;
      }
      .seat {
        position: absolute;
        display: grid;
        place-items: center;
        gap: 6px;
        width: clamp(120px, 28vw, 200px);
      }
      .seat .turn-indicator {
        display: none;
        position: absolute;
        top: -14px;
        left: 50%;
        transform: translateX(-50%);
        width: 0;
        height: 0;
        border-left: 8px solid transparent;
        border-right: 8px solid transparent;
        border-bottom: 8px solid var(--ui2);
      }
      .seat.active .turn-indicator {
        display: block;
      }
      .seat-inner {
        position: relative;
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 6px;
        border: 4px solid #000;
        border-radius: 12px;
        padding: 4px;
        background: var(--seat-bg-color);
        box-shadow: 4px 4px 0 #d4ccb3;
      }
      .score-box {
        position: absolute;
        top: -18px;
        left: 50%;
        transform: translateX(-50%);
        background: rgba(0, 0, 0, 0.6);
        color: #fff;
        padding: 2px 4px;
        border-radius: 4px;
        font-size: 12px;
        font-weight: 700;
        white-space: nowrap;
      }
      .seat-inner .avatar {
        box-shadow: 0 0 0 2px #000;
      }
      .seat-inner .name {
        padding: 2px 6px;
        border: 2px solid #000;
        border-radius: 6px;
        font-size: 11px;
        max-width: 100%;
        white-space: nowrap;
        overflow: hidden;
        text-align: center;
        background: #fff;
        color: #000;
        font-weight: 700;
        text-shadow:
          -1px -1px 0 #fff,
          1px -1px 0 #fff,
          -1px 1px 0 #fff,
          1px 1px 0 #fff;
      }
      .seat.bottom .name {
        font-size: 12px;
      }
      .seat.bottom .seat-inner {
        padding-bottom: 0;
        gap: 4px;
      }
      .seat-inner .cards {
        padding: 0;
        border: none;
        background: none;
        position: relative;
      }
      .seat-inner .card {
        border: none;
      }
      .avatar {
        width: var(--avatar-size);
        height: var(--avatar-size);
        border-radius: 50%;
        display: grid;
        place-items: center;
        background: radial-gradient(
          circle at 30% 30%,
          #fff,
          #ddd 40%,
          #bbb 60%,
          #999 100%
        );
        color: #111;
        font-size: 28px;
        border: 4px solid rgba(255, 255, 255, 0.65);
        box-shadow: 0 8px 20px var(--shadow);
        overflow: hidden;
      }
      .play-btn {
        width: var(--avatar-size);
        height: var(--avatar-size);
        border-radius: 50%;
        background: #22c55e;
        border: 3px solid #000;
        color: #fff;
        font-weight: 700;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
      }

      .top-controls {
        position: absolute;
        top: 4px;
        right: 8px;
        display: flex;
        gap: 4px;
        z-index: 10;
      }
      .top-controls button {
        width: 32px;
        height: 32px;
        padding: 0;
        border: 2px solid #000;
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        background: #2563eb;
        color: #fff;
        font-weight: 600;
        font-size: 14px;
        line-height: 1;
      }
      .settings-panel {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: #fff;
        color: #000;
        padding: 16px;
        border: 2px solid #000;
        border-radius: 8px;
        z-index: 20;
        display: none;
        min-width: 200px;
      }
      .settings-panel.active {
        display: block;
      }
      .settings-panel label {
        display: flex;
        align-items: center;
        gap: 6px;
        margin-top: 8px;
      }
      .settings-panel select {
        margin-left: 6px;
      }
      .settings-actions {
        display: flex;
        gap: 8px;
        justify-content: flex-end;
        margin-top: 8px;
      }

      .frame-style-1 .avatar { border-style: solid; border-width: 2px; }
      .frame-style-2 .avatar { border-style: dashed; border-width: 2px; }
      .frame-style-3 .avatar { border-style: dotted; border-width: 2px; }
      .frame-style-4 .avatar { border-style: double; border-width: 4px; }
      .frame-style-5 .avatar { border-style: groove; border-width: 4px; }
      .frame-style-6 .avatar { border-style: ridge; border-width: 4px; }
      .frame-style-7 .avatar { border-style: inset; border-width: 4px; }
      .frame-style-8 .avatar { border-style: outset; border-width: 4px; }
      .frame-style-9 .avatar {
        border-style: solid;
        border-width: 2px;
        box-shadow: 0 8px 20px var(--shadow), 0 0 0 2px var(--player-frame-color, #000);
      }
      .frame-style-10 .avatar {
        border-style: dashed;
        border-width: 2px;
        box-shadow: 0 8px 20px var(--shadow), 0 0 0 2px var(--player-frame-color, #000);
      }
      .name {
        font-weight: 800;
        text-shadow: 0 2px 6px #000;
        font-size: 14px;
      }
      .timer {
        font-weight: 800;
        background: rgba(0, 0, 0, 0.5);
        padding: 2px 6px;
        border-radius: 8px;
      }
      .seat.active .avatar {
        border-color: var(--ui2);
        box-shadow: 0 0 10px var(--ui2);
      }
      .seat.left,
      .seat.right {
        display: flex;
        flex-direction: column;
        align-items: center;
      }
      .seat.left .cards,
      .seat.right .cards {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 0;
      }
      .seat.left .cards .card,
      .seat.right .cards .card {
        transform: scale(1.05);
        transform-origin: center;
      }
      .seat.bottom .cards {
        touch-action: none;
        transform: scale(var(--my-card-scale));
        transform-origin: center bottom;
        gap: 0;
        transition: transform 0.3s ease;
      }
      .seat.bottom .cards .card:not(:first-child) {
        margin-left: calc(var(--card-w) * -0.4);
      }

      /* CARDS */
      .cards {
        display: flex;
        gap: 6px;
        flex-wrap: nowrap;
      }
      .card {
        width: var(--card-w);
        height: var(--card-h);
        border-radius: 10px;
        position: relative;
        flex: 0 0 auto;
        background: #fff;
        color: #111;
        font-weight: 900;
        letter-spacing: 0.3px;
        box-shadow:
          0 10px 25px var(--shadow),
          inset 0 0 0 2px rgba(0, 0, 0, 0.08);
        touch-action: none;
      }
      .card .tl {
        position: absolute;
        left: 8px;
        top: 6px;
        font-size: calc(var(--card-w) * 0.28);
      }
      .card .br {
        position: absolute;
        right: 8px;
        bottom: 8px;
        font-size: calc(var(--card-w) * 0.3);
      }
      .card .big {
        position: absolute;
        left: 50%;
        top: 50%;
        transform: translate(-50%, -50%);
        font-size: calc(var(--card-w) * 0.52);
        opacity: 0.9;
      }
      .red {
        color: #d12d2d;
      }
      .joker {
        background: repeating-linear-gradient(
          45deg,
          #eee,
          #eee 6px,
          #ddd 6px,
          #ddd 12px
        );
      }
      .selected {
        outline: 3px solid var(--ui2);
        transform: translateY(-6px);
      }
      .suggested {
        outline: none;
        box-shadow: inset 0 0 0 3px var(--ui);
      }
      .highlight-straight {
        box-shadow: inset 0 0 0 9999px var(--highlight-straight);
      }
      .highlight-double {
        box-shadow: inset 0 0 0 9999px var(--highlight-double);
      }
      .highlight-triple {
        box-shadow: inset 0 0 0 9999px var(--highlight-triple);
      }
      .highlight-quad {
        box-shadow: inset 0 0 0 9999px var(--highlight-quad);
      }
      .highlight-highest {
        box-shadow: inset 0 0 0 9999px var(--highlight-highest);
      }
      .highlight-lowest {
        box-shadow: inset 0 0 0 9999px var(--highlight-lowest);
      }
      .highlight-bomb {
        box-shadow: inset 0 0 0 9999px var(--highlight-bomb);
      }

      /* Facedown backs for opponents */
      .back {
        background:
          url('assets/icons/file_00000000bc2862439eecffff3730bbe4.webp')
            center/60% no-repeat,
          repeating-linear-gradient(45deg, #233, #233 6px, #122 6px, #122 12px);
        border: 2px solid rgba(255, 255, 255, 0.5);
        color: transparent;
      }
      .back::before {
        content: '';
        position: absolute;
        inset: 6px;
        border-radius: 8px;
        border: 2px dashed rgba(255, 255, 255, 0.35);
      }
      .opp-fan .card {
        margin-left: -30px;
        transform: rotateZ(var(--rot, 0deg));
      }

      /* Left & right opponents: rotate and tighten card spacing */
      .seat.left .opp-fan .card,
      .seat.right .opp-fan .card {
        margin-left: 0;
      }
      .seat.left .cards .card:not(:first-child),
      .seat.right .cards .card:not(:first-child) {
        margin-top: calc(var(--card-h) * -0.92);
      }
      .seat.left .opp-fan .card {
        transform: rotate(calc(var(--rot, 0deg) - 90deg));
      }
      .seat.right .opp-fan .card {
        transform: rotate(calc(var(--rot, 0deg) + 90deg));
      }

      /* Top opponent: avatar left of cards and tighter spacing */
      .seat.top .top-row {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 20px;
        padding: 0 12px 0 4px;
      }
      .seat.top .seat-inner {
        padding-left: 20px;
        padding-right: 20px;
      }
      .seat.top .cards {
        gap: 0;
      }
      .seat.top .cards .card:not(:first-child) {
        margin-left: calc(var(--card-w) * -0.6);
      }
      .seat.top .top-row .avatar {
        margin-left: -8px;
      }
      .seat.top .top-row .cards {
        margin-right: -8px;
      }

      .card-count {
        position: absolute;
        top: -6px;
        right: -6px;
        background: var(--gold);
        color: #000;
        font-size: 10px;
        font-weight: 700;
        line-height: 1;
        padding: 2px 4px;
        border-radius: 50%;
        box-shadow: 0 0 0 2px #000;
        z-index: 2;
      }

      /* ICON CONTROLS */
      .icon-btn {
        appearance: none;
        border: none;
        background: none;
        cursor: pointer;
        font-size: 32px;
        color: #fff;
        text-shadow: 0 2px 6px #000;
      }
      .controls {
        display: flex;
        align-items: center;
        gap: 12px;
      }
      .pass-icon {
      }

      .avatar-wrap {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 4px;
      }
      .auto-btn,
      .config-btn,
      .lobby-btn {
        width: 32px;
        height: 24px;
        padding: 0;
        border: 2px solid #000;
        border-radius: 6px;
        background: #2563eb;
        color: #fff;
        font-size: 10px;
        font-weight: 600;
      }
      .auto-btn {
        position: fixed;
        left: 8px;
        bottom: calc(var(--card-h) * var(--my-card-scale) + 60px);
        z-index: 5;
      }
      .config-btn {
        position: fixed;
        left: 8px;
        bottom: calc(var(--card-h) * var(--my-card-scale) + 88px);
        z-index: 5;
        font-size: 12px;
      }
      .lobby-btn {
        background: #22c55e;
        margin-top: 16px;
      }

      /* TOAST */
      .toast {
        position: fixed;
        left: 50%;
        top: 12%;
        transform: translateX(-50%);
        background: rgba(0, 0, 0, 0.6);
        border: 1px solid rgba(255, 255, 255, 0.12);
        padding: 8px 14px;
        border-radius: 12px;
        font-weight: 800;
        z-index: 12;
      }

      .combo-label {
        position: absolute;
        top: -28px;
        left: 50%;
        transform: translateX(-50%);
        font-size: 32px;
      }
      .winnerOverlay {
        position: fixed;
        inset: 0;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        gap: 16px;
        background: rgba(0, 0, 0, 0.6);
        z-index: 60;
      }
      .winnerOverlay.hidden {
        display: none;
      }
      .winnerOverlay .emoji {
        font-size: 96px;
      }

      .coin-confetti {
        position: fixed;
        top: -40px;
        width: 48px;
        height: 48px;
        pointer-events: none;
        animation: coin-fall var(--duration, 3s) linear forwards;
      }
      @keyframes coin-fall {
        from {
          transform: translateY(-10vh) rotate(0deg);
          opacity: 1;
        }
        to {
          transform: translateY(100vh) rotate(360deg);
          opacity: 0;
        }
      }

      @media (max-width: 900px) {
        .log {
          display: none;
        }
      }

      .moving-card {
        position: absolute;
        transition: left 0.4s ease, top 0.4s ease, transform 0.4s ease;
        z-index: 1000;
        pointer-events: none;
        transform-style: preserve-3d;
        backface-visibility: hidden;
      }
    </style>
  </head>
  <body class="frame-style-1">
    <div class="stage">
      <!-- Center play area -->
      <div class="center">
        <div class="pile-area">
          <div id="pile" class="pile"></div>
          <div id="pilePlayer" class="pile-player"></div>
        </div>
        <div id="pot" class="pot"></div>
      </div>

      <!-- Seats on perimeter -->
      <div id="seats" class="seats"></div>

      <!-- UI -->
      <div id="toast" class="toast" style="display: none"></div>
    </div>
    <div id="winnerOverlay" class="winnerOverlay hidden">
      <div class="emoji"></div>
    </div>

    <!-- sounds -->
    <audio
      id="sndChip"
      src="https://cdn.jsdelivr.net/gh/naptha/tiny-sound@master/sounds/click2.ogg"
    ></audio>
    <audio
      id="sndCard"
      src="assets/sounds/flipcard-91468.mp3"
    ></audio>
    <audio
      id="sndTimer"
      src="https://cdn.jsdelivr.net/gh/naptha/tiny-sound@master/sounds/beep1.ogg"
    ></audio>
    <audio
      id="sndTurn"
      src="/assets/sounds/wooden-door-knock-102902.mp3"
    ></audio>

    <div class="top-controls">
      <button id="settingsBtn">‚öôÔ∏è</button>
    </div>
    <div id="settingsPanel" class="settings-panel">
      <label>Frame Style<select id="playerFrameStyle"></select></label>
      <label>Frame Color<select id="playerColor"></select></label>
      <div class="settings-actions">
        <button id="saveSettings">Save</button>
        <button id="closeSettings">Close</button>
      </div>
    </div>
    <div id="highlightPanel" class="settings-panel">
      <label>Straight<input type="color" id="straightColor" value="#0ea5e9" /></label>
      <label>Double<input type="color" id="doubleColor" value="#3b82f6" /></label>
      <label>Triple<input type="color" id="tripleColor" value="#ef4444" /></label>
      <label>Lowest<input type="color" id="lowestColor" value="#eab308" /></label>
      <label>Highest<input type="color" id="highestColor" value="#22c55e" /></label>
      <label>4 of Kind<input type="color" id="quadColor" value="#9333ea" /></label>
      <label>Bomb<input type="color" id="bombColor" value="#f43f5e" /></label>
      <div class="settings-actions">
        <button id="saveHighlight">Save</button>
        <button id="closeHighlight">Close</button>
      </div>
    </div>

    <script src="/flag-emojis.js"></script>
    <script>
      (async () => {
        const FLAG_EMOJIS = window.FLAG_EMOJIS || [];
        const api = window.fbApi || {};
        const regionNames = new Intl.DisplayNames(['en'], { type: 'region' });
        function flagName(flag) {
          const codePoints = [...flag].map((c) => c.codePointAt(0) - 0x1f1e6 + 65);
          return regionNames.of(String.fromCharCode(...codePoints));
        }
        const highlightPanel = document.getElementById('highlightPanel');
        const saveHighlight = document.getElementById('saveHighlight');
        const closeHighlight = document.getElementById('closeHighlight');
        saveHighlight.addEventListener('click', () => {
          const root = document.documentElement;
          root.style.setProperty(
            '--highlight-straight',
            hexToRgba(document.getElementById('straightColor').value, 0.35)
          );
          root.style.setProperty(
            '--highlight-double',
            hexToRgba(document.getElementById('doubleColor').value, 0.35)
          );
          root.style.setProperty(
            '--highlight-triple',
            hexToRgba(document.getElementById('tripleColor').value, 0.35)
          );
          root.style.setProperty(
            '--highlight-lowest',
            hexToRgba(document.getElementById('lowestColor').value, 0.35)
          );
          root.style.setProperty(
            '--highlight-highest',
            hexToRgba(document.getElementById('highestColor').value, 0.35)
          );
          root.style.setProperty(
            '--highlight-quad',
            hexToRgba(document.getElementById('quadColor').value, 0.35)
          );
          root.style.setProperty(
            '--highlight-bomb',
            hexToRgba(document.getElementById('bombColor').value, 0.35)
          );
          highlightPanel.classList.remove('active');
        });
        closeHighlight.addEventListener('click', () =>
          highlightPanel.classList.remove('active')
        );

        function hexToRgba(hex, alpha = 0.35) {
          const bigint = parseInt(hex.slice(1), 16);
          const r = (bigint >> 16) & 255;
          const g = (bigint >> 8) & 255;
          const b = bigint & 255;
          return `rgba(${r}, ${g}, ${b}, ${alpha})`;
        }
        const params = new URLSearchParams(location.search);
        let myAccountId = params.get('accountId') || '';
        let myTelegramId = params.get('tgId') || '';
        let avatar = params.get('avatar') || '';
        let username = params.get('username') || 'You';
        const gameType = params.get('game') || 'single';
        const pointsTarget = Number(params.get('points') || 0);
        try {
          if (myAccountId && api.getUserInfo) {
            const u = await api.getUserInfo({ accountId: myAccountId, tgId: myTelegramId });
            if (u) {
              username = u.username || u.first_name || username;
              avatar = u.photo_url || avatar;
            }
          }
        } catch {}
        // ====== UTIL ======
        const el = (s) => document.querySelector(s);
        const pileEl = el('#pile');
        const pilePlayerEl = el('#pilePlayer');
        const centerEl = el('.center');
        const seatsEl = el('#seats');
        const potEl = el('#pot');
        const toastEl = el('#toast');
        const sndChip = el('#sndChip');
        const sndCard = el('#sndCard');
        const sndTimer = el('#sndTimer');
        const sndTurn = el('#sndTurn');
        const winnerOverlay = el('#winnerOverlay');
        const settingsBtn = el('#settingsBtn');
        const settingsPanel = el('#settingsPanel');
        const styleSelect = el('#playerFrameStyle');
        const colorSelect = el('#playerColor');
        const saveSettingsBtn = el('#saveSettings');
        const closeSettingsBtn = el('#closeSettings');
        let lobbyBtn;
        let arrangeVariant = 0;

        function coinConfetti(
          count = 50,
          iconSrc = '/assets/icons/ezgif-54c96d8a9b9236.webp'
        ) {
          const container = document.createElement('div');
          container.style.position = 'fixed';
          container.style.top = '0';
          container.style.left = '0';
          container.style.width = '100%';
          container.style.height = '0';
          container.style.pointerEvents = 'none';
          container.style.zIndex = '60';
          container.style.overflow = 'visible';
          document.body.appendChild(container);
          for (let i = 0; i < count; i++) {
            const img = document.createElement('img');
            img.src = iconSrc;
            img.alt = 'confetti icon';
            img.className = 'coin-confetti';
            const left = Math.random() * 100;
            const delay = Math.random() * 0.2;
            const duration = 2 + Math.random() * 2;
            img.style.left = left + 'vw';
            img.style.animationDelay = delay + 's';
            img.style.setProperty('--duration', duration + 's');
            container.appendChild(img);
          }
          setTimeout(() => container.remove(), 5000);
        }

        function showWinnerOverlay(emoji) {
          if (!winnerOverlay) return;
          const slot = winnerOverlay.querySelector('.emoji');
          if (slot) slot.textContent = emoji || 'üèÜ';
          winnerOverlay.classList.remove('hidden');
        }

        let userScale = 1;
        let userAdjusted = false;
        let pinchStartDist = null;
        let pinchStartScale = 1;

        function pinchDistance(touches) {
          const [a, b] = touches;
          return Math.hypot(a.clientX - b.clientX, a.clientY - b.clientY);
        }

        function setupZoom() {
          const hand = document.querySelector('.seat.bottom .cards');
          if (!hand) return;
          hand.addEventListener(
            'touchstart',
            (e) => {
              if (e.touches.length === 2) {
                pinchStartDist = pinchDistance(e.touches);
                pinchStartScale = userScale;
              }
            },
            { passive: false }
          );
          hand.addEventListener(
            'touchmove',
            (e) => {
              if (e.touches.length === 2 && pinchStartDist) {
                e.preventDefault();
                const dist = pinchDistance(e.touches);
                let scale = pinchStartScale * (dist / pinchStartDist);
                scale = Math.max(0.5, Math.min(scale, 3));
                userScale = scale;
                userAdjusted = true;
                document.documentElement.style.setProperty(
                  '--my-card-scale',
                  scale.toFixed(2)
                );
              }
            },
            { passive: false }
          );
          hand.addEventListener('touchend', (e) => {
            if (e.touches.length < 2) {
              pinchStartDist = null;
            }
          });
        }

        function toast(msg) {
          toastEl.textContent = msg;
          toastEl.style.display = 'block';
          setTimeout(() => (toastEl.style.display = 'none'), 1400);
        }

        function applyFrameSettings() {
          document.body.className = document.body.className.replace(/frame-style-\d+/g, '');
          document.body.classList.add('frame-style-' + styleSelect.value);
          document.documentElement.style.setProperty(
            '--player-frame-color',
            colorSelect.value
          );
        }
        if (settingsBtn) {
          settingsBtn.addEventListener('click', () => settingsPanel.classList.add('active'));
          closeSettingsBtn.addEventListener('click', () => settingsPanel.classList.remove('active'));
          saveSettingsBtn.addEventListener('click', () => {
            applyFrameSettings();
            localStorage.setItem('murlanFrameStyle', styleSelect.value);
            localStorage.setItem('murlanFrameColor', colorSelect.value);
            settingsPanel.classList.remove('active');
          });
          for (let i = 1; i <= 10; i++) {
            const opt = document.createElement('option');
            opt.value = i;
            opt.textContent = 'Style ' + i;
            styleSelect.appendChild(opt);
          }
          ['#000', '#f00', '#0f0', '#00f', '#ff0', '#f0f', '#0ff', '#fff'].forEach(
            (c) => {
              const opt = document.createElement('option');
              opt.value = c;
              opt.textContent = c;
              colorSelect.appendChild(opt);
            }
          );
          const savedStyle = localStorage.getItem('murlanFrameStyle');
          const savedColor = localStorage.getItem('murlanFrameColor');
          if (savedStyle) styleSelect.value = savedStyle;
          if (savedColor) colorSelect.value = savedColor;
          applyFrameSettings();
        }

        // ====== DECK (with Jokers) ======
        const SUITS = ['‚ô†', '‚ô•', '‚ô¶', '‚ô£'];
        const RANKS = [
          3,
          4,
          5,
          6,
          7,
          8,
          9,
          10,
          'J',
          'Q',
          'K',
          'A',
          2,
          'BJ',
          'RJ'
        ]; // BJ < RJ (both above 2)
        function makeDeck() {
          const d = [];
          for (const s of SUITS) {
            for (const r of [3, 4, 5, 6, 7, 8, 9, 10, 'J', 'Q', 'K', 'A', 2])
              d.push({ r, s });
          }
          d.push({ r: 'BJ', s: 'üÉè' });
          d.push({ r: 'RJ', s: 'üÉè' });
          for (let i = d.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [d[i], d[j]] = [d[j], d[i]];
          }
          return d;
        }
        function rankValue(r) {
          if (r === 'RJ') return 17;
          if (r === 'BJ') return 16;
          if (r === 2) return 15;
          if (r === 'A') return 14;
          if (r === 'K') return 13;
          if (r === 'Q') return 12;
          if (r === 'J') return 11;
          return r;
        }

        // ====== STATE ======
        const state = {
          players: [], // {name,isHuman,hand:[],chips,points,finished}
          turn: 0,
          turnTime: 15,
          pile: [], // last played cards
          arrangeMode: false,
          lastPlayLen: 0,
          lastPlayType: null,
          pot: 0,
          passesSincePlay: 0,
          lastPlayerToPlay: 0,
          startPlayer: 0,
          selectedIndices: [],
          finishedOrder: [],
          round: 1,
          playMode: gameType,
          pointsTarget
        };

        let arrangeInterval;

        // create 4 players (user bottom)
        function initPlayers() {
          const flags = [...FLAG_EMOJIS]
            .sort(() => 0.5 - Math.random())
            .slice(0, 3);
          state.players = [
            {
              name: username,
              avatar,
              isHuman: true,
              chips: 1500,
              hand: [],
              points: 0,
              finished: false
            },
            ...flags.map((f, i) => ({
              name: flagName(f),
              avatar: f,
              chips: 1200 - i * 100,
              hand: [],
              points: 0,
              finished: false
            }))
          ];
        }

        async function deal() {
          const deck = makeDeck();
          for (let i = 0; i < 13; i++) {
            for (let p = 0; p < state.players.length; p++) {
              state.players[p].hand.push(deck.pop());
              renderAll();
              if (sndCard) {
                sndCard.currentTime = 0;
                sndCard.play();
              }
              await new Promise((r) => setTimeout(r, 120));
            }
          }
        }

        function findStartPlayer() {
          return state.players.findIndex((p) =>
            p.hand.some((c) => c.r === 3 && c.s === '‚ô†')
          );
        }

        // ===== RENDER =====
        function cardFaceEl(c) {
          const d = document.createElement('div');
          d.className =
            'card' +
            (c.s === '‚ô•' || c.s === '‚ô¶' ? ' red' : '') +
            (c.r === 'RJ' || c.r === 'BJ' ? ' joker' : '');
          const tl = document.createElement('div');
          tl.className = 'tl';
          tl.textContent =
            (c.r === 'BJ' ? 'JB' : c.r === 'RJ' ? 'JR' : c.r) +
            (c.s === 'üÉè' ? '' : c.s);
          const br = document.createElement('div');
          br.className = 'br';
          br.textContent = c.s === 'üÉè' ? 'üÉè' : c.s;
          const big = document.createElement('div');
          big.className = 'big';
          big.textContent = c.s === 'üÉè' ? 'üÉè' : c.s;
          d.append(tl, big, br);
          return d;
        }
        function cardBackEl() {
          const d = document.createElement('div');
          d.className = 'card back';
          return d;
        }

        function posSeats() {
          seatsEl.innerHTML = '';
          const tableRect = el('.stage').getBoundingClientRect();
          const padX = 24,
            padY = 16;
          const x0 = tableRect.left + padX,
            y0 = tableRect.top + padY;
          const w = tableRect.width - padX * 2,
            h = tableRect.height - padY * 2;
          const perim = 2 * (w + h),
            step = perim / state.players.length;
          let s0 = w + h + w / 2; // bottom center for user (index 0)

          state.players.forEach((p, i) => {
            const s = (s0 + i * step) % perim;
            let x, y, side;
            if (s < w) {
              x = x0 + s;
              y = y0;
              side = 'top';
            } else if (s < w + h) {
              x = x0 + w;
              y = y0 + (s - w);
              side = 'right';
            } else if (s < w + h + w) {
              x = x0 + (w - (s - (w + h)));
              y = y0 + h;
              side = 'bottom';
            } else {
              x = x0;
              y = y0 + (h - (s - (w + h + w)));
              side = 'left';
            }

            const seat = document.createElement('div');
            seat.className = 'seat ' + side;
            const indicator = document.createElement('div');
            indicator.className = 'turn-indicator';
            seat.appendChild(indicator);
            const area = el('.stage').getBoundingClientRect();
            if (side === 'bottom') {
              seat.style.left = '50%';
              seat.style.bottom = '8px';
              seat.style.transform = 'translateX(-50%)';
              seat.style.width = 'auto';
            } else if (side === 'top') {
              seat.style.left = '50%';
              seat.style.top = '8px';
              seat.style.transform = 'translateX(-55%)';
              seat.style.width = 'auto';
            } else if (side === 'right') {
              seat.style.left = x - area.left - 20 + 'px';
              seat.style.top = y - area.top + 20 + 'px';
              seat.style.transform = 'translate(-50%,-50%)';
            } else {
              seat.style.left = x - area.left + 20 + 'px';
              seat.style.top = y - area.top + 20 + 'px';
              seat.style.transform = 'translate(-50%,-50%)';
            }

            const seatInner = document.createElement('div');
            seatInner.className = 'seat-inner';

            const scoreEl = document.createElement('div');
            scoreEl.className = 'score-box';
            scoreEl.textContent = 'Score: ' + (p.points || 0);
            seatInner.appendChild(scoreEl);

            const av = document.createElement('div');
            av.className = 'avatar';
            if (p.avatar && p.avatar.startsWith('http')) {
              const img = document.createElement('img');
              img.src = p.avatar;
              img.style.width = '100%';
              img.style.height = '100%';
              img.style.borderRadius = '50%';
              av.appendChild(img);
            } else {
              av.textContent = p.avatar || (p.isHuman ? 'üÉè' : 'üêæ');
            }
            const name = document.createElement('div');
            name.className = 'name';
            name.textContent = p.name;
            if (side === 'left' || side === 'right') {
              const baseLen = 15;
              const baseFont = 11;
              const size = Math.max(
                9,
                Math.min(14, (baseLen / Math.max(p.name.length, 1)) * baseFont)
              );
              name.style.fontSize = size + 'px';
            }

            const cards = document.createElement('div');
            cards.className = 'cards';
            if (p.isHuman) {
              // Show face-up cards (draggable when arrangeMode)
              const sorted = [...p.hand];
              sorted.forEach((c, idx) => {
                const face = cardFaceEl(c);
                face.dataset.index = idx;
                if (state.selectedIndices.includes(idx)) {
                  face.classList.add('selected');
                }
                face.addEventListener('click', () => {
                  const i = Number(face.dataset.index);
                  const pos = state.selectedIndices.indexOf(i);
                  if (pos > -1) {
                    state.selectedIndices.splice(pos, 1);
                    face.classList.remove('selected');
                  } else {
                    state.selectedIndices.push(i);
                    face.classList.add('selected');
                  }
                  sndChip.currentTime = 0;
                  sndChip.play();
                });
                if (state.arrangeMode) {
                  enableDrag(face, cards, p);
                }
                cards.appendChild(face);
              });
            } else {
              // Opponents: facedown fanned stack
              cards.classList.add('opp-fan');
              const count = p.hand.length;
              const show = Math.min(10, count); // cap visual
              for (let k = 0; k < show; k++) {
                const b = cardBackEl();
                b.style.setProperty('--rot', (k - show / 2) * 2 + 'deg');
                cards.appendChild(b);
              }
              const countEl = document.createElement('div');
              countEl.className = 'card-count';
              countEl.textContent = count;
              cards.appendChild(countEl);
              if (side === 'top' && count > 3) {
                cards.style.marginTop = '8px';
              } else if (side === 'top') {
                cards.style.marginTop = '';
              }
            }

            const timer = document.createElement('div');
            timer.className = 'timer';

            if (side === 'bottom') {
              const controls = document.createElement('div');
              controls.className = 'controls';
              controls.style.display = 'flex';
              controls.style.alignItems = 'center';
              controls.style.gap = '8px';
              const playBtn = document.createElement('button');
              playBtn.className = 'play-btn';
              playBtn.textContent = 'Play';
              playBtn.addEventListener('click', confirmPlayAction);
              const passBtn = document.createElement('button');
              passBtn.id = 'passBtn';
              passBtn.className = 'icon-btn pass-icon';
              passBtn.innerHTML =
                'üëã<span style="font-size:14px;display:block">Pass</span>';
              passBtn.style.display = 'flex';
              passBtn.style.flexDirection = 'column';
              passBtn.style.alignItems = 'center';
              passBtn.addEventListener('click', () => {
                toast('Pass');
                state.passesSincePlay++;
                clearSelections();
                advanceTurn();
              });
              const readyBtn = document.createElement('button');
              readyBtn.id = 'readyBtn';
              readyBtn.className = 'play-btn';
              readyBtn.textContent = 'Ready';
              readyBtn.addEventListener('click', () => {
                clearInterval(arrangeInterval);
                state.arrangeMode = false;
                renderAll();
                startGame();
              });

              const avatarWrap = document.createElement('div');
              avatarWrap.className = 'avatar-wrap';
              avatarWrap.appendChild(av);

              const autoBtn = document.createElement('button');
              autoBtn.className = 'auto-btn';
              autoBtn.textContent = 'Auto';
              autoBtn.addEventListener('click', autoArrange);
              avatarWrap.appendChild(autoBtn);

              const configBtn = document.createElement('button');
              configBtn.className = 'config-btn';
              configBtn.textContent = '‚öôÔ∏è';
              configBtn.addEventListener('click', () => {
                highlightPanel.classList.add('active');
              });
              avatarWrap.appendChild(configBtn);

              lobbyBtn = document.createElement('button');
              lobbyBtn.className = 'lobby-btn';
              lobbyBtn.textContent = 'Lobby';
              lobbyBtn.style.display = 'none';
              lobbyBtn.addEventListener('click', () => {
                if (window.parent && window.parent !== window) {
                  window.parent.location.href = '/games/murlanroyale/lobby';
                } else {
                  window.location.href = '/games/murlanroyale/lobby';
                }
              });
              winnerOverlay.appendChild(lobbyBtn);

              readyBtn.style.display = state.arrangeMode ? 'block' : 'none';
              playBtn.style.display = state.arrangeMode ? 'none' : 'block';
              passBtn.style.display = state.arrangeMode ? 'none' : 'flex';
              controls.append(avatarWrap, readyBtn, playBtn, passBtn);
              seatInner.append(controls, cards, timer, name);
            } else if (side === 'left' || side === 'right') {
              seatInner.append(av, cards, name, timer);
            } else if (side === 'top') {
              const topRow = document.createElement('div');
              topRow.className = 'top-row';
              topRow.append(av, cards);
              seatInner.append(topRow, name, timer);
            }
            seat.appendChild(seatInner);
            seatsEl.appendChild(seat);
          });
        }

        // Drag-to-reorder (manual arrange for user)
        let drag = {
          active: false,
          startX: 0,
          fromIdx: -1,
          owner: null,
          container: null
        };
        function enableDrag(elm, container, owner) {
          elm.style.touchAction = 'none';
          elm.addEventListener('pointerdown', (e) => {
            if (!state.arrangeMode || !owner.isHuman) return;
            drag.active = true;
            drag.startX = e.clientX;
            drag.fromIdx = Number(elm.dataset.index);
            drag.owner = owner;
            drag.container = container;
            elm.setPointerCapture(e.pointerId);
            elm.style.opacity = 0.7;
            sndChip.currentTime = 0;
            sndChip.play();
          });
          elm.addEventListener('pointermove', (e) => {
            if (!drag.active) return;
            const dx = e.clientX - drag.startX;
            elm.style.transform = `translateX(${dx}px)`;
          });
          elm.addEventListener('pointerup', (e) => {
            if (!drag.active) return;
            elm.style.opacity = 1;
            elm.style.transform = '';
            const rect = drag.container.getBoundingClientRect();
            const relX = e.clientX - rect.left; // place by slot width
            const slotW =
              rect.width / Math.max(1, drag.container.children.length);
            let toIdx = Math.min(
              drag.container.children.length - 1,
              Math.max(0, Math.floor(relX / slotW))
            );
            reorderHand(drag.owner, drag.fromIdx, toIdx);
            drag.active = false;
            renderAll();
          });
        }
        function reorderHand(player, from, to) {
          if (from === to) return;
          const arr = player.hand;
          const [c] = arr.splice(from, 1);
          arr.splice(to, 0, c);
          if (player.isHuman) {
            state.selectedIndices = state.selectedIndices.map((i) => {
              if (i === from) return to;
              if (from < to && i > from && i <= to) return i - 1;
              if (from > to && i >= to && i < from) return i + 1;
              return i;
            });
          }
        }

        function updateCenterPosition() {
          const count = state.pile.length;
          if (count > 3) {
            const topSeat = document.querySelector('.seat.top');
            const stageRect = el('.stage').getBoundingClientRect();
            const seatRect = topSeat ? topSeat.getBoundingClientRect() : { bottom: 0 };
            const gap = 40;
            centerEl.style.top = seatRect.bottom - stageRect.top + gap + 'px';
            centerEl.style.transform = 'translate(-50%, 0)';
          } else {
            centerEl.style.top = '45%';
            centerEl.style.transform = 'translate(-50%, -50%)';
          }
        }

        function renderPile() {
          pileEl.innerHTML = '';
          pilePlayerEl.innerHTML = '';
          updateCenterPosition();
          if (!state.pile.length) return;
          const scale = state.pile.length > 6 ? 1.1 : 1.3;
          state.pile.forEach((c) => {
            const face = cardFaceEl(c);
            face.style.transform = `scale(${scale})`;
            pileEl.appendChild(face);
          });
          const lp = state.players[state.lastPlayerToPlay];
          if (lp) {
            const av = document.createElement('div');
            av.className = 'avatar';
            if (lp.avatar && lp.avatar.startsWith('http')) {
              const img = document.createElement('img');
              img.src = lp.avatar;
              img.style.width = '100%';
              img.style.height = '100%';
              img.style.borderRadius = '50%';
              av.appendChild(img);
            } else {
              av.textContent = lp.avatar || (lp.isHuman ? 'üÉè' : 'üêæ');
            }
            const name = document.createElement('div');
            name.className = 'name';
            name.textContent = lp.name;
            pilePlayerEl.append(av, name);
          }
        }

        function adjustHandScale() {
          if (userAdjusted) return;
          const hand = document.querySelector('.seat.bottom .cards');
          if (!hand) return;
          const screen = window.innerWidth - 20;
          const natural = hand.scrollWidth;
          if (natural > screen) {
            const scale = screen / natural;
            userScale = scale;
            document.documentElement.style.setProperty(
              '--my-card-scale',
              scale.toFixed(2)
            );
          } else {
            userScale = 1;
            document.documentElement.style.setProperty('--my-card-scale', 1);
          }
        }

        function renderAll() {
          posSeats();
          renderPile();
          if (potEl) potEl.textContent = '';
          updateTimerDisplay();
          adjustHandScale();
          setupZoom();
          if (state.arrangeMode || state.turn === 0) {
            highlightCombos();
          }
        }

        function animateCardsFromAvatar(idx, cards) {
          return new Promise((resolve) => {
            const stage = el('.stage');
            const seat = seatsEl.querySelectorAll('.seat')[idx];
            const avatar = seat ? seat.querySelector('.avatar') : null;
            if (!stage || !avatar) {
              resolve();
              return;
            }
            const stageRect = stage.getBoundingClientRect();
            const avatarRect = avatar.getBoundingClientRect();
            const centerRect = centerEl.getBoundingClientRect();
            let remaining = cards.length;
            cards.forEach((c, i) => {
              const card = cardFaceEl(c);
              card.classList.add('moving-card');
              stage.appendChild(card);
              const cardRect = card.getBoundingClientRect();
              const scale = avatarRect.width / cardRect.width;
              card.style.left =
                avatarRect.left - stageRect.left + avatarRect.width / 2 + 'px';
              card.style.top =
                avatarRect.top - stageRect.top + avatarRect.height / 2 + 'px';
              card.style.transform = `translate(-50%, -50%) scale(${scale})`;
              requestAnimationFrame(() => {
                card.style.left =
                  centerRect.left - stageRect.left + i * (cardRect.width * 0.3) + 'px';
                card.style.top = centerRect.top - stageRect.top + 'px';
                card.style.transform = 'translate(-50%, -50%) scale(1)';
              });
              card.addEventListener(
                'transitionend',
                () => {
                  card.remove();
                  remaining--;
                  if (remaining === 0) resolve();
                },
                { once: true }
              );
            });
          });
        }

        function animateCardTransfer(fromIdx, toIdx, card) {
          return new Promise((resolve) => {
            const stage = el('.stage');
            const seats = seatsEl.querySelectorAll('.seat');
            const fromSeat = seats[fromIdx];
            const toSeat = seats[toIdx];
            if (!stage || !fromSeat || !toSeat) {
              resolve();
              return;
            }
            const stageRect = stage.getBoundingClientRect();
            const fromRect = fromSeat.getBoundingClientRect();
            const toRect = toSeat.getBoundingClientRect();
            const moving = cardFaceEl(card);
            moving.classList.add('moving-card');
            stage.appendChild(moving);
            moving.style.left =
              fromRect.left - stageRect.left + fromRect.width / 2 + 'px';
            moving.style.top =
              fromRect.top - stageRect.top + fromRect.height / 2 + 'px';
            moving.style.transform = 'translate(-50%, -50%) rotateY(-90deg)';
            requestAnimationFrame(() => {
              moving.style.transform = 'translate(-50%, -50%) rotateY(0deg)';
            });
            setTimeout(() => {
              moving.style.left =
                toRect.left - stageRect.left + toRect.width / 2 + 'px';
              moving.style.top =
                toRect.top - stageRect.top + toRect.height / 2 + 'px';
            }, 400);
            moving.addEventListener(
              'transitionend',
              (e) => {
                if (e.propertyName === 'left' || e.propertyName === 'top') {
                  moving.style.transform =
                    'translate(-50%, -50%) rotateY(180deg)';
                  moving.addEventListener(
                    'transitionend',
                    () => {
                      moving.remove();
                      resolve();
                    },
                    { once: true }
                  );
                }
              },
              { once: true }
            );
          });
        }

        function flipCardsTemporarily(idx, cards) {
          return new Promise((resolve) => {
            const stage = el('.stage');
            const seat = seatsEl.querySelectorAll('.seat')[idx];
            if (!stage || !seat) {
              resolve();
              return;
            }
            const stageRect = stage.getBoundingClientRect();
            const seatRect = seat.getBoundingClientRect();
            const elements = cards.map((c, i) => {
              const card = cardFaceEl(c);
              card.classList.add('moving-card');
              stage.appendChild(card);
              card.style.left =
                seatRect.left - stageRect.left + seatRect.width / 2 + i * 20 + 'px';
              card.style.top =
                seatRect.top - stageRect.top + seatRect.height / 2 + 'px';
              card.style.transform = 'translate(-50%, -50%) rotateY(-90deg)';
              requestAnimationFrame(() => {
                card.style.transform = 'translate(-50%, -50%) rotateY(0deg)';
              });
              return card;
            });
            setTimeout(() => {
              let remaining = elements.length;
              elements.forEach((card) => {
                card.style.transform = 'translate(-50%, -50%) rotateY(90deg)';
                card.addEventListener(
                  'transitionend',
                  () => {
                    card.remove();
                    remaining--;
                    if (remaining === 0) resolve();
                  },
                  { once: true }
                );
              });
            }, 2000);
          });
        }

        function waitForUserLowCard(winnerIdx) {
          return new Promise((resolve) => {
            const seat = seatsEl.querySelectorAll('.seat')[winnerIdx];
            const cardEls = seat ? seat.querySelectorAll('.cards .card') : [];
            function handler(e) {
              const idx = Number(e.currentTarget.dataset.index);
              const card = state.players[winnerIdx].hand[idx];
              if (
                rankValue(card.r) >= 3 &&
                rankValue(card.r) <= rankValue('K')
              ) {
                cardEls.forEach((el) => el.removeEventListener('click', handler));
                resolve({ card, idx });
              } else {
                toast('Card must be between 3 and K');
              }
            }
            cardEls.forEach((el) => el.addEventListener('click', handler));
          });
        }

        let timerInterval;
        function updateTimerDisplay() {
          seatsEl.querySelectorAll('.seat').forEach((seat, idx) => {
            const t = seat.querySelector('.timer');
            if (t) {
              if (idx === state.turn) {
                if (idx === 0 && !state.arrangeMode) {
                  t.textContent = 'play';
                } else {
                  t.textContent = state.turnTime;
                }
              } else {
                t.textContent = '';
              }
            }
            seat.classList.toggle('active', idx === state.turn);
          });
        }
        function startTurnTimer() {
          sndTurn.currentTime = 0;
          sndTurn.play();
          state.turnTime = state.players[state.turn].isHuman ? 20 : 5;
          updateTimerDisplay();
          clearInterval(timerInterval);
          timerInterval = setInterval(() => {
            state.turnTime--;
            if (state.turnTime <= 7 && state.turnTime > 0) {
              sndTimer.currentTime = 0;
              sndTimer.play();
            }
            updateTimerDisplay();
            if (state.turnTime <= 0) {
              clearInterval(timerInterval);
              toast('Time up');
              state.passesSincePlay++;
              if (state.players[state.turn].isHuman) clearSelections();
              advanceTurn();
            }
          }, 1000);
        }

        // ===== GAME FLOW (singles/pairs + simple AI) =====
        function collectSelected() {
          return state.selectedIndices.map((i) => ({
            c: player(0).hand[i],
            idx: i
          }));
        }
        function clearSelections() {
          state.selectedIndices = [];
          seatsEl
            .querySelectorAll('.card.selected')
            .forEach((n) => n.classList.remove('selected'));
        }
        function clearSuggestions() {
          seatsEl
            .querySelectorAll(
              '.card.suggested, .card.highlight-straight, .card.highlight-double, .card.highlight-triple, .card.highlight-quad, .card.highlight-highest, .card.highlight-lowest, .card.highlight-bomb'
            )
            .forEach((n) =>
              n.classList.remove(
                'suggested',
                'highlight-straight',
                'highlight-double',
                'highlight-triple',
                'highlight-quad',
                'highlight-highest',
                'highlight-lowest',
                'highlight-bomb'
              )
            );
        }

        function player(i) {
          return state.players[i];
        }

        function comboType(cards) {
          const ranks = cards.map((c) => rankValue(c.r)).sort((a, b) => a - b);
          const suits = cards.map((c) => c.s);
          const uniqueRanks = new Set(ranks).size;
          const uniqueSuits = new Set(suits).size;
          const isSeq =
            ranks.length >= 5 &&
            ranks.every((v, i, arr) => i === 0 || v === arr[i - 1] + 1);
          if (cards.length === 1) return 'single';
          if (cards.length === 2 && uniqueRanks === 1) return 'double';
          if (cards.length === 3 && uniqueRanks === 1) return 'triple';
          if (cards.length === 4 && uniqueRanks === 1) return 'four';
          if (cards.length >= 5 && uniqueSuits === 1 && isSeq)
            return 'straight';
          if (cards.length >= 5 && uniqueSuits === 1) return 'flush';
          if (cards.length >= 5 && isSeq) return 'straight';
          return 'invalid';
        }

        function higherThanPile(cards) {
          const combo = comboType(cards);
          if (combo === 'invalid') return false;
          if (state.lastPlayLen === 0) return true;
          if (
            combo !== state.lastPlayType ||
            cards.length !== state.lastPlayLen
          )
            return false;
          const lastHigh = Math.max(...state.pile.map((c) => rankValue(c.r)));
          const nowHigh = Math.max(...cards.map((c) => rankValue(c.r)));
          return nowHigh > lastHigh;
        }

        function comboLabel(type) {
          switch (type) {
            case 'single':
              return 'Single';
            case 'double':
              return 'Double';
            case 'triple':
              return 'Triple';
            case 'four':
              return '4 of a kind';
            case 'flush':
              return 'Flush';
            case 'straight':
              return 'Straight';
            default:
              return '';
          }
        }

        function canPlaySome(p) {
          // Check if player has any legal move (single/pair) vs current pile
          const hand = p.hand;
          // singles
          if (state.lastPlayLen === 0) {
            return hand.length > 0;
          }
          if (state.lastPlayLen === 1) {
            return hand.some(
              (c) =>
                rankValue(c.r) >
                Math.max(...state.pile.map((pc) => rankValue(pc.r)))
            );
          }
          if (state.lastPlayLen === 2) {
            const counts = countByRank(hand);
            const lastHigh = Math.max(
              ...state.pile.map((pc) => rankValue(pc.r))
            );
            return Object.entries(counts).some(
              ([r, c]) => c >= 2 && rankValue(parseRank(r)) > lastHigh
            );
          }
          return false;
        }
        function parseRank(r) {
          return r === '11'
            ? 'J'
            : r === '12'
              ? 'Q'
              : r === '13'
                ? 'K'
                : r === '14'
                  ? 'A'
                  : r === '15'
                    ? 2
                    : r === '16'
                      ? 'BJ'
                      : r === '17'
                        ? 'RJ'
                        : isNaN(r)
                          ? r
                          : Number(r);
        }
        function countByRank(hand) {
          const m = {};
          hand.forEach((c) => {
            const k = rankValue(c.r);
            m[k] = (m[k] || 0) + 1;
          });
          return m;
        }

        function autoArrangeHand(hand) {
          arrangeVariant = (arrangeVariant + 1) % 2;
          const sorted = [...hand].sort((a, b) => {
            const r = rankValue(a.r) - rankValue(b.r);
            if (r !== 0) return r;
            return arrangeVariant === 0
              ? a.s.localeCompare(b.s)
              : b.s.localeCompare(a.s);
          });
          hand.splice(0, hand.length, ...sorted);
        }

        function autoArrange() {
          autoArrangeHand(state.players[0].hand);
          renderAll();
        }

        function aiChoose(p) {
          const hand = [...p.hand].sort(
            (a, b) => rankValue(a.r) - rankValue(b.r)
          );
          if (state.lastPlayLen === 0) {
            // Start round: prefer lowest pair, else lowest single
            const counts = countByRank(hand);
            const pairRank = Object.keys(counts)
              .map(Number)
              .filter((k) => counts[k] >= 2)
              .sort((a, b) => a - b)[0];
            if (pairRank) {
              return hand
                .filter((c) => rankValue(c.r) === pairRank)
                .slice(0, 2);
            }
            return [hand[0]];
          }
          if (state.lastPlayLen === 1) {
            const lastHigh = Math.max(...state.pile.map((c) => rankValue(c.r)));
            const cand = hand.find((c) => rankValue(c.r) > lastHigh);
            return cand ? [cand] : [];
          }
          if (state.lastPlayLen === 2) {
            const counts = countByRank(hand);
            const lastHigh = Math.max(...state.pile.map((c) => rankValue(c.r)));
            const pair = Object.keys(counts)
              .map(Number)
              .filter((k) => counts[k] >= 2 && k > lastHigh)
              .sort((a, b) => a - b)[0];
            if (pair) {
              return hand.filter((c) => rankValue(c.r) === pair).slice(0, 2);
            }
            return [];
          }
          return [];
        }

        function highlightCombos() {
          const faces = seatsEl.querySelectorAll(
            '.seat.bottom .cards .card:not(.back)'
          );
          faces.forEach((f) =>
            f.classList.remove(
              'highlight-straight',
              'highlight-double',
              'highlight-triple',
              'highlight-quad',
              'highlight-highest',
              'highlight-lowest',
              'highlight-bomb'
            )
          );
          const hand = player(0).hand;
          if (!hand.length) return;
          const highest = Math.max(...hand.map((c) => rankValue(c.r)));
          const lowest = Math.min(...hand.map((c) => rankValue(c.r)));
          hand.forEach((c, idx) => {
            const val = rankValue(c.r);
            if (val === highest) faces[idx].classList.add('highlight-highest');
            if (val === lowest) faces[idx].classList.add('highlight-lowest');
          });
          const counts = {};
          hand.forEach((c) => (counts[c.r] = (counts[c.r] || 0) + 1));
          Object.entries(counts).forEach(([r, cnt]) => {
            hand.forEach((c, idx) => {
              if (c.r === r) {
                if (cnt >= 4)
                  faces[idx].classList.add('highlight-quad', 'highlight-bomb');
                else if (cnt === 3)
                  faces[idx].classList.add('highlight-triple');
                else if (cnt === 2)
                  faces[idx].classList.add('highlight-double');
              }
            });
          });
          const sorted = [...hand].sort(
            (a, b) => rankValue(a.r) - rankValue(b.r)
          );
          let seq = [sorted[0]];
          for (let i = 1; i < sorted.length; i++) {
            const prevVal = rankValue(sorted[i - 1].r);
            const currVal = rankValue(sorted[i].r);
            if (currVal === prevVal) continue;
            if (currVal === prevVal + 1) {
              seq.push(sorted[i]);
            } else {
              if (seq.length >= 5)
                seq.forEach((card) => {
                  const idx = hand.indexOf(card);
                  if (idx > -1)
                    faces[idx].classList.add('highlight-straight');
                });
              seq = [sorted[i]];
            }
          }
          if (seq.length >= 5)
            seq.forEach((card) => {
              const idx = hand.indexOf(card);
              if (idx > -1) faces[idx].classList.add('highlight-straight');
            });
        }

        function highlightSuggestions() {
          highlightCombos();
        }

        function playTurn(i) {
          clearSuggestions();
          const p = player(i);
          if (p.finished) {
            advanceTurn();
            return;
          }
          startTurnTimer();
          if (p.isHuman) {
            toast(
              'Your turn' +
                (state.lastPlayLen
                  ? ` ‚Ä¢ play ${comboLabel(state.lastPlayType)}`
                  : '')
            );
            highlightSuggestions();
            return;
          }
          // AI with small delay
          setTimeout(async () => {
            let chosen = aiChoose(p);
            if (chosen.length === 0) {
              state.passesSincePlay++;
              toast('Pass');
              advanceTurn();
              return;
            }
            // place if higher than pile
            if (!higherThanPile(chosen)) {
              state.passesSincePlay++;
              toast('Pass');
              advanceTurn();
              return;
            }
            // commit play
            const combo = comboType(chosen);
            state.pile = [];
            chosen.forEach((c) => {
              const idx = p.hand.indexOf(c);
              if (idx > -1) p.hand.splice(idx, 1);
            });
            renderAll();
            await animateCardsFromAvatar(i, chosen);
            state.pile.push(...chosen);
            state.lastPlayLen = chosen.length;
            state.lastPlayType = combo;
            state.passesSincePlay = 0;
            state.lastPlayerToPlay = i;
            sndCard.currentTime = 0;
            sndCard.play();
            renderAll();
            advanceTurn();
          }, 1000);
        }

        function advanceTurn() {
          clearSuggestions();
          let newRound = false;
          const activeCount = state.players.filter((p) => !p.finished).length;
          // If everyone else passed since last play, clear pile and give turn back to last player (or next alive if finished)
          if (state.passesSincePlay >= activeCount - 1) {
            state.pile = [];
            state.lastPlayLen = 0;
            state.lastPlayType = null;
            state.passesSincePlay = 0;
            let next = state.lastPlayerToPlay;
            if (state.players[next].finished) {
              next = (next + 1) % state.players.length;
              while (state.players[next].finished) {
                next = (next + 1) % state.players.length;
              }
            }
            state.turn = next;
            renderAll();
            toast('New round');
            newRound = true;
          }
          if (!newRound) {
            let next = (state.turn + 1) % state.players.length;
            while (state.players[next].finished) {
              next = (next + 1) % state.players.length;
            }
            state.turn = next;
          }
          // check if last player finished
          const lp = state.players[state.lastPlayerToPlay];
          if (lp && lp.hand.length === 0 && !lp.finished) {
            lp.finished = true;
            state.finishedOrder.push(state.lastPlayerToPlay);
            if (state.playMode === 'single') {
              toast((lp.isHuman ? 'You' : lp.name) + ' won!');
              clearInterval(timerInterval);
              coinConfetti();
              showWinnerOverlay(state.lastPlayerToPlay === 0 ? 'üÉè' : 'üêæ');
              if (lobbyBtn) lobbyBtn.style.display = 'block';
              return;
            } else {
              if (state.finishedOrder.length === state.players.length - 1) {
                const lastIdx = state.players.findIndex((p) => !p.finished);
                state.players[lastIdx].finished = true;
                state.finishedOrder.push(lastIdx);
              }
              if (state.finishedOrder.length === state.players.length) {
                endRound();
                return;
              }
            }
          }
          playTurn(state.turn);
        }

        async function endRound() {
          const pointsMap = [3, 2, 1, 0];
          state.finishedOrder.forEach((idx, pos) => {
            state.players[idx].points = (state.players[idx].points || 0) + (pointsMap[pos] || 0);
          });
          renderAll();
          if (state.playMode === 'points' && state.pointsTarget > 0) {
            const maxPts = Math.max(...state.players.map((p) => p.points));
            if (maxPts >= state.pointsTarget) {
              const winnerIdx = state.players.findIndex((p) => p.points === maxPts);
              toast((state.players[winnerIdx].isHuman ? 'You' : state.players[winnerIdx].name) + ' win the match!');
              coinConfetti();
              showWinnerOverlay(winnerIdx === 0 ? 'üÉè' : 'üêæ');
              if (lobbyBtn) lobbyBtn.style.display = 'block';
              return;
            }
          }
          const winnerIdx = state.finishedOrder[0];
          const loserIdx = state.finishedOrder[state.finishedOrder.length - 1];
          state.round += 1;
          state.finishedOrder = [];
          state.pile = [];
          state.lastPlayLen = 0;
          state.lastPlayType = null;
          state.passesSincePlay = 0;
          state.players.forEach((p) => {
            p.hand = [];
            p.finished = false;
          });
          await deal();
          autoArrangeHand(state.players[0].hand);
          let startPlayerIdx = loserIdx;
          // Card exchange with animation (points mode, rounds 2+)
          if (
            state.playMode === 'points' &&
            state.round >= 2 &&
            winnerIdx != null &&
            loserIdx != null &&
            winnerIdx !== loserIdx
          ) {
            const loserHand = state.players[loserIdx].hand;
            const winnerHand = state.players[winnerIdx].hand;
            if (loserHand.length > 0) {
              const jokers = loserHand.filter(
                (c) => c.r === 'RJ' || c.r === 'BJ'
              );
              const counts = {};
              loserHand.forEach(
                (c) => (counts[c.r] = (counts[c.r] || 0) + 1)
              );
              let hi = 0;
              for (let i = 1; i < loserHand.length; i++) {
                if (rankValue(loserHand[i].r) > rankValue(loserHand[hi].r)) hi = i;
              }
              const highRank = loserHand[hi].r;
              if (jokers.length === 2) {
                await flipCardsTemporarily(loserIdx, jokers);
                startPlayerIdx = winnerIdx;
              } else if (counts[highRank] === 4) {
                const bomb = loserHand.filter((c) => c.r === highRank);
                await flipCardsTemporarily(loserIdx, bomb);
                startPlayerIdx = winnerIdx;
              } else {
                const highCard = loserHand.splice(hi, 1)[0];
                loserHand.sort((a, b) => rankValue(a.r) - rankValue(b.r));
                renderAll();
                await animateCardTransfer(loserIdx, winnerIdx, highCard);
                winnerHand.push(highCard);
                winnerHand.sort((a, b) => rankValue(a.r) - rankValue(b.r));
                renderAll();
                let low = null;
                if (winnerIdx === 0) {
                  clearSelections();
                  toast('You have to give a lower card to the loser (3-K)');
                  const choice = await waitForUserLowCard(winnerIdx);
                  if (choice) {
                    low = choice.card;
                    winnerHand.splice(choice.idx, 1);
                  }
                  clearSelections();
                } else {
                  const valid = winnerHand.filter(
                    (c) =>
                      rankValue(c.r) >= 3 &&
                      rankValue(c.r) <= rankValue('K')
                  );
                  if (valid.length > 0) {
                    low = valid.reduce((a, c) =>
                      rankValue(c.r) < rankValue(a.r) ? c : a
                    );
                    const idx = winnerHand.indexOf(low);
                    winnerHand.splice(idx, 1);
                  }
                }
                if (low) {
                  renderAll();
                  await animateCardTransfer(winnerIdx, loserIdx, low);
                  loserHand.push(low);
                  loserHand.sort(
                    (a, b) => rankValue(a.r) - rankValue(b.r)
                  );
                }
                winnerHand.sort((a, b) => rankValue(a.r) - rankValue(b.r));
              }
            }
          }
          state.startPlayer = startPlayerIdx;
          renderAll();
          startArrangePhase();
        }

        async function confirmPlayAction() {
          if (state.turn !== 0) {
            return;
          }
          const sel = collectSelected();
          if (sel.length === 0) {
            toast('Select cards first');
            return;
          }
          const cards = sel.map((s) => s.c);
          const combo = comboType(cards);
          if (combo === 'invalid') {
            toast('Invalid combo');
            return;
          }
          if (state.lastPlayLen && combo !== state.lastPlayType) {
            toast('Must play ' + comboLabel(state.lastPlayType));
            return;
          }
          if (!higherThanPile(cards)) {
            toast('Play higher');
            return;
          }
          state.pile = [];
          cards.forEach((c) => {
            const idx = player(0).hand.indexOf(c);
            if (idx > -1) player(0).hand.splice(idx, 1);
          });
          clearSelections();
          clearSuggestions();
          renderAll();
          await animateCardsFromAvatar(0, cards);
          state.pile.push(...cards);
          state.lastPlayLen = cards.length;
          state.lastPlayType = combo;
          state.passesSincePlay = 0;
          state.lastPlayerToPlay = 0;
          sndCard.currentTime = 0;
          sndCard.play();
          renderAll();
          advanceTurn();
        }

        // ===== UI HANDLERS =====

        function startGame() {
          state.turn = state.startPlayer;
          playTurn(state.turn);
        }

        function startArrangePhase() {
          state.arrangeMode = true;
          let t = 60;
          state.turn = 0;
          state.turnTime = t;
          renderAll();
          highlightCombos();
          toast('Arrange your cards');
          arrangeInterval = setInterval(() => {
            t--;
            state.turnTime = t;
            updateTimerDisplay();
            if (t <= 0) {
              clearInterval(arrangeInterval);
              state.arrangeMode = false;
              renderAll();
              startGame();
            }
          }, 1000);
        }

        // boot
        initPlayers();
        await deal();
        autoArrangeHand(state.players[0].hand);
        state.startPlayer = findStartPlayer();
        if (state.startPlayer < 0) state.startPlayer = 0;
        renderAll();
        startArrangePhase();
      })();
    </script>
  </body>
</html>
