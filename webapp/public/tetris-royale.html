<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
<title>Tetris Royale — 4 Player Layout</title>
<style>
  :root{ --bg:#0c1020; --panel:#11172a; --primary:#2563eb; --gold:#d4af37; --text:#e7eefc; --muted:#8fa1d2; --danger:#ff5a6b; }
  *{box-sizing:border-box;font-family:Inter,system-ui,Segoe UI,Roboto,Helvetica,Arial,sans-serif}
  html,body{height:100vh}
  body{margin:0;background:radial-gradient(1200px 800px at 70% -10%, #1a2450 0%, #0c1020 38%, #0c1020 100%) fixed;color:var(--text);overflow:hidden}
  .app{height:100vh;display:flex;flex-direction:column;padding:12px;gap:10px;max-width:1100px;margin:0 auto}
  header{display:flex;gap:12px;align-items:center;justify-content:space-between}
  .badge{background:#0f1736;border:1px solid #223063;border-radius:10px;padding:6px 10px;color:var(--muted);font-size:12px}
  .controls{display:grid;grid-template-columns:1fr 1fr 1fr auto;gap:8px}
  label{font-size:12px;color:var(--muted);display:block;margin-bottom:6px}
  select,button,input{width:100%;padding:10px 12px;border-radius:10px;border:1px solid #223063;background:#0e1430;color:#e7eefc}
  .btn{background:linear-gradient(180deg,#2a6cf0,#2156c8);border:none;font-weight:700;cursor:pointer}
  .hud{display:flex;gap:8px}
  .panel{border:1px solid #223063;background:#0b1228;border-radius:12px;padding:10px;display:flex;align-items:center;justify-content:space-between}
  .score{color:var(--gold);font-weight:800}
  .timer{font-variant-numeric:tabular-nums;font-weight:800}
  .layout{display:grid;grid-template-rows:25vh 1fr;gap:10px;flex:1;min-height:0}
  .top{display:grid;grid-template-columns:repeat(3,1fr);gap:10px}
  .mini{position:relative;border:1px solid #223063;background:linear-gradient(180deg,#0f1530,#0a0f24);border-radius:12px;padding:8px;display:flex;flex-direction:column}
  .mini h3{margin:0;font-size:12px;color:var(--muted);display:flex;align-items:center;gap:4px}
  .mini .oppScore{font-size:12px;color:var(--muted);margin:2px 0 6px}
  @keyframes canvasDepthMove{from{background-position:0 0,center}to{background-position:100px 100px,center}}
  .mini canvas,
  #user{
    flex:1;width:100%;height:100%;
    image-rendering:pixelated;
    background:
      repeating-linear-gradient(45deg,rgba(255,255,255,0.03)0 2px,transparent 2px 4px),
      radial-gradient(circle at center,#1a2450 0%,#0e1430 80%);
    background-size:100px 100px,cover;
    background-position:0 0,center;
    animation:canvasDepthMove 30s linear infinite;
    border-radius:8px;
  }
  .userWrap{position:relative;border:1px solid #223063;background:linear-gradient(180deg,#0f1530,#0a0f24);border-radius:14px;padding:10px;display:flex;flex-direction:column;min-height:0}
  .userWrap h3{margin:0;font-size:13px;color:var(--muted)}
  .userHeader{display:flex;align-items:center;gap:8px;margin-bottom:8px}
  #user{border-radius:10px;touch-action:none}
  .avatar{width:32px;height:32px;border-radius:50%}
  .mini h3 .avatar{width:16px;height:16px;border-radius:2px}
  .scorePanel{flex-direction:column;align-items:center;justify-content:center}
  .countdown{position:fixed;inset:0;display:flex;align-items:center;justify-content:center;font-size:48px;font-weight:bold;color:#fff;background:rgba(0,0,0,0.5);z-index:50}
  .countdown.hidden{display:none}
  .toast{position:fixed;left:50%;transform:translateX(-50%);bottom:16px;background:#0d1536;border:1px solid #223063;border-radius:10px;padding:8px 12px;font-size:13px;opacity:0;transition:opacity .2s}
  .toast.show{opacity:1}
  dialog{border:none;border-radius:16px;background:#0d1330;color:#e7eefc;max-width:520px;width:calc(100% - 24px)}
  .modal{padding:16px;border:1px solid #223063;border-radius:16px;background:linear-gradient(180deg,#0f1736,#0b1126)}
  .grid{display:grid;gap:10px}
  .grid.two{grid-template-columns:1fr 1fr}
  .kpi{background:#0b1228;border:1px solid #223063;border-radius:12px;padding:10px;text-align:center}
  .kpi .v{font-size:22px;font-weight:800}
  .winnerOverlay{position:fixed;inset:0;display:flex;align-items:center;justify-content:center;background:rgba(0,0,0,0.6);z-index:60}
  .winnerOverlay.hidden{display:none}
  .winnerOverlay img{width:120px;height:120px;border-radius:50%}
  .coin-confetti{position:fixed;top:-40px;width:32px;height:32px;pointer-events:none;animation:coin-fall var(--duration,3s) linear forwards}
  @keyframes coin-fall{from{transform:translateY(-10vh) rotate(0deg);opacity:1}to{transform:translateY(100vh) rotate(360deg);opacity:0}}
</style>
</head>
<body>
<div class="app">
  <div id="countdown" class="countdown hidden"></div>
  <div class="layout">
    <div class="top">
      <div class="mini">
        <h3><img src="assets/icons/profile.svg" alt="" class="avatar"/><span class="oppName">P1</span></h3>
        <div class="oppScore">0</div>
        <canvas id="opp1"></canvas>
      </div>
      <div class="mini">
        <h3><img src="assets/icons/profile.svg" alt="" class="avatar"/><span class="oppName">P2</span></h3>
        <div class="oppScore">0</div>
        <canvas id="opp2"></canvas>
      </div>
      <div class="mini">
        <h3><img src="assets/icons/profile.svg" alt="" class="avatar"/><span class="oppName">P3</span></h3>
        <div class="oppScore">0</div>
        <canvas id="opp3"></canvas>
      </div>
    </div>
    <div class="userWrap">
      <div class="userHeader">
        <img src="assets/icons/profile.svg" alt="" class="avatar" id="userAvatar"/>
        <h3 id="username">PLAYER</h3>
        <div class="hud">
          <div class="panel"><strong>Time</strong><span id="time" class="timer">03:00</span></div>
          <div class="panel scorePanel"><strong>Your score</strong><span id="myscore" class="score">0</span></div>
        </div>
      </div>
      <canvas id="user"></canvas>
    </div>
  </div>
</div>
<div id="toast" class="toast"></div>
<dialog id="results">
  <div class="modal">
    <h2>Round results</h2>
    <div class="grid two">
      <div class="kpi"><div class="v" id="winner">-</div><div>Winner</div></div>
      <div class="kpi"><div class="v" id="payout">0</div><div>Payout TPC</div></div>
    </div>
    <div class="grid" style="margin-top:10px">
      <div class="kpi"><div class="v" id="fee">0</div><div>Fee 10%</div></div>
      <div class="kpi"><div class="v" id="potFinal">0</div><div>Final Pot</div></div>
    </div>
    <div class="grid" id="scoreList" style="margin-top:10px"></div>
    <div style="display:flex;gap:8px;flex-wrap:wrap;margin-top:8px">
      <button class="btn" id="rematch">Play Again</button>
      <button class="btn" id="lobby">Return to Lobby</button>
    </div>
  </div>
</dialog>
<div id="winnerOverlay" class="winnerOverlay hidden"></div>
<script src="/flag-emojis.js"></script>
<script src="/falling-ball-api.js"></script>
<script>
if(!window.__TETRIS_ROYALE__){
window.__TETRIS_ROYALE__ = true;
(async function(){
  const COLS = 10, ROWS = 20;
  const COLORS = ['#000','#5aa2ff','#ff9d5a','#ff5a6b','#d4af37','#34d399','#a78bfa','#f472b6'];
  const SHAPES = {
    I:[[0,0,0,0],[1,1,1,1],[0,0,0,0],[0,0,0,0]],
    J:[[1,0,0],[1,1,1],[0,0,0]],
    L:[[0,0,1],[1,1,1],[0,0,0]],
    O:[[1,1],[1,1]],
    S:[[0,1,1],[1,1,0],[0,0,0]],
    T:[[0,1,0],[1,1,1],[0,0,0]],
    Z:[[1,1,0],[0,1,1],[0,0,0]],
  };
  const SCORE_PER_LINES = [0,100,300,500,800];
  const $ = sel => document.querySelector(sel);
  const toastEl = $('#toast');
  const showToast = (msg)=>{ toastEl.textContent = msg; toastEl.classList.add('show'); setTimeout(()=>toastEl.classList.remove('show'), 1400); };
  const fmt = (s)=>{ const m = String((s/60)|0).padStart(2,'0'); const ss = String(Math.max(0, s%60)).padStart(2,'0'); return `${m}:${ss}`; };

  const params = new URLSearchParams(location.search);
  const n = Math.max(2, Math.min(4, parseInt(params.get('players'),10)||4));
  const stake = Math.max(0, parseInt(params.get('amount'),10)||300);
  const durSec = Math.max(10, parseInt(params.get('duration'),10)||180);
  const avatarParam = params.get('avatar') || '';
  const tgId = params.get('tgId');
  const accountId = params.get('accountId');
  const devAccount = params.get('dev');
  const devAccount1 = params.get('dev1');
  const devAccount2 = params.get('dev2');
  const initParam = params.get('init');
  if (initParam && !window.Telegram) {
    window.Telegram = { WebApp: { initData: decodeURIComponent(initParam) } };
  }
  let userName = params.get('name') || params.get('username') || '';

  function emojiToDataUri(flag){
    return `data:image/svg+xml,${encodeURIComponent(`<svg xmlns='http://www.w3.org/2000/svg' width='64' height='64'><text x='50%' y='50%' font-size='48' text-anchor='middle' dominant-baseline='central'>${flag}</text></svg>`)}`;
  }
  const regionNames = new Intl.DisplayNames(['en'], { type: 'region' });
  function flagName(flag){
    const pts = [...flag].map(c=>c.codePointAt(0)-127397);
    const code = String.fromCharCode(...pts);
    return regionNames.of(code) || flag;
  }
  function coinConfetti(count=50, iconSrc='/assets/icons/file_000000005f0c61f48998df883554c3e8 (2).webp'){
    for(let i=0;i<count;i++){
      const img=document.createElement('img');
      img.src=iconSrc;
      img.className='coin-confetti';
      img.style.left=Math.random()*100+'vw';
      img.style.setProperty('--duration', (2+Math.random()*2)+'s');
      document.body.appendChild(img);
      setTimeout(()=>img.remove(),3000);
    }
  }
  async function awardDevShare(total){
    const ops=[];
    if(devAccount1||devAccount2){
      if(devAccount) ops.push(fbApi.depositAccount(devAccount, Math.round(total*0.09), {game:'tetrisroyale-dev'}));
      if(devAccount1) ops.push(fbApi.depositAccount(devAccount1, Math.round(total*0.01), {game:'tetrisroyale-dev1'}));
      if(devAccount2) ops.push(fbApi.depositAccount(devAccount2, Math.round(total*0.02), {game:'tetrisroyale-dev2'}));
    }else if(devAccount){
      ops.push(fbApi.depositAccount(devAccount, Math.round(total*0.1), {game:'tetrisroyale-dev'}));
    }
    if(ops.length){ try{ await Promise.all(ops); }catch{} }
  }

  const accounts = Array(n).fill(null);
  const tgIds = Array(n).fill(null);
  accounts[n-1] = accountId;
  tgIds[n-1] = tgId;
  const playerAvatars = Array(n).fill('');
  const playerNames = Array(n).fill('');

  async function fetchPlayerName(tgId, accountId){
    try{
      const headers={'Content-Type':'application/json'};
      const initData = window?.Telegram?.WebApp?.initData;
      if(initData) headers['X-Telegram-Init-Data'] = initData;
      let res;
      if(tgId){
        res = await fetch('/api/profile/telegram-info',{method:'POST',headers,body:JSON.stringify({telegramId:tgId})});
      }else if(accountId){
        res = await fetch('/api/profile/by-account',{method:'POST',headers,body:JSON.stringify({accountId})});
      }
      if(res && res.ok){
        const data = await res.json();
        return data.nickname || data.firstName || data.first_name || '';
      }
    }catch{}
    return '';
  }

  async function initUserName(){
    if(!userName){
      userName = await fetchPlayerName(tgId, accountId);
    }
    if(!userName){
      const userData = window?.Telegram?.WebApp?.initDataUnsafe?.user;
      userName = userData?.username || [userData?.first_name, userData?.last_name].filter(Boolean).join(' ') || 'Player';
    }
    const el = $('#username');
    if(el) el.textContent = userName;
    playerNames[n-1] = userName;
  }

  function createEmpty(){ return Array.from({length:ROWS},()=>Array(COLS).fill(0)); }
  function randomShape(){ const keys = Object.keys(SHAPES); const k = keys[(Math.random()*keys.length)|0]; return SHAPES[k].map(r=>r.slice()); }
  function rotate(mat){ return mat[0].map((_,i)=>mat.map(row=>row[i])).reverse(); }
  function collide(board, piece, pos){
    for(let y=0;y<piece.length;y++){
      for(let x=0;x<piece[y].length;x++){
        if(!piece[y][x]) continue;
        const nx = pos.x + x, ny = pos.y + y;
        if(nx<0 || nx>=COLS || ny>=ROWS) return true;
        if(ny>=0 && board[ny][nx]) return true;
      }
    }
    return false;
  }
  function merge(board, piece, pos, color){
    for(let y=0;y<piece.length;y++){
      for(let x=0;x<piece[y].length;x++){
        if(piece[y][x]){ board[pos.y+y][pos.x+x] = color; }
      }
    }
  }
  function sweep(board){
    let lines = 0;
    for(let y=ROWS-1;y>=0;y--){
      if(board[y].every(v=>v)){
        board.splice(y,1);
        board.unshift(Array(COLS).fill(0));
        lines++;
        y++;
      }
    }
    return lines;
  }
  function cloneBoard(board){ return board.map(row=>row.slice()); }
  function evaluate(board, lines){
    const heights = Array(COLS).fill(0);
    let aggregateHeight = 0, holes = 0;
    for(let x=0;x<COLS;x++){
      let y=0;
      while(y<ROWS && !board[y][x]) y++;
      heights[x] = ROWS - y;
      aggregateHeight += heights[x];
      for(let yy=y+1;yy<ROWS;yy++) if(!board[yy][x]) holes++;
    }
    let bumpiness = 0;
    for(let x=0;x<COLS-1;x++){ bumpiness += Math.abs(heights[x]-heights[x+1]); }
    return lines*100 - aggregateHeight*1 - holes*45 - bumpiness*5;
  }
  function bestMove(game){
    let best = null;
    const rotations = [];
    let piece = game.piece;
    for(let r=0;r<4;r++){
      if(r>0) piece = rotate(piece);
      rotations.push(piece);
    }
    for(let r=0;r<rotations.length;r++){
      const p = rotations[r];
      const width = p[0].length;
      for(let x=-2;x<=COLS-width+2;x++){
        if(collide(game.board, p, {x, y:0})) continue;
        let y=0; while(!collide(game.board, p, {x, y:y+1})) y++;
        const boardCopy = cloneBoard(game.board);
        merge(boardCopy, p, {x,y}, 1);
        const score = evaluate(boardCopy, sweep(boardCopy));
        if(!best || score>best.score){ best={score,x,rot:r}; }
      }
    }
    return best;
  }
  function fitCanvas(canvas){
    const r = canvas.getBoundingClientRect();
    canvas.width = Math.floor(r.width);
    canvas.height = Math.floor(r.height);
  }
  function shadeColor(color, percent){
    const f = parseInt(color.slice(1), 16);
    const t = percent < 0 ? 0 : 255;
    const p = Math.abs(percent);
    const R = f >> 16;
    const G = f >> 8 & 0x00FF;
    const B = f & 0x0000FF;
    return '#' + (0x1000000 + (Math.round((t - R) * p) + R) * 0x10000 + (Math.round((t - G) * p) + G) * 0x100 + (Math.round((t - B) * p) + B)).toString(16).slice(1);
  }
  function drawBlock(ctx, x, y, w, h, color){
    const grad = ctx.createLinearGradient(x, y, x + w, y + h);
    grad.addColorStop(0, shadeColor(color, 0.3));
    grad.addColorStop(1, shadeColor(color, -0.3));
    ctx.fillStyle = grad;
    ctx.fillRect(x, y, w, h);
    const hl = shadeColor(color, 0.5);
    ctx.fillStyle = hl;
    ctx.fillRect(x, y, w, Math.max(2, h * 0.15));
    ctx.fillRect(x, y, Math.max(2, w * 0.15), h);
  }
  function drawBoard(ctx, canvas, board, active){
    const bw = canvas.width / COLS, bh = canvas.height / ROWS;
    ctx.clearRect(0,0,canvas.width,canvas.height);
    const bgGrad = ctx.createRadialGradient(
      canvas.width/2,
      canvas.height/2,
      0,
      canvas.width/2,
      canvas.height/2,
      Math.max(canvas.width, canvas.height)/2
    );
    bgGrad.addColorStop(0, '#1a2450');
    bgGrad.addColorStop(1, '#0e1430');
    ctx.fillStyle = bgGrad;
    ctx.fillRect(0,0,canvas.width,canvas.height);
    for(let y=0;y<ROWS;y++){
      for(let x=0;x<COLS;x++){
        const c = board[y][x];
        if(c){ drawBlock(ctx, x*bw, y*bh, bw-1, bh-1, c); }
      }
    }
    if(active){
      const {piece,pos,color} = active;
      let gy = pos.y;
      while(!collide(board, piece, {x:pos.x, y:gy+1})) gy++;
      ctx.globalAlpha = 0.3;
      for(let y=0;y<piece.length;y++){
        for(let x=0;x<piece[y].length;x++){
          if(piece[y][x]) drawBlock(ctx, (pos.x+x)*bw, (gy+y)*bh, bw-1, bh-1, color);
        }
      }
      ctx.globalAlpha = 1;
      for(let y=0;y<piece.length;y++){
        for(let x=0;x<piece[y].length;x++){
          if(piece[y][x]) drawBlock(ctx, (pos.x+x)*bw, (pos.y+y)*bh, bw-1, bh-1, color);
        }
      }
    }
  }
  function createGame(canvas){
    const ctx = canvas.getContext('2d');
    fitCanvas(canvas);
    const game = {
      board: createEmpty(),
      piece: randomShape(),
      pos: {x:3,y:0},
      color: COLORS[1 + ((Math.random()*6)|0)],
      dropMs: 700,
      dropAcc: 0,
      score: 0,
      over: false,
      plan: null,
    };
    game.draw = function(){ drawBoard(ctx, canvas, game.board, {piece:game.piece,pos:game.pos,color:game.color}); };
    game.newPiece = function(){
      game.piece = randomShape();
      game.pos = {x:3,y:0};
      game.color = COLORS[1 + ((Math.random()*6)|0)];
      game.plan = null;
      if(collide(game.board, game.piece, game.pos)) game.over = true;
    };
    game.move = function(dir){
      game.pos.x += dir;
      if(collide(game.board, game.piece, game.pos)) game.pos.x -= dir;
    };
    game.rotate = function(){
      const r = rotate(game.piece);
      if(!collide(game.board, r, game.pos)) game.piece = r;
    };
    game.hardDrop = function(){
      while(!collide(game.board, game.piece, {x:game.pos.x,y:game.pos.y+1})) game.pos.y++;
      merge(game.board, game.piece, game.pos, game.color);
      game.score += SCORE_PER_LINES[sweep(game.board)];
      game.newPiece();
    };
    game.step = function(dt){
      game.dropAcc += dt;
      if(game.dropAcc > game.dropMs){
        game.dropAcc = 0;
        game.pos.y++;
        if(collide(game.board, game.piece, game.pos)){
          game.pos.y--;
          merge(game.board, game.piece, game.pos, game.color);
          const lines = sweep(game.board);
          if(lines){ game.score += SCORE_PER_LINES[lines]; showToast(`+${SCORE_PER_LINES[lines]}`); }
          game.newPiece();
        }
      }
    };
    return game;
  }
  function bindUserControls(canvas, game){
    let start = null;
    canvas.addEventListener('pointerdown', e=>{
      const r = canvas.getBoundingClientRect();
      start = {x:e.clientX - r.left, y:e.clientY - r.top, t:performance.now()};
      canvas.setPointerCapture(e.pointerId);
    });
    canvas.addEventListener('pointermove', e=>{
      if(!start) return;
      const r = canvas.getBoundingClientRect();
      const px = e.clientX - r.left, py = e.clientY - r.top;
      const dx = px - start.x;
      if(Math.abs(dx) > r.width/20){
        game.move(dx>0?1:-1);
        start.x = px;
      }
      const dy = py - start.y;
      const rowH = r.height / ROWS;
      const moveRows = Math.floor(dy / rowH);
      if(moveRows !== 0){
        const dir = Math.sign(moveRows);
        for(let i=0;i<Math.abs(moveRows);i++){
          game.pos.y += dir;
          if(collide(game.board, game.piece, game.pos)){ game.pos.y -= dir; break; }
        }
        start.y += moveRows * rowH;
      }
    });
    canvas.addEventListener('pointerup', e=>{
      if(!start) return;
      const r = canvas.getBoundingClientRect();
      const dt = performance.now() - start.t;
      const endX = e.clientX - r.left;
      const endY = e.clientY - r.top;
      const dx = endX - start.x;
      const dy = endY - start.y;
      if(dt < 180){
        if(Math.abs(dx) < r.width/10 && Math.abs(dy) < r.height/10){
          game.rotate();
        } else if(dy > r.height/10){
          game.hardDrop();
        }
      }
      start = null;
      canvas.releasePointerCapture(e.pointerId);
    });
  }
  function botTick(bot){
    if(bot.over) return;
    if(!bot.plan) bot.plan = bestMove(bot);
    if(bot.plan){
      if(bot.plan.rot > 0){ bot.rotate(); bot.plan.rot--; return; }
      if(bot.pos.x < bot.plan.x){ bot.move(1); return; }
      if(bot.pos.x > bot.plan.x){ bot.move(-1); return; }
      bot.hardDrop();
      bot.plan = null;
    }
  }
  const canvases = { user: $('#user'), opp1: $('#opp1'), opp2: $('#opp2'), opp3: $('#opp3') };
  const avatarEls = document.querySelectorAll('.avatar');
  const miniWraps = document.querySelectorAll('.top .mini');
  const oppNameEls = document.querySelectorAll('.oppName');
  const oppScoreEls = document.querySelectorAll('.oppScore');
  const ui = {
    time: $('#time'), myscore: $('#myscore'),
    results: $('#results'), winner: $('#winner'),
    payout: $('#payout'), fee: $('#fee'), potFinal: $('#potFinal'),
    scoreList: $('#scoreList'), rematch: $('#rematch'), lobby: $('#lobby')
  };
  let games = [];
  let last = performance.now();
  let endAt = 0; let running = false; let rafId = null; let botTimer = 0;

  for(let i=0;i<n-1;i++){
    const flag = FLAG_EMOJIS[(Math.random()*FLAG_EMOJIS.length)|0];
    const uri = emojiToDataUri(flag);
    const name = flagName(flag);
    if(avatarEls[i]) avatarEls[i].src = uri;
    if(oppNameEls[i]) oppNameEls[i].textContent = name;
    playerAvatars[i] = uri;
    playerNames[i] = name;
    if(miniWraps[i]) miniWraps[i].style.display='flex';
  }
  for(let i=n-1;i<3;i++){ if(miniWraps[i]) miniWraps[i].style.display='none'; }
  let userAvatar = avatarParam;
  if(!userAvatar){ userAvatar = 'assets/icons/profile.svg'; }
  else if(!(userAvatar.startsWith('http') || userAvatar.startsWith('/') || userAvatar.startsWith('data:'))){
    userAvatar = emojiToDataUri(userAvatar);
  }
  avatarEls[3].src = userAvatar;
  playerAvatars[n-1] = userAvatar;

  function layoutCanvases(){
    Object.values(canvases).forEach(c=>{ if(!c) return; const r=c.getBoundingClientRect(); c.width=r.width; c.height=r.height; });
  }
  function startMatch(){
    layoutCanvases();
    ui.time.textContent = fmt(durSec);
    games = [];
    const oppSlots = [canvases.opp1, canvases.opp2, canvases.opp3];
    for(let i=0;i<n-1;i++){ games.push(createGame(oppSlots[i])); }
    const userGame = createGame(canvases.user); games.push(userGame);
    bindUserControls(canvases.user, userGame);
    endAt = performance.now() + durSec*1000;
    running = true; last = performance.now(); botTimer=0;
    loop();
  }
  function updateTimer(){
    const remain = Math.max(0, Math.ceil((endAt - performance.now())/1000));
    ui.time.textContent = fmt(remain);
    if(remain<=0){ finish(); }
  }
  function loop(){
    if(!running) return;
    const now = performance.now();
    const dt = now - last; last = now; botTimer += dt;
    for(let i=0;i<games.length;i++){
      games[i].step(dt);
      games[i].draw();
    }
    if(botTimer > 1000){ for(let i=0;i<games.length-1;i++) botTick(games[i]); botTimer = 0; }
    for(let i=0;i<games.length-1;i++){
      if(oppScoreEls[i]) oppScoreEls[i].textContent = String(games[i].score);
    }
    ui.myscore.textContent = String(games[games.length-1].score);
    updateTimer();
    rafId = requestAnimationFrame(loop);
  }
  async function finish(){
    if(!running) return; running=false; if(rafId) cancelAnimationFrame(rafId);
    const gross = stake * n; const fee = Math.round(gross*0.10); const net = gross - fee;
    const scores = games.map((g,i)=>({i,score:g.score,name:playerNames[i]}));
    const max = Math.max(...scores.map(s=>s.score));
    const winners = scores.filter(s=>s.score===max);
    const payout = winners.length? Math.floor(net / winners.length) : 0;
    ui.winner.textContent = winners.length>1 ? `Tie (${winners.map(w=>w.name).join(', ')})` : winners[0].name;
    ui.payout.textContent = String(payout);
    ui.fee.textContent = String(fee);
    ui.potFinal.textContent = String(net);
    ui.scoreList.innerHTML = scores.sort((a,b)=>b.score-a.score).map(s=>`<div class="kpi"><div class="v">${s.name}: ${s.score}</div><div>—</div></div>`).join('');
    const overlay = $('#winnerOverlay');
    const avatar = playerAvatars[winners[0].i];
    if(avatar){ overlay.innerHTML = `<img src="${avatar}"/>`; overlay.classList.remove('hidden'); }
    coinConfetti(50);
    if(winners.some(w=>w.i===n-1) && accountId){
      try{
        await fbApi.depositAccount(accountId, payout, {game:'tetrisroyale-win'});
        if(tgId) await fbApi.addTransaction(tgId, 0, 'win', {game:'tetrisroyale', players:n, accountId});
      }catch{}
    }
    await awardDevShare(gross);
    setTimeout(()=>{ overlay.classList.add('hidden'); if(!ui.results.open) ui.results.showModal(); },2000);
  }
  function countdownAndStart(){
    const cd = $('#countdown');
    let c = 3; cd.textContent = c; cd.classList.remove('hidden');
    const timer = setInterval(()=>{
      c--;
      if(c>0){ cd.textContent = c; }
      else { clearInterval(timer); cd.classList.add('hidden'); startMatch(); }
    },1000);
  }

  ui.rematch.addEventListener('click', ()=>{ ui.results.close(); countdownAndStart(); });
  ui.lobby.addEventListener('click', ()=>{ ui.results.close(); location.href='/games/tetrisroyale/lobby'; });
  window.addEventListener('resize', layoutCanvases);
  await initUserName();
  layoutCanvases();
  countdownAndStart();
})();
}
</script>
</body>
</html>
