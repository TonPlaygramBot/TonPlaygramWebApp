<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Pool Royale Demo</title>
    <script type="importmap">
      {
        "imports": {
          "three": "https://unpkg.com/three@0.155.0/build/three.module.js",
          "three/addons/": "https://unpkg.com/three@0.155.0/examples/jsm/"
        }
      }
    </script>
    <style>
      :root {
        --pocket-r: 54;
        --net-depth: 56;
      }
      body {
        margin: 0;
        background: #0c1020;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        min-height: 100vh;
        gap: 26px;
        padding: 24px 12px;
      }
      .jaw-preview {
        position: relative;
        width: min(92vw, 720px);
        aspect-ratio: 3 / 4;
        border-radius: 18px;
        overflow: hidden;
        box-shadow: 0 28px 70px rgba(0, 0, 0, 0.42);
        background: #151515;
      }
      .jaw-preview canvas {
        width: 100%;
        height: 100%;
        display: block;
      }
      .jaw-preview .view-label {
        position: absolute;
        left: 18px;
        padding: 6px 12px;
        border-radius: 999px;
        font-size: 14px;
        font-family: "Segoe UI", system-ui, sans-serif;
        letter-spacing: 0.04em;
        background: rgba(15, 18, 24, 0.78);
        color: rgba(255, 255, 255, 0.85);
        text-transform: uppercase;
        backdrop-filter: blur(4px);
      }
      .jaw-preview .view-label.top {
        top: 16px;
      }
      .jaw-preview .view-label.angled {
        bottom: 18px;
      }
      .stage {
        position: relative;
        max-width: min(92vw, 760px);
        box-shadow: 0 20px 60px rgba(0,0,0,0.35);
        border-radius: 12px;
        overflow: hidden;
      }
      .bg {
        display: block;
        width: 100%;
        height: auto;
        filter: brightness(110%);
      }
      svg.overlay {
        position: absolute;
        inset: 0;
        width: 100%;
        height: 100%;
        pointer-events: none;
      }
      .aim-line {
        position: absolute;
        top: 50%;
        left: 50%;
        width: 2px;
        height: 0;
        background: #fff;
        transform-origin: top center;
        transform: translate(-50%, -100%) rotate(0);
        pointer-events: none;
      }
      .ball {
        position: absolute;
        width: 40px;
        height: 40px;
        border-radius: 50%;
        background: #fff;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
      }
      .target-ball {
        background: #f33;
      }
      .spin-dot {
        position: absolute;
        width: 4px;
        height: 4px;
        border-radius: 50%;
        background: #f00;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        pointer-events: none;
      }
      #spin-controller {
        position: absolute;
        bottom: 10px;
        right: 10px;
        width: 60px;
        height: 60px;
        border-radius: 50%;
        background: rgba(255,255,255,0.25);
        cursor: crosshair;
      }
      #spin-controller .spin-dot {
        pointer-events: none;
      }
      #controls {
        position: absolute;
        bottom: 10px;
        left: 10px;
        color: #fff;
        font-family: sans-serif;
        background: rgba(0,0,0,0.3);
        padding: 6px;
        border-radius: 8px;
      }
      #controls input[type="range"] {
        width: 120px;
      }

      .config-btn {
        position: fixed;
        bottom: 10px;
        right: 10px;
        width: 40px;
        height: 40px;
        border: none;
        border-radius: 50%;
        background: rgba(255,255,255,0.3);
        cursor: pointer;
      }

      .config-panel {
        position: fixed;
        bottom: 60px;
        right: 10px;
        background: rgba(0,0,0,0.8);
        color: #fff;
        padding: 10px;
        border-radius: 8px;
        font-family: sans-serif;
        width: 200px;
      }

      .config-panel label {
        display: block;
        margin-bottom: 8px;
        font-size: 14px;
      }

      .hidden {
        display: none;
      }

      .debug-marker {
        visibility: hidden;
      }
    </style>
  </head>
  <body>
    <div class="jaw-preview">
      <canvas id="jaw-canvas" aria-label="3D pocket jaw visualization"></canvas>
      <span class="view-label top">Top-Down</span>
      <span class="view-label angled">Angled Perspective</span>
    </div>
    <div class="stage">
      <img
        class="bg"
        src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxMDAwIDE1MDAiPjxyZWN0IHdpZHRoPSIxMDAlIiBoZWlnaHQ9IjEwMCUiIGZpbGw9IiMwMDgwMDAiLz48L3N2Zz4="
        alt="Pool table"
      />
      <svg id="frame" class="overlay debug-marker" viewBox="0 0 1000 1500"></svg>
      <div id="aim-line" class="aim-line debug-marker"></div>
      <div id="cue-ball" class="ball">
        <div id="cue-spin-dot" class="spin-dot debug-marker"></div>
      </div>
      <div id="target-ball" class="ball target-ball debug-marker"></div>
      <div id="controls">
        <input id="power" type="range" min="0" max="100" value="40" />
        <button id="shoot">Shoot</button>
      </div>
      <div id="spin-controller">
        <div id="spin-controller-dot" class="spin-dot debug-marker"></div>
      </div>
    </div>
    <button id="config-btn" class="config-btn">⚙️</button>
    <div id="config-panel" class="config-panel hidden">
      <label>Ball Volume:
        <input id="volume" type="range" min="0" max="100" value="50" />
        <span id="volume-value">50%</span>
      </label>
      <label>Brightness:
        <input id="brightness" type="range" min="50" max="150" value="110" />
        <span id="brightness-value">110%</span>
      </label>
      <label>Frame Style:
        <select id="frame-select">
          <option value="classic">Classic</option>
          <option value="minimal">Minimal</option>
          <option value="neon">Neon</option>
          <option value="retro">Retro</option>
        </select>
      </label>
      <label>Frame Color:
        <input id="frame-color" type="color" value="#ff0000" />
      </label>
      <label>Card Color:
        <input id="card-color" type="color" value="#000000" />
      </label>
    </div>
    <script>
      const stage = document.querySelector('.stage');
      const aimLine = document.getElementById('aim-line');
      const cueBall = document.getElementById('cue-ball');
      const targetBall = document.getElementById('target-ball');
      const powerInput = document.getElementById('power');
      const shootBtn = document.getElementById('shoot');
      const spinController = document.getElementById('spin-controller');
      const spinControllerDot = document.getElementById('spin-controller-dot');
      const cueSpinDot = document.getElementById('cue-spin-dot');
      const configBtn = document.getElementById('config-btn');
      const configPanel = document.getElementById('config-panel');
      const volumeSlider = document.getElementById('volume');
      const volumeValue = document.getElementById('volume-value');
      const brightnessSlider = document.getElementById('brightness');
      const brightnessValue = document.getElementById('brightness-value');
      const bgImage = document.querySelector('.bg');
      const frameSelect = document.getElementById('frame-select');
      const frameColorInput = document.getElementById('frame-color');
      const cardColorInput = document.getElementById('card-color');
      const controls = document.getElementById('controls');
      const frameSvg = document.getElementById('frame');

      let ballVolume = volumeSlider.value / 100;
      bgImage.style.filter = `brightness(${brightnessSlider.value}%)`;

      brightnessValue.textContent = `${brightnessSlider.value}%`;
      brightnessSlider.addEventListener('input', () => {
        const val = brightnessSlider.value;
        brightnessValue.textContent = `${val}%`;
        bgImage.style.filter = `brightness(${val}%)`;
      });

      function renderFrame() {
        const color = frameColorInput.value;
        const style = frameSelect.value;
        const templates = {
          classic: `
        <rect x="80" y="80" width="840" height="1340" fill="rgba(0,255,0,0.15)" stroke="${color}" stroke-width="20" />
        <rect x="20" y="20" width="960" height="1460" fill="none" stroke="${color}" stroke-width="40" />`,
          minimal: `
        <rect x="40" y="40" width="920" height="1420" fill="none" stroke="${color}" stroke-width="20" />`,
          neon: `
        <rect x="60" y="60" width="880" height="1380" fill="none" stroke="${color}" stroke-width="25" stroke-dasharray="10 5" />`,
          retro: `
        <rect x="30" y="30" width="940" height="1440" fill="none" stroke="${color}" stroke-width="30" />`
        };
        frameSvg.innerHTML = templates[style];
      }

      renderFrame();

      configBtn.addEventListener('click', () => {
        configPanel.classList.toggle('hidden');
      });

      volumeSlider.addEventListener('input', () => {
        ballVolume = volumeSlider.value / 100;
        volumeValue.textContent = `${volumeSlider.value}%`;
      });

      frameSelect.addEventListener('change', renderFrame);
      frameColorInput.addEventListener('input', renderFrame);
      cardColorInput.addEventListener('input', () => {
        controls.style.background = cardColorInput.value;
      });

      let shotDir = { x: 0, y: -1 };
      let shotLength = 0;
      let spin = { x: 0, y: 0 };

      const rect = stage.getBoundingClientRect();
      const center = { x: rect.width / 2, y: rect.height / 2 };

      cueBall.style.left = `${center.x}px`;
      cueBall.style.top = `${center.y}px`;
      targetBall.style.left = `${center.x}px`;
      targetBall.style.top = `${center.y}px`;

      stage.addEventListener('click', (e) => {
        const r = stage.getBoundingClientRect();
        const cx = r.left + r.width / 2;
        const cy = r.top + r.height / 2;
        const dx = e.clientX - cx;
        const dy = e.clientY - cy;
        const angle = (Math.atan2(dy, dx) * 180) / Math.PI + 90;
        const length = Math.hypot(dx, dy);
        shotDir = { x: dx / length, y: dy / length };
        shotLength = length;
        aimLine.style.height = `${length}px`;
        aimLine.style.transform = `translate(-50%,-100%) rotate(${angle}deg)`;

        const tbx = center.x + shotDir.x * 200;
        const tby = center.y + shotDir.y * 200;
        targetBall.style.left = `${tbx}px`;
        targetBall.style.top = `${tby}px`;
      });

      function updateSpinDots (sx, sy) {
        const max = 40; // percentage offset inside parent
        const pos = (val) => `${50 + val * max}%`;
        spinControllerDot.style.left = pos(sx);
        spinControllerDot.style.top = pos(sy);
        cueSpinDot.style.left = pos(sx);
        // move the cue ball's spin indicator to mirror controller input
        cueSpinDot.style.top = pos(sy);
      }

      // update spin both on click and while dragging for better precision
      let spinning = false;
      function setSpin (e) {
        if (e.type === 'pointermove' && !spinning) return;
        const r = spinController.getBoundingClientRect();
        const cx = r.width / 2;
        const cy = r.height / 2;
        const dx = e.clientX - r.left - cx;
        const dy = e.clientY - r.top - cy;
        const nx = Math.max(Math.min(dx / cx, 1), -1);
        const ny = Math.max(Math.min(dy / cy, 1), -1);
        // invert the vertical component so positive y is top spin
        spin = { x: nx, y: -ny };
        updateSpinDots(nx, ny);
      }
      spinController.addEventListener('pointerdown', (e) => {
        spinning = true;
        spinController.setPointerCapture(e.pointerId);
        setSpin(e);
      });
      spinController.addEventListener('pointermove', setSpin);
      spinController.addEventListener('pointerup', (e) => {
        spinning = false;
        spinController.releasePointerCapture(e.pointerId);
      });

      function playHit(power) {
        const ctx = new (window.AudioContext || window.webkitAudioContext)();
        const osc = ctx.createOscillator();
        const gain = ctx.createGain();
        osc.frequency.value = 400;
        const volume = ballVolume * (power > 0.4 ? 0.3 : 0.8);
        gain.gain.value = volume;
        osc.connect(gain).connect(ctx.destination);
        osc.start();
        osc.stop(ctx.currentTime + 0.1);
      }

      function shoot() {
        const power = Number(powerInput.value) / 100;
        playHit(power);
        const speed = 4 + power * 9;
        let cuePos = { x: center.x, y: center.y };
        let cueVel = { x: shotDir.x * speed, y: shotDir.y * speed };
        let targetPos = {
          x: parseFloat(targetBall.style.left),
          y: parseFloat(targetBall.style.top)
        };
        let targetVel = { x: 0, y: 0 };
        let collided = false;
        let targetTravel = 0;

        function frame() {
          if (!collided) {
            cuePos.x += cueVel.x;
            cuePos.y += cueVel.y;
            cueBall.style.left = `${cuePos.x}px`;
            cueBall.style.top = `${cuePos.y}px`;
            const dx = cuePos.x - targetPos.x;
            const dy = cuePos.y - targetPos.y;
            if (Math.hypot(dx, dy) <= 40) {
              collided = true;
              // apply spin to cue ball after collision
              const forward = spin.y; // top spin is positive
              const side = spin.x;
              const spinScale = speed; // stronger influence for clearer draw/follow
              cueVel = {
                x: shotDir.x * forward * spinScale + -shotDir.y * side * spinScale,
                y: shotDir.y * forward * spinScale + shotDir.x * side * spinScale
              };
              targetVel = { x: shotDir.x * speed, y: shotDir.y * speed };
            }
          } else {
            cuePos.x += cueVel.x;
            cuePos.y += cueVel.y;
            cueVel.x *= 0.96;
            cueVel.y *= 0.96;
            cueBall.style.left = `${cuePos.x}px`;
            cueBall.style.top = `${cuePos.y}px`;
            if (targetTravel < 200) {
              targetPos.x += targetVel.x;
              targetPos.y += targetVel.y;
              targetBall.style.left = `${targetPos.x}px`;
              targetBall.style.top = `${targetPos.y}px`;
              targetTravel += speed;
            } else if (Math.hypot(cueVel.x, cueVel.y) < 0.1) {
              return;
            }
          }
          requestAnimationFrame(frame);
        }
        requestAnimationFrame(frame);
      }

      shootBtn.addEventListener('click', shoot);

      function setDebugVisible (visible) {
        document.querySelectorAll('.debug-marker').forEach((el) => {
          el.style.visibility = visible ? 'visible' : 'hidden';
        });
      }
      window.showDebugMarkers = () => setDebugVisible(true);
      window.hideDebugMarkers = () => setDebugVisible(false);
      setDebugVisible(true);
    </script>
    <script type="module">
      import * as THREE from 'three';
      import { RoomEnvironment } from 'three/addons/environments/RoomEnvironment.js';

      const preview = document.querySelector('.jaw-preview');
      const canvas = document.getElementById('jaw-canvas');
      if (preview && canvas) {
        const renderer = new THREE.WebGLRenderer({
          canvas,
          antialias: true,
          alpha: false
        });
        renderer.outputColorSpace = THREE.SRGBColorSpace;
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.setClearColor(0x161616, 1);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        renderer.autoClear = false;

        const scene = new THREE.Scene();
        scene.background = null;

        const pmrem = new THREE.PMREMGenerator(renderer);
        const envTarget = pmrem.fromScene(new RoomEnvironment(), 0.04);
        scene.environment = envTarget.texture;

        const root = new THREE.Group();
        scene.add(root);

        const clothLevel = 0.0;
        const jawHeight = 0.11;
        const pocketRadius = 0.095;
        const jawDepth = 0.26;
        const jawWidth = 0.13;
        const seamCoord = pocketRadius * (1 - Math.SQRT1_2);
        const seamGap = 0.006;

        const feltMaterial = new THREE.MeshPhysicalMaterial({
          color: 0x0c5a2e,
          roughness: 0.62,
          metalness: 0.03,
          sheen: 0.85,
          sheenRoughness: 0.55,
          clearcoat: 0.08,
          clearcoatRoughness: 0.9
        });

        const cushionMaterial = new THREE.MeshPhysicalMaterial({
          color: 0x1f3e2d,
          roughness: 0.32,
          metalness: 0.08,
          sheen: 0.35,
          sheenColor: new THREE.Color(0x2f5a3a),
          sheenRoughness: 0.65,
          clearcoat: 0.25,
          clearcoatRoughness: 0.45
        });

        const railMaterial = new THREE.MeshPhysicalMaterial({
          color: 0x3a2819,
          roughness: 0.65,
          metalness: 0.05
        });

        const linerMaterial = new THREE.MeshPhysicalMaterial({
          color: 0x1b1b1b,
          roughness: 0.35,
          metalness: 0.3,
          clearcoat: 0.2,
          clearcoatRoughness: 0.4
        });

        const shadowMaterial = new THREE.MeshStandardMaterial({
          color: 0x000000,
          transparent: true,
          opacity: 0.3
        });

        function buildJawGeometry() {
          const shape = new THREE.Shape();
          shape.moveTo(seamCoord, seamCoord);
          shape.absarc(
            pocketRadius,
            pocketRadius,
            pocketRadius,
            Math.PI * 1.25,
            Math.PI * 1.5,
            false
          );
          shape.lineTo(pocketRadius + jawDepth, 0);
          shape.quadraticCurveTo(
            pocketRadius + jawDepth * 0.94,
            -jawWidth * 0.22,
            pocketRadius + jawDepth * 0.84,
            -jawWidth * 0.55
          );
          shape.quadraticCurveTo(
            pocketRadius + jawDepth * 0.52,
            -jawWidth * 1.02,
            seamCoord + jawWidth * 0.34,
            -jawWidth * 1.08
          );
          shape.lineTo(seamCoord - 0.01, -jawWidth * 0.92);
          shape.quadraticCurveTo(
            seamCoord * 0.35,
            -jawWidth * 0.54,
            seamCoord,
            seamCoord
          );

          const geometry = new THREE.ExtrudeGeometry(shape, {
            depth: jawHeight,
            bevelEnabled: true,
            bevelSegments: 4,
            bevelSize: 0.01,
            bevelThickness: 0.012,
            curveSegments: 28,
            steps: 1
          });
          geometry.rotateX(-Math.PI / 2);
          geometry.translate(0, clothLevel, 0);
          return geometry.toNonIndexed();
        }

        const jawGeometryX = buildJawGeometry();
        const jawGeometryZ = jawGeometryX.clone();
        jawGeometryZ.applyMatrix4(
          new THREE.Matrix4().set(
            0, 0, 1, 0,
            0, 1, 0, 0,
            1, 0, 0, 0,
            0, 0, 0, 1
          )
        );
        jawGeometryZ.computeVertexNormals();

        function createJawMeshes() {
          const group = new THREE.Group();

          const jawX = new THREE.Mesh(jawGeometryX, cushionMaterial);
          jawX.castShadow = true;
          jawX.receiveShadow = true;
          jawX.position.set(0, clothLevel, -seamGap * 0.5);

          const jawZ = new THREE.Mesh(jawGeometryZ, cushionMaterial);
          jawZ.castShadow = true;
          jawZ.receiveShadow = true;
          jawZ.position.set(seamGap * 0.5, clothLevel, 0);

          group.add(jawX, jawZ);
          return group;
        }

        const pocketGroup = createJawMeshes();
        root.add(pocketGroup);

        const felt = new THREE.Mesh(
          new THREE.PlaneGeometry(0.82, 0.82, 1, 1),
          feltMaterial
        );
        felt.rotation.x = -Math.PI / 2;
        felt.position.set(0.41, clothLevel - 0.0005, 0.41);
        felt.receiveShadow = true;
        felt.castShadow = false;
        root.add(felt);

        const rail = new THREE.Mesh(
          new THREE.BoxGeometry(0.9, 0.07, 0.2, 1, 1, 1),
          railMaterial
        );
        rail.position.set(0.45, clothLevel + 0.035, -0.1);
        rail.castShadow = true;
        rail.receiveShadow = true;
        root.add(rail);

        const railSide = new THREE.Mesh(
          new THREE.BoxGeometry(0.2, 0.07, 0.9, 1, 1, 1),
          railMaterial
        );
        railSide.position.set(-0.1, clothLevel + 0.035, 0.45);
        railSide.castShadow = true;
        railSide.receiveShadow = true;
        root.add(railSide);

        const basePedestal = new THREE.Mesh(
          new THREE.BoxGeometry(0.96, 0.08, 0.96, 1, 1, 1),
          new THREE.MeshPhysicalMaterial({ color: 0x0e0f12, roughness: 0.9 })
        );
        basePedestal.position.set(0.48, clothLevel - 0.09, 0.48);
        basePedestal.receiveShadow = true;
        basePedestal.castShadow = false;
        root.add(basePedestal);

        const pocketLiner = new THREE.Mesh(
          new THREE.CylinderGeometry(pocketRadius + 0.014, pocketRadius + 0.02, 0.08, 32, 1, true),
          linerMaterial
        );
        pocketLiner.rotation.x = Math.PI / 2;
        pocketLiner.position.set(0.001, clothLevel - 0.001, 0.001);
        pocketLiner.castShadow = true;
        pocketLiner.receiveShadow = true;
        root.add(pocketLiner);

        const pocketDrop = new THREE.Mesh(
          new THREE.CylinderGeometry(pocketRadius * 0.62, pocketRadius * 0.8, 0.28, 24, 1, true),
          new THREE.MeshPhysicalMaterial({
            color: 0x0a0a0a,
            roughness: 0.55,
            metalness: 0.2
          })
        );
        pocketDrop.rotation.x = Math.PI / 2;
        pocketDrop.position.set(0.001, clothLevel - 0.14, 0.001);
        pocketDrop.castShadow = true;
        pocketDrop.receiveShadow = true;
        root.add(pocketDrop);

        const shadowPlane = new THREE.Mesh(
          new THREE.PlaneGeometry(1.6, 1.6, 1, 1),
          shadowMaterial
        );
        shadowPlane.rotation.x = -Math.PI / 2;
        shadowPlane.position.y = clothLevel - 0.16;
        shadowPlane.receiveShadow = false;
        root.add(shadowPlane);

        const hemi = new THREE.HemisphereLight(0xdce9ff, 0x0b0d13, 0.55);
        hemi.position.set(0, 1, 0);
        scene.add(hemi);

        const keyLight = new THREE.DirectionalLight(0xffffff, 1.25);
        keyLight.position.set(0.9, 1.6, 0.7);
        keyLight.castShadow = true;
        keyLight.shadow.mapSize.set(1024, 1024);
        keyLight.shadow.camera.near = 0.2;
        keyLight.shadow.camera.far = 4;
        keyLight.shadow.camera.left = -0.8;
        keyLight.shadow.camera.right = 0.8;
        keyLight.shadow.camera.top = 0.8;
        keyLight.shadow.camera.bottom = -0.8;
        scene.add(keyLight);

        const fill = new THREE.DirectionalLight(0xe5f3ff, 0.35);
        fill.position.set(-0.6, 1.2, -0.4);
        scene.add(fill);

        const rim = new THREE.SpotLight(0xfff2cf, 0.32, 4.5, Math.PI * 0.35, 0.45, 1.2);
        rim.position.set(0.3, 0.95, -0.9);
        rim.target.position.set(0.2, clothLevel + 0.02, 0.2);
        rim.castShadow = false;
        scene.add(rim, rim.target);

        const cameraTop = new THREE.OrthographicCamera(-0.45, 0.45, 0.45, -0.45, 0.01, 4);
        cameraTop.position.set(0.32, 2.5, 0.32);
        cameraTop.lookAt(new THREE.Vector3(0.32, clothLevel + 0.02, 0.32));
        cameraTop.up.set(0, 0, -1);

        const cameraAngled = new THREE.PerspectiveCamera(42, 1, 0.05, 8);
        cameraAngled.position.set(0.88, 0.62, 0.88);
        cameraAngled.lookAt(new THREE.Vector3(0.28, clothLevel + 0.05, 0.28));

        renderer.setScissorTest(true);

        function resize() {
          const width = preview.clientWidth;
          const height = preview.clientHeight;
          if (width === 0 || height === 0) return;
          renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
          renderer.setSize(width, height, false);

          const viewportHeight = height * 0.5;
          const aspect = width / viewportHeight;
          cameraAngled.aspect = aspect;
          cameraAngled.updateProjectionMatrix();

          const orthoHeight = 0.38;
          const orthoWidth = orthoHeight * aspect;
          cameraTop.left = -orthoWidth;
          cameraTop.right = orthoWidth;
          cameraTop.top = orthoHeight;
          cameraTop.bottom = -orthoHeight;
          cameraTop.updateProjectionMatrix();
        }

        window.addEventListener('resize', resize);
        resize();

        const focus = new THREE.Vector3(0.28, clothLevel + 0.045, 0.28);
        const clock = new THREE.Clock();

        function renderLoop() {
          requestAnimationFrame(renderLoop);
          const t = clock.getElapsedTime();
          const radius = 0.88;
          const oscillate = Math.sin(t * 0.45) * 0.08;
          cameraAngled.position.x = focus.x + Math.cos(t * 0.35) * radius;
          cameraAngled.position.z = focus.z + Math.sin(t * 0.35) * (radius * 0.78);
          cameraAngled.position.y = 0.55 + Math.sin(t * 0.52) * 0.06;
          cameraAngled.lookAt(focus.x + oscillate * 0.25, focus.y, focus.z);

          const renderCanvas = renderer.domElement;
          const width = renderCanvas.width;
          const height = renderCanvas.height;
          const halfHeight = height / 2;

          renderer.clear();

          renderer.setViewport(0, halfHeight, width, halfHeight);
          renderer.setScissor(0, halfHeight, width, halfHeight);
          renderer.render(scene, cameraTop);

          renderer.setViewport(0, 0, width, halfHeight);
          renderer.setScissor(0, 0, width, halfHeight);
          renderer.render(scene, cameraAngled);
        }

        renderLoop();

        window.addEventListener('beforeunload', () => {
          pmrem.dispose();
          envTarget.dispose();
          renderer.dispose();
        });
      }
    </script>
    <script type="module" src="./royale-physics.js"></script>
  </body>
</html>
