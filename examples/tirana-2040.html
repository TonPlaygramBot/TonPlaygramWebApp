<!doctype html>
<html lang="sq">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
  <title>Urban Ops ‚Ä¢ Battle Royale (Mobile+ AI v9 ‚Ä¢ WebGL Safe ‚Ä¢ Texture‚Äëproof ‚Ä¢ Rails+Zebra ‚Ä¢ Fire‚ÄëEscapes ‚Ä¢ Armory Slider)</title>
  <style>
    html,body{margin:0;height:100%;background:#f3e3c7;overflow:hidden;font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif}
    body,.hud{touch-action:none}
    #wrap{position:fixed;inset:0}
    canvas{width:100%;height:100%;display:block;touch-action:none;user-select:none}
    .hud{position:fixed;inset:0;pointer-events:none}
    .row{position:absolute;left:10px;right:10px;display:flex;gap:8px;align-items:center}
    .top{top:8px;justify-content:space-between}
    .bottom{bottom:10px;justify-content:space-between}
    .chip{background:rgba(0,0,0,.35);color:#fff;border-radius:999px;padding:6px 10px;font-size:12px;backdrop-filter:blur(4px);pointer-events:auto}
    .btn{background:rgba(0,0,0,.35);color:#fff;border:0;border-radius:14px;padding:10px 14px;font-size:14px;cursor:pointer;pointer-events:auto}
    .btn:active{transform:translateY(1px)}
    .btn[disabled]{opacity:.45;cursor:not-allowed}

    #armory{z-index:60}
    .joy{position:absolute;width:200px;height:200px;border-radius:50%;background:rgba(0,0,0,.08);border:1px solid rgba(0,0,0,.25);opacity:.96;pointer-events:auto;touch-action:none;display:block;z-index:30}
    .knob{position:absolute;left:50%;top:50%;width:110px;height:110px;transform:translate(-50%,-50%);border-radius:50%;background:rgba(0,0,0,.25);border:1px solid rgba(0,0,0,.35)}
    #joyMove{left:18px;bottom:170px}
    #shootPad{right:18px;bottom:170px}
    #aimPad{right:18px;bottom:170px;display:none}
    #shootPad .knob{background:radial-gradient(circle at 50% 50%, rgba(255,70,70,1) 0 30%, rgba(0,0,0,.28) 31%), rgba(0,0,0,.25);}  
    #shootPad .knob::after{content:'SHOOT';position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);color:#fff;font-weight:900;font-size:18px;letter-spacing:.6px;text-shadow:0 1px 2px rgba(0,0,0,.65);}  

    #reloadMini{position:absolute;left:50%;top:-190px;transform:translateX(-50%);width:160px;height:160px;display:flex;align-items:center;justify-content:center;border-radius:50%;border:1px solid rgba(0,0,0,.35);background:radial-gradient(circle at 50% 50%, rgba(255,70,70,1) 0 30%, rgba(0,0,0,.28) 31%), rgba(0,0,0,.25);color:#fff;font-size:18px;font-weight:900;letter-spacing:.6px;pointer-events:auto;box-shadow:0 6px 16px rgba(0,0,0,.35)}

    #crosshair{position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);width:var(--crossSize,30px);height:var(--crossSize,30px);pointer-events:none;z-index:50;display:block}
    #crosshair:before,#crosshair:after{content:"";position:absolute;left:50%;top:50%;background:var(--aimColor,#ff3c3c);box-shadow:0 0 0 2px rgba(255,255,255,0.9) inset, 0 0 6px rgba(0,0,0,.35)}
    #crosshair:before{width:24px;height:3px;transform:translate(-50%,-50%);opacity:.98}
    #crosshair:after{width:3px;height:24px;transform:translate(-50%,-50%);opacity:.98}

    #ammo{position:absolute;right:10px;top:40px;color:#fff;font-weight:600;background:rgba(0,0,0,.35);padding:8px 12px;border-radius:10px;pointer-events:auto}
    #healthbar{position:absolute;left:10px;top:46px;width:260px;height:16px;background:rgba(0,0,0,.2);border-radius:999px;overflow:hidden}
    #healthfill{width:100%;height:100%;background:linear-gradient(90deg,#29ff9a,#00c876)}

    #armory{position:absolute;left:10px;right:10px;bottom:86px;display:flex;gap:8px;overflow:auto;padding:8px;border-radius:14px;background:rgba(0,0,0,.25);backdrop-filter:blur(6px);pointer-events:auto;scroll-behavior:smooth}
    .armBtn{position:relative;flex:0 0 auto;min-width:138px;max-width:168px;padding:8px;border-radius:12px;border:1px solid rgba(255,255,255,.16);background:rgba(0,0,0,.35);color:#e6eefc;font-weight:700;cursor:pointer;display:flex;flex-direction:column;align-items:center;gap:6px}
    .armBtn img{width:124px;height:76px;object-fit:contain;display:block;filter:drop-shadow(0 1px 1px rgba(0,0,0,.3))}
    .armBtn span{font-size:12px;opacity:.95}
    .armBtn.active{outline:2px solid #ffd966;background:rgba(17,23,42,.55)}
    .modeToggle{position:absolute;right:6px;top:6px;padding:3px 6px;border-radius:10px;border:1px solid rgba(255,255,255,.25);background:rgba(0,0,0,.45);color:#fff;font-size:10px;cursor:pointer}

    #armLeft,#armRight{position:absolute;bottom:86px;z-index:12;border-radius:50%;width:44px;height:44px;display:flex;align-items:center;justify-content:center;font-weight:900;background:rgba(0,0,0,.5);border:1px solid rgba(255,255,255,.2)}
    #armLeft{left:12px}
    #armRight{right:12px}

    #mini{position:absolute;left:10px;bottom:56px;color:#0b1324;background:rgba(255,255,255,.6);padding:4px 8px;border-radius:8px;font-size:11px;pointer-events:auto}

    #br{position:absolute;left:50%;top:8px;transform:translateX(-50%);background:rgba(0,0,0,.35);color:#fff;padding:6px 10px;border-radius:999px;font-weight:700;pointer-events:auto}

    #modeBox{position:absolute;right:10px;top:46px;display:flex;gap:6px;pointer-events:auto}
    .modeBtn{padding:6px 10px;border-radius:999px;border:1px solid rgba(255,255,255,.25);background:rgba(0,0,0,.35);color:#fff;font-size:12px;cursor:pointer}
    .modeBtn.active{background:#2a7fff}

    #useCarBtn{position:absolute;left:50%;bottom:168px;transform:translateX(-50%);padding:10px 14px;border-radius:12px;border:1px solid rgba(255,255,255,.25);background:rgba(0,0,0,.6);color:#fff;pointer-events:auto;display:none}
    #exitCarBtn{position:absolute;right:12px;bottom:168px;padding:10px 14px;border-radius:12px;border:1px solid rgba(255,255,255,.25);background:rgba(0,0,0,.6);color:#fff;pointer-events:auto;display:none}
    #hornBtn{position:absolute;left:50%;bottom:118px;transform:translateX(-50%);padding:10px 14px;border-radius:12px;border:1px solid rgba(255,255,255,.25);background:rgba(0,0,0,.6);color:#fff;pointer-events:auto;display:none}
    #brakeBtn{position:absolute;left:calc(50% - 170px);bottom:118px;padding:10px 14px;border-radius:12px;border:1px solid rgba(255,255,255,.25);background:rgba(220,0,0,.75);color:#fff;pointer-events:auto;display:none}

    #climbBtn{position:absolute;left:50%;bottom:156px;transform:translateX(-50%);padding:8px 12px;border-radius:12px;border:1px solid rgba(255,255,255,.25);background:rgba(0,0,0,.7);color:#fff;font-size:14px;pointer-events:auto;display:none}

    #zoomBox{position:absolute;right:4px;bottom:540px;display:none;pointer-events:auto;z-index:25}
    #zoomSlider{appearance:none;width:360px;height:64px;transform:rotate(-90deg);background:rgba(0,0,0,.4);border-radius:999px;outline:none;border:1px solid rgba(255,255,255,.2)}
    #zoomSlider::-webkit-slider-thumb{appearance:none;width:50px;height:50px;border-radius:50%;background:#ffd966;border:1px solid rgba(0,0,0,.4)}
    #zoomSlider::-moz-range-thumb{width:50px;height:50%;border-radius:50%;background:#ffd966;border:1px solid rgba(0,0,0,.4)}

    #result{position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);padding:18px 22px;border-radius:14px;font-weight:900;color:#fff;background:rgba(0,0,0,.6);display:none}

    #settingsBtn{position:absolute;right:56px;top:8px;z-index:30}
    #muteBtn{z-index:30}
    #settings{position:absolute;right:10px;top:56px;width:320px;max-width:calc(100% - 20px);background:rgba(17,23,42,.9);border:1px solid rgba(255,255,255,.18);border-radius:14px;padding:12px 12px 10px;display:none;color:#fff;backdrop-filter:blur(6px);pointer-events:auto}
    #settings h3{margin:4px 0 10px 0;font-size:14px;opacity:.9}
    #settings label{display:flex;justify-content:space-between;align-items:center;font-size:12px;margin:6px 0}
    #settings input[type="range"]{width:160px}
    #settings .row2{display:grid;grid-template-columns:1fr 1fr;gap:8px;margin-top:8px}
    #settings .row2 button{width:100%}

    #hurt{position:absolute;inset:0;background:radial-gradient(closest-side at 50% 50%, rgba(255,0,0,0) 0%, rgba(255,0,0,0) 60%, rgba(255,0,0,0.35) 100%);opacity:0;pointer-events:none;transition:opacity .12s ease-out}

    #hit{position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);width:22px;height:22px;border:2px solid #fff;border-radius:4px;opacity:0;pointer-events:none}

    body.lefty #joyMove{left:auto;right:18px}
    body.lefty #shootPad{right:auto;left:18px}
    body.lefty #aimPad{right:auto;left:18px}
    body.lefty #ammo{left:10px;right:auto}
    body.lefty #modeBox{left:10px;right:auto}

    #diag{position:absolute;left:10px;top:86px;background:rgba(0,0,0,.35);color:#fff;border-radius:10px;padding:8px 10px;font-size:12px;pointer-events:auto;max-width:65ch}
  @media (max-height: 740px), (max-width: 480px){.joy{width:160px;height:160px}.knob{width:96px;height:96px}#joyMove{bottom:140px}#shootPad{bottom:140px}#aimPad{bottom:140px}#armory{bottom:64px}}
  /* Restore joystick to original placement */
#joyMove{right:18px; bottom:220px !important}
#shootPad{left:18px; bottom:220px !important}
#aimPad{left:18px; bottom:220px !important}
.joy{width:300px !important; height:300px !important; z-index:20 !important}
.knob{width:160px !important; height:160px !important}
/* Armory becomes a horizontal slider (touch drag only) */
#armory{z-index:60; overflow-x:auto !important; white-space:nowrap !important; display:flex !important; gap:10px !important; -webkit-overflow-scrolling:touch; scroll-snap-type:x mandatory; padding:8px}
.armBtn{scroll-snap-align:start; flex:0 0 auto}
#armory::-webkit-scrollbar{height:6px}
#armory::-webkit-scrollbar-thumb{background:rgba(255,255,255,.25); border-radius:999px}
/* Hide arrow buttons but keep in DOM (no deletion) */
#armLeft, #armRight{display:none !important;}
</style>
</head>
<body>
  <div id="wrap"></div>

  <div class="hud">
    <div class="row top">
      <div style="display:flex;gap:6px;align-items:center">
        <div class="chip" id="status">Urban Ops ‚Ä¢ Loading‚Ä¶</div>
        <div id="br" class="chip">BR: ON</div>
      </div>
      <div style="display:flex;gap:6px;align-items:center">
        <div id="modeBox">
          <button id="modeA" class="modeBtn active">A: Drag Aim</button>
          <button id="modeB" class="modeBtn">B: Dual Sticks</button>
        </div>
        <button id="settingsBtn" class="btn">‚öôÔ∏è</button>
        <button id="muteBtn" class="btn">üîä</button>
      </div>
    </div>

    <div id="healthbar"><div id="healthfill"></div></div>
    <div id="ammo">‚Äî</div>
    <div id="crosshair"></div>

    <div id="joyMove" class="joy"><div class="knob"></div></div>
    <div id="shootPad" class="joy"><div class="knob"></div><button id="reloadMini" class="btn">RELOAD</button></div>
    <div id="aimPad" class="joy"><div class="knob"></div></div>

    <div id="zoomBox"><input id="zoomSlider" type="range" min="1" max="3" step="0.01" value="1" /></div>

    <div id="armory"></div>
    <button id="armLeft" title="Slide Left">‚óÄ</button>
    <button id="armRight" title="Slide Right">‚ñ∂</button>

    <button id="useCarBtn">üöó Enter Car</button>
    <button id="exitCarBtn">‚¨Ö Exit Car</button>
    <button id="hornBtn">üì£ Horn</button>
    <button id="brakeBtn">üÖø Handbrake</button>
    <button id="climbBtn">‚¨Ü Climb Ladder</button>

    <div id="mini">fps: ‚Äî</div>
    <div id="result"></div>
    <div id="diag" class="chip">Diagnostics: ready.</div>

    <div id="settings">
      <h3>Settings</h3>
      <label>Left-handed layout <input id="setLefty" type="checkbox"></label>
      <label>Auto‚Äëfire <input id="setAutoFire" type="checkbox"></label>
      <label>Aim assist <input id="setAimAssist" type="checkbox"></label>
      <label>Invert Y <input id="setInvertY" type="checkbox"></label>
      <label>Gyro aim <input id="setGyro" type="checkbox"></label>
      <label>Shadows <input id="setShadows" type="checkbox"></label>
      <label>Sens A (drag) <input id="setSensA" type="range" min="0.06" max="0.3" step="0.005"></label>
      <label>Sens B X <input id="setSensBX" type="range" min="0.0006" max="0.003" step="0.0001"></label>
      <label>Sens B Y <input id="setSensBY" type="range" min="0.0006" max="0.003" step="0.0001"></label>
      <label>Resolution scale <input id="setDpr" type="range" min="0.6" max="1" step="0.02"></label>
      <label>Crosshair size <input id="setCross" type="range" min="16" max="52" step="1"></label>
      <div class="row2">
        <button id="setLow">Low</button>
        <button id="setHigh">High</button>
        <button id="setSave">Save</button>
        <button id="setClose">Close</button>
      </div>
    </div>

    <div id="hurt"></div>
    <div id="hit"></div>

    <div class="row bottom">
      <div class="chip">Move = WASD/Left stick ‚Ä¢ Aim = drag (A) or right stick (B) ‚Ä¢ Tap right=Shoot ‚Ä¢ Pinch=Zoom ‚Ä¢ Tap stairs=Rooftop</div>
      <button id="resetBtn" class="btn">Reset</button>
    </div>
  </div>

  <script type="module">
    import * as THREE from 'https://esm.sh/three@0.160.0';
    import * as CANNON from 'https://esm.sh/cannon-es@0.20.0';
    import { GLTFLoader } from 'https://esm.sh/three@0.160.0/examples/jsm/loaders/GLTFLoader.js';
    import { DRACOLoader } from 'https://esm.sh/three@0.160.0/examples/jsm/loaders/DRACOLoader.js';
    import { KTX2Loader } from 'https://esm.sh/three@0.160.0/examples/jsm/loaders/KTX2Loader.js';

    (async function main(){
      const $ = (id)=>document.getElementById(id);
      const wrap = $('wrap');
      const isTouch = ('ontouchstart' in window) || (navigator.maxTouchPoints>0);
      const isMobile = isTouch || /Android|webOS|iPhone|iPad|iPod|Opera Mini|IEMobile/i.test(navigator.userAgent);

      const store = {
        get(k, v){ try{ return JSON.parse(localStorage.getItem(k)) ?? v; }catch(_){ return v; } },
        set(k, v){ try{ localStorage.setItem(k, JSON.stringify(v)); }catch(_){} }
      };
      const settings = store.get('uo_settings', {
        lefty:false, autoFire:true, aimAssist:true, invertY:false, gyro:false,
        sensA:isMobile?0.14:0.12, sensBX:0.0014, sensBY:0.0012,
        dpr:isMobile?0.7:1.0, shadows:!isMobile
      });

      const TARGET_FPS = 90;
      const PHYS_HZ    = 90;
      const AIM_RATE_A   = 0.52;
      const AIM_SMOOTH_A = 3.8;
      let   LOOK_SENS_A  = settings.sensA;
      let   AIM_SENS_B_X = settings.sensBX;
      let   AIM_SENS_B_Y = settings.sensBY;

      function createRendererSafely(){
        const canvas=document.createElement('canvas');
        const baseOpts={ alpha:false, antialias:false, desynchronized:true, depth:true, stencil:false, preserveDrawingBuffer:false, failIfMajorPerformanceCaveat:false };
        let r=null; let ctx=null;
        try{ ctx = canvas.getContext('webgl2', { ...baseOpts, powerPreference:'low-power' }); }catch(_){ }
        if(!ctx){ try{ ctx = canvas.getContext('webgl', { ...baseOpts, powerPreference:'low-power' }) || canvas.getContext('experimental-webgl', { ...baseOpts, powerPreference:'low-power' }); }catch(_){} }
        if(ctx){ try{ r = new THREE.WebGLRenderer({ canvas, context:ctx, antialias:false, precision:'mediump' }); }catch(_){ }
        }
        if(!r){ try{ r = new THREE.WebGLRenderer({ antialias:false, precision:'mediump', powerPreference:'high-performance', alpha:false, preserveDrawingBuffer:false }); }catch(_){} }
        if(!r){ try{ r = new THREE.WebGLRenderer({ antialias:false, precision:'lowp', powerPreference:'default', alpha:false, preserveDrawingBuffer:false }); }catch(_){} }
        if(r){ if(r.domElement && r.domElement.parentNode!==wrap) wrap.appendChild(r.domElement); }
        return r;
      }

      function attachContextGuards(renderer){ if(!renderer||!renderer.domElement) return; const el=renderer.domElement; const overlay=document.createElement('div'); overlay.style.cssText='position:fixed;inset:0;display:none;place-items:center;background:#0b1324;color:#fff;font-weight:700;z-index:9999'; overlay.innerHTML='<div style="max-width:62ch;text-align:center;padding:20px;border:1px solid rgba(255,255,255,.25);border-radius:12px;background:rgba(255,255,255,.06)">WebGL u humb. Po provojm√´ rikthim‚Ä¶</div>'; document.body.appendChild(overlay);
        el.addEventListener('webglcontextlost',(e)=>{ e.preventDefault(); overlay.style.display='grid'; setTimeout(()=>location.reload(), 200); });
        el.addEventListener('webglcontextrestored',()=>{ overlay.style.display='none'; });
      }

      let renderer = createRendererSafely();
      if(!renderer){
        const box=document.createElement('div'); box.style.cssText='position:fixed;inset:0;display:grid;place-items:center;background:#0b1324;color:#fff;font-weight:700;';
        box.innerHTML='<div style="max-width:62ch;text-align:center;padding:20px;border:1px solid rgba(255,255,255,.25);border-radius:12px;background:rgba(255,255,255,.06)">WebGL nuk u krijua. Po provoj modalitet alternativ‚Ä¶</div>';
        document.body.appendChild(box);
        try{ renderer = new THREE.WebGLRenderer({ antialias:false, precision:'lowp', powerPreference:'high-performance', alpha:false, preserveDrawingBuffer:false }); if(renderer && renderer.domElement && renderer.domElement.parentNode!==wrap) wrap.appendChild(renderer.domElement); box.remove(); }catch(_){ /* still null */ }
      }
      if(!renderer){
        const box=document.createElement('div'); box.style.cssText='position:fixed;inset:0;display:grid;place-items:center;background:#0b1324;color:#fff;font-weight:700;'; box.innerHTML='<div style="max-width:62ch;text-align:center;padding:20px;border:1px solid rgba(255,255,255,.25);border-radius:12px;background:rgba(255,255,255,.06)">WebGL nuk u krijua. Provo "Settings ‚Üí Low" dhe rifresko.</div>';
        document.body.appendChild(box);
        return;
      }
      attachContextGuards(renderer);

      renderer.outputColorSpace = THREE.SRGBColorSpace;
      renderer.toneMapping = THREE.ACESFilmicToneMapping;
      renderer.toneMappingExposure = 1.85;
      let allowShadows = settings.shadows;
      renderer.shadowMap.enabled = allowShadows; renderer.shadowMap.type = THREE.PCFSoftShadowMap;
      renderer.debug?.checkShaderErrors && (renderer.debug.checkShaderErrors=false);
      THREE.Cache.enabled = true;

      let dprBase = Math.min(window.devicePixelRatio||1, isMobile ? 0.85 : 1.25);
      let dprScale = settings.dpr;
      const scene = new THREE.Scene(); scene.background = new THREE.Color('#f3e3c7'); scene.fog = new THREE.Fog('#ffe8c7', 700, 2600);
      const camera = new THREE.PerspectiveCamera(70, 9/16, 0.01, 8000); camera.position.set(0,1.7,5.6); scene.add(camera);
      function fit(){ const w=wrap.clientWidth||innerWidth, h=wrap.clientHeight||innerHeight; try{ renderer.setPixelRatio(Math.max(0.6, dprBase*dprScale)); renderer.setSize(w,h,false); camera.aspect=w/h; camera.updateProjectionMatrix(); }catch(_){ /* ignore */ } }
      addEventListener('resize', fit);
      fit();

      const hemi = new THREE.HemisphereLight(0xfff3d6, 0x8a7a6a, 0.55);
      const key  = new THREE.DirectionalLight(0xffd6a0, allowShadows?1.25:1.0); key.position.set(220, 350, 180); key.castShadow=allowShadows; if(allowShadows){ key.shadow.mapSize.set(isMobile?1024:2048,isMobile?1024:2048); key.shadow.camera.near=1; key.shadow.camera.far=3000; key.shadow.camera.left=-900; key.shadow.camera.right=900; key.shadow.camera.top=900; key.shadow.camera.bottom=-900; }
      const fill = new THREE.DirectionalLight(0xbfd6ff, 0.5); fill.position.set(-160,150,-260);
      const rim  = new THREE.DirectionalLight(0x88c2ff, 0.7); rim.position.set(0,200,-280);
      scene.add(hemi, key, fill, rim);

      const world = new CANNON.World({ gravity: new CANNON.Vec3(0,-9.81,0) });
      world.broadphase = new CANNON.SAPBroadphase(world); world.allowSleep = true;
      const matGround=new CANNON.Material('ground'), matPlayer=new CANNON.Material('player'), matEnemy=new CANNON.Material('enemy'), matCar=new CANNON.Material('car'), matBall=new CANNON.Material('bball');
      world.addContactMaterial(new CANNON.ContactMaterial(matGround, matPlayer, { friction:.2, restitution:0 }));
      world.addContactMaterial(new CANNON.ContactMaterial(matGround, matCar, { friction:.9, restitution:0 }));
      world.addContactMaterial(new CANNON.ContactMaterial(matGround, matBall, { friction:.45, restitution:0.86 }));
      const groundBody = new CANNON.Body({ mass:0, material:matGround, shape:new CANNON.Plane() });
      groundBody.quaternion.setFromEuler(-Math.PI/2,0,0); world.addBody(groundBody);

      function makeAsphalt(size=1024){ const c=document.createElement('canvas'); c.width=c.height=size; const x=c.getContext('2d'); x.fillStyle='#2c323a'; x.fillRect(0,0,size,size); for(let i=0;i<7000;i++){ const a=Math.random()*0.12; x.fillStyle=`rgba(255,255,255,${a})`; x.fillRect(Math.random()*size,Math.random()*size,1,1);} for(let i=0;i<300;i++){ x.strokeStyle='rgba(0,0,0,0.25)'; x.lineWidth=Math.random()*1.2; x.beginPath(); x.moveTo(Math.random()*size,Math.random()*size); x.lineTo(Math.random()*size,Math.random()*size); x.stroke(); } const t=new THREE.CanvasTexture(c); t.wrapS=t.wrapT=THREE.RepeatWrapping; t.repeat.set(24,24); t.anisotropy=4; t.colorSpace=THREE.SRGBColorSpace; return t; }
      function makeSidewalk(size=512){ const c=document.createElement('canvas'); c.width=c.height=size; const x=c.getContext('2d'); x.fillStyle='#c9ced6'; x.fillRect(0,0,size,size); x.strokeStyle='#9aa0a8'; x.lineWidth=6; for(let s=0;s<size;s+=64){ x.beginPath(); x.moveTo(s,0); x.lineTo(s,size); x.stroke(); x.beginPath(); x.moveTo(0,s); x.lineTo(size,s); x.stroke(); } const t=new THREE.CanvasTexture(c); t.wrapS=t.wrapT=THREE.RepeatWrapping; t.repeat.set(32,32); t.anisotropy=4; t.colorSpace=THREE.SRGBColorSpace; return t; }
      function facadeTex(hue=200){ const W=256,H=512; const c=document.createElement('canvas'); c.width=W; c.height=H; const ctx=c.getContext('2d'); ctx.fillStyle=`hsl(${hue},16%,74%)`; ctx.fillRect(0,0,W,H); for(let i=0;i<1800;i++){ const a=Math.random()*0.08; ctx.fillStyle=`rgba(0,0,0,${a})`; ctx.fillRect(Math.random()*W,Math.random()*H,1,1);} const cols=6+Math.floor(Math.random()*4), rows=14+Math.floor(Math.random()*6); const padX=12,padY=16; const cellW=(W-2*padX)/cols, cellH=(H-2*padY)/rows; for(let r=0;r<rows;r++){ for(let cix=0;cix<cols;cix++){ const x=padX+cix*cellW+6, y=padY+r*cellH+6, w=cellW-12, h=cellH-12; const g=ctx.createLinearGradient(0,y,0,y+h); g.addColorStop(0,'rgba(240,245,255,0.95)'); g.addColorStop(0.5,'rgba(150,180,220,0.92)'); g.addColorStop(1,'rgba(60,80,120,0.9)'); ctx.fillStyle=g; ctx.fillRect(x,y,w,h); ctx.strokeStyle='rgba(24,28,38,0.9)'; ctx.lineWidth=2; ctx.strokeRect(x,y,w,h); } } const tex=new THREE.CanvasTexture(c); tex.anisotropy=2; tex.colorSpace=THREE.SRGBColorSpace; return tex; }
      function grassProcedural(size=1024){ const c=document.createElement('canvas'); c.width=c.height=size; const x=c.getContext('2d'); x.fillStyle='#7fbf7f'; x.fillRect(0,0,size,size); for(let i=0;i<2600;i++){ x.fillStyle=`rgba(0,80,0,${Math.random()*0.12})`; x.fillRect(Math.random()*size,Math.random()*size,1,1);} const t=new THREE.CanvasTexture(c); t.wrapS=t.wrapT=THREE.RepeatWrapping; t.repeat.set(6,6); t.anisotropy=4; t.colorSpace=THREE.SRGBColorSpace; return t; }
      async function grassFromURL(){ return new Promise((resolve)=>{ const loader=new THREE.TextureLoader(); loader.load('https://threejs.org/examples/textures/terrain/grasslight-big.jpg', (tex)=>{ tex.wrapS=tex.wrapT=THREE.RepeatWrapping; tex.repeat.set(6,6); tex.anisotropy=4; tex.colorSpace=THREE.SRGBColorSpace; resolve(tex); }, ()=>resolve(grassProcedural()), ()=>resolve(grassProcedural())); }); }

      const asphaltTex = makeAsphalt(); const sidewalkTex = makeSidewalk(); const turfTex = await grassFromURL();

      const BLANK_PNG='data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR4nGNgYAAAAAMAASsJTYQAAAAASUVORK5CYII=';

      const assetManager = new THREE.LoadingManager();
      assetManager.onError = (url)=>console.warn('Asset load error:', url);
      assetManager.setURLModifier((url)=>{ if(!url) return url; if(url.startsWith('data:')||url.startsWith('blob:')) return url; if(/\.(png|jpe?g|webp|ktx2|dds|tga)(\?|#|$)/i.test(url)) return BLANK_PNG; return url; });
      const gltfLoaderAssets = new GLTFLoader(assetManager);
      const dracoAssets = new DRACOLoader(assetManager); dracoAssets.setDecoderPath('https://www.gstatic.com/draco/v1/decoders/'); gltfLoaderAssets.setDRACOLoader(dracoAssets); gltfLoaderAssets.setCrossOrigin('anonymous');
      try{ const ktx2A = new KTX2Loader(assetManager).setTranscoderPath('https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/libs/basis/').detectSupport(renderer); gltfLoaderAssets.setKTX2Loader(ktx2A); }catch(_){ /* ignore ktx2 issues */ }
      gltfLoaderAssets.register((parser)=>{ const c=document.createElement('canvas'); c.width=c.height=1; const ctx=c.getContext('2d'); ctx.fillStyle='#888'; ctx.fillRect(0,0,1,1); const blank=new THREE.CanvasTexture(c); blank.colorSpace=THREE.SRGBColorSpace; blank.needsUpdate=true; const orig = parser.getDependency.bind(parser); parser.getDependency = function(type,index){ if(type==='texture'){ return orig(type,index).catch(()=>blank); } return orig(type,index); }; return { name:'TextureFallbackIfMissing' }; });

      const managerGuns=new THREE.LoadingManager(); managerGuns.setURLModifier((url)=>{ if(url?.startsWith('data:')||url?.startsWith('blob:')) return url; if(/(\.(png|jpg|jpeg|webp|ktx2|dds|tga)(\?|#|$))/i.test(url)) return BLANK_PNG; return url; });
      const gltfLoaderGuns=new GLTFLoader(managerGuns); const dracoGuns=new DRACOLoader(managerGuns); dracoGuns.setDecoderPath('https://www.gstatic.com/draco/v1/decoders/'); gltfLoaderGuns.setDRACOLoader(dracoGuns); gltfLoaderGuns.setCrossOrigin('anonymous');
      try{ const ktx2G = new KTX2Loader(managerGuns).setTranscoderPath('https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/libs/basis/').detectSupport(renderer); gltfLoaderGuns.setKTX2Loader(ktx2G); }catch(_){ }
      gltfLoaderGuns.register((parser)=>{ const c=document.createElement('canvas'); c.width=c.height=1; const ctx=c.getContext('2d'); ctx.fillStyle='#888'; ctx.fillRect(0,0,1,1); const blank=new THREE.CanvasTexture(c); blank.colorSpace=THREE.SRGBColorSpace; blank.needsUpdate=true; const orig=parser.getDependency.bind(parser); parser.getDependency=function(type,index){ if(type==='texture') return Promise.resolve(blank); return orig(type,index); }; return {name:'NullTextures'}; });

      const URLS = {
        Sedan: [
          'https://assets.babylonjs.com/meshes/car.glb',
          'https://raw.githubusercontent.com/BabylonJS/Assets/master/meshes/car.glb'
        ],
        CarConcept: [
          'https://cdn.jsdelivr.net/gh/KhronosGroup/glTF-Sample-Assets@main/Models/CarConcept/glTF-Binary/CarConcept.glb',
          'https://raw.githubusercontent.com/KhronosGroup/glTF-Sample-Assets/main/Models/CarConcept/glTF-Binary/CarConcept.glb'
        ],
        MilkTruck: [
          'https://cdn.jsdelivr.net/gh/KhronosGroup/glTF-Sample-Models@master/2.0/CesiumMilkTruck/glTF-Binary/CesiumMilkTruck.glb',
          'https://raw.githubusercontent.com/KhronosGroup/glTF-Sample-Models/master/2.0/CesiumMilkTruck/glTF-Binary/CesiumMilkTruck.glb'
        ],
        FireTruck: [
          'https://raw.githubusercontent.com/Kenney-CCO/Kenney-CCO.glb/main/firetruck.glb',
          'https://cdn.jsdelivr.net/gh/Kenney-CCO/Kenney-CCO.glb@main/firetruck.glb',
          'https://raw.githubusercontent.com/MonuYadav05/Astrikos-gc-project/main/public/FireTruck.glb'
        ],
        Bus: [
          'https://raw.githubusercontent.com/jade0815/my-3d-bus-models/main/Bus.glb',
          'https://raw.githubusercontent.com/IHyeonii/PythonStudy/main/free_school_bus_-_low_poly.glb',
          'https://raw.githubusercontent.com/haelimk/project/8c50930d7f283f345c46a0dcdf2a984286c3b4c0/bus.glb'
        ],
        Motorcycle: [
          'https://raw.githubusercontent.com/shosuz-evangelist/3dObjects4Apps/main/Motorcycle.glb',
          'https://raw.githubusercontent.com/jade12855/3D_model/main/Motorcycle.glb'
        ],
        Soldier: [
          'https://cdn.jsdelivr.net/gh/KhronosGroup/glTF-Sample-Models@master/2.0/Soldier/glTF-Binary/Soldier.glb',
          'https://raw.githubusercontent.com/KhronosGroup/glTF-Sample-Models/master/2.0/Soldier/glTF-Binary/Soldier.glb'
        ]
      };

      async function loadGLB(urls){
        let lastErr=null;
        for(const u of urls){ try{ const gltf = await gltfLoaderAssets.loadAsync(u); return gltf; }catch(e){ lastErr=e; } }
        console.warn('All sources failed for', urls[0], lastErr);
        throw (lastErr||new Error('All sources failed'));
      }
      function centerXZ(root){ const box=new THREE.Box3().setFromObject(root); const c=new THREE.Vector3(); box.getCenter(c); root.position.x -= c.x; root.position.z -= c.z; }
      function placeOnGround(root,y=0){ const box=new THREE.Box3().setFromObject(root); const dy=y - box.min.y; root.position.y += dy; }
      function scaleToLen(root, L=3.8){ const box=new THREE.Box3().setFromObject(root); const s=new THREE.Vector3(); box.getSize(s); const cur=Math.max(s.x,s.z)||1; const k=L/cur; root.scale.multiplyScalar(k); root.updateMatrixWorld(true); }

      const depot = { refs:{}, ready:false };
      const REF_LEN = 3.9;
      async function buildDepot(){
        const def = [
          ['sedan','Sedan'], ['concept','CarConcept'], ['milk','MilkTruck'], ['bus','Bus'], ['fire','FireTruck'], ['moto','Motorcycle']
        ];
        for(const [k,keyName] of def){
          try{ const gltf=await loadGLB(URLS[keyName]); const base=(gltf.scene||gltf.scenes?.[0]); base.traverse(o=>{ if(o.isMesh){ o.castShadow=allowShadows; o.receiveShadow=allowShadows; o.material && (o.material.needsUpdate = true); } }); centerXZ(base); scaleToLen(base, keyName==='bus'? 8.5 : keyName==='moto'? 2.0 : REF_LEN); placeOnGround(base,0); depot.refs[k]=base; }catch(e){ console.warn('Vehicle failed', keyName, e); }
        }
        depot.ready=true; $('status').textContent = 'Urban Ops ‚Ä¢ Ready';
      }
      buildDepot();

      const city = new THREE.Group(); scene.add(city);
      const BLOCKS_X=6, BLOCKS_Z=6; const CELL=120; const ROAD=22; const SIDE=8; const PLOT=CELL-ROAD*2; const startX = -(BLOCKS_X*CELL)/2 + CELL/2; const startZ = -(BLOCKS_Z*CELL)/2 + CELL/2;

      const groundGeo = new THREE.PlaneGeometry((CELL)*BLOCKS_X + ROAD*2, (CELL)*BLOCKS_Z + ROAD*2);
      const groundMat = new THREE.MeshLambertMaterial({ color: 0xf0e4cf });
      const gnd = new THREE.Mesh(groundGeo, groundMat); gnd.rotation.x=-Math.PI/2; gnd.receiveShadow=allowShadows; city.add(gnd);

      const roadMat = new THREE.MeshLambertMaterial({ map: asphaltTex });
      const sidewalkMat = new THREE.MeshLambertMaterial({ map: sidewalkTex });
      const xRoads=[], zRoads=[]; const sidewalks=new THREE.Group(); city.add(sidewalks);
      for(let ix=0; ix<=BLOCKS_X; ix++){ const geo=new THREE.PlaneGeometry(ROAD,(CELL)*BLOCKS_Z + ROAD); const m=new THREE.Mesh(geo, roadMat); m.rotation.x=-Math.PI/2; const x = ix*CELL-(BLOCKS_X*CELL)/2; m.position.set(x, 0.01, ROAD*0.5-(BLOCKS_Z*CELL)/2); m.receiveShadow=allowShadows; city.add(m); xRoads.push(x);
        const sL=new THREE.Mesh(new THREE.PlaneGeometry(SIDE,(CELL)*BLOCKS_Z + ROAD), sidewalkMat); sL.rotation.x=-Math.PI/2; sL.position.set(x-ROAD/2 - SIDE/2, 0.012, ROAD*0.5-(BLOCKS_Z*CELL)/2); sidewalks.add(sL);
        const sR=sL.clone(); sR.position.x = x+ROAD/2 + SIDE/2; sidewalks.add(sR);
      }
      for(let iz=0; iz<=BLOCKS_Z; iz++){ const geo=new THREE.PlaneGeometry((CELL)*BLOCKS_X + ROAD, ROAD); const m=new THREE.Mesh(geo, roadMat); m.rotation.x=-Math.PI/2; const z = iz*CELL-(BLOCKS_Z*CELL)/2; m.position.set(ROAD*0.5-(BLOCKS_X*CELL)/2, 0.01, z); m.receiveShadow=allowShadows; city.add(m); zRoads.push(z);
        const sT=new THREE.Mesh(new THREE.PlaneGeometry((CELL)*BLOCKS_X + ROAD, SIDE), sidewalkMat); sT.rotation.x=-Math.PI/2; sT.position.set(ROAD*0.5-(BLOCKS_X*CELL)/2, 0.012, z-ROAD/2 - SIDE/2); sidewalks.add(sT);
        const sB=sT.clone(); sB.position.z = z+ROAD/2 + SIDE/2; sidewalks.add(sB);
      }

      const zebraGaps=[];
      function addMarkings(){
        const marks=new THREE.Group(); marks.renderOrder=5; city.add(marks);
        function centerDashLineX(z){ for(let ix=0; ix<BLOCKS_X; ix++){ const x0=xRoads[ix], x1=xRoads[ix+1]; const segs=14; for(let s=0;s<segs;s++){ const px = THREE.MathUtils.lerp(x0,x1,s/segs) + (x1-x0)/(segs*2); const dash=new THREE.Mesh(new THREE.PlaneGeometry(4,0.7), new THREE.MeshBasicMaterial({color:0xffffff,transparent:true,opacity:0.9})); dash.rotation.x=-Math.PI/2; dash.position.set(px,0.021,z); marks.add(dash);} const stop=new THREE.Mesh(new THREE.PlaneGeometry(8,0.8), new THREE.MeshBasicMaterial({color:0xffffff})); stop.rotation.x=-Math.PI/2; stop.position.set(x1-ROAD*0.6,0.022,z); marks.add(stop);} }
        function centerDashLineZ(x){ for(let iz=0; iz<BLOCKS_Z; iz++){ const z0=zRoads[iz], z1=zRoads[iz+1]; const segs=14; for(let s=0;s<segs;s++){ const pz = THREE.MathUtils.lerp(z0,z1,s/segs) + (z1-z0)/(segs*2); const dash=new THREE.Mesh(new THREE.PlaneGeometry(4,0.7), new THREE.MeshBasicMaterial({color:0xffffff,transparent:true,opacity:0.9})); dash.rotation.x=-Math.PI/2; dash.position.set(x,0.021,pz); marks.add(dash);} const stop=new THREE.Mesh(new THREE.PlaneGeometry(8,0.8), new THREE.MeshBasicMaterial({color:0xffffff})); stop.rotation.x=-Math.PI/2; stop.position.set(x,0.022,z1-ROAD*0.6); marks.add(stop);} }
        xRoads.forEach(z=>centerDashLineX(z));
        zRoads.forEach(x=>centerDashLineZ(x));
        const zebraM=new THREE.MeshBasicMaterial({color:0xffffff,transparent:true,opacity:0.95});
        for(let ix=1; ix<BLOCKS_X; ix++){
          for(let iz=1; iz<BLOCKS_Z; iz++){
            const x=xRoads[ix], z=zRoads[iz];
            const zc = z-ROAD*0.2; const xStart = x-5; for(let i=0;i<10;i++){ const stripe=new THREE.Mesh(new THREE.PlaneGeometry(0.7,3.6), zebraM); stripe.rotation.x=-Math.PI/2; stripe.position.set(xStart+i*1.2,0.023,zc); marks.add(stripe); }
            zebraGaps.push({ x0:x-6, x1:x+6, z0:zc-2.2, z1:zc+2.2 });
            const xc = x-ROAD*0.2; const zStart = z-5; for(let i=0;i<10;i++){ const stripe=new THREE.Mesh(new THREE.PlaneGeometry(0.7,3.6), zebraM); stripe.rotation.x=-Math.PI/2; stripe.position.set(xc,0.023,zStart+i*1.2); marks.add(stripe); }
            zebraGaps.push({ x0:xc-2.2, x1:xc+2.2, z0:z-6, z1:z+6 });
          }
        }
      }
      addMarkings();

      const rails = new THREE.Group(); city.add(rails);
      const railMat = new THREE.MeshLambertMaterial({ color:'#444d55' });
      function mergeRanges(r){ if(!r.length) return []; r.sort((a,b)=>a[0]-b[0]); const out=[r[0].slice()]; for(let i=1;i<r.length;i++){ const [s,e]=r[i]; const last=out[out.length-1]; if(s<=last[1]+0.01) last[1]=Math.max(last[1],e); else out.push([s,e]); } return out; }
      function invertRanges(start,end,block){ const blocks=mergeRanges(block.map(b=>[Math.max(start,b[0]), Math.min(end,b[1])]).filter(b=>b[0]<b[1])); const segs=[]; let cur=start; for(const [s,e] of blocks){ if(s>cur) segs.push([cur,s]); cur=e; } if(cur<end) segs.push([cur,end]); return segs; }
      function addBarZ(x, z0, z1, y){ const len=z1-z0; if(len<=0.2) return; const bar=new THREE.Mesh(new THREE.BoxGeometry(0.08,y?0.08:0.08,len), railMat); bar.position.set(x, y, (z0+z1)/2); rails.add(bar); }
      function addBarX(z, x0, x1, y){ const len=x1-x0; if(len<=0.2) return; const bar=new THREE.Mesh(new THREE.BoxGeometry(len,0.08,0.08), railMat); bar.position.set((x0+x1)/2, y, z); rails.add(bar); }
      function addPostsAlongZ(x, z0, z1){ for(let z=z0; z<=z1; z+=4){ const post=new THREE.Mesh(new THREE.CylinderGeometry(0.08,0.08,1.1,10), railMat); post.position.set(x,0.55,z); rails.add(post); } }
      function addPostsAlongX(z, x0, x1){ for(let x=x0; x<=x1; x+=4){ const post=new THREE.Mesh(new THREE.CylinderGeometry(0.08,0.08,1.1,10), railMat); post.position.set(x,0.55,z); rails.add(post); } }
      function buildRails(){
        const minZ = zRoads[0]-CELL/2, maxZ = zRoads[zRoads.length-1]+CELL/2;
        const minX = xRoads[0]-CELL/2, maxX = xRoads[xRoads.length-1]+CELL/2;
        const edgeOffset = ROAD/2 + 0.2;
        for(let ix=0; ix<xRoads.length; ix++){
          const x=xRoads[ix];
          for(const side of [-1,1]){
            const px = x + side*edgeOffset;
            const blocks = zebraGaps.filter(r=> px>=r.x0-0.6 && px<=r.x1+0.6).map(r=>[r.z0-0.35,r.z1+0.35]);
            const segs = invertRanges(minZ, maxZ, blocks);
            for(const [a,b] of segs){ addBarZ(px, a, b, 0.52); addBarZ(px, a, b, 0.92); addPostsAlongZ(px, a, b); }
          }
        }
        for(let iz=0; iz<zRoads.length; iz++){
          const z=zRoads[iz];
          for(const side of [-1,1]){
            const pz = z + side*edgeOffset;
            const blocks = zebraGaps.filter(r=> pz>=r.z0-0.6 && pz<=r.z1+0.6).map(r=>[r.x0-0.35,r.x1+0.35]);
            const segs = invertRanges(minX, maxX, blocks);
            for(const [a,b] of segs){ addBarX(pz, a, b, 0.52); addBarX(pz, a, b, 0.92); addPostsAlongX(pz, a, b); }
          }
        }
      }
      buildRails();

      const ladders=[]; const stairMeshes=[]; const buildings=[]; const institutions=[]; const fountains=[]; const busStops=[]; const billboards=[];
      function makeSign(text, w=24, h=6, bg='#111', fg='#ffd966'){ const c=document.createElement('canvas'); c.width=1024; c.height=256; const x=c.getContext('2d'); x.fillStyle=bg; x.fillRect(0,0,1024,256); x.fillStyle=fg; x.font='900 140px system-ui, Arial'; x.textAlign='center'; x.textBaseline='middle'; x.fillText(text,512,140); const t=new THREE.CanvasTexture(c); t.colorSpace=THREE.SRGBColorSpace; const m=new THREE.MeshBasicMaterial({ map:t, transparent:true }); const mesh=new THREE.Mesh(new THREE.PlaneGeometry(w,h), m); mesh.renderOrder=6; return mesh; }

      function addTower(xc,zc){
        const w=THREE.MathUtils.randFloat(PLOT*0.32,PLOT*0.46), d=THREE.MathUtils.randFloat(PLOT*0.28,PLOT*0.46), h=THREE.MathUtils.randFloat(26,78);
        const geo=new THREE.BoxGeometry(w,h,d); const hue=(180+Math.random()*80)|0; const mat=new THREE.MeshLambertMaterial({ map:facadeTex(hue) });
        const m=new THREE.Mesh(geo, mat); m.position.set(xc, h/2, zc); m.castShadow=allowShadows; m.receiveShadow=allowShadows; city.add(m);
        buildings.push({mesh:m,w,d,h});
        if(h>52){ const lx=xc+w/2-2, lz=zc+d/2-2; ladders.push({x:lx,y0:0,y1:h-2,z:lz}); makeFireEscape(m, lx, lz, h); }
      }
      function makeFireEscape(buildMesh, x, z, h){
        const g=new THREE.Group(); const stairM=new THREE.MeshLambertMaterial({color:'#2c2f33'}); const stepH=2.8; const levels=Math.floor(h/stepH);
        for(let i=1;i<levels;i++){
          const y=i*stepH; const plat=new THREE.Mesh(new THREE.BoxGeometry(3,0.12,1.2), stairM); plat.position.set(x, y, z); g.add(plat);
          const railL=new THREE.Mesh(new THREE.BoxGeometry(0.1,1.0,1.2), stairM); railL.position.set(x-1.45,y+0.5,z); g.add(railL);
          const railR=railL.clone(); railR.position.x = x+1.45; g.add(railR);
          const steps=8; for(let s=0;s<steps;s++){ const st=new THREE.Mesh(new THREE.BoxGeometry(0.3,0.06,1.0), stairM); st.position.set(x-1.2+s*(2.4/steps), y-0.6+s*(1.2/steps), z); g.add(st);} }
        const signUp = makeSign('CLIMB UP', 6, 1.6, '#0b1222','#ffd966'); signUp.position.set(x, 1.2, z+1.0); g.add(signUp);
        const signDown = makeSign('CLIMB DOWN', 6, 1.6, '#0b1222','#ffd966'); signDown.position.set(x, h-1.6, z+1.0); g.add(signDown);
        const signUpBack = signUp.clone(); signUpBack.rotation.y=Math.PI; signUpBack.position.z = z-1.0; g.add(signUpBack);
        const signDownBack = signDown.clone(); signDownBack.rotation.y=Math.PI; signDownBack.position.z = z-1.0; g.add(signDownBack);
        g.userData.type='fireEscape'; stairMeshes.push(g);
        city.add(g);
      }
      function addTrees(area, count=12){ const g=new THREE.Group(); const {x0= startX, x1= startX+CELL, z0= startZ, z1= startZ+CELL}=area||{}; for(let i=0;i<count;i++){ const x=THREE.MathUtils.lerp(x0,x1,Math.random()); const z=THREE.MathUtils.lerp(z0,z1,Math.random()); const trunk=new THREE.Mesh(new THREE.CylinderGeometry(0.16,0.22,2.2,10), new THREE.MeshLambertMaterial({color:'#6b4f2a'})); trunk.position.set(x,1.1,z); const crown=new THREE.Mesh(new THREE.SphereGeometry(1.2,18,14), new THREE.MeshLambertMaterial({color:'#79b97a', map:turfTex})); crown.position.set(x,2.3,z); g.add(trunk,crown);} city.add(g); return g; }

// ===== Populate blocks (buildings + some trees) =====
for(let ix=0; ix<BLOCKS_X; ix++){
  for(let iz=0; iz<BLOCKS_Z; iz++){
    const cx = startX + ix*CELL; const cz = startZ + iz*CELL;
    const lotCenterX = cx; const lotCenterZ = cz;
    addTower(lotCenterX, lotCenterZ);
    addTrees({ x0: lotCenterX-PLOT*0.45, x1: lotCenterX+PLOT*0.45, z0: lotCenterZ-PLOT*0.45, z1: lotCenterZ+PLOT*0.45 }, 6+Math.floor(Math.random()*6));
  }
}

// ===== Player (faster speed) =====
const player = { }; player.body = new CANNON.Body({ mass:85, material:matPlayer, shape:new CANNON.Sphere(0.35), position:new CANNON.Vec3(0,1.6,0) }); world.addBody(player.body);
player.dirYaw = 0; player.speed = 0; player.maxSpeed = 10.2; // faster than before
player.mesh = new THREE.Mesh(new THREE.SphereGeometry(0.35,16,12), new THREE.MeshStandardMaterial({color:'#1e293b', metalness:0.2, roughness:0.8})); player.mesh.castShadow=allowShadows; scene.add(player.mesh);

// Camera follows player
camera.position.set(0, 2.2, 5.6);

// ===== Weapon anchor on camera (same pose as Uzi) =====
const weaponAnchor = new THREE.Group(); weaponAnchor.position.set(0.32,-0.24,-0.58); weaponAnchor.rotation.set(THREE.MathUtils.degToRad(-6), THREE.MathUtils.degToRad(-86), 0); camera.add(weaponAnchor);

const CURATED = [
  {key:'glock', label:'Glock', urls:['https://raw.githubusercontent.com/webaverse/pistol/master/glock.glb','https://raw.githubusercontent.com/webaverse/pistol/main/glock.glb'], scale:0.6},
  {key:'pistol', label:'Pistol', urls:['https://raw.githubusercontent.com/webaverse/pistol/master/pistol.glb','https://raw.githubusercontent.com/webaverse/pistol/main/pistol.glb'], scale:0.6},
  {key:'uzi', label:'Uzi', urls:['https://raw.githubusercontent.com/webaverse/uzi/main/uzi.glb','https://raw.githubusercontent.com/webaverse-mmo/uzi/main/uzi.glb'], scale:0.6},
  {key:'ak47', label:'AK‚Äë47', urls:['https://raw.githubusercontent.com/LazerMaker/gun-models-ak47-and-supprest-pistol-/master/ak47.glb'], scale:0.8},
  {key:'mp5', label:'MP5', urls:['https://raw.githubusercontent.com/Jay-Oh-eN/assets/main/mp5.glb'], scale:0.75},
  {key:'grenade', label:'Grenade', urls:['https://raw.githubusercontent.com/friuns2/bingextension/main/grenade.glb'], scale:2.0},
  {key:'battle', label:'Battle Rifle', urls:['https://raw.githubusercontent.com/Sinojouni/games/main/battle_rifle_animated.glb'], scale:0.9},
  {key:'infantry', label:'Infantry Rifle', urls:['https://raw.githubusercontent.com/ssdeanx/glb-textures/main/infantry_automatic_rifle.glb'], scale:0.9},
  {key:'rifle', label:'Rifle', urls:['https://raw.githubusercontent.com/webaverse/assets/master/rifle.glb'], scale:0.9},
  {key:'gun', label:'Gun', urls:['https://raw.githubusercontent.com/codewithtom/godot-fps/master/Assets/gun.glb'], scale:0.85},
  {key:'rifle2', label:'Rifle (Air908)', urls:['https://raw.githubusercontent.com/Air908/3dmodels/main/GunRifle.glb'], scale:0.9},
  {key:'awp', label:'Sniper AWP', urls:['https://raw.githubusercontent.com/GarbajYT/godot-sniper-rifle/master/AWP.glb'], scale:0.9},
];

// Per-weapon offsets (all anchored to same Uzi pose). ADS = desired FOV factor
const WEAPON_TUNE = {
  glock:{ pos:[0,0,0], rot:[0,0,0], ads:0.70 },
  pistol:{ pos:[0,0,0], rot:[0,0,0], ads:0.72 },
  uzi:{ pos:[0,0,0], rot:[0,0,0], ads:0.68 },
  mp5:{ pos:[0.00,-0.03,0.0], rot:[0.04,-0.04,0], ads:0.64 },
  ak47:{ pos:[-0.04,-0.05,0.02], rot:[0.06,-0.10,0], ads:0.58 },
  battle:{ pos:[-0.02,-0.04,0.01], rot:[0.04,-0.08,0], ads:0.60 },
  infantry:{ pos:[-0.02,-0.04,0.01], rot:[0.04,-0.08,0], ads:0.60 },
  rifle:{ pos:[-0.02,-0.04,0.01], rot:[0.04,-0.08,0], ads:0.60 },
  rifle2:{ pos:[-0.02,-0.04,0.01], rot:[0.04,-0.08,0], ads:0.60 },
  gun:{ pos:[0,0,0], rot:[0,0,0], ads:0.70 },
  awp:{ pos:[-0.06,-0.06,0.02], rot:[0.06,-0.12,0], ads:0.50 },
  grenade:{ pos:[0.06,-0.06,0.02], rot:[0.0,0.0,0], ads:0.80 },
};

function centerAndScale(g, target=1){ const box=new THREE.Box3().setFromObject(g); const size=new THREE.Vector3(); box.getSize(size); const c=new THREE.Vector3(); box.getCenter(c); g.position.sub(c); const s = target / (Math.max(size.x,size.y,size.z) || 1); g.scale.setScalar(s); return g; }

async function loadWithRetry(urls, timeoutMs=12000){ for(const url of urls){ try{ const gltf=await new Promise((resolve)=>{ const to=setTimeout(()=>resolve(null), timeoutMs); gltfLoaderGuns.load(url, (g)=>{ clearTimeout(to); resolve(g); }, undefined, ()=>{ clearTimeout(to); resolve(null); }); }); if(gltf) return gltf; }catch{} } return null; }

let currentWeapon=null; const weaponCache=new Map(); const baseFov=70; camera.fov = baseFov; camera.updateProjectionMatrix();
async function equipWeapon(key){ const def = CURATED.find(w=>w.key===key); if(!def) return; if(currentWeapon){ weaponAnchor.remove(currentWeapon); currentWeapon.traverse?.(o=>{ if(o.material?.map) o.material.map.needsUpdate=true; }); currentWeapon=null; }
  let root = weaponCache.get(key);
  if(!root){ const gltf=await loadWithRetry(def.urls); if(!gltf){ console.warn('Failed to load', key); return; } root = gltf.scene || gltf.scenes?.[0]; root.traverse(o=>{ if(o.isMesh){ o.castShadow=allowShadows; o.receiveShadow=allowShadows; }}); centerAndScale(root, def.scale||1); weaponCache.set(key, root); }
  const inst = root.clone(true); const tune=WEAPON_TUNE[key]||{pos:[0,0,0],rot:[0,0,0],ads:0.7}; inst.position.add(new THREE.Vector3().fromArray(tune.pos)); inst.rotation.set(tune.rot[0], tune.rot[1], tune.rot[2]); weaponAnchor.add(inst); currentWeapon=inst; // ADS per-weapon
  adsTargetFov = baseFov * (tune.ads||0.7);
}

// Build Armory UI (touch slider; tap to select)
const armEl = document.getElementById('armory'); function addArmCard(w){ const btn=document.createElement('button'); btn.className='armBtn'; btn.title=w.label; const img=document.createElement('img'); img.alt=w.label; img.src='data:image/svg+xml;utf8,'+encodeURIComponent(`<svg xmlns="http://www.w3.org/2000/svg" width="240" height="120"><rect width="100%" height="100%" fill="#0b1224"/><text x="50%" y="55%" font-size="22" font-weight="700" text-anchor="middle" fill="#ffd966" font-family="system-ui">${w.label}</text></svg>`); const span=document.createElement('span'); span.textContent=w.label; btn.appendChild(img); btn.appendChild(span); btn.addEventListener('click',()=>{ [...armEl.children].forEach(c=>c.classList.remove('active')); btn.classList.add('active'); equipWeapon(w.key); }); armEl.appendChild(btn); }
CURATED.forEach(addArmCard);
// Ensure Glock (same anchor as Uzi) is selected by default
setTimeout(()=>{ const first=armEl.querySelector('.armBtn'); if(first){ first.classList.add('active'); equipWeapon('glock'); } }, 0);

// ===== Climb (A) ‚Äî proximity to ladder signs =====
const climbBtn = document.getElementById('climbBtn'); let onRoof=false; function checkLadder(){ const p=player.body.position; let near=null; for(const l of ladders){ const dx=p.x-l.x, dz=p.z-l.z; if(Math.hypot(dx,dz)<2.2){ near=l; break; } } climbBtn.style.display = near? 'block':'none'; climbBtn.onclick = ()=>{ if(!near) return; if(!onRoof){ player.body.position.set(near.x, near.y1+1.2, near.z); onRoof=true; } else { player.body.position.set(near.x, near.y0+1.2, near.z); onRoof=false; } }; }

// ===== Controls: swap sides (movement on right, fire/aim on left) =====
const joyMove = document.getElementById('joyMove');
const shootPad = document.getElementById('shootPad');
const aimPad = document.getElementById('aimPad');
const modeA = document.getElementById('modeA'); const modeB = document.getElementById('modeB');
let controlMode='A'; modeA.onclick=()=>{ controlMode='A'; aimPad.style.display='none'; modeA.classList.add('active'); modeB.classList.remove('active'); };
modeB.onclick=()=>{ controlMode='B'; aimPad.style.display='block'; modeB.classList.add('active'); modeA.classList.remove('active'); };

function bindStick(el){ const knob=el.querySelector('.knob'); let rect, active=false, id=null, cx=0, cy=0, dx=0, dy=0, rad=120; const out={dx:0,dy:0}; function setKnob(nx,ny){ knob.style.left=(50+nx*40)+'%'; knob.style.top=(50+ny*40)+'%'; }
  function start(e){ if(active) return; const t=(e.touches? e.touches[0]:e); id=t.identifier||'mouse'; rect=el.getBoundingClientRect(); cx = rect.left + rect.width/2; cy = rect.top + rect.height/2; active=true; setKnob(0,0); }
  function move(e){ if(!active) return; let tx,ty; if(e.touches){ for(const tt of e.touches){ if((tt.identifier||'mouse')===id){ tx=tt.clientX; ty=tt.clientY; break; } } } else { tx=e.clientX; ty=e.clientY; }
    const vx = (tx-cx)/rad; const vy = (ty-cy)/rad; const len=Math.hypot(vx,vy); const scl = len>1? 1/len : 1; dx=vx*scl; dy=vy*scl; setKnob(dx,dy); out.dx=dx; out.dy=dy; }
  function end(){ active=false; out.dx=out.dy=0; setKnob(0,0); }
  el.addEventListener('touchstart',start,{passive:true}); el.addEventListener('touchmove',move,{passive:true}); el.addEventListener('touchend',end); el.addEventListener('mousedown',start); window.addEventListener('mousemove',move); window.addEventListener('mouseup',end); return out; }

const mv = bindStick(joyMove); const look = bindStick(aimPad);
let firing=false; shootPad.addEventListener('touchstart',()=>{ firing=true; },{passive:true}); shootPad.addEventListener('touchend',()=>{ firing=false; },{passive:true}); shootPad.addEventListener('mousedown',()=>{ firing=true; }); window.addEventListener('mouseup',()=>{ firing=false; });

// ===== Movement / Look =====
const keys={}; addEventListener('keydown',e=>keys[e.code]=true); addEventListener('keyup',e=>keys[e.code]=false);
function updatePlayer(dt){ // movement from right stick (mv)
  let xx = mv.dx, yy = mv.dy; if(keys['KeyW']) yy-=0.7; if(keys['KeyS']) yy+=0.7; if(keys['KeyA']) xx-=0.7; if(keys['KeyD']) xx+=0.7;
  const dir = new CANNON.Vec3(xx*player.maxSpeed, player.body.velocity.y, yy*player.maxSpeed);
  player.body.velocity.x = dir.x; player.body.velocity.z = dir.z;
  // look: A=drag screen not implemented; B=left stick
  if(controlMode==='B'){ player.dirYaw -= look.dx * 2.4; }
  camera.rotation.set(0, player.dirYaw, 0);
  const camOffset = new THREE.Vector3(0, 1.9, 3.6).applyAxisAngle(new THREE.Vector3(0,1,0), player.dirYaw);
  camera.position.set(player.body.position.x + camOffset.x, player.body.position.y + camOffset.y, player.body.position.z + camOffset.z);
  camera.lookAt(player.body.position.x, player.body.position.y+1.3, player.body.position.z);
  player.mesh.position.copy(player.body.position);
}

// ===== Shooting (simple tracer) =====
const tracerMat = new THREE.LineBasicMaterial({ color: 0xff4444 }); const tracerGeom = new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(), new THREE.Vector3(0,0,-4)]); const tracer = new THREE.Line(tracerGeom, tracerMat); tracer.visible=false; camera.add(tracer);
let adsTargetFov = baseFov*0.7; // updated per-weapon
function updateCombat(dt){ camera.fov += (adsTargetFov - camera.fov) * Math.min(1, dt*8); camera.updateProjectionMatrix(); tracer.visible=false; if(firing && currentWeapon){ tracer.visible=true; tracer.material.needsUpdate=true; }
}

// ===== Armory touch slider inertia (native scroll is enough, keep small helper) =====
let armTouch=false, ax0=0, scrollX0=0; armEl.addEventListener('touchstart',e=>{ armTouch=true; ax0=e.touches[0].clientX; scrollX0=armEl.scrollLeft; }, {passive:true}); armEl.addEventListener('touchmove',e=>{ if(!armTouch) return; const dx=ax0 - e.touches[0].clientX; armEl.scrollLeft = scrollX0 + dx; }, {passive:true}); armEl.addEventListener('touchend',()=>{ armTouch=false; });

// ===== Diagnostics =====
const diagEl=document.getElementById('diag'); function setDiag(txt){ diagEl.textContent=txt; }

// ===== Main loop =====
let last=performance.now(); function loop(now){ const dt=Math.min(0.033,(now-last)/1000); last=now; world.step(1/PHYS_HZ, dt, 3); updatePlayer(dt); updateCombat(dt); checkLadder(); renderer.render(scene, camera); requestAnimationFrame(loop); }
requestAnimationFrame(loop);

// ===== Resize once more after assets =====
setTimeout(fit, 50);

// ===== Simple self-checks =====
(function diagnostics(){ const okR = !!renderer.getContext(); const okC = !!city; const okA = !!armEl.children.length; setDiag(`Renderer:${okR?'‚úÖ':'‚ùå'} City:${okC?'‚úÖ':'‚ùå'} Armory:${okA?'‚úÖ':'‚ùå'} ‚Ä¢ Tap a gun to equip ‚Ä¢ Movement on RIGHT stick, Fire on LEFT.`); })();

})();
  </script>
</body>
</html>
